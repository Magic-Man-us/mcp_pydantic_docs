{"title": "Pydantic People", "anchor": "pydantic-people", "heading_level": 1, "md_text": "Pydantic has an amazing community of contributors, reviewers, and experts that help propel the project forward.\nHere, we celebrate those people and their contributions.", "url": "https://docs.pydantic.dev/latest/docs/pydantic_people/#pydantic-people", "page": "docs/pydantic_people", "source_site": "pydantic"}
{"title": "Maintainers", "anchor": "maintainers", "heading_level": 2, "md_text": "These are the current maintainers of the Pydantic repository. Feel free to tag us if you have questions, review requests, or feature requests for which you'd like feedback!\n\n{{ maintainers }}", "url": "https://docs.pydantic.dev/latest/docs/pydantic_people/#maintainers", "page": "docs/pydantic_people", "source_site": "pydantic"}
{"title": "Experts", "anchor": "experts", "heading_level": 2, "md_text": "These are the users that have helped others the most with questions in GitHub through *all time*.\n\n{{ experts }}", "url": "https://docs.pydantic.dev/latest/docs/pydantic_people/#experts", "page": "docs/pydantic_people", "source_site": "pydantic"}
{"title": "Most active users last month", "anchor": "most-active-users-last-month", "heading_level": 3, "md_text": "These are the users that have helped others the most with questions in GitHub during the last month.\n\n{{ most_active_users }}", "url": "https://docs.pydantic.dev/latest/docs/pydantic_people/#most-active-users-last-month", "page": "docs/pydantic_people", "source_site": "pydantic"}
{"title": "Top contributors", "anchor": "top-contributors", "heading_level": 2, "md_text": "These are the users that have created the most pull requests that have been *merged*.\n\n{{ top_contributors }}", "url": "https://docs.pydantic.dev/latest/docs/pydantic_people/#top-contributors", "page": "docs/pydantic_people", "source_site": "pydantic"}
{"title": "Top Reviewers", "anchor": "top-reviewers", "heading_level": 2, "md_text": "These are the users that have reviewed the most Pull Requests from others, assisting with code quality, documentation, bug fixes, feature requests, etc.\n\n{{ top_reviewers }}", "url": "https://docs.pydantic.dev/latest/docs/pydantic_people/#top-reviewers", "page": "docs/pydantic_people", "source_site": "pydantic"}
{"title": "About the data", "anchor": "about-the-data", "heading_level": 2, "md_text": "The data displayed above is calculated monthly via the Github GraphQL API (see\n[source code](https://github.com/pydantic/pydantic/tree/main/.github/actions/people/people.py),\nmany thanks to [Sebasti\u00e1n Ram\u00edrez](https://github.com/tiangolo) for the script from which we based this logic).\n\nDepending on changing conditions, the thresholds for the different categories of contributors may change in the future.", "url": "https://docs.pydantic.dev/latest/docs/pydantic_people/#about-the-data", "page": "docs/pydantic_people", "source_site": "pydantic"}
{"title": "install", "anchor": null, "heading_level": 0, "md_text": "Installation is as simple as:\n\n=== \"pip\"\n\n    ```bash\n    pip install pydantic\n    ```\n\n=== \"uv\"\n\n    ```bash\n    uv add pydantic\n    ```\n\nPydantic has a few dependencies:\n\n* [`pydantic-core`](https://pypi.org/project/pydantic-core/): Core validation logic for Pydantic written in Rust.\n* [`typing-extensions`](https://pypi.org/project/typing-extensions/): Backport of the standard library [typing][] module.\n* [`annotated-types`](https://pypi.org/project/annotated-types/): Reusable constraint types to use with [`typing.Annotated`][].\n\nIf you've got Python 3.9+ and `pip` installed, you're good to go.\n\nPydantic is also available on [conda](https://www.anaconda.com) under the [conda-forge](https://conda-forge.org)\nchannel:\n\n```bash\nconda install pydantic -c conda-forge\n```", "url": "https://docs.pydantic.dev/latest/docs/install/", "page": "docs/install", "source_site": "pydantic"}
{"title": "Optional dependencies", "anchor": "optional-dependencies", "heading_level": 2, "md_text": "Pydantic has the following optional dependencies:\n\n* `email`: Email validation provided by the [email-validator](https://pypi.org/project/email-validator/) package.\n* `timezone`: Fallback IANA time zone database provided by the [tzdata](https://pypi.org/project/tzdata/) package.\n\nTo install optional dependencies along with Pydantic:\n\n=== \"pip\"\n\n    ```bash\n    # with the `email` extra:\n    pip install 'pydantic[email]'\n    # or with `email` and `timezone` extras:\n    pip install 'pydantic[email,timezone]'\n    ```\n\n=== \"uv\"\n\n    ```bash\n    # with the `email` extra:\n    uv add 'pydantic[email]'\n    # or with `email` and `timezone` extras:\n    uv add 'pydantic[email,timezone]'\n    ```\n\nOf course, you can also install requirements manually with `pip install email-validator tzdata`.", "url": "https://docs.pydantic.dev/latest/docs/install/#optional-dependencies", "page": "docs/install", "source_site": "pydantic"}
{"title": "Install from repository", "anchor": "install-from-repository", "heading_level": 2, "md_text": "And if you prefer to install Pydantic directly from the repository:\n\n=== \"pip\"\n\n    ```bash\n    pip install 'git+https://github.com/pydantic/pydantic@main'\n    # or with `email` and `timezone` extras:\n    pip install 'git+https://github.com/pydantic/pydantic@main#egg=pydantic[email,timezone]'\n    ```\n\n=== \"uv\"\n\n    ```bash\n    uv add 'git+https://github.com/pydantic/pydantic@main'\n    # or with `email` and `timezone` extras:\n    uv add 'git+https://github.com/pydantic/pydantic@main#egg=pydantic[email,timezone]'\n    ```", "url": "https://docs.pydantic.dev/latest/docs/install/#install-from-repository", "page": "docs/install", "source_site": "pydantic"}
{"title": "Why use Pydantic Validation?", "anchor": "why-use-pydantic-validation", "heading_level": 1, "md_text": "Today, Pydantic is downloaded <span id=\"download-count\">many</span> times a month and used by some of the largest and most recognisable organisations in the world.\n\nIt's hard to know why so many people have adopted Pydantic since its inception six years ago, but here are a few guesses.", "url": "https://docs.pydantic.dev/latest/docs/why/#why-use-pydantic-validation", "page": "docs/why", "source_site": "pydantic"}
{"title": "Type hints powering schema validation {#type-hints}", "anchor": "type-hints-powering-schema-validation-type-hints", "heading_level": 2, "md_text": "The schema that Pydantic validates against is generally defined by Python [type hints](https://docs.python.org/3/glossary.html#term-type-hint).\n\nType hints are great for this since, if you're writing modern Python, you already know how to use them.\nUsing type hints also means that Pydantic integrates well with static typing tools\n(like [mypy](https://www.mypy-lang.org/) and [Pyright](https://github.com/microsoft/pyright/))\nand IDEs (like [PyCharm](https://www.jetbrains.com/pycharm/) and [VSCode](https://code.visualstudio.com/)).\n\n???+ example \"Example - just type hints\"\n    ```python\n    from typing import Annotated, Literal\n\n    from annotated_types import Gt\n\n    from pydantic import BaseModel\n\n\n    class Fruit(BaseModel):\n        name: str  # (1)!\n        color: Literal['red', 'green']  # (2)!\n        weight: Annotated[float, Gt(0)]  # (3)!\n        bazam: dict[str, list[tuple[int, bool, float]]]  # (4)!\n\n\n    print(\n        Fruit(\n            name='Apple',\n            color='red',\n            weight=4.2,\n            bazam={'foobar': [(1, True, 0.1)]},\n        )\n    )\n    #> name='Apple' color='red' weight=4.2 bazam={'foobar': [(1, True, 0.1)]}\n    ```\n\n    1. The `name` field is simply annotated with `str` &mdash; any string is allowed.\n    2. The [`Literal`][typing.Literal] type is used to enforce that `color` is either `'red'` or `'green'`.\n    3. Even when we want to apply constraints not encapsulated in Python types, we can use [`Annotated`][typing.Annotated]\n       and [`annotated-types`](https://github.com/annotated-types/annotated-types) to enforce constraints while still keeping typing support.\n    4. I'm not claiming \"bazam\" is really an attribute of fruit, but rather to show that arbitrarily complex types can easily be validated.\n\n!!! tip \"Learn more\"\n    See the [documentation on supported types](concepts/types.md).", "url": "https://docs.pydantic.dev/latest/docs/why/#type-hints-powering-schema-validation-type-hints", "page": "docs/why", "source_site": "pydantic"}
{"title": "Performance", "anchor": "performance", "heading_level": 2, "md_text": "Pydantic's core validation logic is implemented in a separate package ([`pydantic-core`](https://github.com/pydantic/pydantic-core)),\nwhere validation for most types is implemented in Rust.\n\nAs a result, Pydantic is among the fastest data validation libraries for Python.\n\n??? example \"Performance Example - Pydantic vs. dedicated code\"\n    In general, dedicated code should be much faster than a general-purpose validator, but in this example\n    Pydantic is >300% faster than dedicated code when parsing JSON and validating URLs.\n\n    ```python {title=\"Performance Example\" test=\"skip\"}\n    import json\n    import timeit\n    from urllib.parse import urlparse\n\n    import requests\n\n    from pydantic import HttpUrl, TypeAdapter\n\n    reps = 7\n    number = 100\n    r = requests.get('https://api.github.com/emojis')\n    r.raise_for_status()\n    emojis_json = r.content\n\n\n    def emojis_pure_python(raw_data):\n        data = json.loads(raw_data)\n        output = {}\n        for key, value in data.items():\n            assert isinstance(key, str)\n            url = urlparse(value)\n            assert url.scheme in ('https', 'http')\n            output[key] = url\n\n\n    emojis_pure_python_times = timeit.repeat(\n        'emojis_pure_python(emojis_json)',\n        globals={\n            'emojis_pure_python': emojis_pure_python,\n            'emojis_json': emojis_json,\n        },\n        repeat=reps,\n        number=number,\n    )\n    print(f'pure python: {min(emojis_pure_python_times) / number * 1000:0.2f}ms')\n    #> pure python: 5.32ms\n\n    type_adapter = TypeAdapter(dict[str, HttpUrl])\n    emojis_pydantic_times = timeit.repeat(\n        'type_adapter.validate_json(emojis_json)',\n        globals={\n            'type_adapter': type_adapter,\n            'HttpUrl': HttpUrl,\n            'emojis_json': emojis_json,\n        },\n        repeat=reps,\n        number=number,\n    )\n    print(f'pydantic: {min(emojis_pydantic_times) / number * 1000:0.2f}ms')\n    #> pydantic: 1.54ms\n\n    print(\n        f'Pydantic {min(emojis_pure_python_times) / min(emojis_pydantic_times):0.2f}x faster'\n    )\n    #> Pydantic 3.45x faster\n    ```\n\nUnlike other performance-centric libraries written in compiled languages, Pydantic also has excellent support for customizing validation via [functional validators](#customisation).\n\n!!! tip \"Learn more\"\n    Samuel Colvin's [talk at PyCon 2023](https://youtu.be/pWZw7hYoRVU) explains how [`pydantic-core`](https://github.com/pydantic/pydantic-core)\n    works and how it integrates with Pydantic.", "url": "https://docs.pydantic.dev/latest/docs/why/#performance", "page": "docs/why", "source_site": "pydantic"}
{"title": "Serialization", "anchor": "serialization", "heading_level": 2, "md_text": "Pydantic provides functionality to serialize model in three ways:\n\n1. To a Python `dict` made up of the associated Python objects.\n2. To a Python `dict` made up only of \"jsonable\" types.\n3. To a JSON string.\n\nIn all three modes, the output can be customized by excluding specific fields, excluding unset fields, excluding default values, and excluding `None` values.\n\n??? example \"Example - Serialization 3 ways\"\n\n    ```python\n    from datetime import datetime\n\n    from pydantic import BaseModel\n\n\n    class Meeting(BaseModel):\n        when: datetime\n        where: bytes\n        why: str = 'No idea'\n\n\n    m = Meeting(when='2020-01-01T12:00', where='home')\n    print(m.model_dump(exclude_unset=True))\n    #> {'when': datetime.datetime(2020, 1, 1, 12, 0), 'where': b'home'}\n    print(m.model_dump(exclude={'where'}, mode='json'))\n    #> {'when': '2020-01-01T12:00:00', 'why': 'No idea'}\n    print(m.model_dump_json(exclude_defaults=True))\n    #> {\"when\":\"2020-01-01T12:00:00\",\"where\":\"home\"}\n    ```\n\n!!! tip \"Learn more\"\n    See the [documentation on serialization](concepts/serialization.md).", "url": "https://docs.pydantic.dev/latest/docs/why/#serialization", "page": "docs/why", "source_site": "pydantic"}
{"title": "JSON Schema", "anchor": "json-schema", "heading_level": 2, "md_text": "A [JSON Schema](https://json-schema.org/) can be generated for any Pydantic schema &mdash; allowing self-documenting APIs and integration with a wide variety of tools which support the JSON Schema format.\n\n??? example \"Example - JSON Schema\"\n\n    ```python\n    from datetime import datetime\n\n    from pydantic import BaseModel\n\n\n    class Address(BaseModel):\n        street: str\n        city: str\n        zipcode: str\n\n\n    class Meeting(BaseModel):\n        when: datetime\n        where: Address\n        why: str = 'No idea'\n\n\n    print(Meeting.model_json_schema())\n    \"\"\"\n    {\n        '$defs': {\n            'Address': {\n                'properties': {\n                    'street': {'title': 'Street', 'type': 'string'},\n                    'city': {'title': 'City', 'type': 'string'},\n                    'zipcode': {'title': 'Zipcode', 'type': 'string'},\n                },\n                'required': ['street', 'city', 'zipcode'],\n                'title': 'Address',\n                'type': 'object',\n            }\n        },\n        'properties': {\n            'when': {'format': 'date-time', 'title': 'When', 'type': 'string'},\n            'where': {'$ref': '#/$defs/Address'},\n            'why': {'default': 'No idea', 'title': 'Why', 'type': 'string'},\n        },\n        'required': ['when', 'where'],\n        'title': 'Meeting',\n        'type': 'object',\n    }\n    \"\"\"\n    ```\n\nPydantic is compliant with the latest version of JSON Schema specification\n([2020-12](https://json-schema.org/draft/2020-12/release-notes.html)), which\nis compatible with [OpenAPI 3.1](https://spec.openapis.org/oas/v3.1.0.html).\n\n!!! tip \"Learn more\"\n    See the [documentation on JSON Schema](concepts/json_schema.md).", "url": "https://docs.pydantic.dev/latest/docs/why/#json-schema", "page": "docs/why", "source_site": "pydantic"}
{"title": "Strict mode and data coercion {#strict-lax}", "anchor": "strict-mode-and-data-coercion-strict-lax", "heading_level": 2, "md_text": "By default, Pydantic is tolerant to common incorrect types and coerces data to the right type &mdash;\ne.g. a numeric string passed to an `int` field will be parsed as an `int`.\n\nPydantic also has as [strict mode](concepts/strict_mode.md), where types are not coerced and a\nvalidation error is raised unless the input data exactly matches the expected schema.\n\nBut strict mode would be pretty useless when validating JSON data since JSON doesn't have types matching\nmany common Python types like [`datetime`][datetime.datetime], [`UUID`][uuid.UUID] or [`bytes`][].\n\nTo solve this, Pydantic can parse and validate JSON in one step. This allows sensible data conversion\n(e.g. when parsing strings into [`datetime`][datetime.datetime] objects). Since the JSON parsing is\nimplemented in Rust, it's also very performant.\n\n??? example \"Example - Strict mode that's actually useful\"\n\n    ```python\n    from datetime import datetime\n\n    from pydantic import BaseModel, ValidationError\n\n\n    class Meeting(BaseModel):\n        when: datetime\n        where: bytes\n\n\n    m = Meeting.model_validate({'when': '2020-01-01T12:00', 'where': 'home'})\n    print(m)\n    #> when=datetime.datetime(2020, 1, 1, 12, 0) where=b'home'\n    try:\n        m = Meeting.model_validate(\n            {'when': '2020-01-01T12:00', 'where': 'home'}, strict=True\n        )\n    except ValidationError as e:\n        print(e)\n        \"\"\"\n        2 validation errors for Meeting\n        when\n          Input should be a valid datetime [type=datetime_type, input_value='2020-01-01T12:00', input_type=str]\n        where\n          Input should be a valid bytes [type=bytes_type, input_value='home', input_type=str]\n        \"\"\"\n\n    m_json = Meeting.model_validate_json(\n        '{\"when\": \"2020-01-01T12:00\", \"where\": \"home\"}'\n    )\n    print(m_json)\n    #> when=datetime.datetime(2020, 1, 1, 12, 0) where=b'home'\n    ```\n\n!!! tip \"Learn more\"\n    See the [documentation on strict mode](concepts/strict_mode.md).", "url": "https://docs.pydantic.dev/latest/docs/why/#strict-mode-and-data-coercion-strict-lax", "page": "docs/why", "source_site": "pydantic"}
{"title": "Dataclasses, TypedDicts, and more {#dataclasses-typeddict-more}", "anchor": "dataclasses-typeddicts-and-more-dataclasses-typeddict-more", "heading_level": 2, "md_text": "Pydantic provides four ways to create schemas and perform validation and serialization:\n\n1. [`BaseModel`](concepts/models.md) &mdash; Pydantic's own super class with many common utilities available via instance methods.\n2. [Pydantic dataclasses](concepts/dataclasses.md) &mdash; a wrapper around standard dataclasses with additional validation performed.\n3. [`TypeAdapter`][pydantic.type_adapter.TypeAdapter] &mdash; a general way to adapt any type for validation and serialization.\n   This allows types like [`TypedDict`](api/standard_library_types.md#typeddict) and [`NamedTuple`](api/standard_library_types.md#named-tuples)\n   to be validated as well as simple types (like [`int`][] or [`timedelta`][datetime.timedelta]) &mdash; [all types](concepts/types.md) supported\n   can be used with [`TypeAdapter`][pydantic.type_adapter.TypeAdapter].\n4. [`validate_call`](concepts/validation_decorator.md) &mdash; a decorator to perform validation when calling a function.\n\n??? example \"Example - schema based on a [`TypedDict`][typing.TypedDict]\"\n\n    ```python\n    from datetime import datetime\n\n    from typing_extensions import NotRequired, TypedDict\n\n    from pydantic import TypeAdapter\n\n\n    class Meeting(TypedDict):\n        when: datetime\n        where: bytes\n        why: NotRequired[str]\n\n\n    meeting_adapter = TypeAdapter(Meeting)\n    m = meeting_adapter.validate_python(  # (1)!\n        {'when': '2020-01-01T12:00', 'where': 'home'}\n    )\n    print(m)\n    #> {'when': datetime.datetime(2020, 1, 1, 12, 0), 'where': b'home'}\n    meeting_adapter.dump_python(m, exclude={'where'})  # (2)!\n\n    print(meeting_adapter.json_schema())  # (3)!\n    \"\"\"\n    {\n        'properties': {\n            'when': {'format': 'date-time', 'title': 'When', 'type': 'string'},\n            'where': {'format': 'binary', 'title': 'Where', 'type': 'string'},\n            'why': {'title': 'Why', 'type': 'string'},\n        },\n        'required': ['when', 'where'],\n        'title': 'Meeting',\n        'type': 'object',\n    }\n    \"\"\"\n    ```\n\n    1. [`TypeAdapter`][pydantic.type_adapter.TypeAdapter] for a [`TypedDict`][typing.TypedDict] performing validation,\n       it can also validate JSON data directly with [`validate_json`][pydantic.type_adapter.TypeAdapter.validate_json].\n    2. [`dump_python`][pydantic.type_adapter.TypeAdapter.dump_python] to serialise a [`TypedDict`][typing.TypedDict]\n       to a python object, it can also serialise to JSON with [`dump_json`][pydantic.type_adapter.TypeAdapter.dump_json].\n    3. [`TypeAdapter`][pydantic.type_adapter.TypeAdapter] can also generate a JSON Schema.", "url": "https://docs.pydantic.dev/latest/docs/why/#dataclasses-typeddicts-and-more-dataclasses-typeddict-more", "page": "docs/why", "source_site": "pydantic"}
{"title": "Customisation", "anchor": "customisation", "heading_level": 2, "md_text": "Functional validators and serializers, as well as a powerful protocol for custom types, means the way Pydantic operates can be customized on a per-field or per-type basis.\n\n??? example \"Customisation Example - wrap validators\"\n    \"wrap validators\" are new in Pydantic V2 and are one of the most powerful ways to customize validation.\n\n    ```python\n    from datetime import datetime, timezone\n    from typing import Any\n\n    from pydantic_core.core_schema import ValidatorFunctionWrapHandler\n\n    from pydantic import BaseModel, field_validator\n\n\n    class Meeting(BaseModel):\n        when: datetime\n\n        @field_validator('when', mode='wrap')\n        def when_now(\n            cls, input_value: Any, handler: ValidatorFunctionWrapHandler\n        ) -> datetime:\n            if input_value == 'now':\n                return datetime.now()\n            when = handler(input_value)\n            # in this specific application we know tz naive datetimes are in UTC\n            if when.tzinfo is None:\n                when = when.replace(tzinfo=timezone.utc)\n            return when\n\n\n    print(Meeting(when='2020-01-01T12:00+01:00'))\n    #> when=datetime.datetime(2020, 1, 1, 12, 0, tzinfo=TzInfo(3600))\n    print(Meeting(when='now'))\n    #> when=datetime.datetime(2032, 1, 2, 3, 4, 5, 6)\n    print(Meeting(when='2020-01-01T12:00'))\n    #> when=datetime.datetime(2020, 1, 1, 12, 0, tzinfo=datetime.timezone.utc)\n    ```\n\n!!! tip \"Learn more\"\n    See the documentation on [validators](concepts/validators.md), [custom serializers](concepts/serialization.md#serializers),\n    and [custom types](concepts/types.md#custom-types).", "url": "https://docs.pydantic.dev/latest/docs/why/#customisation", "page": "docs/why", "source_site": "pydantic"}
{"title": "Ecosystem", "anchor": "ecosystem", "heading_level": 2, "md_text": "At the time of writing there are 466,400 repositories on GitHub and 8,119 packages on PyPI that depend on Pydantic.\n\nSome notable libraries that depend on Pydantic:\n\n{{ libraries }}\n\nMore libraries using Pydantic can be found at [`Kludex/awesome-pydantic`](https://github.com/Kludex/awesome-pydantic).", "url": "https://docs.pydantic.dev/latest/docs/why/#ecosystem", "page": "docs/why", "source_site": "pydantic"}
{"title": "Organisations using Pydantic {#using-pydantic}", "anchor": "organisations-using-pydantic-using-pydantic", "heading_level": 2, "md_text": "Some notable companies and organisations using Pydantic together with comments on why/how we know they're using Pydantic.\n\nThe organisations below are included because they match one or more of the following criteria:\n\n* Using Pydantic as a dependency in a public repository.\n* Referring traffic to the Pydantic documentation site from an organization-internal domain &mdash; specific referrers are not included since they're generally not in the public domain.\n* Direct communication between the Pydantic team and engineers employed by the organization about usage of Pydantic within the organization.\n\nWe've included some extra detail where appropriate and already in the public domain.\n\n{{ organisations }}", "url": "https://docs.pydantic.dev/latest/docs/why/#organisations-using-pydantic-using-pydantic", "page": "docs/why", "source_site": "pydantic"}
{"title": "contributing", "anchor": null, "heading_level": 0, "md_text": "We'd love you to contribute to Pydantic!", "url": "https://docs.pydantic.dev/latest/docs/contributing/", "page": "docs/contributing", "source_site": "pydantic"}
{"title": "Issues", "anchor": "issues", "heading_level": 2, "md_text": "Questions, feature requests and bug reports are all welcome as [discussions or issues](https://github.com/pydantic/pydantic/issues/new/choose).\n**However, to report a security vulnerability, please see our [security policy](https://github.com/pydantic/pydantic/security/policy).**\n\nTo make it as simple as possible for us to help you, please include the output of the following call in your issue:\n\n```bash\npython -c \"import pydantic.version; print(pydantic.version.version_info())\"\n```\n\nIf you're using Pydantic prior to **v2.0** please use:\n\n```bash\npython -c \"import pydantic.utils; print(pydantic.utils.version_info())\"\n```\n\nPlease try to always include the above unless you're unable to install Pydantic or **know** it's not relevant\nto your question or feature request.", "url": "https://docs.pydantic.dev/latest/docs/contributing/#issues", "page": "docs/contributing", "source_site": "pydantic"}
{"title": "Pull Requests", "anchor": "pull-requests", "heading_level": 2, "md_text": "It should be extremely simple to get started and create a Pull Request.\nPydantic is released regularly so you should see your improvements release in a matter of days or weeks \ud83d\ude80.\n\nUnless your change is trivial (typo, docs tweak etc.), please create an issue to discuss the change before\ncreating a pull request.\n\n!!! note \"Pydantic V1 is in maintenance mode\"\n    Pydantic v1 is in maintenance mode, meaning that only bug fixes and security fixes will be accepted.\n    New features should be targeted at Pydantic v2.\n\n    To submit a fix to Pydantic v1, use the `1.10.X-fixes` as a target branch.\n\nIf you're looking for something to get your teeth into, check out the\n[\"help wanted\"](https://github.com/pydantic/pydantic/issues?q=is%3Aopen+is%3Aissue+label%3A%22help+wanted%22)\nlabel on github.\n\nTo make contributing as easy and fast as possible, you'll want to run tests and linting locally. Luckily,\nPydantic has few dependencies, doesn't require compiling and tests don't need access to databases, etc.\nBecause of this, setting up and running the tests should be very simple.\n\n!!! tip\n    **tl;dr**: use `make format` to fix formatting, `make` to run tests and linting and `make docs`\n    to build the docs.", "url": "https://docs.pydantic.dev/latest/docs/contributing/#pull-requests", "page": "docs/contributing", "source_site": "pydantic"}
{"title": "Prerequisites", "anchor": "prerequisites", "heading_level": 3, "md_text": "You'll need the following prerequisites:\n\n* Any Python version between **Python 3.9 and 3.12**\n* [**uv**](https://docs.astral.sh/uv/getting-started/installation/) or other virtual environment tool\n* **git**\n* **make**", "url": "https://docs.pydantic.dev/latest/docs/contributing/#prerequisites", "page": "docs/contributing", "source_site": "pydantic"}
{"title": "Installation and setup", "anchor": "installation-and-setup", "heading_level": 3, "md_text": "Fork the repository on GitHub and clone your fork locally.\n\n```bash", "url": "https://docs.pydantic.dev/latest/docs/contributing/#installation-and-setup", "page": "docs/contributing", "source_site": "pydantic"}
{"title": "Clone your fork and cd into the repo directory", "anchor": "clone-your-fork-and-cd-into-the-repo-directory", "heading_level": 1, "md_text": "git clone git@github.com:<your username>/pydantic.git\ncd pydantic", "url": "https://docs.pydantic.dev/latest/docs/contributing/#clone-your-fork-and-cd-into-the-repo-directory", "page": "docs/contributing", "source_site": "pydantic"}
{"title": "https://pypa.github.io/pipx/", "anchor": "httpspypagithubiopipx", "heading_level": 1, "md_text": "pipx install uv\npipx install pre-commit", "url": "https://docs.pydantic.dev/latest/docs/contributing/#httpspypagithubiopipx", "page": "docs/contributing", "source_site": "pydantic"}
{"title": "Install pydantic, dependencies, test dependencies and doc dependencies", "anchor": "install-pydantic-dependencies-test-dependencies-and-doc-dependencies", "heading_level": 1, "md_text": "make install\n```", "url": "https://docs.pydantic.dev/latest/docs/contributing/#install-pydantic-dependencies-test-dependencies-and-doc-dependencies", "page": "docs/contributing", "source_site": "pydantic"}
{"title": "Check out a new branch and make your changes", "anchor": "check-out-a-new-branch-and-make-your-changes", "heading_level": 3, "md_text": "Create a new branch for your changes.\n\n```bash", "url": "https://docs.pydantic.dev/latest/docs/contributing/#check-out-a-new-branch-and-make-your-changes", "page": "docs/contributing", "source_site": "pydantic"}
{"title": "Checkout a new branch and make your changes", "anchor": "checkout-a-new-branch-and-make-your-changes", "heading_level": 1, "md_text": "git checkout -b my-new-feature-branch", "url": "https://docs.pydantic.dev/latest/docs/contributing/#checkout-a-new-branch-and-make-your-changes", "page": "docs/contributing", "source_site": "pydantic"}
{"title": "Make your changes...", "anchor": "make-your-changes", "heading_level": 1, "md_text": "```", "url": "https://docs.pydantic.dev/latest/docs/contributing/#make-your-changes", "page": "docs/contributing", "source_site": "pydantic"}
{"title": "Run tests and linting", "anchor": "run-tests-and-linting", "heading_level": 3, "md_text": "Run tests and linting locally to make sure everything is working as expected.\n\n```bash", "url": "https://docs.pydantic.dev/latest/docs/contributing/#run-tests-and-linting", "page": "docs/contributing", "source_site": "pydantic"}
{"title": "Run automated code formatting and linting", "anchor": "run-automated-code-formatting-and-linting", "heading_level": 1, "md_text": "make format", "url": "https://docs.pydantic.dev/latest/docs/contributing/#run-automated-code-formatting-and-linting", "page": "docs/contributing", "source_site": "pydantic"}
{"title": "Run tests and linting", "anchor": "run-tests-and-linting", "heading_level": 1, "md_text": "make", "url": "https://docs.pydantic.dev/latest/docs/contributing/#run-tests-and-linting", "page": "docs/contributing", "source_site": "pydantic"}
{"title": "You can run `make help` to see more options.", "anchor": "you-can-run-make-help-to-see-more-options", "heading_level": 1, "md_text": "```", "url": "https://docs.pydantic.dev/latest/docs/contributing/#you-can-run-make-help-to-see-more-options", "page": "docs/contributing", "source_site": "pydantic"}
{"title": "Build documentation", "anchor": "build-documentation", "heading_level": 3, "md_text": "If you've made any changes to the documentation (including changes to function signatures, class definitions, or docstrings that will appear in the API documentation), make sure it builds successfully.\n\nWe use `mkdocs-material[imaging]` to support social previews (see the [plugin documentation](https://squidfunk.github.io/mkdocs-material/plugins/requirements/image-processing/)).\n\n```bash", "url": "https://docs.pydantic.dev/latest/docs/contributing/#build-documentation", "page": "docs/contributing", "source_site": "pydantic"}
{"title": "Build documentation", "anchor": "build-documentation", "heading_level": 1, "md_text": "make docs", "url": "https://docs.pydantic.dev/latest/docs/contributing/#build-documentation", "page": "docs/contributing", "source_site": "pydantic"}
{"title": "You can also use `uv run mkdocs serve` to serve the documentation at localhost:8000", "anchor": "you-can-also-use-uv-run-mkdocs-serve-to-serve-the-documentation-at-localhost8000", "heading_level": 1, "md_text": "```\n\nIf this isn't working due to issues with the imaging plugin, try commenting out the `social` plugin line in `mkdocs.yml` and running `make docs` again.", "url": "https://docs.pydantic.dev/latest/docs/contributing/#you-can-also-use-uv-run-mkdocs-serve-to-serve-the-documentation-at-localhost8000", "page": "docs/contributing", "source_site": "pydantic"}
{"title": "Updating the documentation", "anchor": "updating-the-documentation", "heading_level": 4, "md_text": "We push a new version of the documentation with each minor release, and we push to a `dev` path with each commit to `main`.\n\nIf you're updating the documentation out of cycle with a minor release and want your changes to be reflected on `latest`,\ndo the following:\n\n1. Open a PR against `main` with your docs changes\n2. Once the PR is merged, checkout the `docs-update` branch. This branch should be up to date with the latest patch release.\nFor example, if the latest release is `v2.9.2`, you should make sure `docs-update` is up to date with the `v2.9.2` tag.\n3. Checkout a new branch from `docs-update` and cherry-pick your changes onto this branch.\n4. Push your changes and open a PR against `docs-update`.\n5. Once the PR is merged, the new docs will be built and deployed.\n\n!!! note\n    Maintainer shortcut - as a maintainer, you can skip the second PR and just cherry pick directly onto the `docs-update` branch.", "url": "https://docs.pydantic.dev/latest/docs/contributing/#updating-the-documentation", "page": "docs/contributing", "source_site": "pydantic"}
{"title": "Commit and push your changes", "anchor": "commit-and-push-your-changes", "heading_level": 3, "md_text": "Commit your changes, push your branch to GitHub, and create a pull request.\n\nPlease follow the pull request template and fill in as much information as possible. Link to any relevant issues and include a description of your changes.\n\nWhen your pull request is ready for review, add a comment with the message \"please review\" and we'll take a look as soon as we can.", "url": "https://docs.pydantic.dev/latest/docs/contributing/#commit-and-push-your-changes", "page": "docs/contributing", "source_site": "pydantic"}
{"title": "Documentation style", "anchor": "documentation-style", "heading_level": 2, "md_text": "Documentation is written in Markdown and built using [Material for MkDocs](https://squidfunk.github.io/mkdocs-material/). API documentation is build from docstrings using [mkdocstrings](https://mkdocstrings.github.io/).", "url": "https://docs.pydantic.dev/latest/docs/contributing/#documentation-style", "page": "docs/contributing", "source_site": "pydantic"}
{"title": "Code documentation", "anchor": "code-documentation", "heading_level": 3, "md_text": "When contributing to Pydantic, please make sure that all code is well documented. The following should be documented using properly formatted docstrings:\n\n* Modules\n* Class definitions\n* Function definitions\n* Module-level variables\n\nPydantic uses [Google-style docstrings](https://google.github.io/styleguide/pyguide.html#38-comments-and-docstrings) formatted according to [PEP 257](https://www.python.org/dev/peps/pep-0257/) guidelines. (See [Example Google Style Python Docstrings](https://sphinxcontrib-napoleon.readthedocs.io/en/latest/example_google.html) for further examples.)\n\n[pydocstyle](https://www.pydocstyle.org/en/stable/index.html) is used for linting docstrings. You can run `make format` to check your docstrings.\n\nWhere this is a conflict between Google-style docstrings and pydocstyle linting, follow the pydocstyle linting hints.\n\nClass attributes and function arguments should be documented in the format \"name: description.\" When applicable, a return type should be documented with just a description. Types are inferred from the signature.\n\n```python\nclass Foo:\n    \"\"\"A class docstring.\n\n    Attributes:\n        bar: A description of bar. Defaults to \"bar\".\n    \"\"\"\n\n    bar: str = 'bar'\n```\n\n```python\ndef bar(self, baz: int) -> str:\n    \"\"\"A function docstring.\n\n    Args:\n        baz: A description of `baz`.\n\n    Returns:\n        A description of the return value.\n    \"\"\"\n\n    return 'bar'\n```\n\nYou may include example code in docstrings. This code should be complete, self-contained, and runnable. Docstring examples are tested, so make sure they are correct and complete. See [`BeforeValidator`][pydantic.functional_validators.AfterValidator] for an example.\n\n!!! note \"Class and instance attributes\"\n    Class attributes should be documented in the class docstring.\n\n    Instance attributes should be documented as \"Args\" in the `__init__` docstring.", "url": "https://docs.pydantic.dev/latest/docs/contributing/#code-documentation", "page": "docs/contributing", "source_site": "pydantic"}
{"title": "Documentation Style", "anchor": "documentation-style", "heading_level": 3, "md_text": "In general, documentation should be written in a friendly, approachable style. It should be easy to read and understand, and should be as concise as possible while still being complete.\n\nCode examples are encouraged, but should be kept short and simple. However, every code example should be complete, self-contained, and runnable. (If you're not sure how to do this, ask for help!) We prefer print output to naked asserts, but if you're testing something that doesn't have a useful print output, asserts are fine.\n\nPydantic's unit test will test all code examples in the documentation, so it's important that they are correct and complete. When adding a new code example, use the following to test examples and update their formatting and output:\n\n```bash", "url": "https://docs.pydantic.dev/latest/docs/contributing/#documentation-style", "page": "docs/contributing", "source_site": "pydantic"}
{"title": "Run tests and update code examples", "anchor": "run-tests-and-update-code-examples", "heading_level": 1, "md_text": "pytest tests/test_docs.py --update-examples\n```", "url": "https://docs.pydantic.dev/latest/docs/contributing/#run-tests-and-update-code-examples", "page": "docs/contributing", "source_site": "pydantic"}
{"title": "Debugging Python and Rust", "anchor": "debugging-python-and-rust", "heading_level": 2, "md_text": "If you're working with `pydantic` and `pydantic-core`, you might find it helpful to debug Python and Rust code together.\nHere's a quick guide on how to do that. This tutorial is done in VSCode, but you can use similar steps in other IDEs.\n\n<div style=\"position: relative; padding-bottom: 56.4035546262415%; height: 0;\">\n    <iframe src=\"https://www.loom.com/embed/71019f8b92b04839ae233eb70c23c5b5?sid=1ea39ca9-d0cc-494b-8214-159f7cc26190\" frameborder=\"0\" webkitallowfullscreen mozallowfullscreen allowfullscreen style=\"position: absolute; top: 0; left: 0; width: 100%; height: 100%;\">\n    </iframe>\n</div>", "url": "https://docs.pydantic.dev/latest/docs/contributing/#debugging-python-and-rust", "page": "docs/contributing", "source_site": "pydantic"}
{"title": "Badges", "anchor": "badges", "heading_level": 2, "md_text": "[![Pydantic v1](https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/pydantic/pydantic/main/docs/badge/v1.json)](https://pydantic.dev)\n[![Pydantic v2](https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/pydantic/pydantic/main/docs/badge/v2.json)](https://pydantic.dev)\n\nPydantic has a badge that you can use to show that your project uses Pydantic. You can use this badge in your `README.md`:", "url": "https://docs.pydantic.dev/latest/docs/contributing/#badges", "page": "docs/contributing", "source_site": "pydantic"}
{"title": "With Markdown", "anchor": "with-markdown", "heading_level": 3, "md_text": "```md\n[![Pydantic v1](https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/pydantic/pydantic/main/docs/badge/v1.json)](https://pydantic.dev)\n\n[![Pydantic v2](https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/pydantic/pydantic/main/docs/badge/v2.json)](https://pydantic.dev)\n```", "url": "https://docs.pydantic.dev/latest/docs/contributing/#with-markdown", "page": "docs/contributing", "source_site": "pydantic"}
{"title": "With reStructuredText", "anchor": "with-restructuredtext", "heading_level": 3, "md_text": "```rst\n.. image:: https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/pydantic/pydantic/main/docs/badge/v1.json\n    :target: https://pydantic.dev\n    :alt: Pydantic\n\n.. image:: https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/pydantic/pydantic/main/docs/badge/v2.json\n    :target: https://pydantic.dev\n    :alt: Pydantic\n```", "url": "https://docs.pydantic.dev/latest/docs/contributing/#with-restructuredtext", "page": "docs/contributing", "source_site": "pydantic"}
{"title": "With HTML", "anchor": "with-html", "heading_level": 3, "md_text": "```html\n<a href=\"https://pydantic.dev\"><img src=\"https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/pydantic/pydantic/main/docs/badge/v1.json\" alt=\"Pydantic Version 1\" style=\"max-width:100%;\"></a>\n\n<a href=\"https://pydantic.dev\"><img src=\"https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/pydantic/pydantic/main/docs/badge/v2.json\" alt=\"Pydantic Version 2\" style=\"max-width:100%;\"></a>\n```", "url": "https://docs.pydantic.dev/latest/docs/contributing/#with-html", "page": "docs/contributing", "source_site": "pydantic"}
{"title": "Adding your library as part of Pydantic's third party test suite", "anchor": "adding-your-library-as-part-of-pydantics-third-party-test-suite", "heading_level": 2, "md_text": "To be able to identify regressions early during development, Pydantic runs tests on various third-party projects\nusing Pydantic. We consider adding support for testing new open source projects (that rely heavily on Pydantic) if your said project matches some of the following criteria:\n\n* The project is actively maintained.\n* The project makes use of Pydantic internals (e.g. relying on the [`BaseModel`][pydantic.BaseModel] metaclass, typing utilities).\n* The project is popular enough (although small projects can still be included depending on how Pydantic is being used).\n* The project CI is simple enough to be ported into Pydantic's testing workflow.\n\nIf your project meets some of these criteria, you can [open feature request][open feature request]\nto discuss the inclusion of your project.\n\n[open feature request]: https://github.com/pydantic/pydantic/issues/new?assignees=&labels=feature+request&projects=&template=feature_request.yml", "url": "https://docs.pydantic.dev/latest/docs/contributing/#adding-your-library-as-part-of-pydantics-third-party-test-suite", "page": "docs/contributing", "source_site": "pydantic"}
{"title": "Pydantic Validation", "anchor": "pydantic-validation", "heading_level": 1, "md_text": "[![CI](https://img.shields.io/github/actions/workflow/status/pydantic/pydantic/ci.yml?branch=main&logo=github&label=CI)](https://github.com/pydantic/pydantic/actions?query=event%3Apush+branch%3Amain+workflow%3ACI)\n[![Coverage](https://coverage-badge.samuelcolvin.workers.dev/pydantic/pydantic.svg)](https://github.com/pydantic/pydantic/actions?query=event%3Apush+branch%3Amain+workflow%3ACI)<br>\n[![pypi](https://img.shields.io/pypi/v/pydantic.svg)](https://pypi.python.org/pypi/pydantic)\n[![CondaForge](https://img.shields.io/conda/v/conda-forge/pydantic.svg)](https://anaconda.org/conda-forge/pydantic)\n[![downloads](https://static.pepy.tech/badge/pydantic/month)](https://pepy.tech/project/pydantic)<br>\n[![license](https://img.shields.io/github/license/pydantic/pydantic.svg)](https://github.com/pydantic/pydantic/blob/main/LICENSE)\n[![llms.txt](https://img.shields.io/badge/llms.txt-green)](https://docs.pydantic.dev/latest/llms.txt)\n\n{{ version }}.\n\nPydantic is the most widely used data validation library for Python.\n\nFast and extensible, Pydantic plays nicely with your linters/IDE/brain. Define how data should be in pure, canonical Python 3.9+; validate it with Pydantic.\n\n!!! logfire \"Monitor Pydantic with Pydantic Logfire :fire:\"\n    **[Pydantic Logfire](https://pydantic.dev/logfire)** is an application monitoring tool that is as simple to use and powerful as Pydantic itself.\n\n    Logfire integrates with many popular Python libraries including FastAPI, OpenAI and Pydantic itself, so you can use Logfire to monitor Pydantic validations and understand why some inputs fail validation:\n\n    ```python {title=\"Monitoring Pydantic with Logfire\" test=\"skip\"}\n    from datetime import datetime\n\n    import logfire\n\n    from pydantic import BaseModel\n\n    logfire.configure()\n    logfire.instrument_pydantic()  # (1)!\n\n\n    class Delivery(BaseModel):\n        timestamp: datetime\n        dimensions: tuple[int, int]\n\n\n    # this will record details of a successful validation to logfire\n    m = Delivery(timestamp='2020-01-02T03:04:05Z', dimensions=['10', '20'])\n    print(repr(m.timestamp))\n    #> datetime.datetime(2020, 1, 2, 3, 4, 5, tzinfo=TzInfo(UTC))\n    print(m.dimensions)\n    #> (10, 20)\n\n    Delivery(timestamp='2020-01-02T03:04:05Z', dimensions=['10'])  # (2)!\n    ```\n\n    1. Set logfire record all both successful and failed validations, use `record='failure'` to only record failed validations, [learn more](https://logfire.pydantic.dev/docs/integrations/pydantic/).\n    2. This will raise a `ValidationError` since there are too few `dimensions`, details of the input data and validation errors will be recorded in Logfire.\n\n    Would give you a view like this in the Logfire platform:\n\n    [![Logfire Pydantic Integration](img/logfire-pydantic-integration.png)](https://logfire.pydantic.dev/docs/guides/web-ui/live/)\n\n    This is just a toy example, but hopefully makes clear the potential value of instrumenting a more complex application.\n\n    **[Learn more about Pydantic Logfire](https://logfire.pydantic.dev/docs/)**\n\n    **Sign up for our newsletter, *The Pydantic Stack*, with updates & tutorials on Pydantic, Logfire, and Pydantic AI:**\n\n      <form method=\"POST\" action=\"https://eu.customerioforms.com/forms/submit_action?site_id=53d2086c3c4214eaecaa&form_id=14b22611745b458&success_url=https://docs.pydantic.dev/\" class=\"md-typeset\" style=\"display: flex; align-items: center; gap: 0.5rem; max-width: 100%;\">\n          <input\n          type=\"email\"\n          id=\"email_input\"\n          name=\"email\"\n          class=\"md-input md-input--stretch\"\n          style=\"flex: 1; background: var(--md-default-bg-color); color: var(--md-default-fg-color);\"\n          required\n          placeholder=\"Email\"\n          data-1p-ignore\n          data-lpignore=\"true\"\n          data-protonpass-ignore=\"true\"\n          data-bwignore=\"true\"\n          />\n          <input type=\"hidden\" id=\"source_input\" name=\"source\" value=\"pydantic\" />\n          <button type=\"submit\" class=\"md-button md-button--primary\">Subscribe</button>\n      </form>", "url": "https://docs.pydantic.dev/latest/docs/#pydantic-validation", "page": "docs/", "source_site": "pydantic"}
{"title": "Why use Pydantic?", "anchor": "why-use-pydantic", "heading_level": 2, "md_text": "* **Powered by type hints** &mdash; with Pydantic, schema validation and serialization are controlled by type annotations; less to learn, less code to write, and integration with your IDE and static analysis tools. [Learn more\u2026](why.md#type-hints)\n* **Speed** &mdash; Pydantic's core validation logic is written in Rust. As a result, Pydantic is among the fastest data validation libraries for Python. [Learn more\u2026](why.md#performance)\n* **JSON Schema** &mdash; Pydantic models can emit JSON Schema, allowing for easy integration with other tools. [Learn more\u2026](why.md#json-schema)\n* **Strict** and **Lax** mode &mdash; Pydantic can run in either strict mode (where data is not converted) or lax mode where Pydantic tries to coerce data to the correct type where appropriate. [Learn more\u2026](why.md#strict-lax)\n* **Dataclasses**, **TypedDicts** and more &mdash; Pydantic supports validation of many standard library types including `dataclass` and `TypedDict`. [Learn more\u2026](why.md#dataclasses-typeddict-more)\n* **Customisation** &mdash; Pydantic allows custom validators and serializers to alter how data is processed in many powerful ways. [Learn more\u2026](why.md#customisation)\n* **Ecosystem** &mdash; around 8,000 packages on PyPI use Pydantic, including massively popular libraries like\n  *FastAPI*, *huggingface*, *Django Ninja*, *SQLModel*, & *LangChain*. [Learn more\u2026](why.md#ecosystem)\n* **Battle tested** &mdash; Pydantic is downloaded over 360M times/month and is used by all FAANG companies and 20 of the 25 largest companies on NASDAQ. If you're trying to do something with Pydantic, someone else has probably already done it. [Learn more\u2026](why.md#using-pydantic)\n\n[Installing Pydantic](install.md) is as simple as: `pip install pydantic`", "url": "https://docs.pydantic.dev/latest/docs/#why-use-pydantic", "page": "docs/", "source_site": "pydantic"}
{"title": "Pydantic examples", "anchor": "pydantic-examples", "heading_level": 2, "md_text": "To see Pydantic at work, let's start with a simple example, creating a custom class that inherits from `BaseModel`:\n\n```python {upgrade=\"skip\" title=\"Validation Successful\" requires=\"3.10\"}\nfrom datetime import datetime\n\nfrom pydantic import BaseModel, PositiveInt\n\n\nclass User(BaseModel):\n    id: int  # (1)!\n    name: str = 'John Doe'  # (2)!\n    signup_ts: datetime | None  # (3)!\n    tastes: dict[str, PositiveInt]  # (4)!\n\n\nexternal_data = {\n    'id': 123,\n    'signup_ts': '2019-06-01 12:22',  # (5)!\n    'tastes': {\n        'wine': 9,\n        b'cheese': 7,  # (6)!\n        'cabbage': '1',  # (7)!\n    },\n}\n\nuser = User(**external_data)  # (8)!\n\nprint(user.id)  # (9)!\n#> 123\nprint(user.model_dump())  # (10)!\n\"\"\"\n{\n    'id': 123,\n    'name': 'John Doe',\n    'signup_ts': datetime.datetime(2019, 6, 1, 12, 22),\n    'tastes': {'wine': 9, 'cheese': 7, 'cabbage': 1},\n}\n\"\"\"\n```\n\n1. `id` is of type `int`; the annotation-only declaration tells Pydantic that this field is required. Strings,\n   bytes, or floats will be coerced to integers if possible; otherwise an exception will be raised.\n2. `name` is a string; because it has a default, it is not required.\n3. `signup_ts` is a [`datetime`][datetime.datetime] field that is required, but the value `None` may be provided;\n   Pydantic will process either a [Unix timestamp](https://en.wikipedia.org/wiki/Unix_time) integer (e.g. `1496498400`)\n   or a string representing the date and time.\n4. `tastes` is a dictionary with string keys and positive integer values. The `PositiveInt` type is\n   shorthand for `Annotated[int, annotated_types.Gt(0)]`.\n5. The input here is an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) formatted datetime, but Pydantic will\n   convert it to a [`datetime`][datetime.datetime] object.\n6. The key here is `bytes`, but Pydantic will take care of coercing it to a string.\n7. Similarly, Pydantic will coerce the string `'1'` to the integer `1`.\n8. We create instance of `User` by passing our external data to `User` as keyword arguments.\n9. We can access fields as attributes of the model.\n10. We can convert the model to a dictionary with [`model_dump()`][pydantic.BaseModel.model_dump].\n\nIf validation fails, Pydantic will raise an error with a breakdown of what was wrong:\n\n```python {upgrade=\"skip\" title=\"Validation Error\" test=\"skip\" lint=\"skip\"}", "url": "https://docs.pydantic.dev/latest/docs/#pydantic-examples", "page": "docs/", "source_site": "pydantic"}
{"title": "continuing the above example...", "anchor": "continuing-the-above-example", "heading_level": 1, "md_text": "from datetime import datetime\nfrom pydantic import BaseModel, PositiveInt, ValidationError\n\n\nclass User(BaseModel):\n    id: int\n    name: str = 'John Doe'\n    signup_ts: datetime | None\n    tastes: dict[str, PositiveInt]\n\n\nexternal_data = {'id': 'not an int', 'tastes': {}}  # (1)!\n\ntry:\n    User(**external_data)  # (2)!\nexcept ValidationError as e:\n    print(e.errors())\n    \"\"\"\n    [\n        {\n            'type': 'int_parsing',\n            'loc': ('id',),\n            'msg': 'Input should be a valid integer, unable to parse string as an integer',\n            'input': 'not an int',\n            'url': 'https://errors.pydantic.dev/2/v/int_parsing',\n        },\n        {\n            'type': 'missing',\n            'loc': ('signup_ts',),\n            'msg': 'Field required',\n            'input': {'id': 'not an int', 'tastes': {}},\n            'url': 'https://errors.pydantic.dev/2/v/missing',\n        },\n    ]\n    \"\"\"\n```\n\n1. The input data is wrong here &mdash; `id` is not a valid integer, and `signup_ts` is missing.\n2. Trying to instantiate `User` will raise a [`ValidationError`][pydantic_core.ValidationError] with a list of errors.", "url": "https://docs.pydantic.dev/latest/docs/#continuing-the-above-example", "page": "docs/", "source_site": "pydantic"}
{"title": "Who is using Pydantic?", "anchor": "who-is-using-pydantic", "heading_level": 2, "md_text": "Hundreds of organisations and packages are using Pydantic. Some of the prominent companies and organizations around the world who are using Pydantic include:\n\n{{ organisations }}\n\nFor a more comprehensive list of open-source projects using Pydantic see the\n[list of dependents on github](https://github.com/pydantic/pydantic/network/dependents), or you can find some awesome projects using Pydantic in [awesome-pydantic](https://github.com/Kludex/awesome-pydantic).", "url": "https://docs.pydantic.dev/latest/docs/#who-is-using-pydantic", "page": "docs/", "source_site": "pydantic"}
{"title": "Getting help with Pydantic", "anchor": "getting-help-with-pydantic", "heading_level": 1, "md_text": "If you need help getting started with Pydantic or with advanced usage, the following sources may be useful.", "url": "https://docs.pydantic.dev/latest/docs/help_with_pydantic/#getting-help-with-pydantic", "page": "docs/help_with_pydantic", "source_site": "pydantic"}
{"title": ":material-help: Usage Documentation", "anchor": "material-help-usage-documentation", "heading_level": 2, "md_text": "The [usage documentation](concepts/models.md) is the most complete guide on how to use Pydantic.", "url": "https://docs.pydantic.dev/latest/docs/help_with_pydantic/#material-help-usage-documentation", "page": "docs/help_with_pydantic", "source_site": "pydantic"}
{"title": ":material-api: API Documentation", "anchor": "material-api-api-documentation", "heading_level": 2, "md_text": "The [API documentation](api/base_model.md) gives reference docs for all public Pydantic APIs.", "url": "https://docs.pydantic.dev/latest/docs/help_with_pydantic/#material-api-api-documentation", "page": "docs/help_with_pydantic", "source_site": "pydantic"}
{"title": ":simple-github: GitHub Discussions", "anchor": "simple-github-github-discussions", "heading_level": 2, "md_text": "[GitHub discussions](https://github.com/pydantic/pydantic/discussions) are useful for asking questions, your question and the answer will help everyone.", "url": "https://docs.pydantic.dev/latest/docs/help_with_pydantic/#simple-github-github-discussions", "page": "docs/help_with_pydantic", "source_site": "pydantic"}
{"title": ":simple-stackoverflow: Stack Overflow", "anchor": "simple-stackoverflow-stack-overflow", "heading_level": 2, "md_text": "Use the [`pydantic`](https://stackoverflow.com/questions/tagged/pydantic) tag on Stack Overflow to ask questions, note this is not always monitored by the core Pydantic team.", "url": "https://docs.pydantic.dev/latest/docs/help_with_pydantic/#simple-stackoverflow-stack-overflow", "page": "docs/help_with_pydantic", "source_site": "pydantic"}
{"title": ":simple-youtube: YouTube", "anchor": "simple-youtube-youtube", "heading_level": 2, "md_text": "Youtube has lots of useful [videos on Pydantic](https://www.youtube.com/results?search_query=pydantic).\n\nIn particular Marcelo Trylesinski's video [\"Pydantic V1 to V2 - The Migration\"](https://youtu.be/sD_xpYl4fPU) has helped people a lot when migrating from Pydantic V1 to V2.", "url": "https://docs.pydantic.dev/latest/docs/help_with_pydantic/#simple-youtube-youtube", "page": "docs/help_with_pydantic", "source_site": "pydantic"}
{"title": "migration", "anchor": null, "heading_level": 0, "md_text": "---\ndescription: Migrating from Pydantic V1.\n---\n\nPydantic V2 introduces a number of changes to the API, including some breaking changes.\n\nThis page provides a guide highlighting the most\nimportant changes to help you migrate your code from Pydantic V1 to Pydantic V2.", "url": "https://docs.pydantic.dev/latest/docs/migration/", "page": "docs/migration", "source_site": "pydantic"}
{"title": "Install Pydantic V2", "anchor": "install-pydantic-v2", "heading_level": 2, "md_text": "Pydantic V2 is now the current production release of Pydantic.\nYou can install Pydantic V2 from PyPI:\n\n```bash\npip install -U pydantic\n```\n\nIf you encounter any issues, please [create an issue in GitHub](https://github.com/pydantic/pydantic/issues) using\nthe `bug V2` label. This will help us to actively monitor and track errors, and to continue to improve the library's\nperformance.\n\nIf you need to use latest Pydantic V1 for any reason, see the [Continue using Pydantic V1 features](#continue-using-pydantic-v1-features) section below for details on installation and imports from `pydantic.v1`.", "url": "https://docs.pydantic.dev/latest/docs/migration/#install-pydantic-v2", "page": "docs/migration", "source_site": "pydantic"}
{"title": "Code transformation tool", "anchor": "code-transformation-tool", "heading_level": 2, "md_text": "We have created a tool to help you migrate your code. This tool is still in beta, but we hope it will help you to\nmigrate your code more quickly.\n\nYou can install the tool from PyPI:\n\n```bash\npip install bump-pydantic\n```\n\nThe usage is simple. If your project structure is:\n\n    * repo_folder\n        * my_package\n            * <python source files> ...\n\nThen you'll want to do:\n\n    cd /path/to/repo_folder\n    bump-pydantic my_package\n\nSee more about it on the [Bump Pydantic](https://github.com/pydantic/bump-pydantic) repository.", "url": "https://docs.pydantic.dev/latest/docs/migration/#code-transformation-tool", "page": "docs/migration", "source_site": "pydantic"}
{"title": "Continue using Pydantic V1 features", "anchor": "continue-using-pydantic-v1-features", "heading_level": 2, "md_text": "Pydantic V1 is still available when you need it, though we recommend migrating to\nPydantic V2 for its improvements and new features.\n\nIf you need to use latest Pydantic V1, you can install it with:\n\n```bash\npip install \"pydantic==1.*\"\n```\n\nThe Pydantic V2 package also continues to provide access to the Pydantic V1 API\nby importing through `pydantic.v1`.\n\nFor example, you can use the `BaseModel` class from Pydantic V1 instead of the\nPydantic V2 `pydantic.BaseModel` class:\n\n```python {test=\"skip\" lint=\"skip\" upgrade=\"skip\"}\nfrom pydantic.v1 import BaseModel\n```\n\nYou can also import functions that have been removed from Pydantic V2, such as `lenient_isinstance`:\n\n```python {test=\"skip\" lint=\"skip\" upgrade=\"skip\"}\nfrom pydantic.v1.utils import lenient_isinstance\n```\n\nPydantic V1 documentation is available at [https://docs.pydantic.dev/1.10/](https://docs.pydantic.dev/1.10/).", "url": "https://docs.pydantic.dev/latest/docs/migration/#continue-using-pydantic-v1-features", "page": "docs/migration", "source_site": "pydantic"}
{"title": "Using Pydantic v1 features in a v1/v2 environment", "anchor": "using-pydantic-v1-features-in-a-v1v2-environment", "heading_level": 3, "md_text": "As of `pydantic>=1.10.17`, the `pydantic.v1` namespace can be used within V1.\nThis makes it easier to migrate to V2, which also supports the `pydantic.v1`\nnamespace. In order to unpin a `pydantic<2` dependency and continue using V1\nfeatures, take the following steps:\n\n1. Replace `pydantic<2` with `pydantic>=1.10.17`\n2. Find and replace all occurrences of:\n\n```python {test=\"skip\" lint=\"skip\" upgrade=\"skip\"}\nfrom pydantic.<module> import <object>\n```\n\nwith:\n\n```python {test=\"skip\" lint=\"skip\" upgrade=\"skip\"}\nfrom pydantic.v1.<module> import <object>\n```\n\nHere's how you can import `pydantic`'s v1 features based on your version of `pydantic`:\n\n=== \"`pydantic>=1.10.17,<3`\"\n    As of `v1.10.17` the `.v1` namespace is available in V1, allowing imports as below:\n\n    ```python {test=\"skip\" lint=\"skip\" upgrade=\"skip\"}\n    from pydantic.v1.fields import ModelField\n    ```\n\n=== \"`pydantic<3`\"\n    All versions of Pydantic V1 and V2 support the following import pattern, in case you don't\n    know which version of Pydantic you are using:\n\n    ```python {test=\"skip\" lint=\"skip\" upgrade=\"skip\"}\n    try:\n        from pydantic.v1.fields import ModelField\n    except ImportError:\n        from pydantic.fields import ModelField\n    ```\n\n!!! note\n    When importing modules using `pydantic>=1.10.17,<2` with the `.v1` namespace\n    these modules will *not* be the **same** module as the same import without the `.v1`\n    namespace, but the symbols imported *will* be. For example `pydantic.v1.fields is not pydantic.fields`\n    but `pydantic.v1.fields.ModelField is pydantic.fields.ModelField`. Luckily, this is not likely to be relevant\n    in the vast majority of cases. It's just an unfortunate consequence of providing a smoother migration experience.", "url": "https://docs.pydantic.dev/latest/docs/migration/#using-pydantic-v1-features-in-a-v1v2-environment", "page": "docs/migration", "source_site": "pydantic"}
{"title": "Migration guide", "anchor": "migration-guide", "heading_level": 2, "md_text": "The following sections provide details on the most important changes in Pydantic V2.", "url": "https://docs.pydantic.dev/latest/docs/migration/#migration-guide", "page": "docs/migration", "source_site": "pydantic"}
{"title": "Changes to `pydantic.BaseModel`", "anchor": "changes-to-pydanticbasemodel", "heading_level": 3, "md_text": "Various method names have been changed; all non-deprecated `BaseModel` methods now have names matching either the\nformat `model_.*` or `__.*pydantic.*__`. Where possible, we have retained the deprecated methods with their old names\nto help ease migration, but calling them will emit `DeprecationWarning`s.\n\n| Pydantic V1 | Pydantic V2  |\n| ----------- | ------------ |\n| `__fields__` | `model_fields` |\n| `__private_attributes__` | `__pydantic_private__` |\n| `__validators__` | `__pydantic_validator__` |\n| `construct()` | `model_construct()` |\n| `copy()` | `model_copy()` |\n| `dict()` | `model_dump()` |\n| `json_schema()` | `model_json_schema()` |\n| `json()` | `model_dump_json()` |\n| `parse_obj()` | `model_validate()` |\n| `update_forward_refs()` | `model_rebuild()` |\n\n* Some of the built-in data-loading functionality has been slated for removal. In particular,\n    `parse_raw` and `parse_file` are now deprecated. In Pydantic V2, `model_validate_json` works like `parse_raw`. Otherwise, you should load the data and then pass it to `model_validate`.\n* The `from_orm` method has been deprecated; you can now just use `model_validate` (equivalent to `parse_obj` from\n  Pydantic V1) to achieve something similar, as long as you've set `from_attributes=True` in the model config.\n* The `__eq__` method has changed for models.\n    * Models can only be equal to other `BaseModel` instances.\n    * For two model instances to be equal, they must have the same:\n        * Type (or, in the case of generic models, non-parametrized generic origin type)\n        * Field values\n        * Extra values (only relevant when `model_config['extra'] == 'allow'`)\n        * Private attribute values; models with different values of private attributes are no longer equal.\n        * Models are no longer equal to the dicts containing their data.\n        * Non-generic models of different types are never equal.\n        * Generic models with different origin types are never equal. We don't require *exact* type equality so that,\n            for example, instances of `MyGenericModel[Any]` could be equal to instances of `MyGenericModel[int]`.\n* We have replaced the use of the `__root__` field to specify a \"custom root model\" with a new type called\n    [`RootModel`](concepts/models.md#rootmodel-and-custom-root-types) which is intended to replace the functionality of\n    using a field called `__root__` in Pydantic V1. Note, `RootModel` types no longer support the `arbitrary_types_allowed`\n    config setting. See [this issue comment](https://github.com/pydantic/pydantic/issues/6710#issuecomment-1700948167) for an explanation.\n* We have significantly expanded Pydantic's capabilities related to customizing serialization. In particular, we have\n    added the [`@field_serializer`](api/functional_serializers.md#pydantic.functional_serializers.field_serializer),\n    [`@model_serializer`](api/functional_serializers.md#pydantic.functional_serializers.model_serializer), and\n    [`@computed_field`](api/fields.md#pydantic.fields.computed_field) decorators, which each address various\n    shortcomings from Pydantic V1.\n    * See [Custom serializers](concepts/serialization.md#serializers) for the usage docs of these new decorators.\n    * Due to performance overhead and implementation complexity, we have now deprecated support for specifying\n        `json_encoders` in the model config. This functionality was originally added for the purpose of achieving custom\n        serialization logic, and we think the new serialization decorators are a better choice in most common scenarios.\n* We have changed the behavior related to serializing subclasses of models when they occur as nested fields in a parent\n  model. In V1, we would always include all fields from the subclass instance. In V2, when we dump a model, we only\n  include the fields that are defined on the annotated type of the field. This helps prevent some accidental security\n  bugs. You can read more about this (including how to opt out of this behavior) in the\n  [relevant section](concepts/serialization.md#subclasses-of-model-like-types) of the model exporting docs.\n* `GetterDict` has been removed as it was just an implementation detail of `orm_mode`, which has been removed.\n* In many cases, arguments passed to the constructor will be **copied** in order to perform validation and, where necessary, coercion\n  (see the [documentation](./concepts/models.md#attribute-copies)).\n  This is notable in the case of passing mutable objects as arguments to a constructor.\n* The `.json()` method is deprecated, and attempting to use this deprecated method with arguments such as\n`indent` or `ensure_ascii` may lead to confusing errors. For best results, switch to V2's equivalent, `model_dump_json()`.\nIf you'd still like to use said arguments, you can use [this workaround](https://github.com/pydantic/pydantic/issues/8825#issuecomment-1946206415).\n* JSON serialization of non-string key values is generally done with `str(key)`, leading to some changes in behavior such as the following:\n\n```python {test=\"skip\"}\nfrom typing import Optional\n\nfrom pydantic import BaseModel as V2BaseModel\nfrom pydantic.v1 import BaseModel as V1BaseModel", "url": "https://docs.pydantic.dev/latest/docs/migration/#changes-to-pydanticbasemodel", "page": "docs/migration", "source_site": "pydantic"}
{"title": "Changes to `pydantic.BaseModel`", "anchor": "changes-to-pydanticbasemodel", "heading_level": 3, "md_text": "\nclass V1Model(V1BaseModel):\n    a: dict[Optional[str], int]\n\n\nclass V2Model(V2BaseModel):\n    a: dict[Optional[str], int]\n\n\nv1_model = V1Model(a={None: 123})\nv2_model = V2Model(a={None: 123})", "url": "https://docs.pydantic.dev/latest/docs/migration/#changes-to-pydanticbasemodel", "page": "docs/migration", "source_site": "pydantic"}
{"title": "V1", "anchor": "v1", "heading_level": 1, "md_text": "print(v1_model.json())\n#> {\"a\": {\"null\": 123}}", "url": "https://docs.pydantic.dev/latest/docs/migration/#v1", "page": "docs/migration", "source_site": "pydantic"}
{"title": "V2", "anchor": "v2", "heading_level": 1, "md_text": "print(v2_model.model_dump_json())\n#> {\"a\":{\"None\":123}}\n```\n\n* `model_dump_json()` results are compacted in order to save space, and don't always exactly match that of `json.dumps()` output.\nThat being said, you can easily modify the separators used in `json.dumps()` results in order to align the two outputs:\n\n```python {test=\"skip\"}\nimport json\n\nfrom pydantic import BaseModel as V2BaseModel\nfrom pydantic.v1 import BaseModel as V1BaseModel\n\n\nclass V1Model(V1BaseModel):\n    a: list[str]\n\n\nclass V2Model(V2BaseModel):\n    a: list[str]\n\n\nv1_model = V1Model(a=['fancy', 'sushi'])\nv2_model = V2Model(a=['fancy', 'sushi'])", "url": "https://docs.pydantic.dev/latest/docs/migration/#v2", "page": "docs/migration", "source_site": "pydantic"}
{"title": "V1", "anchor": "v1", "heading_level": 1, "md_text": "print(v1_model.json())\n#> {\"a\": [\"fancy\", \"sushi\"]}", "url": "https://docs.pydantic.dev/latest/docs/migration/#v1", "page": "docs/migration", "source_site": "pydantic"}
{"title": "V2", "anchor": "v2", "heading_level": 1, "md_text": "print(v2_model.model_dump_json())\n#> {\"a\":[\"fancy\",\"sushi\"]}", "url": "https://docs.pydantic.dev/latest/docs/migration/#v2", "page": "docs/migration", "source_site": "pydantic"}
{"title": "Plain json.dumps", "anchor": "plain-jsondumps", "heading_level": 1, "md_text": "print(json.dumps(v2_model.model_dump()))\n#> {\"a\": [\"fancy\", \"sushi\"]}", "url": "https://docs.pydantic.dev/latest/docs/migration/#plain-jsondumps", "page": "docs/migration", "source_site": "pydantic"}
{"title": "Modified json.dumps", "anchor": "modified-jsondumps", "heading_level": 1, "md_text": "print(json.dumps(v2_model.model_dump(), separators=(',', ':')))\n#> {\"a\":[\"fancy\",\"sushi\"]}\n```", "url": "https://docs.pydantic.dev/latest/docs/migration/#modified-jsondumps", "page": "docs/migration", "source_site": "pydantic"}
{"title": "Changes to `pydantic.generics.GenericModel`", "anchor": "changes-to-pydanticgenericsgenericmodel", "heading_level": 3, "md_text": "The `pydantic.generics.GenericModel` class is no longer necessary, and has been removed. Instead, you can now\ncreate generic `BaseModel` subclasses by just adding `Generic` as a parent class on a `BaseModel` subclass directly.\nThis looks like `class MyGenericModel(BaseModel, Generic[T]): ...`.\n\nMixing of V1 and V2 models is not supported which means that type parameters of such generic `BaseModel` (V2)\ncannot be V1 models.\n\nWhile it may not raise an error, we strongly advise against using *parametrized* generics in `isinstance` checks.\n\n* For example, you should not do `isinstance(my_model, MyGenericModel[int])`.\n    However, it is fine to do `isinstance(my_model, MyGenericModel)`. (Note that for standard generics, it would raise\n    an error to do a subclass check with a parameterized generic.)\n* If you need to perform `isinstance` checks against parametrized generics, you can do this by subclassing the\n    parametrized generic class. This looks like `class MyIntModel(MyGenericModel[int]): ...` and\n    `isinstance(my_model, MyIntModel)`.\n\nFind more information in the [Generic models](concepts/models.md#generic-models) documentation.", "url": "https://docs.pydantic.dev/latest/docs/migration/#changes-to-pydanticgenericsgenericmodel", "page": "docs/migration", "source_site": "pydantic"}
{"title": "Changes to `pydantic.Field`", "anchor": "changes-to-pydanticfield", "heading_level": 3, "md_text": "`Field` no longer supports arbitrary keyword arguments to be added to the JSON schema. Instead, any extra\ndata you want to add to the JSON schema should be passed as a dictionary to the `json_schema_extra` keyword argument.\n\nIn Pydantic V1, the `alias` property returns the field's name when no alias is set.\nIn Pydantic V2, this behavior has changed to return `None` when no alias is set.\n\nThe following properties have been removed from or changed in `Field`:\n\n* `const`\n* `min_items` (use `min_length` instead)\n* `max_items` (use `max_length` instead)\n* `unique_items`\n* `allow_mutation` (use `frozen` instead)\n* `regex` (use `pattern` instead)\n* `final` (use the [typing.Final][] type hint instead)\n\nField constraints are no longer automatically pushed down to the parameters of generics.  For example, you can no longer validate every element of a list matches a regex by providing `my_list: list[str] = Field(pattern=\".*\")`.  Instead, use [`typing.Annotated`][] to provide an annotation on the `str` itself: `my_list: list[Annotated[str, Field(pattern=\".*\")]]`", "url": "https://docs.pydantic.dev/latest/docs/migration/#changes-to-pydanticfield", "page": "docs/migration", "source_site": "pydantic"}
{"title": "Changes to dataclasses", "anchor": "changes-to-dataclasses", "heading_level": 3, "md_text": "Pydantic [dataclasses](concepts/dataclasses.md) continue to be useful for enabling the data validation on standard\ndataclasses without having to subclass `BaseModel`. Pydantic V2 introduces the following changes to this dataclass behavior:\n\n* When used as fields, dataclasses (Pydantic or vanilla) no longer accept tuples as validation inputs; dicts should be\n  used instead.\n* The `__post_init__` in Pydantic dataclasses will now be called *after* validation, rather than before.\n    * As a result, the `__post_init_post_parse__` method would have become redundant, so has been removed.\n* Pydantic no longer supports `extra='allow'` for Pydantic dataclasses, where extra fields passed to the initializer would be\n    stored as extra attributes on the dataclass. `extra='ignore'` is still supported for the purpose of ignoring\n    unexpected fields while parsing data, they just won't be stored on the instance.\n* Pydantic dataclasses no longer have an attribute `__pydantic_model__`, and no longer use an underlying `BaseModel`\n    to perform validation or provide other functionality.\n    * To perform validation, generate a JSON schema, or make use of\n        any other functionality that may have required `__pydantic_model__` in V1, you should now wrap the dataclass\n        with a [`TypeAdapter`][pydantic.type_adapter.TypeAdapter] ([discussed more below](#introduction-of-typeadapter)) and\n        make use of its methods.\n* In Pydantic V1, if you used a vanilla (i.e., non-Pydantic) dataclass as a field, the config of the parent type would\n    be used as though it was the config for the dataclass itself as well. In Pydantic V2, this is no longer the case.\n    * In Pydantic V2, to override the config (like you would with `model_config` on a `BaseModel`),\n        you can use the `config` parameter on the `@dataclass` decorator.\n        See [Dataclass Config](concepts/dataclasses.md#dataclass-config) for examples.", "url": "https://docs.pydantic.dev/latest/docs/migration/#changes-to-dataclasses", "page": "docs/migration", "source_site": "pydantic"}
{"title": "Changes to config", "anchor": "changes-to-config", "heading_level": 3, "md_text": "* In Pydantic V2, to specify config on a model, you should set a class attribute called `model_config` to be a dict\n  with the key/value pairs you want to be used as the config. The Pydantic V1 behavior to create a class called `Config`\n  in the namespace of the parent `BaseModel` subclass is now deprecated.\n\n* When subclassing a model, the `model_config` attribute is inherited. This is helpful in the case where you'd like to use\na base class with a given configuration for many models. Note, if you inherit from multiple `BaseModel` subclasses,\nlike `class MyModel(Model1, Model2)`, the non-default settings in the `model_config` attribute from the two models\nwill be merged, and for any settings defined in both, those from `Model2` will override those from `Model1`.\n\n* The following config settings have been removed:\n    * `allow_mutation` \u2014 this has been removed. You should be able to use [frozen](api/config.md#pydantic.config.ConfigDict) equivalently (inverse of current use).\n    * `error_msg_templates`\n    * `fields` \u2014 this was the source of various bugs, so has been removed.\n      You should be able to use `Annotated` on fields to modify them as desired.\n    * `getter_dict` \u2014 `orm_mode` has been removed, and this implementation detail is no longer necessary.\n    * `smart_union` - the default `union_mode` in Pydantic V2 is `'smart'`.\n    * `underscore_attrs_are_private` \u2014 the Pydantic V2 behavior is now the same as if this was always set\n      to `True` in Pydantic V1.\n    * `json_loads`\n    * `json_dumps`\n    * `copy_on_model_validation`\n    * `post_init_call`\n\n* The following config settings have been renamed:\n    * `allow_population_by_field_name` \u2192 `populate_by_name` (or `validate_by_name` starting in v2.11)\n    * `anystr_lower` \u2192 `str_to_lower`\n    * `anystr_strip_whitespace` \u2192 `str_strip_whitespace`\n    * `anystr_upper` \u2192 `str_to_upper`\n    * `keep_untouched` \u2192 `ignored_types`\n    * `max_anystr_length` \u2192 `str_max_length`\n    * `min_anystr_length` \u2192 `str_min_length`\n    * `orm_mode` \u2192 `from_attributes`\n    * `schema_extra` \u2192 `json_schema_extra`\n    * `validate_all` \u2192 `validate_default`\n\nSee the [`ConfigDict` API reference][pydantic.config.ConfigDict] for more details.", "url": "https://docs.pydantic.dev/latest/docs/migration/#changes-to-config", "page": "docs/migration", "source_site": "pydantic"}
{"title": "`@validator` and `@root_validator` are deprecated", "anchor": "validator-and-root_validator-are-deprecated", "heading_level": 4, "md_text": "* `@validator` has been deprecated, and should be replaced with [`@field_validator`](concepts/validators.md), which provides various new features\n    and improvements.\n    * The new `@field_validator` decorator does not have the `each_item` keyword argument; validators you want to\n        apply to items within a generic container should be added by annotating the type argument. See\n        [validators in Annotated metadata](concepts/types.md#using-the-annotated-pattern) for details.\n        This looks like `list[Annotated[int, Field(ge=0)]]`\n    * Even if you keep using the deprecated `@validator` decorator, you can no longer add the `field` or\n        `config` arguments to the signature of validator functions. If you need access to these, you'll need\n        to migrate to `@field_validator` \u2014 see the [next section](#changes-to-validators-allowed-signatures)\n        for more details.\n    * If you use the `always=True` keyword argument to a validator function, note that standard validators\n        for the annotated type will *also* be applied even to defaults, not just the custom validators. For\n        example, despite the fact that the validator below will never error, the following code raises a `ValidationError`:\n\n!!! note\n    To avoid this, you can use the `validate_default` argument in the `Field` function. When set to `True`, it mimics the behavior of `always=True` in Pydantic v1. However, the new way of using `validate_default` is encouraged as it provides more flexibility and control.\n\n```python {test=\"skip\"}\nfrom pydantic import BaseModel, validator\n\n\nclass Model(BaseModel):\n    x: str = 1\n\n    @validator('x', always=True)\n    @classmethod\n    def validate_x(cls, v):\n        return v\n\n\nModel()\n```\n\n* `@root_validator` has been deprecated, and should be replaced with\n    [`@model_validator`](api/functional_validators.md#pydantic.functional_validators.model_validator), which also provides new features and improvements.\n    Be aware that the allowed signatures have changed (see the [relevant documentation](./concepts/validators.md#model-validators)).\n    * Under some circumstances (such as assignment when `model_config['validate_assignment'] is True`),\n        the `@model_validator` decorator will receive an instance of the model, not a dict of values. You may\n        need to be careful to handle this case.\n    * Even if you keep using the deprecated `@root_validator` decorator, due to refactors in validation logic,\n        you can no longer run with `skip_on_failure=False` (which is the default value of this keyword argument,\n        so must be set explicitly to `True`).", "url": "https://docs.pydantic.dev/latest/docs/migration/#validator-and-root_validator-are-deprecated", "page": "docs/migration", "source_site": "pydantic"}
{"title": "Changes to `@validator`'s allowed signatures", "anchor": "changes-to-validators-allowed-signatures", "heading_level": 4, "md_text": "In Pydantic V1, functions wrapped by `@validator` could receive keyword arguments with metadata about what was\nbeing validated. Some of these arguments have been removed from `@field_validator` in Pydantic V2:\n\n* `config`: Pydantic V2's config is now a dictionary instead of a class, which means this argument is no longer\n    backwards compatible. If you need to access the configuration you should migrate to `@field_validator` and use\n    `info.config`.\n* `field`: this argument used to be a `ModelField` object, which was a quasi-internal class that no longer exists\n    in Pydantic V2. Most of this information can still be accessed by using the field name from `info.field_name`\n    to index into `cls.model_fields`\n\n```python\nfrom pydantic import BaseModel, ValidationInfo, field_validator\n\n\nclass Model(BaseModel):\n    x: int\n\n    @field_validator('x')\n    def val_x(cls, v: int, info: ValidationInfo) -> int:\n        assert info.config is not None\n        print(info.config.get('title'))\n        #> Model\n        print(cls.model_fields[info.field_name].is_required())\n        #> True\n        return v\n\n\nModel(x=1)\n```", "url": "https://docs.pydantic.dev/latest/docs/migration/#changes-to-validators-allowed-signatures", "page": "docs/migration", "source_site": "pydantic"}
{"title": "`TypeError` is no longer converted to `ValidationError` in validators", "anchor": "typeerror-is-no-longer-converted-to-validationerror-in-validators", "heading_level": 4, "md_text": "Previously, when raising a `TypeError` within a validator function, that error would be wrapped into a `ValidationError`\nand, in some cases (such as with FastAPI), these errors might be displayed to end users. This led to a variety of\nundesirable behavior &mdash; for example, calling a function with the wrong signature might produce a user-facing\n`ValidationError`.\n\nHowever, in Pydantic V2, when a `TypeError` is raised in a validator, it is no longer converted into a\n`ValidationError`:\n\n```python\nimport pytest\n\nfrom pydantic import BaseModel, field_validator\n\n\nclass Model(BaseModel):\n    x: int\n\n    @field_validator('x')\n    def val_x(cls, v: int) -> int:\n        return str.lower(v)  # raises a TypeError\n\n\nwith pytest.raises(TypeError):\n    Model(x=1)\n```\n\nThis applies to all validation decorators.", "url": "https://docs.pydantic.dev/latest/docs/migration/#typeerror-is-no-longer-converted-to-validationerror-in-validators", "page": "docs/migration", "source_site": "pydantic"}
{"title": "Validator behavior changes", "anchor": "validator-behavior-changes", "heading_level": 4, "md_text": "Pydantic V2 includes some changes to type coercion. For example:\n\n* coercing `int`, `float`, and `Decimal` values to strings is now optional and disabled by default, see\n  [Coerce Numbers to Strings][pydantic.config.ConfigDict.coerce_numbers_to_str].\n* iterable of pairs is no longer coerced to a dict.\n\nSee the [Conversion table](concepts/conversion_table.md) for details on Pydantic V2 type coercion defaults.", "url": "https://docs.pydantic.dev/latest/docs/migration/#validator-behavior-changes", "page": "docs/migration", "source_site": "pydantic"}
{"title": "The `allow_reuse` keyword argument is no longer necessary", "anchor": "the-allow_reuse-keyword-argument-is-no-longer-necessary", "heading_level": 4, "md_text": "Previously, Pydantic tracked \"reused\" functions in decorators as this was a common source of mistakes.\nWe did this by comparing the function's fully qualified name (module name + function name), which could result in false\npositives. The `allow_reuse` keyword argument could be used to disable this when it was intentional.\n\nOur approach to detecting repeatedly defined functions has been overhauled to only error for redefinition within a\nsingle class, reducing false positives and bringing the behavior more in line with the errors that type checkers\nand linters would give for defining a method with the same name multiple times in a single class definition.\n\nIn nearly all cases, if you were using `allow_reuse=True`, you should be able to simply delete that keyword argument and\nhave things keep working as expected.", "url": "https://docs.pydantic.dev/latest/docs/migration/#the-allow_reuse-keyword-argument-is-no-longer-necessary", "page": "docs/migration", "source_site": "pydantic"}
{"title": "`@validate_arguments` has been renamed to `@validate_call`", "anchor": "validate_arguments-has-been-renamed-to-validate_call", "heading_level": 4, "md_text": "In Pydantic V2, the `@validate_arguments` decorator has been renamed to `@validate_call`.\n\nIn Pydantic V1, the decorated function had various attributes added, such as `raw_function`, and `validate`\n(which could be used to validate arguments without actually calling the decorated function). Due to limited use of\nthese attributes, and performance-oriented changes in implementation, we have not preserved this functionality in\n`@validate_call`.", "url": "https://docs.pydantic.dev/latest/docs/migration/#validate_arguments-has-been-renamed-to-validate_call", "page": "docs/migration", "source_site": "pydantic"}
{"title": "Input types are not preserved", "anchor": "input-types-are-not-preserved", "heading_level": 3, "md_text": "In Pydantic V1 we made great efforts to preserve the types of all field inputs for generic collections when they were\nproper subtypes of the field annotations. For example, given the annotation `Mapping[str, int]` if you passed in a\n`collection.Counter()` you'd get a `collection.Counter()` as the value.\n\nSupporting this behavior in V2 would have negative performance implications for the general case\n(we'd have to check types every time) and would add a lot of complexity to validation. Further, even in V1 this behavior\nwas inconsistent and partially broken: it did not work for many types (`str`, `UUID`, etc.), and for generic\ncollections it's impossible to re-build the original input correctly without a lot of special casing\n(consider `ChainMap`; rebuilding the input is necessary because we need to replace values after validation, e.g.\nif coercing strings to ints).\n\nIn Pydantic V2 we no longer attempt to preserve the input type in all cases; instead, we only promise that the output\ntype will match the type annotations.\n\nGoing back to the `Mapping` example, we promise the output will be a valid `Mapping`, and in practice it will be a\nplain `dict`:\n\n```python\nfrom collections.abc import Mapping\n\nfrom pydantic import TypeAdapter\n\n\nclass MyDict(dict):\n    pass\n\n\nta = TypeAdapter(Mapping[str, int])\nv = ta.validate_python(MyDict())\nprint(type(v))\n#> <class 'dict'>\n```\n\nIf you want the output type to be a specific type, consider annotating it as such or implementing a custom validator:\n\n```python\nfrom collections.abc import Mapping\nfrom typing import Annotated, Any, TypeVar\n\nfrom pydantic import (\n    TypeAdapter,\n    ValidationInfo,\n    ValidatorFunctionWrapHandler,\n    WrapValidator,\n)\n\n\ndef restore_input_type(\n    value: Any, handler: ValidatorFunctionWrapHandler, _info: ValidationInfo\n) -> Any:\n    return type(value)(handler(value))\n\n\nT = TypeVar('T')\nPreserveType = Annotated[T, WrapValidator(restore_input_type)]\n\n\nta = TypeAdapter(PreserveType[Mapping[str, int]])\n\n\nclass MyDict(dict):\n    pass\n\n\nv = ta.validate_python(MyDict())\nassert type(v) is MyDict\n```\n\nWhile we don't promise to preserve input types everywhere, we *do* preserve them for subclasses of `BaseModel`,\nand for dataclasses:\n\n```python\nimport pydantic.dataclasses\nfrom pydantic import BaseModel\n\n\nclass InnerModel(BaseModel):\n    x: int\n\n\nclass OuterModel(BaseModel):\n    inner: InnerModel\n\n\nclass SubInnerModel(InnerModel):\n    y: int\n\n\nm = OuterModel(inner=SubInnerModel(x=1, y=2))\nprint(m)\n#> inner=SubInnerModel(x=1, y=2)\n\n\n@pydantic.dataclasses.dataclass\nclass InnerDataclass:\n    x: int\n\n\n@pydantic.dataclasses.dataclass\nclass SubInnerDataclass(InnerDataclass):\n    y: int\n\n\n@pydantic.dataclasses.dataclass\nclass OuterDataclass:\n    inner: InnerDataclass\n\n\nd = OuterDataclass(inner=SubInnerDataclass(x=1, y=2))\nprint(d)\n#> OuterDataclass(inner=SubInnerDataclass(x=1, y=2))\n```", "url": "https://docs.pydantic.dev/latest/docs/migration/#input-types-are-not-preserved", "page": "docs/migration", "source_site": "pydantic"}
{"title": "Dicts", "anchor": "dicts", "heading_level": 4, "md_text": "Iterables of pairs (which include empty iterables) no longer pass validation for fields of type `dict`.", "url": "https://docs.pydantic.dev/latest/docs/migration/#dicts", "page": "docs/migration", "source_site": "pydantic"}
{"title": "Unions", "anchor": "unions", "heading_level": 4, "md_text": "While union types will still attempt validation of each choice from left to right, they now preserve the type of the\ninput whenever possible, even if the correct type is not the first choice for which the input would pass validation.\nAs a demonstration, consider the following example:\n\n```python\nfrom typing import Union\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    x: Union[int, str]\n\n\nprint(Model(x='1'))\n#> x='1'\n```\n\nIn Pydantic V1, the printed result would have been `x=1`, since the value would pass validation as an `int`.\nIn Pydantic V2, we recognize that the value is an instance of one of the cases and short-circuit the standard union validation.\n\nTo revert to the non-short-circuiting left-to-right behavior of V1, annotate the union with `Field(union_mode='left_to_right')`.\nSee [Union Mode](./concepts/unions.md#union-modes) for more details.", "url": "https://docs.pydantic.dev/latest/docs/migration/#unions", "page": "docs/migration", "source_site": "pydantic"}
{"title": "Required, optional, and nullable fields", "anchor": "required-optional-and-nullable-fields", "heading_level": 4, "md_text": "Pydantic V2 changes some of the logic for specifying whether a field annotated as `Optional` is required\n(i.e., has no default value) or not (i.e., has a default value of `None` or any other value of the corresponding type), and now more closely matches the\nbehavior of `dataclasses`. Similarly, fields annotated as `Any` no longer have a default value of `None`.\n\nThe following table describes the behavior of field annotations in V2:\n\n| State                                                 | Field Definition            |\n|-------------------------------------------------------|-----------------------------|\n| Required, cannot be `None`                            | `f1: str`                   |\n| Not required, cannot be `None`, is `'abc'` by default | `f2: str = 'abc'`           |\n| Required, can be `None`                               | `f3: Optional[str]`         |\n| Not required, can be `None`, is `None` by default     | `f4: Optional[str] = None`  |\n| Not required, can be `None`, is `'abc'` by default    | `f5: Optional[str] = 'abc'` |\n| Required, can be any type (including `None`)          | `f6: Any`                   |\n| Not required, can be any type (including `None`)      | `f7: Any = None`            |\n\n!!! note\n    A field annotated as `typing.Optional[T]` will be required, and will allow for a value of `None`.\n    It does not mean that the field has a default value of `None`. *(This is a breaking change from V1.)*\n\n!!! note\n    Any default value if provided makes a field not required.\n\nHere is a code example demonstrating the above:\n\n```python\nfrom typing import Optional\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Foo(BaseModel):\n    f1: str  # required, cannot be None\n    f2: Optional[str]  # required, can be None - same as str | None\n    f3: Optional[str] = None  # not required, can be None\n    f4: str = 'Foobar'  # not required, but cannot be None\n\n\ntry:\n    Foo(f1=None, f2=None, f4='b')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Foo\n    f1\n      Input should be a valid string [type=string_type, input_value=None, input_type=NoneType]\n    \"\"\"\n```", "url": "https://docs.pydantic.dev/latest/docs/migration/#required-optional-and-nullable-fields", "page": "docs/migration", "source_site": "pydantic"}
{"title": "Patterns / regex on strings", "anchor": "patterns-regex-on-strings", "heading_level": 4, "md_text": "Pydantic V1 used Python's regex library. Pydantic V2 uses the Rust [regex crate].\nThis crate is not just a \"Rust version of regular expressions\", it's a completely different approach to regular expressions.\nIn particular, it promises linear time searching of strings in exchange for dropping a couple of features (namely look arounds and backreferences).\nWe believe this is a tradeoff worth making, in particular because Pydantic is used to validate untrusted input where ensuring things don't accidentally run in exponential time depending on the untrusted input is important.\nOn the flipside, for anyone not using these features complex regex validation should be orders of magnitude faster because it's done in Rust and in linear time.\n\nIf you still want to use Python's regex library, you can use the [`regex_engine`](./api/config.md#pydantic.config.ConfigDict.regex_engine) config setting.\n\n[regex crate]: https://github.com/rust-lang/regex", "url": "https://docs.pydantic.dev/latest/docs/migration/#patterns-regex-on-strings", "page": "docs/migration", "source_site": "pydantic"}
{"title": "Type conversion from floats to integers", "anchor": "type-conversion-from-floats-to-integers", "heading_level": 3, "md_text": "In V1, whenever a field was annotated as `int`, any float value would be accepted, which could lead to a potential data\nloss if the float value contains a non-zero decimal part. In V2, type conversion from floats to integers is only allowed\nif the decimal part is zero:\n\n```python\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: int\n\n\nprint(Model(x=10.0))\n#> x=10\ntry:\n    Model(x=10.2)\nexcept ValidationError as err:\n    print(err)\n    \"\"\"\n    1 validation error for Model\n    x\n      Input should be a valid integer, got a number with a fractional part [type=int_from_float, input_value=10.2, input_type=float]\n    \"\"\"\n```", "url": "https://docs.pydantic.dev/latest/docs/migration/#type-conversion-from-floats-to-integers", "page": "docs/migration", "source_site": "pydantic"}
{"title": "Introduction of `TypeAdapter`", "anchor": "introduction-of-typeadapter", "heading_level": 3, "md_text": "Pydantic V1 had weak support for validating or serializing non-`BaseModel` types.\n\nTo work with them, you had to either create a \"root\" model or use the utility functions in `pydantic.tools`\n(namely, `parse_obj_as` and `schema_of`).\n\nIn Pydantic V2 this is *a lot* easier: the [`TypeAdapter`][pydantic.type_adapter.TypeAdapter] class lets you create an object\nwith methods for validating, serializing, and producing JSON schemas for arbitrary types.\nThis serves as a complete replacement for `parse_obj_as` and `schema_of` (which are now deprecated),\nand also covers some of the use cases of \"root\" models. ([`RootModel`](concepts/models.md#rootmodel-and-custom-root-types),\n[discussed above](#changes-to-pydanticbasemodel), covers the others.)\n\n```python\nfrom pydantic import TypeAdapter\n\nadapter = TypeAdapter(list[int])\nassert adapter.validate_python(['1', '2', '3']) == [1, 2, 3]\nprint(adapter.json_schema())\n#> {'items': {'type': 'integer'}, 'type': 'array'}\n```\n\nDue to limitations of inferring generic types with common type checkers, to get proper typing in some scenarios, you\nmay need to explicitly specify the generic parameter:\n\n```python {test=\"skip\"}\nfrom pydantic import TypeAdapter\n\nadapter = TypeAdapter[str | int](str | int)\n...\n```\n\nSee [Type Adapter](concepts/type_adapter.md) for more information.", "url": "https://docs.pydantic.dev/latest/docs/migration/#introduction-of-typeadapter", "page": "docs/migration", "source_site": "pydantic"}
{"title": "Defining custom types", "anchor": "defining-custom-types", "heading_level": 3, "md_text": "We have completely overhauled the way custom types are defined in pydantic.\n\nWe have exposed hooks for generating both `pydantic-core` and JSON schemas, allowing you to get all the performance\nbenefits of Pydantic V2 even when using your own custom types.\n\nWe have also introduced ways to use [`typing.Annotated`][] to add custom validation to your own types.\n\nThe main changes are:\n\n* `__get_validators__` should be replaced with `__get_pydantic_core_schema__`.\n  See [Custom Data Types](concepts/types.md#customizing_validation_with_get_pydantic_core_schema) for more information.\n* `__modify_schema__` becomes `__get_pydantic_json_schema__`.\n  See [JSON Schema Customization](concepts/json_schema.md#customizing-json-schema) for more information.\n\nAdditionally, you can use [`typing.Annotated`][] to modify or provide the `__get_pydantic_core_schema__` and\n`__get_pydantic_json_schema__` functions of a type by annotating it, rather than modifying the type itself.\nThis provides a powerful and flexible mechanism for integrating third-party types with Pydantic, and in some cases\nmay help you remove hacks from Pydantic V1 introduced to work around the limitations for custom types.\n\nSee [Custom Data Types](concepts/types.md#custom-types) for more information.", "url": "https://docs.pydantic.dev/latest/docs/migration/#defining-custom-types", "page": "docs/migration", "source_site": "pydantic"}
{"title": "Changes to JSON schema generation", "anchor": "changes-to-json-schema-generation", "heading_level": 3, "md_text": "We received many requests over the years to make changes to the JSON schemas that pydantic generates.\n\nIn Pydantic V2, we have tried to address many of the common requests:\n\n* The JSON schema for `Optional` fields now indicates that the value `null` is allowed.\n* The `Decimal` type is now exposed in JSON schema (and serialized) as a string.\n* The JSON schema no longer preserves namedtuples as namedtuples.\n* The JSON schema we generate by default now targets draft 2020-12 (with some OpenAPI extensions).\n* When they differ, you can now specify if you want the JSON schema representing the inputs to validation,\n    or the outputs from serialization.\n\nHowever, there have been many reasonable requests over the years for changes which we have not chosen to implement.\n\nIn Pydantic V1, even if you were willing to implement changes yourself, it was very difficult because the JSON schema\ngeneration process involved various recursive function calls; to override one, you'd have to copy and modify the whole\nimplementation.\n\nIn Pydantic V2, one of our design goals was to make it easier to customize JSON schema generation. To this end, we have\nintroduced the class [`GenerateJsonSchema`](api/json_schema.md#pydantic.json_schema.GenerateJsonSchema),\nwhich implements the translation of a type's pydantic-core schema into\na JSON schema. By design, this class breaks the JSON schema generation process into smaller methods that can be\neasily overridden in subclasses to modify the \"global\" approach to generating JSON schema.\n\nThe various methods that can be used to produce JSON schema (such as `BaseModel.model_json_schema` or\n`TypeAdapter.json_schema`) accept a keyword argument `schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema`,\nand you can pass your custom subclass to these methods in order to use your own approach to generating JSON schema.\n\nHopefully this means that if you disagree with any of the choices we've made, or if you are reliant on behaviors in\nPydantic V1 that have changed in Pydantic V2, you can use a custom `schema_generator`, modifying the\n`GenerateJsonSchema` class as necessary for your application.", "url": "https://docs.pydantic.dev/latest/docs/migration/#changes-to-json-schema-generation", "page": "docs/migration", "source_site": "pydantic"}
{"title": "`BaseSettings` has moved to `pydantic-settings`", "anchor": "basesettings-has-moved-to-pydantic-settings", "heading_level": 3, "md_text": "[`BaseSettings`](api/pydantic_settings.md#pydantic_settings.BaseSettings), the base object for Pydantic\n[settings management](concepts/pydantic_settings.md), has been moved to a separate package,\n[`pydantic-settings`](https://github.com/pydantic/pydantic-settings).\n\nAlso, the `parse_env_var` classmethod has been removed. So, you need to\n[customise settings sources](concepts/pydantic_settings.md#customise-settings-sources)\nto have your own parsing function.", "url": "https://docs.pydantic.dev/latest/docs/migration/#basesettings-has-moved-to-pydantic-settings", "page": "docs/migration", "source_site": "pydantic"}
{"title": "Color and Payment Card Numbers moved to `pydantic-extra-types`", "anchor": "color-and-payment-card-numbers-moved-to-pydantic-extra-types", "heading_level": 3, "md_text": "The following special-use types have been moved to the\n[Pydantic Extra Types](https://github.com/pydantic/pydantic-extra-types) package,\nwhich may be installed separately if needed.\n\n* [Color Types](api/pydantic_extra_types_color.md)\n* [Payment Card Numbers](api/pydantic_extra_types_payment.md)", "url": "https://docs.pydantic.dev/latest/docs/migration/#color-and-payment-card-numbers-moved-to-pydantic-extra-types", "page": "docs/migration", "source_site": "pydantic"}
{"title": "Url and Dsn types in `pydantic.networks` no longer inherit from `str`", "anchor": "url-and-dsn-types-in-pydanticnetworks-no-longer-inherit-from-str", "heading_level": 3, "md_text": "In Pydantic V1 the [`AnyUrl`][pydantic.networks.AnyUrl] type inherited from `str`, and all the other\n`Url` and `Dsn` types inherited from these. In Pydantic V2 these types are built on two new `Url` and `MultiHostUrl`\nclasses using `Annotated`.\n\nInheriting from `str` had upsides and downsides, and for V2 we decided it would be better to remove this. To use these\ntypes in APIs which expect `str` you'll now need to convert them (with `str(url)`).\n\nPydantic V2 uses Rust's [Url](https://crates.io/crates/url) crate for URL validation.\nSome of the URL validation differs slightly from the previous behavior in V1.\nOne notable difference is that the new `Url` types append slashes to the validated version if no path is included,\neven if a slash is not specified in the argument to a `Url` type constructor. See the example below for this behavior:\n\n```python\nfrom pydantic import AnyUrl\n\nassert str(AnyUrl(url='https://google.com')) == 'https://google.com/'\nassert str(AnyUrl(url='https://google.com/')) == 'https://google.com/'\nassert str(AnyUrl(url='https://google.com/api')) == 'https://google.com/api'\nassert str(AnyUrl(url='https://google.com/api/')) == 'https://google.com/api/'\n```\n\nIf you still want to use the old behavior without the appended slash, take a look at this [solution](https://github.com/pydantic/pydantic/issues/7186#issuecomment-1690235887).", "url": "https://docs.pydantic.dev/latest/docs/migration/#url-and-dsn-types-in-pydanticnetworks-no-longer-inherit-from-str", "page": "docs/migration", "source_site": "pydantic"}
{"title": "Constrained types", "anchor": "constrained-types", "heading_level": 3, "md_text": "The `Constrained*` classes were *removed*, and you should replace them by `Annotated[<type>, Field(...)]`, for example:\n\n```python {test=\"skip\"}\nfrom pydantic import BaseModel, ConstrainedInt\n\n\nclass MyInt(ConstrainedInt):\n    ge = 0\n\n\nclass Model(BaseModel):\n    x: MyInt\n```\n\n...becomes:\n\n```python\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Field\n\nMyInt = Annotated[int, Field(ge=0)]\n\n\nclass Model(BaseModel):\n    x: MyInt\n```\n\nRead more about it in the [Composing types via `Annotated`](concepts/types.md#using-the-annotated-pattern)\ndocs.\n\nFor `ConstrainedStr` you can use [`StringConstraints`][pydantic.types.StringConstraints] instead.", "url": "https://docs.pydantic.dev/latest/docs/migration/#constrained-types", "page": "docs/migration", "source_site": "pydantic"}
{"title": "Mypy plugins", "anchor": "mypy-plugins", "heading_level": 3, "md_text": "Pydantic V2 contains a [mypy](https://mypy.readthedocs.io/en/stable/extending_mypy.html#configuring-mypy-to-use-plugins) plugin in\n`pydantic.mypy`.\n\nWhen using [V1 features](migration.md#continue-using-pydantic-v1-features) the\n`pydantic.v1.mypy` plugin might need to also be enabled.\n\nTo configure the mypy plugins:\n\n=== \"`mypy.ini`\"\n\n    ```ini\n    [mypy]\n    plugins = pydantic.mypy, pydantic.v1.mypy  # include `.v1.mypy` if required.\n    ```\n\n=== \"`pyproject.toml`\"\n\n    ```toml\n    [tool.mypy]\n    plugins = [\n        \"pydantic.mypy\",\n        \"pydantic.v1.mypy\",  # include `.v1.mypy` if required.\n    ]\n    ```", "url": "https://docs.pydantic.dev/latest/docs/migration/#mypy-plugins", "page": "docs/migration", "source_site": "pydantic"}
{"title": "Other changes", "anchor": "other-changes", "heading_level": 2, "md_text": "* Dropped support for [`email-validator<2.0.0`](https://github.com/JoshData/python-email-validator). Make sure to update\n  using `pip install -U email-validator`.", "url": "https://docs.pydantic.dev/latest/docs/migration/#other-changes", "page": "docs/migration", "source_site": "pydantic"}
{"title": "Moved in Pydantic V2", "anchor": "moved-in-pydantic-v2", "heading_level": 2, "md_text": "| Pydantic V1 | Pydantic V2 |\n| --- | --- |\n| `pydantic.BaseSettings` | [`pydantic_settings.BaseSettings`](#basesettings-has-moved-to-pydantic-settings) |\n| `pydantic.color` | [`pydantic_extra_types.color`][pydantic_extra_types.color] |\n| `pydantic.types.PaymentCardBrand` | [`pydantic_extra_types.PaymentCardBrand`](#color-and-payment-card-numbers-moved-to-pydantic-extra-types) |\n| `pydantic.types.PaymentCardNumber` | [`pydantic_extra_types.PaymentCardNumber`](#color-and-payment-card-numbers-moved-to-pydantic-extra-types) |\n| `pydantic.utils.version_info` | [`pydantic.version.version_info`][pydantic.version.version_info] |\n| `pydantic.error_wrappers.ValidationError` | [`pydantic.ValidationError`][pydantic_core.ValidationError] |\n| `pydantic.utils.to_camel` | [`pydantic.alias_generators.to_pascal`][pydantic.alias_generators.to_pascal] |\n| `pydantic.utils.to_lower_camel` | [`pydantic.alias_generators.to_camel`][pydantic.alias_generators.to_camel] |\n| `pydantic.PyObject` | [`pydantic.ImportString`][pydantic.types.ImportString] |", "url": "https://docs.pydantic.dev/latest/docs/migration/#moved-in-pydantic-v2", "page": "docs/migration", "source_site": "pydantic"}
{"title": "Deprecated and moved in Pydantic V2", "anchor": "deprecated-and-moved-in-pydantic-v2", "heading_level": 2, "md_text": "| Pydantic V1 | Pydantic V2 |\n| --- | --- |\n| `pydantic.tools.schema_of` | `pydantic.deprecated.tools.schema_of` |\n| `pydantic.tools.parse_obj_as` | `pydantic.deprecated.tools.parse_obj_as` |\n| `pydantic.tools.schema_json_of` | `pydantic.deprecated.tools.schema_json_of` |\n| `pydantic.json.pydantic_encoder` | `pydantic.deprecated.json.pydantic_encoder` |\n| `pydantic.validate_arguments` | `pydantic.deprecated.decorator.validate_arguments` |\n| `pydantic.json.custom_pydantic_encoder` | `pydantic.deprecated.json.custom_pydantic_encoder` |\n| `pydantic.json.ENCODERS_BY_TYPE` | `pydantic.deprecated.json.ENCODERS_BY_TYPE` |\n| `pydantic.json.timedelta_isoformat` | `pydantic.deprecated.json.timedelta_isoformat` |\n| `pydantic.decorator.validate_arguments` | `pydantic.deprecated.decorator.validate_arguments` |\n| `pydantic.class_validators.validator` | `pydantic.deprecated.class_validators.validator` |\n| `pydantic.class_validators.root_validator` | `pydantic.deprecated.class_validators.root_validator` |\n| `pydantic.utils.deep_update` | `pydantic.v1.utils.deep_update` |\n| `pydantic.utils.GetterDict` | `pydantic.v1.utils.GetterDict` |\n| `pydantic.utils.lenient_issubclass` | `pydantic.v1.utils.lenient_issubclass` |\n| `pydantic.utils.lenient_isinstance` | `pydantic.v1.utils.lenient_isinstance` |\n| `pydantic.utils.is_valid_field` | `pydantic.v1.utils.is_valid_field` |\n| `pydantic.utils.update_not_none` | `pydantic.v1.utils.update_not_none` |\n| `pydantic.utils.import_string` | `pydantic.v1.utils.import_string` |\n| `pydantic.utils.Representation` | `pydantic.v1.utils.Representation` |\n| `pydantic.utils.ROOT_KEY` | `pydantic.v1.utils.ROOT_KEY` |\n| `pydantic.utils.smart_deepcopy` | `pydantic.v1.utils.smart_deepcopy` |\n| `pydantic.utils.sequence_like` | `pydantic.v1.utils.sequence_like` |", "url": "https://docs.pydantic.dev/latest/docs/migration/#deprecated-and-moved-in-pydantic-v2", "page": "docs/migration", "source_site": "pydantic"}
{"title": "Removed in Pydantic V2", "anchor": "removed-in-pydantic-v2", "heading_level": 2, "md_text": "* `pydantic.ConstrainedBytes`\n* `pydantic.ConstrainedDate`\n* `pydantic.ConstrainedDecimal`\n* `pydantic.ConstrainedFloat`\n* `pydantic.ConstrainedFrozenSet`\n* `pydantic.ConstrainedInt`\n* `pydantic.ConstrainedList`\n* `pydantic.ConstrainedSet`\n* `pydantic.ConstrainedStr`\n* `pydantic.JsonWrapper`\n* `pydantic.NoneBytes`\n    * This was an alias to `None | bytes`.\n* `pydantic.NoneStr`\n    * This was an alias to `None | str`.\n* `pydantic.NoneStrBytes`\n    * This was an alias to `None | str | bytes`.\n* `pydantic.Protocol`\n* `pydantic.Required`\n* `pydantic.StrBytes`\n    * This was an alias to `str | bytes`.\n* `pydantic.compiled`\n* `pydantic.config.get_config`\n* `pydantic.config.inherit_config`\n* `pydantic.config.prepare_config`\n* `pydantic.create_model_from_namedtuple`\n* `pydantic.create_model_from_typeddict`\n* `pydantic.dataclasses.create_pydantic_model_from_dataclass`\n* `pydantic.dataclasses.make_dataclass_validator`\n* `pydantic.dataclasses.set_validation`\n* `pydantic.datetime_parse.parse_date`\n* `pydantic.datetime_parse.parse_time`\n* `pydantic.datetime_parse.parse_datetime`\n* `pydantic.datetime_parse.parse_duration`\n* `pydantic.error_wrappers.ErrorWrapper`\n* `pydantic.errors.AnyStrMaxLengthError`\n* `pydantic.errors.AnyStrMinLengthError`\n* `pydantic.errors.ArbitraryTypeError`\n* `pydantic.errors.BoolError`\n* `pydantic.errors.BytesError`\n* `pydantic.errors.CallableError`\n* `pydantic.errors.ClassError`\n* `pydantic.errors.ColorError`\n* `pydantic.errors.ConfigError`\n* `pydantic.errors.DataclassTypeError`\n* `pydantic.errors.DateError`\n* `pydantic.errors.DateNotInTheFutureError`\n* `pydantic.errors.DateNotInThePastError`\n* `pydantic.errors.DateTimeError`\n* `pydantic.errors.DecimalError`\n* `pydantic.errors.DecimalIsNotFiniteError`\n* `pydantic.errors.DecimalMaxDigitsError`\n* `pydantic.errors.DecimalMaxPlacesError`\n* `pydantic.errors.DecimalWholeDigitsError`\n* `pydantic.errors.DictError`\n* `pydantic.errors.DurationError`\n* `pydantic.errors.EmailError`\n* `pydantic.errors.EnumError`\n* `pydantic.errors.EnumMemberError`\n* `pydantic.errors.ExtraError`\n* `pydantic.errors.FloatError`\n* `pydantic.errors.FrozenSetError`\n* `pydantic.errors.FrozenSetMaxLengthError`\n* `pydantic.errors.FrozenSetMinLengthError`\n* `pydantic.errors.HashableError`\n* `pydantic.errors.IPv4AddressError`\n* `pydantic.errors.IPv4InterfaceError`\n* `pydantic.errors.IPv4NetworkError`\n* `pydantic.errors.IPv6AddressError`\n* `pydantic.errors.IPv6InterfaceError`\n* `pydantic.errors.IPv6NetworkError`\n* `pydantic.errors.IPvAnyAddressError`\n* `pydantic.errors.IPvAnyInterfaceError`\n* `pydantic.errors.IPvAnyNetworkError`\n* `pydantic.errors.IntEnumError`\n* `pydantic.errors.IntegerError`\n* `pydantic.errors.InvalidByteSize`\n* `pydantic.errors.InvalidByteSizeUnit`\n* `pydantic.errors.InvalidDiscriminator`\n* `pydantic.errors.InvalidLengthForBrand`\n* `pydantic.errors.JsonError`\n* `pydantic.errors.JsonTypeError`\n* `pydantic.errors.ListError`\n* `pydantic.errors.ListMaxLengthError`\n* `pydantic.errors.ListMinLengthError`\n* `pydantic.errors.ListUniqueItemsError`\n* `pydantic.errors.LuhnValidationError`\n* `pydantic.errors.MissingDiscriminator`\n* `pydantic.errors.MissingError`\n* `pydantic.errors.NoneIsAllowedError`\n* `pydantic.errors.NoneIsNotAllowedError`\n* `pydantic.errors.NotDigitError`\n* `pydantic.errors.NotNoneError`\n* `pydantic.errors.NumberNotGeError`\n* `pydantic.errors.NumberNotGtError`\n* `pydantic.errors.NumberNotLeError`\n* `pydantic.errors.NumberNotLtError`\n* `pydantic.errors.NumberNotMultipleError`\n* `pydantic.errors.PathError`\n* `pydantic.errors.PathNotADirectoryError`\n* `pydantic.errors.PathNotAFileError`\n* `pydantic.errors.PathNotExistsError`\n* `pydantic.errors.PatternError`\n* `pydantic.errors.PyObjectError`\n* `pydantic.errors.PydanticTypeError`\n* `pydantic.errors.PydanticValueError`\n* `pydantic.errors.SequenceError`\n* `pydantic.errors.SetError`\n* `pydantic.errors.SetMaxLengthError`\n* `pydantic.errors.SetMinLengthError`\n* `pydantic.errors.StrError`\n* `pydantic.errors.StrRegexError`\n* `pydantic.errors.StrictBoolError`\n* `pydantic.errors.SubclassError`\n* `pydantic.errors.TimeError`\n* `pydantic.errors.TupleError`\n* `pydantic.errors.TupleLengthError`\n* `pydantic.errors.UUIDError`\n* `pydantic.errors.UUIDVersionError`\n* `pydantic.errors.UrlError`\n* `pydantic.errors.UrlExtraError`\n* `pydantic.errors.UrlHostError`\n* `pydantic.errors.UrlHostTldError`\n* `pydantic.errors.UrlPortError`\n* `pydantic.errors.UrlSchemeError`\n* `pydantic.errors.UrlSchemePermittedError`\n* `pydantic.errors.UrlUserInfoError`\n* `pydantic.errors.WrongConstantError`\n* `pydantic.main.validate_model`\n* `pydantic.networks.stricturl`\n* `pydantic.parse_file_as`\n* `pydantic.parse_raw_as`\n* `pydantic.stricturl`\n* `pydantic.tools.parse_file_as`\n* `pydantic.tools.parse_raw_as`\n* `pydantic.types.JsonWrapper`\n* `pydantic.types.NoneBytes`\n* `pydantic.types.NoneStr`\n* `pydantic.types.NoneStrBytes`\n* `pydantic.types.PyObject`\n* `pydantic.types.StrBytes`\n* `pydantic.typing.evaluate_forwardref`\n* `pydantic.typing.AbstractSetIntStr`\n* `pydantic.typing.AnyCallable`\n* `pydantic.typing.AnyClassMethod`\n* `pydantic.typing.CallableGenerator`\n* `pydantic.typing.DictAny`\n* `pydantic.typing.DictIntStrAny`\n* `pydantic.typing.DictStrAny`\n* `pydantic.typing.IntStr`\n* `pydantic.typing.ListStr`\n* `pydantic.typing.MappingIntStrAny`\n* `pydantic.typing.NoArgAnyCallable`\n* `pydantic.typing.NoneType`\n* `pydantic.typing.ReprArgs`\n* `pydantic.typing.SetStr`\n* `pydantic.typing.StrPath`\n* `pydantic.typing.TupleGenerator`\n* `pydantic.typing.WithArgsTypes`\n* `pydantic.typing.all_literal_values`\n* `pydantic.typing.display_as_type`\n* `pydantic.typing.get_all_type_hints`\n* `pydantic.typing.get_args`\n* `pydantic.typing.get_origin`\n* `pydantic.typing.get_sub_types`\n* `pydantic.typing.is_callable_type`\n* `pydantic.typing.is_classvar`\n* `pydantic.typing.is_finalvar`\n* `pydantic.typing.is_literal_type`\n* `pydantic.typing.is_namedtuple`\n* `pydantic.typing.is_new_type`\n* `pydantic.typing.is_none_type`\n* `pydantic.typing.is_typeddict`\n* `pydantic.typing.is_typeddict_special`\n* `pydantic.typing.is_union`\n* `pydantic.typing.new_type_supertype`\n* `pydantic.typing.resolve_annotations`\n* `pydantic.typing.typing_base`\n* `pydantic.typing.update_field_forward_refs`\n* `pydantic.typing.update_model_forward_refs`\n* `pydantic.utils.ClassAttribute`\n* `pydantic.utils.DUNDER_ATTRIBUTES`\n* `pydantic.utils.PyObjectStr`\n* `pydantic.utils.ValueItems`\n* `pydantic.utils.almost_equal_floats`\n* `pydantic.utils.get_discriminator_alias_and_values`\n* `pydantic.utils.get_model`\n* `pydantic.utils.get_unique_discriminator_alias`\n* `pydantic.utils.in_ipython`\n* `pydantic.utils.is_valid_identifier`\n* `pydantic.utils.path_type`\n* `pydantic.utils.validate_field_name`\n* `pydantic.validate_model`", "url": "https://docs.pydantic.dev/latest/docs/migration/#removed-in-pydantic-v2", "page": "docs/migration", "source_site": "pydantic"}
{"title": "version-policy", "anchor": null, "heading_level": 0, "md_text": "First of all, we recognize that the transitions from Pydantic V1 to V2 has been and will be painful for some users.\nWe're sorry about this pain :pray:, it was an unfortunate but necessary step to correct design mistakes of V1.\n\n**There will not be another breaking change of this magnitude!**", "url": "https://docs.pydantic.dev/latest/docs/version-policy/", "page": "docs/version-policy", "source_site": "pydantic"}
{"title": "Pydantic V1", "anchor": "pydantic-v1", "heading_level": 2, "md_text": "Active development of V1 has already stopped, however critical bug fixes and security vulnerabilities will be fixed in V1 until\nthe release of Pydantic V3.", "url": "https://docs.pydantic.dev/latest/docs/version-policy/#pydantic-v1", "page": "docs/version-policy", "source_site": "pydantic"}
{"title": "Pydantic V2", "anchor": "pydantic-v2", "heading_level": 2, "md_text": "We will not intentionally make breaking changes in minor releases of V2.\n\nFunctionality marked as deprecated will not be removed until the next major V3 release.\n\nOf course, some apparently safe changes and bug fixes will inevitably break some users' code &mdash; obligatory link to [xkcd](https://xkcd.com/1172/).\n\nThe following changes will **NOT** be considered breaking changes, and may occur in minor releases:\n\n* Bug fixes that may result in existing code breaking, provided that such code was relying on undocumented features/constructs.\n* Changing the format of JSON Schema [references](https://json-schema.org/understanding-json-schema/structuring#dollarref).\n* Changing the `msg`, `ctx`, and `loc` fields of [`ValidationError`][pydantic_core.ValidationError] exceptions. `type` will not change &mdash; if you're programmatically parsing error messages, you should use `type`.\n* Adding new keys to [`ValidationError`][pydantic_core.ValidationError] exceptions &mdash; e.g. we intend to add `line_number` and `column_number` to errors when validating JSON once we migrate to a new JSON parser.\n* Adding new [`ValidationError`][pydantic_core.ValidationError] errors.\n* Changing how `__repr__` behaves, even of public classes.\n* The contents of the [core schemas](./internals/architecture.md#communicating-between-pydantic-and-pydantic-core-the-core-schema) (usually available under the\n<!-- https://github.com/DavidAnson/markdownlint/issues/1472 -->\n<!-- markdownlint-disable-next-line strong-style -->\n  [`__pydantic_core_schema__`][pydantic.BaseModel.__pydantic_core_schema__] attribute for Pydantic models and `core_schema` for [type adapters](./concepts/type_adapter.md))\n  may change between releases (this is a low-level format Pydantic uses to plan how to execute validation and serialization).\n\nIn all cases we will aim to minimize churn and do so only when justified by the increase of quality of Pydantic for users.", "url": "https://docs.pydantic.dev/latest/docs/version-policy/#pydantic-v2", "page": "docs/version-policy", "source_site": "pydantic"}
{"title": "Pydantic V3 and beyond", "anchor": "pydantic-v3-and-beyond", "heading_level": 2, "md_text": "We expect to make new major releases roughly once a year going forward, although as mentioned above, any associated breaking changes should be trivial to fix compared to the V1-to-V2 transition.", "url": "https://docs.pydantic.dev/latest/docs/version-policy/#pydantic-v3-and-beyond", "page": "docs/version-policy", "source_site": "pydantic"}
{"title": "Experimental Features", "anchor": "experimental-features", "heading_level": 2, "md_text": "At Pydantic, we like to move quickly and innovate! To that end, we may introduce experimental features in minor releases.\n\n!!! abstract \"Usage Documentation\"\n    To learn more about our current experimental features, see the [experimental features documentation](./concepts/experimental.md).\n\nPlease keep in mind, experimental features are active works in progress. If these features are successful, they'll eventually become part of Pydantic. If unsuccessful, said features will be removed with little notice. While in its experimental phase, a feature's API and behaviors may not be stable, and it's very possible that changes made to the feature will not be backward-compatible.", "url": "https://docs.pydantic.dev/latest/docs/version-policy/#experimental-features", "page": "docs/version-policy", "source_site": "pydantic"}
{"title": "Naming Conventions", "anchor": "naming-conventions", "heading_level": 3, "md_text": "We use one of the following naming conventions to indicate that a feature is experimental:\n\n1. The feature is located in the [`experimental`](api/experimental.md) module. In this case, you can access the feature like this:\n\n    ```python {test=\"skip\" lint=\"skip\"}\n    from pydantic.experimental import feature_name\n    ```\n\n2. The feature is located in the main module, but prefixed with `experimental_`. This case occurs when we add a new field, argument, or method to an existing data structure already within the main `pydantic` module.\n\nNew features with these naming conventions are subject to change or removal, and we are looking for feedback and suggestions before making them a permanent part of Pydantic. See the [feedback section](./concepts/experimental.md#feedback) for more information.", "url": "https://docs.pydantic.dev/latest/docs/version-policy/#naming-conventions", "page": "docs/version-policy", "source_site": "pydantic"}
{"title": "Lifecycle of Experimental Features", "anchor": "lifecycle-of-experimental-features", "heading_level": 3, "md_text": "1. A new feature is added, either in the [`experimental`](api/experimental.md) module or with the `experimental_` prefix.\n2. The behavior is often modified during patch/minor releases, with potential API/behavior changes.\n3. If the feature is successful, we promote it to Pydantic with the following steps:\n\n    a. If it was in the [`experimental`](api/experimental.md) module, the feature is cloned to Pydantic's main module. The original experimental feature still remains in the [`experimental`](api/experimental.md) module, but it will show a warning when used. If the feature was already in the main Pydantic module, we create a copy of the feature without the `experimental_` prefix, so the feature exists with both the official and experimental names. A deprecation warning is attached to the experimental version.\n\n    b. At some point, the code of the experimental feature is removed, but there will still be a stub of the feature that provides an error message with appropriate instructions.\n\n    c. As a last step, the experimental version of the feature is entirely removed from the codebase.\n\nIf the feature is unsuccessful or unpopular, it's removed with little notice. A stub will remain in the location of the deprecated feature with an error message.\n\nThanks to [streamlit](https://docs.streamlit.io/develop/quick-reference/prerelease) for the inspiration for the lifecycle and naming conventions of our new experimental feature patterns.", "url": "https://docs.pydantic.dev/latest/docs/version-policy/#lifecycle-of-experimental-features", "page": "docs/version-policy", "source_site": "pydantic"}
{"title": "Support for Python versions", "anchor": "support-for-python-versions", "heading_level": 2, "md_text": "Pydantic will drop support for a Python version when the following conditions are met:\n\n* The Python version has reached its [expected end of life](https://devguide.python.org/versions/).\n* less than 5% of downloads of the most recent minor release are using that version.", "url": "https://docs.pydantic.dev/latest/docs/version-policy/#support-for-python-versions", "page": "docs/version-policy", "source_site": "pydantic"}
{"title": "architecture", "anchor": null, "heading_level": 0, "md_text": "!!! note\n    This section is part of the *internals* documentation, and is partly targeted to contributors.\n\nStarting with Pydantic V2, part of the codebase is written in Rust in a separate package called `pydantic-core`.\nThis was done partly in order to improve validation and serialization performance (with the cost of limited\ncustomization and extendibility of the internal logic).\n\nThis architecture documentation will first cover how the two `pydantic` and `pydantic-core` packages interact\ntogether, then will go through the architecture specifics for various patterns (model definition, validation,\nserialization, JSON Schema).\n\nUsage of the Pydantic library can be divided into two parts:\n\n* Model definition, done in the `pydantic` package.\n* Model validation and serialization, done in the `pydantic-core` package.", "url": "https://docs.pydantic.dev/latest/docs/internals/architecture/", "page": "docs/internals/architecture", "source_site": "pydantic"}
{"title": "Model definition", "anchor": "model-definition", "heading_level": 2, "md_text": "Whenever a Pydantic [`BaseModel`][pydantic.main.BaseModel] is defined, the metaclass\nwill analyze the body of the model to collect a number of elements:\n\n* Defined annotations to build model fields (collected in the [`model_fields`][pydantic.main.BaseModel.model_fields] attribute).\n* Model configuration, set with [`model_config`][pydantic.main.BaseModel.model_config].\n* Additional validators/serializers.\n* Private attributes, class variables, identification of generic parametrization, etc.", "url": "https://docs.pydantic.dev/latest/docs/internals/architecture/#model-definition", "page": "docs/internals/architecture", "source_site": "pydantic"}
{"title": "Communicating between `pydantic` and `pydantic-core`: the core schema", "anchor": "communicating-between-pydantic-and-pydantic-core-the-core-schema", "heading_level": 3, "md_text": "We then need a way to communicate the collected information from the model definition to `pydantic-core`,\nso that validation and serialization is performed accordingly. To do so, Pydantic uses the concept\nof a core schema: a structured (and serializable) Python dictionary (represented using\n[`TypedDict`][typing.TypedDict] definitions) describing a specific validation and serialization\nlogic. It is the core data structure used to communicate between the `pydantic` and `pydantic-core`\npackages. Every core schema has a required `type` key, and extra properties depending on this `type`.\n\nThe generation of a core schema is handled in a single place, by the `GenerateSchema` class\n(no matter if it is for a Pydantic model or anything else).\n\n!!! note\n    It is not possible to define a custom core schema. A core schema needs to be understood by the\n    `pydantic-core` package, and as such we only support a fixed number of core schema types.\n    This is also part of the reason why the `GenerateSchema` isn't truly exposed and properly\n    documented.\n\n    The core schema definitions can be found in the [`pydantic_core.core_schema`][] module.\n\nIn the case of a Pydantic model, a core schema will be constructed and set as the\n[`__pydantic_core_schema__`][pydantic.main.BaseModel.__pydantic_core_schema__] attribute.\n\nTo illustrate what a core schema looks like, we will take the example of the\n[`bool`][pydantic_core.core_schema.bool_schema] core schema:\n\n```python {lint=\"skip\" test=\"skip\"}\nclass BoolSchema(TypedDict, total=False):\n    type: Required[Literal['bool']]\n    strict: bool\n    ref: str\n    metadata: Any\n    serialization: SerSchema\n```\n\nWhen defining a Pydantic model with a boolean field:\n\n```python\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    foo: bool = Field(strict=True)\n```\n\nThe core schema for the `foo` field will look like:\n\n```python\n{\n    'type': 'bool',\n    'strict': True,\n}\n```\n\nAs seen in the [`BoolSchema`][pydantic_core.core_schema.bool_schema] definition,\nthe serialization logic is also defined in the core schema.\nIf we were to define a custom serialization function for `foo` (1), the `serialization` key would look like:\n{ .annotate }\n\n1. For example using the [`field_serializer`][pydantic.functional_serializers.field_serializer] decorator:\n\n    ```python {test=\"skip\" lint=\"skip\"}\n    class Model(BaseModel):\n        foo: bool = Field(strict=True)\n\n        @field_serializer('foo', mode='plain')\n        def serialize_foo(self, value: bool) -> Any:\n            ...\n    ```\n\n```python {lint=\"skip\" test=\"skip\"}\n{\n    'type': 'function-plain',\n    'function': <function Model.serialize_foo at 0x111>,\n    'is_field_serializer': True,\n    'info_arg': False,\n    'return_schema': {'type': 'int'},\n}\n```\n\nNote that this is also a core schema definition, just that it is only relevant for `pydantic-core` during serialization.\n\nCore schemas cover a broad scope, and are used whenever we want to communicate between the Python and Rust side.\nWhile the previous examples were related to validation and serialization, it could in theory be used for anything:\nerror management, extra metadata, etc.", "url": "https://docs.pydantic.dev/latest/docs/internals/architecture/#communicating-between-pydantic-and-pydantic-core-the-core-schema", "page": "docs/internals/architecture", "source_site": "pydantic"}
{"title": "JSON Schema generation", "anchor": "json-schema-generation", "heading_level": 3, "md_text": "You may have noticed that the previous serialization core schema has a `return_schema` key.\nThis is because the core schema is also used to generate the corresponding JSON Schema.\n\nSimilar to how the core schema is generated, the JSON Schema generation is handled by the\n[`GenerateJsonSchema`][pydantic.json_schema.GenerateJsonSchema] class.\nThe [`generate`][pydantic.json_schema.GenerateJsonSchema.generate] method\nis the main entry point and is given the core schema of that model.\n\nComing back to our `bool` field example, the [`bool_schema`][pydantic.json_schema.GenerateJsonSchema.bool_schema]\nmethod will be given the previously generated [boolean core schema][pydantic_core.core_schema.bool_schema]\nand will return the following JSON Schema:\n\n```json\n{\n    {\"type\": \"boolean\"}\n}\n```", "url": "https://docs.pydantic.dev/latest/docs/internals/architecture/#json-schema-generation", "page": "docs/internals/architecture", "source_site": "pydantic"}
{"title": "Customizing the core schema and JSON schema", "anchor": "customizing-the-core-schema-and-json-schema", "heading_level": 3, "md_text": "!!! abstract \"Usage Documentation\"\n    [Custom types](../concepts/types.md#custom-types)\n\n    [Implementing `__get_pydantic_core_schema__`](../concepts/json_schema.md#implementing-__get_pydantic_core_schema__)\n\n    [Implementing `__get_pydantic_json_schema__`](../concepts/json_schema.md#implementing-__get_pydantic_json_schema__)\n\nWhile the `GenerateSchema` and [`GenerateJsonSchema`][pydantic.json_schema.GenerateJsonSchema] classes handle\nthe creation of the corresponding schemas, Pydantic offers a way to customize them in some cases, following a wrapper pattern.\nThis customization is done through the `__get_pydantic_core_schema__` and `__get_pydantic_json_schema__` methods.\n\nTo understand this wrapper pattern, we will take the example of metadata classes used with [`Annotated`][typing.Annotated],\nwhere the `__get_pydantic_core_schema__` method can be used:\n\n```python\nfrom typing import Annotated, Any\n\nfrom pydantic_core import CoreSchema\n\nfrom pydantic import GetCoreSchemaHandler, TypeAdapter\n\n\nclass MyStrict:\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source: Any, handler: GetCoreSchemaHandler\n    ) -> CoreSchema:\n        schema = handler(source)  # (1)!\n        schema['strict'] = True\n        return schema\n\n\nclass MyGt:\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source: Any, handler: GetCoreSchemaHandler\n    ) -> CoreSchema:\n        schema = handler(source)  # (2)!\n        schema['gt'] = 1\n        return schema\n\n\nta = TypeAdapter(Annotated[int, MyStrict(), MyGt()])\n```\n\n1. `MyStrict` is the first annotation to be applied. At this point, `schema = {'type': 'int'}`.\n2. `MyGt` is the last annotation to be applied. At this point, `schema = {'type': 'int', 'strict': True}`.\n\nWhen the `GenerateSchema` class builds the core schema for `Annotated[int, MyStrict(), MyGt()]`, it will\ncreate an instance of a `GetCoreSchemaHandler` to be passed to the `MyGt.__get_pydantic_core_schema__` method. (1)\n{ .annotate }\n\n1. In the case of our [`Annotated`][typing.Annotated] pattern, the `GetCoreSchemaHandler` is defined in a nested way.\n    Calling it will recursively call the other `__get_pydantic_core_schema__` methods until it reaches the `int` annotation,\n    where a simple `{'type': 'int'}` schema is returned.\n\nThe `source` argument depends on the core schema generation pattern. In the case of [`Annotated`][typing.Annotated],\nthe `source` will be the type being annotated. When [defining a custom type](../concepts/types.md#as-a-method-on-a-custom-type),\nthe `source` will be the actual class where `__get_pydantic_core_schema__` is defined.", "url": "https://docs.pydantic.dev/latest/docs/internals/architecture/#customizing-the-core-schema-and-json-schema", "page": "docs/internals/architecture", "source_site": "pydantic"}
{"title": "Model validation and serialization", "anchor": "model-validation-and-serialization", "heading_level": 2, "md_text": "While model definition was scoped to the *class* level (i.e. when defining your model), model validation\nand serialization happens at the *instance* level. Both these concepts are handled in `pydantic-core`\n(providing a 5 to 20 performance increase compared to Pydantic V1), by using the previously built core schema.\n\n`pydantic-core` exposes a [`SchemaValidator`][pydantic_core.SchemaValidator] and\n[`SchemaSerializer`][pydantic_core.SchemaSerializer] class to perform these tasks:\n\n```python\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    foo: int\n\n\nmodel = Model.model_validate({'foo': 1})  # (1)!\ndumped = model.model_dump()  # (2)!\n```\n\n1. The provided data is sent to `pydantic-core` by using the\n   [`SchemaValidator.validate_python`][pydantic_core.SchemaValidator.validate_python] method.\n   `pydantic-core` will validate (following the core schema of the model) the data and populate\n   the model's `__dict__` attribute.\n2. The `model` instance is sent to `pydantic-core` by using the\n   [`SchemaSerializer.to_python`][pydantic_core.SchemaSerializer.to_python] method.\n   `pydantic-core` will read the instance's `__dict__` attribute and built the appropriate result\n   (again, following the core schema of the model).", "url": "https://docs.pydantic.dev/latest/docs/internals/architecture/#model-validation-and-serialization", "page": "docs/internals/architecture", "source_site": "pydantic"}
{"title": "resolving_annotations", "anchor": null, "heading_level": 0, "md_text": "!!! note\n    This section is part of the *internals* documentation, and is partly targeted to contributors.\n\nPydantic heavily relies on [type hints][type hint] at runtime to build schemas for validation, serialization, etc.\n\nWhile type hints were primarily introduced for static type checkers (such as [Mypy] or [Pyright]), they are\naccessible (and sometimes evaluated) at runtime. This means that the following would fail at runtime,\nbecause `Node` has yet to be defined in the current module:\n\n```python {test=\"skip\" lint=\"skip\"}\nclass Node:\n    \"\"\"Binary tree node.\"\"\"\n\n    # NameError: name 'Node' is not defined:\n    def __init__(self, l: Node, r: Node) -> None:\n        self.left = l\n        self.right = r\n```\n\nTo circumvent this issue, forward references can be used (by wrapping the annotation in quotes).\n\nIn Python 3.7, [PEP 563] introduced the concept of *postponed evaluation of annotations*, meaning\nwith the `from __future__ import annotations` [future statement], type hints are stringified by default:\n\n```python {requires=\"3.12\" lint=\"skip\"}\nfrom __future__ import annotations\n\nfrom pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    f: MyType\n    # Given the future import above, this is equivalent to:\n    # f: 'MyType'\n\n\ntype MyType = int\n\nprint(Foo.__annotations__)\n#> {'f': 'MyType'}\n```", "url": "https://docs.pydantic.dev/latest/docs/internals/resolving_annotations/", "page": "docs/internals/resolving_annotations", "source_site": "pydantic"}
{"title": "The challenges of runtime evaluation", "anchor": "the-challenges-of-runtime-evaluation", "heading_level": 2, "md_text": "Static type checkers make use of the <abbr title=\"Abstract Syntax Tree\">AST</abbr> to analyze the defined annotations.\nRegarding the previous example, this has the benefit of being able to understand what `MyType` refers to when analyzing\nthe class definition of `Foo`, even if `MyType` isn't yet defined at runtime.\n\nHowever, for runtime tools such as Pydantic, it is more challenging to correctly resolve these forward annotations.\nThe Python standard library provides some tools to do so ([`typing.get_type_hints()`][typing.get_type_hints],\n[`inspect.get_annotations()`][inspect.get_annotations]), but they come with some limitations. Thus, they are\nbeing re-implemented in Pydantic with improved support for edge cases.\n\nAs Pydantic as grown, it's adapted to support many edge cases requiring irregular patterns for annotation evaluation.\nSome of these use cases aren't necessarily sound from a static type checking perspective. In v2.10, the internal\nlogic was refactored in an attempt to simplify and standardize annotation evaluation. Admittedly, backwards compatibility\nposed some challenges, and there is still some noticeable scar tissue in the codebase because of this.There's a hope that\n[PEP 649] (introduced in Python 3.14) will greatly simplify the process, especially when it comes to dealing with locals\nof a function.\n\nTo evaluate forward references, Pydantic roughly follows the same logic as described in the documentation of the\n[`typing.get_type_hints()`][typing.get_type_hints] function. That is, the built-in [`eval()`][eval] function is used\nby passing the forward reference, a global, and a local namespace. The namespace fetching logic is defined in the\nsections below.", "url": "https://docs.pydantic.dev/latest/docs/internals/resolving_annotations/#the-challenges-of-runtime-evaluation", "page": "docs/internals/resolving_annotations", "source_site": "pydantic"}
{"title": "Resolving annotations at class definition", "anchor": "resolving-annotations-at-class-definition", "heading_level": 2, "md_text": "The following example will be used as a reference throughout this section:\n\n```python {test=\"skip\" lint=\"skip\"}", "url": "https://docs.pydantic.dev/latest/docs/internals/resolving_annotations/#resolving-annotations-at-class-definition", "page": "docs/internals/resolving_annotations", "source_site": "pydantic"}
{"title": "module1.py:", "anchor": "module1py", "heading_level": 1, "md_text": "type MyType = int\n\nclass Base:\n    f1: 'MyType'", "url": "https://docs.pydantic.dev/latest/docs/internals/resolving_annotations/#module1py", "page": "docs/internals/resolving_annotations", "source_site": "pydantic"}
{"title": "module2.py:", "anchor": "module2py", "heading_level": 1, "md_text": "from pydantic import BaseModel\n\nfrom module1 import Base\n\ntype MyType = str\n\n\ndef inner() -> None:\n    type InnerType = bool\n\n    class Model(BaseModel, Base):\n        type LocalType = bytes\n\n        f2: 'MyType'\n        f3: 'InnerType'\n        f4: 'LocalType'\n        f5: 'UnknownType'\n\n    type InnerType2 = complex\n```\n\nWhen the `Model` class is being built, different [namespaces][namespace] are at play. For each base class\nof the `Model`'s [MRO][method resolution order] (in reverse order \u2014 that is, starting with `Base`), the\nfollowing logic is applied:\n\n1. Fetch the `__annotations__` key from the current base class' `__dict__`, if present. For `Base`, this will be\n   `{'f1': 'MyType'}`.\n2. Iterate over the `__annotations__` items and try to evaluate the annotation [^1] using a custom wrapper around\n   the built-in [`eval()`][eval] function. This function takes two `globals` and `locals` arguments:\n     * The current module's `__dict__` is naturally used as `globals`. For `Base`, this will be\n       `sys.modules['module1'].__dict__`.\n     * For the `locals` argument, Pydantic will try to resolve symbols in the following namespaces, sorted by highest priority:\n         * A namespace created on the fly, containing the current class name (`{cls.__name__: cls}`). This is done\n           in order to support recursive references.\n         * The locals of the current class (i.e. `cls.__dict__`). For `Model`, this will include `LocalType`.\n         * The parent namespace of the class, if different from the globals described above. This is the\n           [locals][frame.f_locals] of the frame where the class is being defined. For `Base`, because the class is being\n           defined in the module directly, this namespace won't be used as it will result in the globals being used again.\n           For `Model`, the parent namespace is the locals of the frame of `inner()`.\n3. If the annotation failed to evaluate, it is kept as is, so that the model can be rebuilt at a later stage. This will\n   be the case for `f5`.\n\nThe following table lists the resolved type annotations for every field, once the `Model` class has been created:\n\n| Field name | Resolved annotation |\n|------------|---------------------|\n| `f1`       | [`int`][]           |\n| `f2`       | [`str`][]           |\n| `f3`       | [`bool`][]          |\n| `f4`       | [`bytes`][]         |\n| `f5`       | `'UnknownType'`     |", "url": "https://docs.pydantic.dev/latest/docs/internals/resolving_annotations/#module2py", "page": "docs/internals/resolving_annotations", "source_site": "pydantic"}
{"title": "Limitations and backwards compatibility concerns", "anchor": "limitations-and-backwards-compatibility-concerns", "heading_level": 3, "md_text": "While the namespace fetching logic is trying to be as accurate as possible, we still face some limitations:\n\n<div class=\"annotate\" markdown>\n\n* The locals of the current class (`cls.__dict__`) may include irrelevant entries, most of them being dunder attributes.\n  This means that the following annotation: `f: '__doc__'` will successfully (and unexpectedly) be resolved.\n* When the `Model` class is being created inside a function, we keep a copy of the [locals][frame.f_locals] of the frame.\n  This copy only includes the symbols defined in the locals when `Model` is being defined, meaning `InnerType2` won't be included\n  (and will **not be** if doing a model rebuild at a later point!).\n    * To avoid memory leaks, we use [weak references][weakref] to the locals of the function, meaning some forward references might\n    not resolve outside the function (1).\n    * Locals of the function are only taken into account for Pydantic models, but this pattern does not apply to dataclasses, typed\n    dictionaries or named tuples.\n\n</div>\n\n1. Here is an example:\n\n    ```python {test=\"skip\" lint=\"skip\"}\n    def func():\n        A = int\n\n        class Model(BaseModel):\n            f: 'A | Forward'\n\n        return Model\n\n\n    Model = func()\n\n    Model.model_rebuild(_types_namespace={'Forward': str})\n    # pydantic.errors.PydanticUndefinedAnnotation: name 'A' is not defined\n    ```\n\nFor backwards compatibility reasons, and to be able to support valid use cases without having to rebuild models,\nthe namespace logic described above is a bit different when it comes to core schema generation.\nTaking the following example:\n{#backwards-compatibility-logic}\n\n```python\nfrom dataclasses import dataclass\n\nfrom pydantic import BaseModel\n\n\n@dataclass\nclass Foo:\n    a: 'Bar | None' = None\n\n\nclass Bar(BaseModel):\n    b: Foo\n```\n\nOnce the fields for `Bar` have been collected (meaning annotations resolved), the `GenerateSchema` class converts\nevery field into a core schema. When it encounters another class-like field type (such as a dataclass), it will\ntry to evaluate annotations, following roughly the same logic as [described above](#resolving-annotations-at-class-definition).\nHowever, to evaluate the `'Bar | None'` annotation, `Bar` needs to be present in the globals or locals, which is normally\n*not* the case: `Bar` is being created, so it is not \"assigned\" to the current module's `__dict__` at that point.\n\nTo avoid having to call [`model_rebuild()`][pydantic.BaseModel.model_rebuild] on `Bar`, both the parent namespace\n(if `Bar` was to be defined inside a function, and [the namespace provided during a model rebuild](#model-rebuild-semantics))\nand the `{Bar.__name__: Bar}` namespace are included in the locals during annotations evaluation of `Foo`\n(with the lowest priority) (1).\n{ .annotate }\n\n1. This backwards compatibility logic can introduce some inconsistencies, such as the following:\n\n    ```python {lint=\"skip\"}\n    from dataclasses import dataclass\n\n    from pydantic import BaseModel\n\n\n    @dataclass\n    class Foo:\n        # `a` and `b` shouldn't resolve:\n        a: 'Model'\n        b: 'Inner'\n\n\n    def func():\n        Inner = int\n\n        class Model(BaseModel):\n            foo: Foo\n\n        Model.__pydantic_complete__\n        #> True, should be False.\n    ```", "url": "https://docs.pydantic.dev/latest/docs/internals/resolving_annotations/#limitations-and-backwards-compatibility-concerns", "page": "docs/internals/resolving_annotations", "source_site": "pydantic"}
{"title": "Resolving annotations when rebuilding a model", "anchor": "resolving-annotations-when-rebuilding-a-model", "heading_level": 2, "md_text": "When a forward reference fails to evaluate, Pydantic will silently fail and stop the core schema\ngeneration process. This can be seen by inspecting the `__pydantic_core_schema__` of a model class:\n\n```python {lint=\"skip\"}\nfrom pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    f: 'MyType'\n\n\nFoo.__pydantic_core_schema__\n#> <pydantic._internal._mock_val_ser.MockCoreSchema object at 0x73cd0d9e6d00>\n```\n\nIf you then properly define `MyType`, you can rebuild the model:\n\n```python {test=\"skip\" lint=\"skip\"}\ntype MyType = int\n\nFoo.model_rebuild()\nFoo.__pydantic_core_schema__\n#> {'type': 'model', 'schema': {...}, ...}\n```\n\nThe [`model_rebuild()`][pydantic.BaseModel.model_rebuild] method uses a *rebuild namespace*, with the following semantics:\n{#model-rebuild-semantics}\n\n* If an explicit `_types_namespace` argument is provided, it is used as the rebuild namespace.\n* If no namespace is provided, the namespace where the method is called will be used as the rebuild namespace.\n\nThis *rebuild namespace* will be merged with the model's parent namespace (if it was defined in a function) and used as is\n(see the [backwards compatibility logic](#backwards-compatibility-logic) described above).\n\n[Mypy]: https://www.mypy-lang.org/\n[Pyright]: https://github.com/microsoft/pyright/\n[PEP 563]: https://peps.python.org/pep-0563/\n[PEP 649]: https://peps.python.org/pep-0649/\n[future statement]: https://docs.python.org/3/reference/simple_stmts.html#future\n\n[^1]: This is done unconditionally, as forward annotations can be only present *as part* of a type hint (e.g. `Optional['int']`), as dictated by\n      the [typing specification](https://typing.readthedocs.io/en/latest/spec/annotations.html#string-annotations).", "url": "https://docs.pydantic.dev/latest/docs/internals/resolving_annotations/#resolving-annotations-when-rebuilding-a-model", "page": "docs/internals/resolving_annotations", "source_site": "pydantic"}
{"title": "rich", "anchor": null, "heading_level": 0, "md_text": "Pydantic models may be printed with the [Rich](https://github.com/willmcgugan/rich) library which will add additional formatting and color to the output. Here's an example:\n\n![Printing Pydantic models with Rich](../img/rich_pydantic.png)\n\nSee the Rich documentation on [pretty printing](https://rich.readthedocs.io/en/latest/pretty.html) for more information.", "url": "https://docs.pydantic.dev/latest/docs/integrations/rich/", "page": "docs/integrations/rich", "source_site": "pydantic"}
{"title": "logfire", "anchor": null, "heading_level": 0, "md_text": "Pydantic integrates seamlessly with **Pydantic Logfire**, an observability platform built by us on the same belief as our open source library \u2014 that the most powerful tools can be easy to use.", "url": "https://docs.pydantic.dev/latest/docs/integrations/logfire/", "page": "docs/integrations/logfire", "source_site": "pydantic"}
{"title": "Getting Started", "anchor": "getting-started", "heading_level": 2, "md_text": "Logfire has an out-of-the-box Pydantic integration that lets you understand the data passing through your Pydantic models and get analytics on validations. For existing Pydantic users, it delivers unparalleled insights into your usage of Pydantic models.\n\n[Getting started](https://logfire.pydantic.dev/docs/) with Logfire can be done in three simple steps:\n\n1. Set up your Logfire account.\n2. Install the Logfire SDK.\n3. Instrument your project.", "url": "https://docs.pydantic.dev/latest/docs/integrations/logfire/#getting-started", "page": "docs/integrations/logfire", "source_site": "pydantic"}
{"title": "Basic Usage", "anchor": "basic-usage", "heading_level": 3, "md_text": "Once you've got Logfire set up, you can start using it to monitor your Pydantic models and get insights into your data validation:\n\n```python {test=\"skip\"}\nfrom datetime import date\n\nimport logfire\n\nfrom pydantic import BaseModel\n\nlogfire.configure()  # (1)!\n\n\nclass User(BaseModel):\n    name: str\n    country_code: str\n    dob: date\n\n\nuser = User(name='Anne', country_code='USA', dob='2000-01-01')\nlogfire.info('user processed: {user!r}', user=user)  # (2)!\n```\n\n1. The `logfire.configure()` call is all you need to instrument your project with Logfire.\n2. The `logfire.info()` call logs the `user` object to Logfire, with builtin support for Pydantic models.\n\n![basic pydantic logfire usage](../img/basic_logfire.png)", "url": "https://docs.pydantic.dev/latest/docs/integrations/logfire/#basic-usage", "page": "docs/integrations/logfire", "source_site": "pydantic"}
{"title": "Pydantic Instrumentation", "anchor": "pydantic-instrumentation", "heading_level": 3, "md_text": "You can even record information about the validation process automatically by\nusing the builtin [Pydantic integration](https://logfire.pydantic.dev/docs/why-logfire/pydantic/):\n\n```python {test=\"skip\"}\nfrom datetime import date\n\nimport logfire\n\nfrom pydantic import BaseModel\n\nlogfire.configure()\nlogfire.instrument_pydantic()  # (1)!\n\n\nclass User(BaseModel):\n    name: str\n    country_code: str\n    dob: date\n\n\nUser(name='Anne', country_code='USA', dob='2000-01-01')\nUser(name='David', country_code='GBR', dob='invalid-dob')\n```\n\n1. The `logfire.instrument_pydantic()` call automatically logs validation information for all Pydantic models in your project.\n\nYou'll see each successful and failed validation logged in Logfire:\n\n![logfire instrumentation](../img/logfire_instrument.png)\n\nAnd you can investigate each of the corresponding spans to get validation details:\n\n![logfire span details](../img/logfire_span.png)\n\n<!-- TODO: add examples re tracing performance issues - what kind of example do we want to use? -->", "url": "https://docs.pydantic.dev/latest/docs/integrations/logfire/#pydantic-instrumentation", "page": "docs/integrations/logfire", "source_site": "pydantic"}
{"title": "devtools", "anchor": null, "heading_level": 0, "md_text": "!!! note\n    **Admission:** I (the primary developer of Pydantic) also develop python-devtools.\n\n[python-devtools](https://python-devtools.helpmanual.io/) (`pip install devtools`) provides a number of tools which\nare useful during Python development, including `debug()` an alternative to `print()` which formats output in a way\nwhich should be easier to read than `print` as well as giving information about which file/line the print statement\nis on and what value was printed.\n\nPydantic integrates with *devtools* by implementing the `__pretty__` method on most public classes.\n\nIn particular `debug()` is useful when inspecting models:\n\n```python {test=\"no-print-intercept\"}\nfrom datetime import datetime\n\nfrom devtools import debug\n\nfrom pydantic import BaseModel\n\n\nclass Address(BaseModel):\n    street: str\n    country: str\n    lat: float\n    lng: float\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    signup_ts: datetime\n    friends: list[int]\n    address: Address\n\n\nuser = User(\n    id='123',\n    name='John Doe',\n    signup_ts='2019-06-01 12:22',\n    friends=[1234, 4567, 7890],\n    address=dict(street='Testing', country='uk', lat=51.5, lng=0),\n)\ndebug(user)\nprint('\\nshould be much easier read than:\\n')\nprint('user:', user)\n```\n\nWill output in your terminal:\n\n{{ devtools_example }}\n\n!!! note\n    `python-devtools` doesn't yet support Python 3.13.", "url": "https://docs.pydantic.dev/latest/docs/integrations/devtools/", "page": "docs/integrations/devtools", "source_site": "pydantic"}
{"title": "pyrefly", "anchor": null, "heading_level": 0, "md_text": "[Pyrefly](https://pyrefly.org/) is a Python type checker and language server with built-in support for a number of Pydantic-specific features. This support works out-of-the-box with Pydantic and Pyrefly installed, with no additional configuration needed.\n\nPyrefly is available as both an [IDE extension](https://pyrefly.org/en/docs/IDE/) and a [command-line type checker](https://pyrefly.org/en/docs/installation/).", "url": "https://docs.pydantic.dev/latest/docs/integrations/pyrefly/", "page": "docs/integrations/pyrefly", "source_site": "pydantic"}
{"title": "IDE extension", "anchor": "ide-extension", "heading_level": 2, "md_text": "Pyrefly gives you IDE features such as go-to-definition and autocomplete on your Pydantic models.\n\nHere\u2019s an example of signature help, powered by Pyrefly\u2019s understanding of the Pydantic-specific `validation_alias` keyword:\n\n![Signature help with the Pyrefly IDE extension](../img/pyrefly.png)\n\nAs you type `Model()`, Pyrefly hints that you need to use the name `x_` to populate the `x` field.", "url": "https://docs.pydantic.dev/latest/docs/integrations/pyrefly/#ide-extension", "page": "docs/integrations/pyrefly", "source_site": "pydantic"}
{"title": "Type checker", "anchor": "type-checker", "heading_level": 2, "md_text": "Pyrefly can also catch errors in your code before you run it. Consider the following example:\n\n```python {test=\"skip\" linenums=\"1\"}\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass Model1(BaseModel, frozen=True):\n    x: int\n\n\nclass Model2(BaseModel):\n    model_config = ConfigDict(frozen=True)\n    x: int\n\n\nmodel1 = Model1(x=0)\nmodel1.x = 1  # validation error: mutating a frozen field\n\nmodel2 = Model2(x=0)\nmodel2.x = 1  # validation error: mutating a frozen field\n```\n\nSince `Model1` declares that it is frozen using a [standard type system feature](https://typing.python.org/en/latest/spec/dataclasses.html#the-dataclass-transform-decorator), any type checker of your choice will catch the validation error from mutating `model1.x`. However, a type checker without special support for the Pydantic `ConfigDict` class will miss the validation error from mutating `model2.x`.\n\nPyrefly catches both errors:\n\n```output\nERROR Cannot set field `x` [read-only]\n  --> foo.py:11:1\n   |\n11 | model1.x = 1  # validation error: mutating a frozen field\n   | ^^^^^^^^\n   |\n  This field belongs to a frozen Pydantic model\nERROR Cannot set field `x` [read-only]\n  --> foo.py:14:1\n   |\n14 | model2.x = 1  # validation error: mutating a frozen field\n   | ^^^^^^^^\n   |\n  This field belongs to a frozen Pydantic model\n```\n\nSee the [Pyrefly documentation](https://pyrefly.org/en/docs/pydantic/\n) for more information.", "url": "https://docs.pydantic.dev/latest/docs/integrations/pyrefly/#type-checker", "page": "docs/integrations/pyrefly", "source_site": "pydantic"}
{"title": "visual_studio_code", "anchor": null, "heading_level": 0, "md_text": "Pydantic works well with any editor or IDE out of the box because it's made on top of standard Python type annotations.\n\nWhen using [Visual Studio Code (VS Code)](https://code.visualstudio.com/), there are some **additional editor features** supported, comparable to the ones provided by the [PyCharm plugin](../integrations/pycharm.md).\n\nThis means that you will have **autocompletion** (or \"IntelliSense\") and **error checks** for types and required arguments even while creating new Pydantic model instances.\n\n![pydantic autocompletion in VS Code](../img/vs_code_01.png)", "url": "https://docs.pydantic.dev/latest/docs/integrations/visual_studio_code/", "page": "docs/integrations/visual_studio_code", "source_site": "pydantic"}
{"title": "Configure VS Code", "anchor": "configure-vs-code", "heading_level": 2, "md_text": "To take advantage of these features, you need to make sure you configure VS Code correctly, using the recommended settings.\n\nIn case you have a different configuration, here's a short overview of the steps.", "url": "https://docs.pydantic.dev/latest/docs/integrations/visual_studio_code/#configure-vs-code", "page": "docs/integrations/visual_studio_code", "source_site": "pydantic"}
{"title": "Install Pylance", "anchor": "install-pylance", "heading_level": 3, "md_text": "You should use the [Pylance](https://marketplace.visualstudio.com/items?itemName=ms-python.vscode-pylance) extension for VS Code. It is the recommended, next-generation, official VS Code plug-in for Python.\n\nPylance is installed as part of the [Python Extension for VS Code](https://marketplace.visualstudio.com/items?itemName=ms-python.python) by default, so it should probably just work. Otherwise, you can double check it's installed and enabled in your editor.", "url": "https://docs.pydantic.dev/latest/docs/integrations/visual_studio_code/#install-pylance", "page": "docs/integrations/visual_studio_code", "source_site": "pydantic"}
{"title": "Configure your environment", "anchor": "configure-your-environment", "heading_level": 3, "md_text": "Then you need to make sure your editor knows the [Python environment](https://code.visualstudio.com/docs/python/python-tutorial#_install-and-use-packages) (probably a virtual environment) for your Python project.\n\nThis would be the environment in where you installed Pydantic.", "url": "https://docs.pydantic.dev/latest/docs/integrations/visual_studio_code/#configure-your-environment", "page": "docs/integrations/visual_studio_code", "source_site": "pydantic"}
{"title": "Configure Pylance", "anchor": "configure-pylance", "heading_level": 3, "md_text": "With the default configurations, you will get support for autocompletion, but Pylance might not check for type errors.\n\nYou can enable type error checks from Pylance with these steps:\n\n* Open the \"User Settings\"\n* Search for `Type Checking Mode`\n* You will find an option under `Python \u203a Analysis: Type Checking Mode`\n* Set it to `basic` or `strict` (by default it's `off`)\n\n![Type Checking Mode set to strict in VS Code](../img/vs_code_02.png)\n\nNow you will not only get autocompletion when creating new Pydantic model instances but also error checks for **required arguments**.\n\n![Required arguments error checks in VS Code](../img/vs_code_03.png)\n\nAnd you will also get error checks for **invalid data types**.\n\n![Invalid data types error checks in VS Code](../img/vs_code_04.png)\n\n!!! note \"Technical Details\"\n    Pylance is the VS Code extension, it's closed source, but free to use. Underneath, Pylance uses an open source tool (also from Microsoft) called [Pyright](https://github.com/microsoft/pyright) that does all the heavy lifting.\n\n    You can read more about it in the [Pylance Frequently Asked Questions](https://github.com/microsoft/pylance-release/blob/main/FAQ.md#what-is-the-relationship-between-pylance-pyright-and-the-python-extension).", "url": "https://docs.pydantic.dev/latest/docs/integrations/visual_studio_code/#configure-pylance", "page": "docs/integrations/visual_studio_code", "source_site": "pydantic"}
{"title": "Configure mypy", "anchor": "configure-mypy", "heading_level": 3, "md_text": "You might also want to configure mypy in VS Code to get mypy error checks inline in your editor (alternatively/additionally to Pylance).\n\nThis would include the errors detected by the [Pydantic mypy plugin](../integrations/mypy.md), if you configured it.\n\nTo enable mypy in VS Code, do the following:\n\n* Open the \"User Settings\"\n* Search for `Mypy Enabled`\n* You will find an option under `Python \u203a Linting: Mypy Enabled`\n* Check the box (by default it's unchecked)\n\n![mypy enabled in VS Code](../img/vs_code_05.png)", "url": "https://docs.pydantic.dev/latest/docs/integrations/visual_studio_code/#configure-mypy", "page": "docs/integrations/visual_studio_code", "source_site": "pydantic"}
{"title": "Tips and tricks", "anchor": "tips-and-tricks", "heading_level": 2, "md_text": "Here are some additional tips and tricks to improve your developer experience when using VS Code with Pydantic.", "url": "https://docs.pydantic.dev/latest/docs/integrations/visual_studio_code/#tips-and-tricks", "page": "docs/integrations/visual_studio_code", "source_site": "pydantic"}
{"title": "Strict errors", "anchor": "strict-errors", "heading_level": 3, "md_text": "The way this additional editor support works is that Pylance will treat your Pydantic models as if they were Python's pure `dataclasses`.\n\nAnd it will show **strict type error checks** about the data types passed in arguments when creating a new Pydantic model instance.\n\nIn this example you can see that it shows that a `str` of `'23'` is not a valid `int` for the argument `age`.\n\n![VS Code strict type errors](../img/vs_code_06.png)\n\nIt would expect `age=23` instead of `age='23'`.\n\nNevertheless, the design, and one of the main features of Pydantic, is that it is very **lenient with data types**.\n\nIt will actually accept the `str` with value `'23'` and will convert it to an `int` with value `23`.\n\nThese strict error checks are **very useful** most of the time and can help you **detect many bugs early**. But there are cases, like with `age='23'`, where they could be inconvenient by reporting a \"false positive\" error.\n\n---\n\nThis example above with `age='23'` is intentionally simple, to show the error and the differences in types.\n\nBut more common cases where these strict errors would be inconvenient would be when using more sophisticated data types, like `int` values for `datetime` fields, or `dict` values for Pydantic sub-models.\n\nFor example, this is valid for Pydantic:\n\n```python {hl_lines=\"12 17\"}\nfrom pydantic import BaseModel\n\n\nclass Knight(BaseModel):\n    title: str\n    age: int\n    color: str = 'blue'\n\n\nclass Quest(BaseModel):\n    title: str\n    knight: Knight\n\n\nquest = Quest(\n    title='To seek the Holy Grail', knight={'title': 'Sir Lancelot', 'age': 23}\n)\n```\n\nThe type of the field `knight` is declared with the class `Knight` (a Pydantic model) and the code is passing a literal `dict` instead. This is still valid for Pydantic, and the `dict` would be automatically converted to a `Knight` instance.\n\nNevertheless, it would be detected as a type error:\n\n![VS Code strict type errors with model](../img/vs_code_07.png)\n\nIn those cases, there are several ways to disable or ignore strict errors in very specific places, while still preserving them in the rest of the code.\n\nBelow are several techniques to achieve it.", "url": "https://docs.pydantic.dev/latest/docs/integrations/visual_studio_code/#strict-errors", "page": "docs/integrations/visual_studio_code", "source_site": "pydantic"}
{"title": "Disable type checks in a line", "anchor": "disable-type-checks-in-a-line", "heading_level": 4, "md_text": "You can disable the errors for a specific line using a comment of:\n\n```python", "url": "https://docs.pydantic.dev/latest/docs/integrations/visual_studio_code/#disable-type-checks-in-a-line", "page": "docs/integrations/visual_studio_code", "source_site": "pydantic"}
{"title": "type: ignore", "anchor": "type-ignore", "heading_level": 1, "md_text": "```\n\nor (to be specific to pylance/pyright):\n\n```python", "url": "https://docs.pydantic.dev/latest/docs/integrations/visual_studio_code/#type-ignore", "page": "docs/integrations/visual_studio_code", "source_site": "pydantic"}
{"title": "pyright: ignore", "anchor": "pyright-ignore", "heading_level": 1, "md_text": "```\n\n([pyright](https://github.com/microsoft/pyright) is the language server used by Pylance.).\n\ncoming back to the example with `age='23'`, it would be:\n\n```python {hl_lines=\"10\"}\nfrom pydantic import BaseModel\n\n\nclass Knight(BaseModel):\n    title: str\n    age: int\n    color: str = 'blue'\n\n\nlancelot = Knight(title='Sir Lancelot', age='23')  # pyright: ignore\n```\n\nthat way Pylance and mypy will ignore errors in that line.\n\n**Pros**: it's a simple change in that line to remove errors there.\n\n**Cons**: any other error in that line will also be omitted, including type checks, misspelled arguments, required arguments not provided, etc.", "url": "https://docs.pydantic.dev/latest/docs/integrations/visual_studio_code/#pyright-ignore", "page": "docs/integrations/visual_studio_code", "source_site": "pydantic"}
{"title": "Override the type of a variable", "anchor": "override-the-type-of-a-variable", "heading_level": 4, "md_text": "You can also create a variable with the value you want to use and declare its type explicitly with `Any`.\n\n```python {hl_lines=\"1 11-12\"}\nfrom typing import Any\n\nfrom pydantic import BaseModel\n\n\nclass Knight(BaseModel):\n    title: str\n    age: int\n    color: str = 'blue'\n\n\nage_str: Any = '23'\nlancelot = Knight(title='Sir Lancelot', age=age_str)\n```\n\nthat way Pylance and mypy will interpret the variable `age_str` as if they didn't know its type, instead of knowing it has a type of `str` when an `int` was expected (and then showing the corresponding error).\n\n**Pros**: errors will be ignored only for a specific value, and you will still see any additional errors for the other arguments.\n\n**Cons**: it requires importing `Any` and a new variable in a new line for each argument that needs ignoring errors.", "url": "https://docs.pydantic.dev/latest/docs/integrations/visual_studio_code/#override-the-type-of-a-variable", "page": "docs/integrations/visual_studio_code", "source_site": "pydantic"}
{"title": "Override the type of a value with `cast`", "anchor": "override-the-type-of-a-value-with-cast", "heading_level": 4, "md_text": "The same idea from the previous example can be put on the same line with the help of `cast()`.\n\nThis way, the type declaration of the value is overridden inline, without requiring another variable.\n\n```python {hl_lines=\"1 11\"}\nfrom typing import Any, cast\n\nfrom pydantic import BaseModel\n\n\nclass Knight(BaseModel):\n    title: str\n    age: int\n    color: str = 'blue'\n\n\nlancelot = Knight(title='Sir Lancelot', age=cast(Any, '23'))\n```\n\n`cast(Any, '23')` doesn't affect the value, it's still just `'23'`, but now Pylance and mypy will assume it is of type `Any`, which means, they will act as if they didn't know the type of the value.\n\nSo, this is the equivalent of the previous example, without the additional variable.\n\n**Pros**: errors will be ignored only for a specific value, and you will still see any additional errors for the other arguments. There's no need for additional variables.\n\n**Cons**: it requires importing `Any` and `cast`, and if you are not used to using `cast()`, it could seem strange at first.", "url": "https://docs.pydantic.dev/latest/docs/integrations/visual_studio_code/#override-the-type-of-a-value-with-cast", "page": "docs/integrations/visual_studio_code", "source_site": "pydantic"}
{"title": "Config in class arguments", "anchor": "config-in-class-arguments", "heading_level": 3, "md_text": "Pydantic has a rich set of [Model Configurations][pydantic.config.ConfigDict] available.\n\nThese configurations can be set in an internal `class Config` on each model:\n\n```python {hl_lines=\"9-10\"}\nfrom pydantic import BaseModel\n\n\nclass Knight(BaseModel):\n    model_config = dict(frozen=True)\n    title: str\n    age: int\n    color: str = 'blue'\n```\n\nor passed as keyword arguments when defining the model class:\n\n```python {hl_lines=\"4\"}\nfrom pydantic import BaseModel\n\n\nclass Knight(BaseModel, frozen=True):\n    title: str\n    age: int\n    color: str = 'blue'\n```\n\nThe specific configuration **`frozen`** (in beta) has a special meaning.\n\nIt prevents other code from changing a model instance once it's created, keeping it **\"frozen\"**.\n\nWhen using the second version to declare `frozen=True` (with **keyword arguments** in the class definition),\nPylance can use it to help you check in your code and **detect errors** when something is trying to set values\nin a model that is \"frozen\".\n\n![VS Code strict type errors with model](../img/vs_code_08.png)", "url": "https://docs.pydantic.dev/latest/docs/integrations/visual_studio_code/#config-in-class-arguments", "page": "docs/integrations/visual_studio_code", "source_site": "pydantic"}
{"title": "Adding a default with `Field`", "anchor": "adding-a-default-with-field", "heading_level": 2, "md_text": "Pylance/pyright requires `default` to be a keyword argument to `Field` in order to infer that the field is optional.\n\n```python\nfrom pydantic import BaseModel, Field\n\n\nclass Knight(BaseModel):\n    title: str = Field(default='Sir Lancelot')  # this is okay\n    age: int = Field(\n        23\n    )  # this works fine at runtime but will case an error for pyright\n\n\nlance = Knight()  # error: Argument missing for parameter \"age\"\n```\n\nThis is a limitation of dataclass transforms and cannot be fixed in pydantic.", "url": "https://docs.pydantic.dev/latest/docs/integrations/visual_studio_code/#adding-a-default-with-field", "page": "docs/integrations/visual_studio_code", "source_site": "pydantic"}
{"title": "Technical Details", "anchor": "technical-details", "heading_level": 2, "md_text": "!!! warning\n    As a Pydantic user, you don't need the details below. Feel free to skip the rest of this section.\n\n    These details are only useful for other library authors, etc.\n\nThis additional editor support works by making use of the [`@dataclass_transform` decorator](https://typing.python.org/en/latest/spec/dataclasses.html#the-dataclass-transform-decorator)\n(introduced by [PEP 681](https://peps.python.org/pep-0681/)).\n\nThe standard provides a way for libraries like Pydantic and others to tell editors and tools that they (the editors) should treat these libraries (e.g. Pydantic) as if they were [dataclasses][dataclasses], providing autocompletion, type checks, etc.", "url": "https://docs.pydantic.dev/latest/docs/integrations/visual_studio_code/#technical-details", "page": "docs/integrations/visual_studio_code", "source_site": "pydantic"}
{"title": "Flake8 plugin", "anchor": "flake8-plugin", "heading_level": 2, "md_text": "If using Flake8 in your project, a [plugin](https://pypi.org/project/flake8-pydantic/) is available\nand can be installed using the following:\n\n```bash\npip install flake8-pydantic\n```\n\nThe lint errors provided by this plugin are namespaced under the `PYDXXX` code. To ignore some unwanted\nrules, the Flake8 configuration can be adapted:\n\n```ini\n[flake8]\nextend-ignore = PYD001,PYD002\n```", "url": "https://docs.pydantic.dev/latest/docs/integrations/linting/#flake8-plugin", "page": "docs/integrations/linting", "source_site": "pydantic"}
{"title": "Code Generation with datamodel-code-generator", "anchor": "code-generation-with-datamodel-code-generator", "heading_level": 1, "md_text": "The [datamodel-code-generator](https://github.com/koxudaxi/datamodel-code-generator/) project is a library and command-line utility to generate pydantic models from just about any data source, including:\n\n* OpenAPI 3 (YAML/JSON)\n* JSON Schema\n* JSON/YAML/CSV Data (which will be converted to JSON Schema)\n* Python dictionary (which will be converted to JSON Schema)\n* GraphQL schema\n\nWhenever you find yourself with any data convertible JSON but without pydantic models, this tool will allow you to generate type-safe model hierarchies on demand.", "url": "https://docs.pydantic.dev/latest/docs/integrations/datamodel_code_generator/#code-generation-with-datamodel-code-generator", "page": "docs/integrations/datamodel_code_generator", "source_site": "pydantic"}
{"title": "Installation", "anchor": "installation", "heading_level": 2, "md_text": "```bash\npip install datamodel-code-generator\n```", "url": "https://docs.pydantic.dev/latest/docs/integrations/datamodel_code_generator/#installation", "page": "docs/integrations/datamodel_code_generator", "source_site": "pydantic"}
{"title": "Example", "anchor": "example", "heading_level": 2, "md_text": "In this case, datamodel-code-generator creates pydantic models from a JSON Schema file.\n\n```bash\ndatamodel-codegen  --input person.json --input-file-type jsonschema --output model.py\n```\n\nperson.json:\n\n```json\n{\n  \"$id\": \"person.json\",\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Person\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"first_name\": {\n      \"type\": \"string\",\n      \"description\": \"The person's first name.\"\n    },\n    \"last_name\": {\n      \"type\": \"string\",\n      \"description\": \"The person's last name.\"\n    },\n    \"age\": {\n      \"description\": \"Age in years.\",\n      \"type\": \"integer\",\n      \"minimum\": 0\n    },\n    \"pets\": {\n      \"type\": \"array\",\n      \"items\": [\n        {\n          \"$ref\": \"#/definitions/Pet\"\n        }\n      ]\n    },\n    \"comment\": {\n      \"type\": \"null\"\n    }\n  },\n  \"required\": [\n      \"first_name\",\n      \"last_name\"\n  ],\n  \"definitions\": {\n    \"Pet\": {\n      \"properties\": {\n        \"name\": {\n          \"type\": \"string\"\n        },\n        \"age\": {\n          \"type\": \"integer\"\n        }\n      }\n    }\n  }\n}\n```\n\nmodel.py:\n\n```python {upgrade=\"skip\" requires=\"3.10\"}", "url": "https://docs.pydantic.dev/latest/docs/integrations/datamodel_code_generator/#example", "page": "docs/integrations/datamodel_code_generator", "source_site": "pydantic"}
{"title": "timestamp: 2020-05-19T15:07:31+00:00", "anchor": "timestamp-2020-05-19t1507310000", "heading_level": 1, "md_text": "from __future__ import annotations\n\nfrom typing import Any\n\nfrom pydantic import BaseModel, Field, conint\n\n\nclass Pet(BaseModel):\n    name: str | None = None\n    age: int | None = None\n\n\nclass Person(BaseModel):\n    first_name: str = Field(description=\"The person's first name.\")\n    last_name: str = Field(description=\"The person's last name.\")\n    age: conint(ge=0) | None = Field(None, description='Age in years.')\n    pets: list[Pet] | None = None\n    comment: Any | None = None\n```\n\nMore information can be found on the\n[official documentation](https://koxudaxi.github.io/datamodel-code-generator/)", "url": "https://docs.pydantic.dev/latest/docs/integrations/datamodel_code_generator/#timestamp-2020-05-19t1507310000", "page": "docs/integrations/datamodel_code_generator", "source_site": "pydantic"}
{"title": "llms", "anchor": null, "heading_level": 0, "md_text": "The Pydantic documentation is available in the [llms.txt](https://llmstxt.org/) format.\nThis format is defined in Markdown and suited for large language models.\n\nTwo formats are available:\n\n* [llms.txt](https://docs.pydantic.dev/latest/llms.txt): a file containing a brief description\n  of the project, along with links to the different sections of the documentation. The structure\n  of this file is described in details in the [format documentation](https://llmstxt.org/#format).\n* [llms-full.txt](https://docs.pydantic.dev/latest/llms-full.txt): Similar to the `llms.txt` file,\n  but every link content is included. Note that this file may be too large for some LLMs.\n\nAs of today, these files *cannot* be natively leveraged by LLM frameworks or IDEs. Alternatively,\na [MCP server](https://modelcontextprotocol.io/) can be implemented to properly parse the `llms.txt`\nfile.", "url": "https://docs.pydantic.dev/latest/docs/integrations/llms/", "page": "docs/integrations/llms", "source_site": "pydantic"}
{"title": "documentation", "anchor": null, "heading_level": 0, "md_text": "Pydantic uses [MkDocs](https://www.mkdocs.org/) for documentation, together with\n[mkdocstrings](https://mkdocstrings.github.io/). As such, you can make use of Pydantic's\nSphinx object inventory to cross-reference the Pydantic API documentation.\n\n=== \"Sphinx\"\n\n    In your [Sphinx configuration](https://www.sphinx-doc.org/en/master/usage/configuration.html),\n    add the following to the [`intersphinx` extension configuration](https://www.sphinx-doc.org/en/master/usage/extensions/intersphinx.html#configuration):\n\n    ```python {test=\"skip\"}\n    intersphinx_mapping = {\n        'pydantic': ('https://docs.pydantic.dev/latest', None),  # (1)!\n    }\n    ```\n\n    1. You can also use `dev` instead of `latest` to target the latest documentation build, up to date\n       with the [`main`](https://github.com/pydantic/pydantic/tree/main) branch.\n\n=== \"mkdocstrings\"\n\n    In your [MkDocs configuration](https://www.mkdocs.org/user-guide/configuration/), add the following\n    import to your [mkdocstrings plugin configuration](https://mkdocstrings.github.io/usage/#cross-references-to-other-projects-inventories):\n\n    ```yaml\n    plugins:\n    - mkdocstrings:\n        handlers:\n          python:\n            import:\n            - https://docs.pydantic.dev/latest/objects.inv  # (1)!\n    ```\n\n    1. You can also use `dev` instead of `latest` to target the latest documentation build, up to date\n       with the [`main`](https://github.com/pydantic/pydantic/tree/main) branch.", "url": "https://docs.pydantic.dev/latest/docs/integrations/documentation/", "page": "docs/integrations/documentation", "source_site": "pydantic"}
{"title": "aws_lambda", "anchor": null, "heading_level": 0, "md_text": "`pydantic` integrates well with AWS Lambda functions. In this guide, we'll discuss how to setup `pydantic` for an AWS Lambda function.", "url": "https://docs.pydantic.dev/latest/docs/integrations/aws_lambda/", "page": "docs/integrations/aws_lambda", "source_site": "pydantic"}
{"title": "Installing Python libraries for AWS Lambda functions", "anchor": "installing-python-libraries-for-aws-lambda-functions", "heading_level": 2, "md_text": "There are many ways to utilize Python libraries in AWS Lambda functions. As outlined in the [AWS Lambda documentation](https://docs.aws.amazon.com/lambda/latest/dg/lambda-python.html), the most common approaches include:\n\n* Using a [`.zip` file archive](https://docs.aws.amazon.com/lambda/latest/dg/python-package.html) to package your code and dependencies\n* Using [AWS Lambda Layers](https://docs.aws.amazon.com/lambda/latest/dg/python-layers.html) to share libraries across multiple functions\n* Using a [container image](https://docs.aws.amazon.com/lambda/latest/dg/python-image.html) to package your code and dependencies\n\nAll of these approaches can be used with `pydantic`. The best approach for you will depend on your specific requirements and constraints. We'll cover the first two cases more in-depth here, as dependency management with\na container image is more straightforward. If you're using a container image, you might find [this comment](https://github.com/pydantic/pydantic/issues/6557#issuecomment-1699456562) helpful for installing `pydantic`.\n\n!!! tip\n    If you use `pydantic` across multiple functions, you may want to consider AWS Lambda Layers, which support seamless sharing of libraries across multiple functions.\n\nRegardless of the dependencies management approach you choose, it's beneficial to adhere to these guidelines to ensure a smooth\ndependency management process.", "url": "https://docs.pydantic.dev/latest/docs/integrations/aws_lambda/#installing-python-libraries-for-aws-lambda-functions", "page": "docs/integrations/aws_lambda", "source_site": "pydantic"}
{"title": "Installing `pydantic` for AWS Lambda functions", "anchor": "installing-pydantic-for-aws-lambda-functions", "heading_level": 2, "md_text": "When you're building your `.zip` file archive with your code and dependencies or organizing your `.zip` file for a Lambda Layer, you'll likely use a local virtual environment to install and manage your dependencies. This can be a bit tricky if you're using `pip` because `pip` installs wheels compiled for your local platform, which may not be compatible with the Lambda environment.\n\nThus, we suggest you use a command similar to the following:\n\n```bash\npip install \\\n    --platform manylinux2014_x86_64 \\  # (1)!\n    --target=<your_package_dir> \\  # (2)!\n    --implementation cp \\  # (3)!\n    --python-version 3.10 \\  # (4)!\n    --only-binary=:all: \\  # (5)!\n    --upgrade pydantic  # (6)!\n```\n\n1. Use the platform corresponding to your Lambda runtime.\n2. Specify the directory where you want to install the package (often `python` for Lambda Layers).\n3. Use the CPython implementation.\n4. The Python version must be compatible with the Lambda runtime.\n5. This flag ensures that the package is installed pre-built binary wheels.\n6. The latest version of `pydantic` will be installed.", "url": "https://docs.pydantic.dev/latest/docs/integrations/aws_lambda/#installing-pydantic-for-aws-lambda-functions", "page": "docs/integrations/aws_lambda", "source_site": "pydantic"}
{"title": "Missing `pydantic_core` module", "anchor": "missing-pydantic_core-module", "heading_level": 3, "md_text": "The\n\n```output\nno module named `pydantic_core._pydantic_core`\n```\n\nerror is a common issue that indicates you have installed `pydantic` incorrectly. To debug this issue, you can try the following steps (before the failing import):\n\n1. Check the contents of the installed `pydantic-core` package. Are the compiled library and its type stubs both present?\n\n    ```python {test=\"skip\" lint=\"skip\"}\n    from importlib.metadata import files\n    print([file for file in files('pydantic-core') if file.name.startswith('_pydantic_core')])\n    \"\"\"\n    [PackagePath('pydantic_core/_pydantic_core.pyi'), PackagePath('pydantic_core/_pydantic_core.cpython-312-x86_64-linux-gnu.so')]\n    \"\"\"\n    ```\n\n    You should expect to see two files like those printed above. The compiled library file should have the `.so` or `.pyd` extension with a name that varies according to the OS and Python version.\n\n2. Check that your lambda's Python version is compatible with the compiled library version found above.\n\n    ```python {test=\"skip\" lint=\"skip\"}\n    import sysconfig\n    print(sysconfig.get_config_var(\"EXT_SUFFIX\"))\n    #> '.cpython-312-x86_64-linux-gnu.so'\n    ```\n\nYou should expect to see the same suffix here as the compiled library, for example here we see this suffix `.cpython-312-x86_64-linux-gnu.so` indeed matches `_pydantic_core.cpython-312-x86_64-linux-gnu.so`.\n\nIf these two checks do not match, your build steps have not installed the correct native code for your lambda's target platform. You should adjust your build steps to change the version of the installed library which gets installed.\n\nMost likely errors:\n\n* Your OS or CPU architecture is mismatched (e.g. darwin vs x86_64-linux-gnu). Try passing correct `--platform` argument to `pip install` when installing your lambda dependencies, or build inside a linux docker container for the correct platform. Possible platforms at the moment include `--platform manylinux2014_x86_64` or `--platform manylinux2014_aarch64`, but these may change with a future Pydantic major release.\n\n* Your Python version is mismatched (e.g. `cpython-310` vs `cpython-312`). Try passing correct `--python-version` argument to `pip install`, or otherwise change the Python version used on your build.", "url": "https://docs.pydantic.dev/latest/docs/integrations/aws_lambda/#missing-pydantic_core-module", "page": "docs/integrations/aws_lambda", "source_site": "pydantic"}
{"title": "No package metadata was found for `email-validator`", "anchor": "no-package-metadata-was-found-for-email-validator", "heading_level": 3, "md_text": "Pydantic uses `version` from `importlib.metadata` to [check what version](https://github.com/pydantic/pydantic/pull/6033) of `email-validator` is installed.\nThis package versioning mechanism is somewhat incompatible with AWS Lambda, even though it's the industry standard for versioning packages in Python. There\nare a few ways to fix this issue:\n\nIf you're deploying your lambda with the serverless framework, it's likely that the appropriate metadata for the `email-validator` package is not being included in your deployment package. Tools like [`serverless-python-requirements`](https://github.com/serverless/serverless-python-requirements/tree/master)\nremove metadata to reduce package size. You can fix this issue by setting the `slim` setting to false in your `serverless.yml` file:\n\n```yaml\npythonRequirements:\n    dockerizePip: non-linux\n    slim: false\n    fileName: requirements.txt\n```\n\nYou can read more about this fix, and other `slim` settings that might be relevant in this [blog post](https://biercoff.com/how-to-fix-package-not-found-error-importlib-metadata/).\n\nIf you're using a `.zip` archive for your code and/or dependencies, make sure that your package contains the required version metadata. To do this, make sure you include the `dist-info` directory in your `.zip` archive for the `email-validator` package.\n\nThis issue has been reported for other popular python libraries like [`jsonschema`](https://github.com/python-jsonschema/jsonschema/issues/584), so you can\nread more about the issue and potential fixes there as well.", "url": "https://docs.pydantic.dev/latest/docs/integrations/aws_lambda/#no-package-metadata-was-found-for-email-validator", "page": "docs/integrations/aws_lambda", "source_site": "pydantic"}
{"title": "More Debugging Tips", "anchor": "more-debugging-tips", "heading_level": 3, "md_text": "If you're still struggling with installing `pydantic` for your AWS Lambda, you might consult with [this issue](https://github.com/pydantic/pydantic/issues/6557), which covers a variety of problems and solutions encountered by other developers.", "url": "https://docs.pydantic.dev/latest/docs/integrations/aws_lambda/#more-debugging-tips", "page": "docs/integrations/aws_lambda", "source_site": "pydantic"}
{"title": "Validating `event` and `context` data", "anchor": "validating-event-and-context-data", "heading_level": 3, "md_text": "Check out our [blog post](https://pydantic.dev/articles/lambda-intro) to learn more about how to use `pydantic` to validate `event` and `context` data in AWS Lambda functions.", "url": "https://docs.pydantic.dev/latest/docs/integrations/aws_lambda/#validating-event-and-context-data", "page": "docs/integrations/aws_lambda", "source_site": "pydantic"}
{"title": "mypy", "anchor": null, "heading_level": 0, "md_text": "Pydantic works well with [mypy](http://mypy-lang.org) right out of the box.\n\nHowever, Pydantic also ships with a mypy plugin that adds a number of important Pydantic-specific\nfeatures that improve its ability to type-check your code.\n\nFor example, consider the following script:\n\n```python {test=\"skip\" linenums=\"1\"}\nfrom datetime import datetime\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    age: int\n    first_name = 'John'\n    last_name: Optional[str] = None\n    signup_ts: Optional[datetime] = None\n    list_of_ints: list[int]\n\n\nm = Model(age=42, list_of_ints=[1, '2', b'3'])\nprint(m.middle_name)  # not a model field!\nModel()  # will raise a validation error for age and list_of_ints\n```\n\nWithout any special configuration, mypy does not catch the [missing model field annotation](../errors/usage_errors.md#model-field-missing-annotation)\nand errors about the `list_of_ints` argument which Pydantic parses correctly:\n\n```output\n15: error: List item 1 has incompatible type \"str\"; expected \"int\"  [list-item]\n15: error: List item 2 has incompatible type \"bytes\"; expected \"int\"  [list-item]\n16: error: \"Model\" has no attribute \"middle_name\"  [attr-defined]\n17: error: Missing named argument \"age\" for \"Model\"  [call-arg]\n17: error: Missing named argument \"list_of_ints\" for \"Model\"  [call-arg]\n```\n\nBut [with the plugin enabled](#enabling-the-plugin), it gives the correct errors:\n\n```output\n9: error: Untyped fields disallowed  [pydantic-field]\n16: error: \"Model\" has no attribute \"middle_name\"  [attr-defined]\n17: error: Missing named argument \"age\" for \"Model\"  [call-arg]\n17: error: Missing named argument \"list_of_ints\" for \"Model\"  [call-arg]\n```\n\nWith the pydantic mypy plugin, you can fearlessly refactor your models knowing mypy will catch any mistakes\nif your field names or types change.\n\nNote that mypy already supports some features without using the Pydantic plugin, such as synthesizing a `__init__`\nmethod for Pydantic models and dataclasses. See the [mypy plugin capabilities](#mypy-plugin-capabilities) for a list\nof additional features.\n\nThe Pydantic mypy plugin is tested against the latest mypy version. Older versions might work but won't be tested.", "url": "https://docs.pydantic.dev/latest/docs/integrations/mypy/", "page": "docs/integrations/mypy", "source_site": "pydantic"}
{"title": "Enabling the Plugin", "anchor": "enabling-the-plugin", "heading_level": 2, "md_text": "To enable the plugin, just add `pydantic.mypy` to the list of plugins in your\n[mypy config file](https://mypy.readthedocs.io/en/latest/config_file.html):\n\n=== \"`mypy.ini`\"\n\n    ```ini\n    [mypy]\n    plugins = pydantic.mypy\n    ```\n\n=== \"`pyproject.toml`\"\n\n    ```toml\n    [tool.mypy]\n    plugins = ['pydantic.mypy']\n    ```\n\n!!! note\n\n    If you're using `pydantic.v1` models, you'll need to add `pydantic.v1.mypy` to your list of plugins.\n\nSee the [plugin configuration](#configuring-the-plugin) for more details.", "url": "https://docs.pydantic.dev/latest/docs/integrations/mypy/#enabling-the-plugin", "page": "docs/integrations/mypy", "source_site": "pydantic"}
{"title": "Generate a `__init__` signature for Pydantic models", "anchor": "generate-a-__init__-signature-for-pydantic-models", "heading_level": 3, "md_text": "* Any required fields that don't have dynamically-determined aliases will be included as required\n  keyword arguments.\n* If the [`validate_by_name`][pydantic.ConfigDict.validate_by_name] model configuration value is set to\n  `True`, the generated signature will use the field names rather than aliases.\n* The [`init_forbid_extra`](#init_forbid_extra) and [`init_typed`](#init_typed) plugin configuration\n  values can further fine-tune the synthesized `__init__` method.", "url": "https://docs.pydantic.dev/latest/docs/integrations/mypy/#generate-a-__init__-signature-for-pydantic-models", "page": "docs/integrations/mypy", "source_site": "pydantic"}
{"title": "Generate a typed signature for `model_construct`", "anchor": "generate-a-typed-signature-for-model_construct", "heading_level": 3, "md_text": "* The [`model_construct`][pydantic.BaseModel.model_construct] method is an alternative to model validation when input data is\n  known to be valid and should not be parsed (see the [documentation](../concepts/models.md#creating-models-without-validation)).\n  Because this method performs no runtime validation, static checking is important to detect errors.", "url": "https://docs.pydantic.dev/latest/docs/integrations/mypy/#generate-a-typed-signature-for-model_construct", "page": "docs/integrations/mypy", "source_site": "pydantic"}
{"title": "Support for frozen models", "anchor": "support-for-frozen-models", "heading_level": 3, "md_text": "* If the [`frozen`][pydantic.ConfigDict.frozen] configuration is set to `True`, you will get\n  an error if you try mutating a model field (see [faux immutability](../concepts/models.md#faux-immutability))", "url": "https://docs.pydantic.dev/latest/docs/integrations/mypy/#support-for-frozen-models", "page": "docs/integrations/mypy", "source_site": "pydantic"}
{"title": "Respect the type of the `Field`'s `default` and `default_factory`", "anchor": "respect-the-type-of-the-fields-default-and-default_factory", "heading_level": 3, "md_text": "* Field with both a `default` and a `default_factory` will result in an error during static checking.\n* The type of the `default` and `default_factory` value must be compatible with the one of the field.", "url": "https://docs.pydantic.dev/latest/docs/integrations/mypy/#respect-the-type-of-the-fields-default-and-default_factory", "page": "docs/integrations/mypy", "source_site": "pydantic"}
{"title": "Warn about the use of untyped fields", "anchor": "warn-about-the-use-of-untyped-fields", "heading_level": 3, "md_text": "* While defining a field without an annotation will result in a [runtime error](../errors/usage_errors.md#model-field-missing-annotation),\n  the plugin will also emit a type checking error.", "url": "https://docs.pydantic.dev/latest/docs/integrations/mypy/#warn-about-the-use-of-untyped-fields", "page": "docs/integrations/mypy", "source_site": "pydantic"}
{"title": "Prevent the use of required dynamic aliases", "anchor": "prevent-the-use-of-required-dynamic-aliases", "heading_level": 3, "md_text": "See the documentation of the [`warn_required_dynamic_aliases`](#warn_required_dynamic_aliases) plugin configuration value.", "url": "https://docs.pydantic.dev/latest/docs/integrations/mypy/#prevent-the-use-of-required-dynamic-aliases", "page": "docs/integrations/mypy", "source_site": "pydantic"}
{"title": "Configuring the Plugin", "anchor": "configuring-the-plugin", "heading_level": 2, "md_text": "To change the values of the plugin settings, create a section in your mypy config file called `[pydantic-mypy]`,\nand add any key-value pairs for settings you want to override.\n\nA configuration file with all plugin strictness flags enabled (and some other mypy strictness flags, too) might look like:\n\n=== \"`mypy.ini`\"\n\n    ```ini\n    [mypy]\n    plugins = pydantic.mypy\n\n    follow_imports = silent\n    warn_redundant_casts = True\n    warn_unused_ignores = True\n    disallow_any_generics = True\n    no_implicit_reexport = True\n    disallow_untyped_defs = True\n\n    [pydantic-mypy]\n    init_forbid_extra = True\n    init_typed = True\n    warn_required_dynamic_aliases = True\n    ```\n\n=== \"`pyproject.toml`\"\n\n    ```toml\n    [tool.mypy]\n    plugins = [\"pydantic.mypy\"]\n\n    follow_imports = \"silent\"\n    warn_redundant_casts = true\n    warn_unused_ignores = true\n    disallow_any_generics = true\n    no_implicit_reexport = true\n    disallow_untyped_defs = true\n\n    [tool.pydantic-mypy]\n    init_forbid_extra = true\n    init_typed = true\n    warn_required_dynamic_aliases = true\n    ```", "url": "https://docs.pydantic.dev/latest/docs/integrations/mypy/#configuring-the-plugin", "page": "docs/integrations/mypy", "source_site": "pydantic"}
{"title": "`init_typed`", "anchor": "init_typed", "heading_level": 3, "md_text": "Because Pydantic performs [data conversion](../concepts/models.md#data-conversion) by default, the following is still valid at runtime:\n\n```python {test=\"skip\" lint=\"skip\"}\nclass Model(BaseModel):\n    a: int\n\n\nModel(a='1')\n```\n\nFor this reason, the plugin will use [`Any`][typing.Any] for field annotations when synthesizing the `__init__` method,\nunless `init_typed` is set or [strict mode](../concepts/strict_mode.md) is enabled on the model.", "url": "https://docs.pydantic.dev/latest/docs/integrations/mypy/#init_typed", "page": "docs/integrations/mypy", "source_site": "pydantic"}
{"title": "`init_forbid_extra`", "anchor": "init_forbid_extra", "heading_level": 3, "md_text": "By default, Pydantic allows (and ignores) any extra provided argument:\n\n```python {test=\"skip\" lint=\"skip\"}\nclass Model(BaseModel):\n    a: int = 1\n\n\nModel(unrelated=2)\n```\n\nFor this reason, the plugin will add an extra `**kwargs: Any` parameter when synthesizing the `__init__` method, unless\n`init_forbid_extra` is set or the [`extra`][pydantic.ConfigDict.extra] is set to `'forbid'`.", "url": "https://docs.pydantic.dev/latest/docs/integrations/mypy/#init_forbid_extra", "page": "docs/integrations/mypy", "source_site": "pydantic"}
{"title": "`warn_required_dynamic_aliases`", "anchor": "warn_required_dynamic_aliases", "heading_level": 3, "md_text": "Whether to error when using a dynamically-determined alias or alias generator on a model with\n[`validate_by_name`][pydantic.ConfigDict.validate_by_name] set to `False`. If such aliases are\npresent, mypy cannot properly type check calls to `__init__`. In this case, it will default to\ntreating all arguments as not required.\n\n!!! note \"Compatibility with `Any` being disallowed\"\n    Some mypy configuration options (such as [`disallow_any_explicit`](https://mypy.readthedocs.io/en/stable/config_file.html#confval-disallow_any_explicit))\n    will error because the synthesized `__init__` method contains [`Any`][typing.Any] annotations. To circumvent the issue, you will have\n    to enable both `init_forbid_extra` and `init_typed`.", "url": "https://docs.pydantic.dev/latest/docs/integrations/mypy/#warn_required_dynamic_aliases", "page": "docs/integrations/mypy", "source_site": "pydantic"}
{"title": "pycharm", "anchor": null, "heading_level": 0, "md_text": "While pydantic will work well with any IDE out of the box, a\n[PyCharm plugin](https://plugins.jetbrains.com/plugin/12861-pydantic)\noffering improved pydantic integration is available on the JetBrains Plugins Repository for PyCharm.\nYou can install the plugin for free from the plugin marketplace\n(PyCharm's Preferences -> Plugin -> Marketplace -> search \"pydantic\").\n\nThe plugin currently supports the following features:\n\n* For `pydantic.BaseModel.__init__`:\n    * Inspection\n    * Autocompletion\n    * Type-checking\n\n* For fields of `pydantic.BaseModel`:\n    * Refactor-renaming fields updates `__init__` calls, and affects sub- and super-classes\n    * Refactor-renaming `__init__` keyword arguments updates field names, and affects sub- and super-classes\n\nMore information can be found on the\n[official plugin page](https://plugins.jetbrains.com/plugin/12861-pydantic)\nand [Github repository](https://github.com/koxudaxi/pydantic-pycharm-plugin).", "url": "https://docs.pydantic.dev/latest/docs/integrations/pycharm/", "page": "docs/integrations/pycharm", "source_site": "pydantic"}
{"title": "hypothesis", "anchor": null, "heading_level": 0, "md_text": "[Hypothesis](https://hypothesis.readthedocs.io/) is the Python library for\n[property-based testing](https://increment.com/testing/in-praise-of-property-based-testing/).\nHypothesis can infer how to construct type-annotated classes, and supports builtin types,\nmany standard library types, and generic types from the\n[`typing`](https://docs.python.org/3/library/typing.html) and\n[`typing_extensions`](https://pypi.org/project/typing-extensions/) modules by default.\n\nPydantic v2.0 drops built-in support for Hypothesis and no more ships with the integrated Hypothesis plugin.\n\n!!! warning\n    We are temporarily removing the Hypothesis plugin in favor of studying a different mechanism. For more information, see the issue [annotated-types/annotated-types#37](https://github.com/annotated-types/annotated-types/issues/37).\n\n    The Hypothesis plugin may be back in a future release. Subscribe to [pydantic/pydantic#4682](https://github.com/pydantic/pydantic/issues/4682) for updates.", "url": "https://docs.pydantic.dev/latest/docs/integrations/hypothesis/", "page": "docs/integrations/hypothesis", "source_site": "pydantic"}
{"title": "types", "anchor": null, "heading_level": 0, "md_text": "::: pydantic.types\n    options:\n        show_root_heading: true\n        merge_init_into_class: false", "url": "https://docs.pydantic.dev/latest/docs/api/types/", "page": "docs/api/types", "source_site": "pydantic"}
{"title": "validate_call", "anchor": null, "heading_level": 0, "md_text": "::: pydantic.validate_call_decorator", "url": "https://docs.pydantic.dev/latest/docs/api/validate_call/", "page": "docs/api/validate_call", "source_site": "pydantic"}
{"title": "pydantic_extra_types_country", "anchor": null, "heading_level": 0, "md_text": "::: pydantic_extra_types.country", "url": "https://docs.pydantic.dev/latest/docs/api/pydantic_extra_types_country/", "page": "docs/api/pydantic_extra_types_country", "source_site": "pydantic"}
{"title": "pydantic_extra_types_semantic_version", "anchor": null, "heading_level": 0, "md_text": "::: pydantic_extra_types.semantic_version", "url": "https://docs.pydantic.dev/latest/docs/api/pydantic_extra_types_semantic_version/", "page": "docs/api/pydantic_extra_types_semantic_version", "source_site": "pydantic"}
{"title": "pydantic_extra_types_payment", "anchor": null, "heading_level": 0, "md_text": "::: pydantic_extra_types.payment", "url": "https://docs.pydantic.dev/latest/docs/api/pydantic_extra_types_payment/", "page": "docs/api/pydantic_extra_types_payment", "source_site": "pydantic"}
{"title": "json_schema", "anchor": null, "heading_level": 0, "md_text": "::: pydantic.json_schema", "url": "https://docs.pydantic.dev/latest/docs/api/json_schema/", "page": "docs/api/json_schema", "source_site": "pydantic"}
{"title": "aliases", "anchor": null, "heading_level": 0, "md_text": "::: pydantic.aliases", "url": "https://docs.pydantic.dev/latest/docs/api/aliases/", "page": "docs/api/aliases", "source_site": "pydantic"}
{"title": "fields", "anchor": null, "heading_level": 0, "md_text": "::: pydantic.fields\n    options:\n      group_by_category: false\n      members:\n        - Field\n        - FieldInfo\n        - PrivateAttr\n        - ModelPrivateAttr\n        - computed_field\n        - ComputedFieldInfo\n      filters:\n        - \"!^from_field$\"\n        - \"!^from_annotation$\"\n        - \"!^from_annotated_attribute$\"\n        - \"!^merge_field_infos$\"\n        - \"!^rebuild_annotation$\"\n        - \"!^apply_typevars_map$\"", "url": "https://docs.pydantic.dev/latest/docs/api/fields/", "page": "docs/api/fields", "source_site": "pydantic"}
{"title": "base_model", "anchor": null, "heading_level": 0, "md_text": "Pydantic models are simply classes which inherit from `BaseModel` and define fields as annotated attributes.\n\n::: pydantic.BaseModel\n    options:\n        show_root_heading: true\n        merge_init_into_class: false\n        group_by_category: false\n        # explicit members list so we can set order and include `__init__` easily\n        members:\n          - __init__\n          - model_config\n          - model_fields\n          - model_computed_fields\n          - __pydantic_core_schema__\n          - model_extra\n          - model_fields_set\n          - model_construct\n          - model_copy\n          - model_dump\n          - model_dump_json\n          - model_json_schema\n          - model_parametrized_name\n          - model_post_init\n          - model_rebuild\n          - model_validate\n          - model_validate_json\n          - model_validate_strings\n\n::: pydantic.create_model\n    options:\n        show_root_heading: true", "url": "https://docs.pydantic.dev/latest/docs/api/base_model/", "page": "docs/api/base_model", "source_site": "pydantic"}
{"title": "pydantic_extra_types_language_code", "anchor": null, "heading_level": 0, "md_text": "::: pydantic_extra_types.language_code", "url": "https://docs.pydantic.dev/latest/docs/api/pydantic_extra_types_language_code/", "page": "docs/api/pydantic_extra_types_language_code", "source_site": "pydantic"}
{"title": "pydantic_extra_types_timezone_name", "anchor": null, "heading_level": 0, "md_text": "::: pydantic_extra_types.timezone_name", "url": "https://docs.pydantic.dev/latest/docs/api/pydantic_extra_types_timezone_name/", "page": "docs/api/pydantic_extra_types_timezone_name", "source_site": "pydantic"}
{"title": "pydantic_extra_types_phone_numbers", "anchor": null, "heading_level": 0, "md_text": "::: pydantic_extra_types.phone_numbers", "url": "https://docs.pydantic.dev/latest/docs/api/pydantic_extra_types_phone_numbers/", "page": "docs/api/pydantic_extra_types_phone_numbers", "source_site": "pydantic"}
{"title": "pydantic_extra_types_script_code", "anchor": null, "heading_level": 0, "md_text": "::: pydantic_extra_types.script_code", "url": "https://docs.pydantic.dev/latest/docs/api/pydantic_extra_types_script_code/", "page": "docs/api/pydantic_extra_types_script_code", "source_site": "pydantic"}
{"title": "pydantic_core_schema", "anchor": null, "heading_level": 0, "md_text": "::: pydantic_core.core_schema", "url": "https://docs.pydantic.dev/latest/docs/api/pydantic_core_schema/", "page": "docs/api/pydantic_core_schema", "source_site": "pydantic"}
{"title": "pydantic_extra_types_pendulum_dt", "anchor": null, "heading_level": 0, "md_text": "::: pydantic_extra_types.pendulum_dt", "url": "https://docs.pydantic.dev/latest/docs/api/pydantic_extra_types_pendulum_dt/", "page": "docs/api/pydantic_extra_types_pendulum_dt", "source_site": "pydantic"}
{"title": "pydantic_extra_types_routing_numbers", "anchor": null, "heading_level": 0, "md_text": "::: pydantic_extra_types.routing_number", "url": "https://docs.pydantic.dev/latest/docs/api/pydantic_extra_types_routing_numbers/", "page": "docs/api/pydantic_extra_types_routing_numbers", "source_site": "pydantic"}
{"title": "config", "anchor": null, "heading_level": 0, "md_text": "::: pydantic.config\n    options:\n      group_by_category: false\n      members:\n        - ConfigDict\n        - with_config\n        - ExtraValues\n        - BaseConfig\n\n::: pydantic.alias_generators\n    options:\n      show_root_heading: true", "url": "https://docs.pydantic.dev/latest/docs/api/config/", "page": "docs/api/config", "source_site": "pydantic"}
{"title": "pydantic_settings", "anchor": null, "heading_level": 0, "md_text": "::: pydantic_settings", "url": "https://docs.pydantic.dev/latest/docs/api/pydantic_settings/", "page": "docs/api/pydantic_settings", "source_site": "pydantic"}
{"title": "pydantic_extra_types_currency_code", "anchor": null, "heading_level": 0, "md_text": "::: pydantic_extra_types.currency_code", "url": "https://docs.pydantic.dev/latest/docs/api/pydantic_extra_types_currency_code/", "page": "docs/api/pydantic_extra_types_currency_code", "source_site": "pydantic"}
{"title": "functional_validators", "anchor": null, "heading_level": 0, "md_text": "::: pydantic.functional_validators", "url": "https://docs.pydantic.dev/latest/docs/api/functional_validators/", "page": "docs/api/functional_validators", "source_site": "pydantic"}
{"title": "pydantic_extra_types_coordinate", "anchor": null, "heading_level": 0, "md_text": "::: pydantic_extra_types.coordinate", "url": "https://docs.pydantic.dev/latest/docs/api/pydantic_extra_types_coordinate/", "page": "docs/api/pydantic_extra_types_coordinate", "source_site": "pydantic"}
{"title": "root_model", "anchor": null, "heading_level": 0, "md_text": "::: pydantic.root_model", "url": "https://docs.pydantic.dev/latest/docs/api/root_model/", "page": "docs/api/root_model", "source_site": "pydantic"}
{"title": "errors", "anchor": null, "heading_level": 0, "md_text": "::: pydantic.errors", "url": "https://docs.pydantic.dev/latest/docs/api/errors/", "page": "docs/api/errors", "source_site": "pydantic"}
{"title": "version", "anchor": null, "heading_level": 0, "md_text": "::: pydantic.__version__\n    options:\n        show_root_heading: true\n\n::: pydantic.version.version_info\n    options:\n        show_root_heading: true", "url": "https://docs.pydantic.dev/latest/docs/api/version/", "page": "docs/api/version", "source_site": "pydantic"}
{"title": "type_adapter", "anchor": null, "heading_level": 0, "md_text": "::: pydantic.type_adapter.TypeAdapter", "url": "https://docs.pydantic.dev/latest/docs/api/type_adapter/", "page": "docs/api/type_adapter", "source_site": "pydantic"}
{"title": "pydantic_extra_types_ulid", "anchor": null, "heading_level": 0, "md_text": "::: pydantic_extra_types.ulid", "url": "https://docs.pydantic.dev/latest/docs/api/pydantic_extra_types_ulid/", "page": "docs/api/pydantic_extra_types_ulid", "source_site": "pydantic"}
{"title": "annotated_handlers", "anchor": null, "heading_level": 0, "md_text": "::: pydantic.annotated_handlers", "url": "https://docs.pydantic.dev/latest/docs/api/annotated_handlers/", "page": "docs/api/annotated_handlers", "source_site": "pydantic"}
{"title": "networks", "anchor": null, "heading_level": 0, "md_text": "::: pydantic.networks", "url": "https://docs.pydantic.dev/latest/docs/api/networks/", "page": "docs/api/networks", "source_site": "pydantic"}
{"title": "functional_serializers", "anchor": null, "heading_level": 0, "md_text": "::: pydantic.functional_serializers", "url": "https://docs.pydantic.dev/latest/docs/api/functional_serializers/", "page": "docs/api/functional_serializers", "source_site": "pydantic"}
{"title": "pydantic_extra_types_isbn", "anchor": null, "heading_level": 0, "md_text": "::: pydantic_extra_types.isbn", "url": "https://docs.pydantic.dev/latest/docs/api/pydantic_extra_types_isbn/", "page": "docs/api/pydantic_extra_types_isbn", "source_site": "pydantic"}
{"title": "pydantic_extra_types_color", "anchor": null, "heading_level": 0, "md_text": "::: pydantic_extra_types.color", "url": "https://docs.pydantic.dev/latest/docs/api/pydantic_extra_types_color/", "page": "docs/api/pydantic_extra_types_color", "source_site": "pydantic"}
{"title": "pydantic_extra_types_mac_address", "anchor": null, "heading_level": 0, "md_text": "::: pydantic_extra_types.mac_address", "url": "https://docs.pydantic.dev/latest/docs/api/pydantic_extra_types_mac_address/", "page": "docs/api/pydantic_extra_types_mac_address", "source_site": "pydantic"}
{"title": "dataclasses", "anchor": null, "heading_level": 0, "md_text": "::: pydantic.dataclasses", "url": "https://docs.pydantic.dev/latest/docs/api/dataclasses/", "page": "docs/api/dataclasses", "source_site": "pydantic"}
{"title": "Pipeline API", "anchor": "pipeline-api", "heading_level": 2, "md_text": "::: pydantic.experimental.pipeline\n    options:\n        members:\n            - _Pipeline", "url": "https://docs.pydantic.dev/latest/docs/api/experimental/#pipeline-api", "page": "docs/api/experimental", "source_site": "pydantic"}
{"title": "Arguments schema API", "anchor": "arguments-schema-api", "heading_level": 2, "md_text": "::: pydantic.experimental.arguments_schema\n    options:\n        members:\n            - generate_arguments_schema", "url": "https://docs.pydantic.dev/latest/docs/api/experimental/#arguments-schema-api", "page": "docs/api/experimental", "source_site": "pydantic"}
{"title": "pydantic_core", "anchor": null, "heading_level": 0, "md_text": "::: pydantic_core\n    options:\n        allow_inspection: false\n        show_source: false\n        members:\n        - SchemaValidator\n        - SchemaSerializer\n        - ValidationError\n        - ErrorDetails\n        - InitErrorDetails\n        - SchemaError\n        - PydanticCustomError\n        - PydanticKnownError\n        - PydanticOmit\n        - PydanticUseDefault\n        - PydanticSerializationError\n        - PydanticSerializationUnexpectedValue\n        - Url\n        - MultiHostUrl\n        - MultiHostHost\n        - ArgsKwargs\n        - Some\n        - TzInfo\n        - to_json\n        - from_json\n        - to_jsonable_python\n        - list_all_errors\n        - ErrorTypeInfo\n        - __version__", "url": "https://docs.pydantic.dev/latest/docs/api/pydantic_core/", "page": "docs/api/pydantic_core", "source_site": "pydantic"}
{"title": "standard_library_types", "anchor": null, "heading_level": 0, "md_text": "---\ndescription: Support for common types from the Python standard library.\n---\n\nThis section enumerates the supported built-in and standard library types: the allowed values,\nthe possible constraints, and whether strictness can be configured.\n\nSee also the [conversion table](../concepts/conversion_table.md) for a summary of the allowed values for each type.\n\n!!! note\n    Unless specified otherwise, values are serialized as-is, in both Python and JSON modes.", "url": "https://docs.pydantic.dev/latest/docs/api/standard_library_types/", "page": "docs/api/standard_library_types", "source_site": "pydantic"}
{"title": "Booleans", "anchor": "booleans", "heading_level": 2, "md_text": "Built-in type: [`bool`][]\n\n<h3>Validation</h3>\n\n* A valid [`bool`][] instance, i.e. `True` or `False`.\n* The integers `0` or `1`.\n* A string, which when converted to lowercase is one of `'0'`, `'off'`, `'f'`, `'false'`, `'n'`, `'no'`, `'1'`, `'on'` `'t'`, `'true'`, `'y'`, `'yes'`.\n* [`bytes`][] objects that are valid per the previous rule when decoded to a string.\n\n<h3>Strictness</h3>\n\nIn [strict mode](../concepts/strict_mode.md), only boolean values are valid. Pydantic provides the [`StrictBool`][pydantic.types.StrictBool]\ntype as a convenience to [using the `Strict()` metadata class](../concepts/strict_mode.md#using-the-strict-metadata-class).\n\n<h3>Example</h3>\n\n```python\nfrom pydantic import BaseModel, ValidationError\n\n\nclass BooleanModel(BaseModel):\n    bool_value: bool\n\n\nprint(BooleanModel(bool_value=False))\n#> bool_value=False\nprint(BooleanModel(bool_value='False'))\n#> bool_value=False\nprint(BooleanModel(bool_value=1))\n#> bool_value=True\ntry:\n    BooleanModel(bool_value=[])\nexcept ValidationError as e:\n    print(str(e))\n    \"\"\"\n    1 validation error for BooleanModel\n    bool_value\n      Input should be a valid boolean [type=bool_type, input_value=[], input_type=list]\n    \"\"\"\n```", "url": "https://docs.pydantic.dev/latest/docs/api/standard_library_types/#booleans", "page": "docs/api/standard_library_types", "source_site": "pydantic"}
{"title": "Strings", "anchor": "strings", "heading_level": 2, "md_text": "Built-in type: [`str`][]\n\n<h3>Validation</h3>\n\n* Strings are accepted as-is.\n* [`bytes`][] and [`bytearray`][] are decoded to UTF-8 strings.\n* [Enums][enum] are converted using the [`value`][enum.Enum.value] attribute, by calling [`str()`][str]\n  on it.\n* If [`coerce_numbers_to_str`][pydantic.ConfigDict.coerce_numbers_to_str] is set, any number type\n  ([`int`][], [`float`][] and [`Decimal`][decimal.Decimal]) will be coerced to a string and accepted\n  as-is.\n\n<h3>Constraints</h3>\n\nStrings support the following constraints:\n\n| Constraint         | Description                                       | JSON Schema                                                                                                                                   |\n| ------------------ | ------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------- |\n| `pattern`          | A regex pattern that the string must match        | [`pattern`](https://json-schema.org/understanding-json-schema/reference/string#regexp) keyword (see [note](#pattern-constraint-note) below).  |\n| `min_length`       | The minimum length of the string                  | [`minLength`](https://json-schema.org/understanding-json-schema/reference/string#length) keyword                                              |\n| `max_length`       | The maximum length of the string                  | [`maxLength`](https://json-schema.org/understanding-json-schema/reference/string#length) keyword                                              |\n| `strip_whitespace` | Whether to remove leading and trailing whitespace | N/A                                                                                                                                           |\n| `to_upper`         | Whether to convert the string to uppercase        | N/A                                                                                                                                           |\n| `to_lower`         | Whether to convert the string to lowercase        | N/A                                                                                                                                           |\n\nThese constraints can be provided using the [`StringConstraints`][pydantic.types.StringConstraints] metadata type, or using the [`Field()`][pydantic.Field] function (except for `to_upper` and `to_lower`).\nThe `MinLen`, `MaxLen`, `Len`, `LowerCase`, `UpperCase` metadata types from the [`annotated-types`](https://github.com/annotated-types/annotated-types)\nlibrary can also be used.\n\n<!-- markdownlint-disable-next-line no-empty-links -->\n[](){#pattern-constraint-note}\n\n!!! note \"`pattern` constraint\"\n    By default, Pydantic will use the [`regex`](https://docs.rs/regex) Rust crate to enforce the `pattern` constraint. The regex engine can be controlled\n    using the [`regex_engine`][pydantic.ConfigDict.regex_engine] configuration value. If a compiled [regular expression object][re.Pattern] is used for\n    `pattern`, the Python engine will automatically be used.\n\n    While the JSON Schema specification [recommends](https://json-schema.org/draft/2020-12/json-schema-core#name-regular-expressions) using patterns\n    valid according to dialect described in [ECMA-262](https://262.ecma-international.org/11.0/index.html#sec-patterns), Pydantic will *not* enforce it.\n\n<h3>Strictness</h3>\n\nIn [strict mode](../concepts/strict_mode.md), only string values are valid. Pydantic provides the [`StrictStr`][pydantic.types.StrictStr]\ntype as a convenience to [using the `Strict()` metadata class](../concepts/strict_mode.md#using-the-strict-metadata-class).\n\n<h3>Example</h3>\n\n```python\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, StringConstraints\n\n\nclass StringModel(BaseModel):\n    str_value: str = \"\"\n    constrained_str_value: Annotated[str, StringConstraints(to_lower=True)] = \"\"\n\n\nprint(StringModel(str_value=\"test\").str_value)\n#> test\nprint(StringModel(constrained_str_value='TEST').constrained_str_value)\n#> test\n```", "url": "https://docs.pydantic.dev/latest/docs/api/standard_library_types/#strings", "page": "docs/api/standard_library_types", "source_site": "pydantic"}
{"title": "Bytes", "anchor": "bytes", "heading_level": 2, "md_text": "Built-in type: [`bytes`][].\n\nSee also: [`ByteSize`][pydantic.types.ByteSize].\n\n<h3>Validation</h3>\n\n* [`bytes`][] instances are validated as is.\n* Strings and [`bytearray`][] instances are converted as bytes, following the [`val_json_bytes`][pydantic.ConfigDict.val_json_bytes] configuration value\n  (despite its name, it applies to both Python and JSON modes).\n\n<h3>Constraints</h3>\n\nStrings support the following constraints:\n\n| Constraint         | Description                     | JSON Schema                                                                                      |\n| ------------------ | --------------------------------| -------------------------------------------------------------------------------------------------|\n| `min_length`       | The minimum length of the bytes | [`minLength`](https://json-schema.org/understanding-json-schema/reference/string#length) keyword |\n| `max_length`       | The maximum length of the bytes | [`maxLength`](https://json-schema.org/understanding-json-schema/reference/string#length) keyword |\n\nThe `MinLen` and `MaxLen` metadata types from the [`annotated-types`](https://github.com/annotated-types/annotated-types)\nlibrary can also be used.\n\n<h3>Strictness</h3>\n\nIn [strict mode](../concepts/strict_mode.md), only [`bytes`][] instances are valid. Pydantic provides the [`StrictBytes`][pydantic.types.StrictBytes]\ntype as a convenience to [using the `Strict()` metadata class](../concepts/strict_mode.md#using-the-strict-metadata-class).\n\nIn JSON mode, strict mode has no effect.\n\n<!-- old anchor added for backwards compatibility -->\n<!-- markdownlint-disable-next-line no-empty-links -->\n[](){#number-types}", "url": "https://docs.pydantic.dev/latest/docs/api/standard_library_types/#bytes", "page": "docs/api/standard_library_types", "source_site": "pydantic"}
{"title": "Numbers", "anchor": "numbers", "heading_level": 2, "md_text": "Pydantic supports the following numeric types from the Python standard library:\n\n<!-- old anchor added for backwards compatibility -->\n<!-- markdownlint-disable-next-line no-empty-links -->\n[](){#int}", "url": "https://docs.pydantic.dev/latest/docs/api/standard_library_types/#numbers", "page": "docs/api/standard_library_types", "source_site": "pydantic"}
{"title": "Integers", "anchor": "integers", "heading_level": 3, "md_text": "Built-in type: [`int`][].\n\n<h4>Validation</h4>\n\n* Integers are validated as-is.\n* Strings and bytes are attempted to be converted to integers and validated as-is\n  (see the [jiter implementation](https://docs.rs/jiter/latest/jiter/enum.NumberInt.html#impl-TryFrom%3C%26%5Bu8%5D%3E-for-NumberInt) for details).\n* Floats are validated as integers, provided the float input is not infinite or a NaN (not-a-number)\n  and the fractional part is 0.\n* [`Decimal`][decimal.Decimal] instances, provided they are [finite][decimal.Decimal.is_finite] and the\n  denominator is 1.\n* [`Fraction`][fractions.Fraction] instances, provided they are [integers][fractions.Fraction.is_integer].\n* [Enums][enum] are converted using the [`value`][enum.Enum.value] attribute.\n\n<h4>Constraints</h4>\n\nIntegers support the following constraints (numbers must be coercible to integers):\n\n| Constraint    | Description                                            | JSON Schema                                                                                             |\n| ------------- | ------------------------------------------------------ | ------------------------------------------------------------------------------------------------------- |\n| `le`          | The value must be less than or equal to this number    | [`maximum`](https://json-schema.org/understanding-json-schema/reference/numeric#range) keyword          |\n| `ge`          | The value must be greater than or equal to this number | [`minimum`](https://json-schema.org/understanding-json-schema/reference/numeric#range) keyword          |\n| `lt`          | The value must be strictly less than this number       | [`exclusiveMaximum`](https://json-schema.org/understanding-json-schema/reference/numeric#range) keyword |\n| `gt`          | The value must be strictly greater than this number    | [`exclusiveMinimum`](https://json-schema.org/understanding-json-schema/reference/numeric#range) keyword |\n| `multiple_of` | The value must be a multiple of this number            | [`multipleOf`](https://json-schema.org/understanding-json-schema/reference/numeric#multiples) keyword   |\n\nThese constraints can be provided using the [`Field()`][pydantic.Field] function.\nThe `Le`, `Ge`, `Lt`, `Gt` and `MultipleOf` metadata types from the [`annotated-types`](https://github.com/annotated-types/annotated-types)\nlibrary can also be used.\n\nPydantic also provides the following types to further constrain the allowed integer values:\n\n* [`PositiveInt`][pydantic.types.PositiveInt]: Requires the input to be greater than zero.\n* [`NegativeInt`][pydantic.types.NegativeInt]: Requires the input to be less than zero.\n* [`NonPositiveInt`][pydantic.types.NonPositiveInt]: Requires the input to be less than or equal to zero.\n* [`NonNegativeInt`][pydantic.types.NonNegativeInt]: Requires the input to be greater than or equal to zero.\n\n<h4>Strictness</h4>\n\nIn [strict mode](../concepts/strict_mode.md), only integer values are valid. Pydantic provides the [`StrictInt`][pydantic.types.StrictInt]\ntype as a convenience to [using the `Strict()` metadata class](../concepts/strict_mode.md#using-the-strict-metadata-class).\n\n<!-- old anchor added for backwards compatibility -->\n<!-- markdownlint-disable-next-line no-empty-links -->\n[](){#float}", "url": "https://docs.pydantic.dev/latest/docs/api/standard_library_types/#integers", "page": "docs/api/standard_library_types", "source_site": "pydantic"}
{"title": "Floats", "anchor": "floats", "heading_level": 3, "md_text": "Built-in type: [`float`][].\n\n<h4>Validation</h4>\n\n* Floats are validated as-is.\n* String and bytes are attempted to be converted to floats and validated as-is.\n  (see the [Rust implementation](https://doc.rust-lang.org/src/core/num/dec2flt/mod.rs.html) for details).\n* If the input has a [`__float__()`][object.__float__] method, it will be called to convert the input into\n  a float. If `__float__()` is not defined, it falls back to [`__index__()`][object.__index__]. This includes\n  (but not limited to) the [`Decimal`][decimal.Decimal] and [`Fraction`][fractions.Fraction] types.\n\n<h4>Constraints</h4>\n\nFloats support the following constraints:\n\n| Constraint      | Description                                             | JSON Schema                                                                                             |\n| --------------- | ------------------------------------------------------- | ------------------------------------------------------------------------------------------------------- |\n| `le`            | The value must be less than or equal to this number     | [`maximum`](https://json-schema.org/understanding-json-schema/reference/numeric#range) keyword          |\n| `ge`            | The value must be greater than or equal to this number  | [`minimum`](https://json-schema.org/understanding-json-schema/reference/numeric#range) keyword          |\n| `lt`            | The value must be strictly less than this number        | [`exclusiveMaximum`](https://json-schema.org/understanding-json-schema/reference/numeric#range) keyword |\n| `gt`            | The value must be strictly greater than this number     | [`exclusiveMinimum`](https://json-schema.org/understanding-json-schema/reference/numeric#range) keyword |\n| `multiple_of`   | The value must be a multiple of this number             | [`multipleOf`](https://json-schema.org/understanding-json-schema/reference/numeric#multiples) keyword   |\n| `allow_inf_nan` | Whether to allow NaN (not-a-number) and infinite values | N/A                                                                                                     |\n\nThese constraints can be provided using the [`Field()`][pydantic.Field] function.\nThe `Le`, `Ge`, `Lt`, `Gt` and `MultipleOf` metadata types from the [`annotated-types`](https://github.com/annotated-types/annotated-types)\nlibrary and the [`AllowInfNan`][pydantic.types.AllowInfNan] type can also be used.\n\nPydantic also provides the following types as convenience aliases:\n\n* [`PositiveFloat`][pydantic.types.PositiveFloat]: Requires the input to be greater than zero.\n* [`NegativeFloat`][pydantic.types.NegativeFloat]: Requires the input to be less than zero.\n* [`NonPositiveFloat`][pydantic.types.NonPositiveFloat]: Requires the input to be less than or equal to zero.\n* [`NonNegativeFloat`][pydantic.types.NonNegativeFloat]: Requires the input to be greater than or equal to zero.\n* [`FiniteFloat`][pydantic.types.FiniteFloat]: Prevents NaN (not-a-number) and infinite values.\n\n<h4>Strictness</h4>\n\nIn [strict mode](../concepts/strict_mode.md), only float values and inputs having a [`__float__()`][object.__float__]\nor [`__index__()`][object.__index__] method are valid.\nPydantic provides the [`StrictFloat`][pydantic.types.StrictFloat] type as a convenience to\n[using the `Strict()` metadata class](../concepts/strict_mode.md#using-the-strict-metadata-class).\n\n<!-- old anchor added for backwards compatibility -->\n<!-- markdownlint-disable-next-line no-empty-links -->\n[](){#enumintenum}", "url": "https://docs.pydantic.dev/latest/docs/api/standard_library_types/#floats", "page": "docs/api/standard_library_types", "source_site": "pydantic"}
{"title": "Integer enums", "anchor": "integer-enums", "heading_level": 3, "md_text": "Standard library type: [`enum.IntEnum`][].\n\n<h4>Validation</h4>\n\n* If the [`enum.IntEnum`][] type is used directly, any [`enum.IntEnum`][] instance is validated as-is\n* Id an [`enum.IntEnum`][] subclass is used as a type, any enum member or value that correspond to the\n  enum members values is validated as-is.\n\nSee [Enums](#enums) for more details.\n\n<!-- old anchor added for backwards compatibility -->\n<!-- markdownlint-disable-next-line no-empty-links -->\n[](){#decimaldecimal}", "url": "https://docs.pydantic.dev/latest/docs/api/standard_library_types/#integer-enums", "page": "docs/api/standard_library_types", "source_site": "pydantic"}
{"title": "Decimals", "anchor": "decimals", "heading_level": 3, "md_text": "Standard library type: [`decimal.Decimal`][].\n\n<h4>Validation</h4>\n\n* [`Decimal`][decimal.Decimal] instances are validated as is.\n* Any value accepted by the [`Decimal`][decimal.Decimal] constructor (apart from the\n  three-tuple input) will validate.\n\n<h4>Constraints</h4>\n\nDecimals support the following constraints (numbers must be coercible to decimals):\n\n| Constraint       | Description                                                                                                         | JSON Schema                                                                                                                    |\n| ---------------- | ------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------ |\n| `le`             | The value must be less than or equal to this number                                                                 | [`maximum`](https://json-schema.org/understanding-json-schema/reference/numeric#range) keyword                                 |\n| `ge`             | The value must be greater than or equal to this number                                                              | [`minimum`](https://json-schema.org/understanding-json-schema/reference/numeric#range) keyword                                 |\n| `lt`             | The value must be strictly less than this number                                                                    | [`exclusiveMaximum`](https://json-schema.org/understanding-json-schema/reference/numeric#range) keyword                        |\n| `gt`             | The value must be strictly greater than this number                                                                 | [`exclusiveMinimum`](https://json-schema.org/understanding-json-schema/reference/numeric#range) keyword                        |\n| `multiple_of`    | The value must be a multiple of this number                                                                         | [`multipleOf`](https://json-schema.org/understanding-json-schema/reference/numeric#multiples) keyword                          |\n| `allow_inf_nan`  | Whether to allow NaN (not-a-number) and infinite values                                                             | N/A                                                                                                                            |\n| `max_digits`     | The maximum number of decimal digits allowed. The zero before the decimal point and trailing zeros are not counted. | [`pattern`](https://json-schema.org/understanding-json-schema/reference/string#regexp) keyword, to describe the string pattern |\n| `decimal_places` | The maximum number of decimal places allowed. Trailing zeros are not counted.                                       | [`pattern`](https://json-schema.org/understanding-json-schema/reference/string#regexp) keyword, to describe the string pattern |\n\nNote that the JSON Schema [`pattern`](https://json-schema.org/understanding-json-schema/reference/string#regexp) keyword will be specified\nin the JSON Schema to describe the string pattern in all cases (and can vary if `max_digits` and/or `decimal_places` is specified).\n\nThese constraints can be provided using the [`Field()`][pydantic.Field] function.\nThe `Le`, `Ge`, `Lt`, `Gt` and `MultipleOf` metadata types from the [`annotated-types`](https://github.com/annotated-types/annotated-types)\nlibrary and the [`AllowInfNan`][pydantic.types.AllowInfNan] type can also be used.\n\n<h4>Strictness</h4>\n\nIn [strict mode](../concepts/strict_mode.md), only [`decimal.Decimal`][] instances are accepted. In JSON mode, strict mode has no effect.\n\n<h4>Serialization</h4>\n\nIn [Python mode](../concepts/serialization.md#python-mode), [`Decimal`][decimal.Decimal] instances are\nserialized as is.\n\nIn [JSON mode](../concepts/serialization.md#json-mode), they are serialized as strings.\nA [serializer](../concepts/serialization.md#field-plain-serializer) can be used to override this behavior:\n\n```python\nfrom decimal import Decimal\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, PlainSerializer\n\n\nclass Model(BaseModel):\n    f: Annotated[Decimal, PlainSerializer(float, when_used='json')]\n\n\nmy_model = Model(f=Decimal('2.1'))\n\nprint(my_model.model_dump())  # (1)!\n#> {'f': Decimal('2.1')}\nprint(my_model.model_dump_json())  # (2)!\n#> {\"f\":2.1}\n```\n\n1. In Python mode, `f`remains a [`Decimal`][decimal.Decimal] instance.\n2. In JSON mode, `f` is serialized as a float.\n\n<!-- old anchor added for backwards compatibility -->\n<!-- markdownlint-disable-next-line no-empty-links -->\n[](){#complex}", "url": "https://docs.pydantic.dev/latest/docs/api/standard_library_types/#decimals", "page": "docs/api/standard_library_types", "source_site": "pydantic"}
{"title": "Complex numbers", "anchor": "complex-numbers", "heading_level": 3, "md_text": "Built-in type: [`complex`][].\n\n<h4>Validation</h4>\n\n* [`complex`][] instances are validated as-is.\n* Strings are validated using the [`complex()`][complex] constructor.\n* Numbers (integers and floats) are used as the real part.\n* Objects defining [`__complex__()`][object.__complex__], [`__float__()`][object.__float__].\n  or [`__index__()`][object.__index__] are currently *not* accepted.\n\n<h4>Strictness</h4>\n\nIn [strict mode](../concepts/strict_mode.md), only [`complex`][] instances are accepted. In JSON mode, only strings that are\naccepted by the [`complex()`][complex] constructor are allowed.\n\n<h4>Serialization</h4>\n\nIn [Python mode](../concepts/serialization.md#python-mode), [`complex`][] instances are\nserialized as is.\n\nIn [JSON mode](../concepts/serialization.md#json-mode), they are serialized as strings.\n\n<!-- old anchor added for backwards compatibility -->\n<!-- markdownlint-disable-next-line no-empty-links -->\n[](){#fractionsfraction}", "url": "https://docs.pydantic.dev/latest/docs/api/standard_library_types/#complex-numbers", "page": "docs/api/standard_library_types", "source_site": "pydantic"}
{"title": "Fractions", "anchor": "fractions", "heading_level": 3, "md_text": "Standard library type: [`fractions.Fraction`][].\n\n<h4>Validation</h4>\n\n* [`Fraction`][fractions.Fraction] instances are validated as is.\n* Floats, strings and [`decimal.Decimal`][] instances are validated using the [`Fraction()`][fractions.Fraction]\n  constructor.\n\n<h4>Strictness</h4>\n\nIn [strict mode](../concepts/strict_mode.md), only [`Fraction`][fractions.Fraction] instances are accepted. In JSON mode, strict mode has no effect.\n\n<h4>Serialization</h4>\n\nFractions are serialized as strings, both in [Python](../concepts/serialization.md#python-mode)\nand [JSON](../concepts/serialization.md#json-mode) modes.\n\n<!-- old anchor added for backwards compatibility -->\n<!-- markdownlint-disable-next-line no-empty-links -->\n[](){#datetime-types}", "url": "https://docs.pydantic.dev/latest/docs/api/standard_library_types/#fractions", "page": "docs/api/standard_library_types", "source_site": "pydantic"}
{"title": "Date and time types", "anchor": "date-and-time-types", "heading_level": 2, "md_text": "Pydantic supports the following [date and time](https://docs.python.org/library/datetime.html#available-types)\ntypes from the [`datetime`][] standard library:\n\n<!-- old anchor added for backwards compatibility -->\n<!-- markdownlint-disable-next-line no-empty-links -->\n[](){#datetimedatetime}", "url": "https://docs.pydantic.dev/latest/docs/api/standard_library_types/#date-and-time-types", "page": "docs/api/standard_library_types", "source_site": "pydantic"}
{"title": "Datetimes", "anchor": "datetimes", "heading_level": 3, "md_text": "Standard library type: [`datetime.datetime`][].\n\n<h4>Validation</h4>\n\n* [`datetime`][datetime.datetime] instances are validated as is.\n* Strings and bytes are validated in two ways:\n    * Strings complying to the [RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339) format (both datetime and date).\n      See the [speedate](https://docs.rs/speedate/) documentation for more details.\n    * Unix timestamps, both as seconds or milliseconds sinch the [epoch](https://en.wikipedia.org/wiki/Unix_time).\n      See the [`val_temporal_unit`][pydantic.ConfigDict.val_temporal_unit] configuration value for more details.\n* Integers and floats (or types that can be coerced as integers or floats) are validated as unix timestamps, following the\n  same semantics as strings.\n* [`datetime.date`][] instances are accepted, and converted to a [`datetime`][datetime.datetime] instance\n  by setting the [`hour`][datetime.datetime.hour], [`minute`][datetime.datetime.minute], [`second`][datetime.datetime.second] and\n  [`microsecond`][datetime.datetime.microsecond] attributes to `0`, and the [`tzinfo`][datetime.datetime.tzinfo] attribute to `None`.\n\n!!! note\n    Named timezone support (as specified in [RFC 9557](https://datatracker.ietf.org/doc/html/rfc9557.html))\n    can be tracked in [this issue](https://github.com/pydantic/pydantic/issues/12252).\n\n<h4>Serialization</h4>\n\nIn [Python mode](../concepts/serialization.md#python-mode), [`datetime`][datetime.datetime] instances are\nserialized as is.\n\nIn [JSON mode](../concepts/serialization.md#json-mode), they are serialized as strings.\n\n<h4>Constraints</h4>\n\nDatetimes support the following constraints (constraint values must be coercible to a [`datetime`][datetime.datetime] instance):\n\n| Constraint | Description                                              | JSON Schema |\n| ---------- | -------------------------------------------------------- | ----------- |\n| `le`       | The value must be less than or equal to this datetime    | N/A         |\n| `ge`       | The value must be greater than or equal to this datetime | N/A         |\n| `lt`       | The value must be strictly less than this datetime       | N/A         |\n| `gt`       | The value must be strictly greater than this datetime    | N/A         |\n\nThese constraints can be provided using the [`Field()`][pydantic.Field] function.\nThe `Le`, `Ge`, `Lt` and `Gt` metadata types from the [`annotated-types`](https://github.com/annotated-types/annotated-types)\nlibrary can also be used.\n\nPydantic also provides the following types to further constrain the allowed datetime values:\n\n* [`AwareDatetime`][pydantic.types.AwareDatetime]: Requires the input to have a timezone.\n* [`NaiveDatetime`][pydantic.types.NaiveDatetime]: Requires the input to *not* have a timezone.\n* [`PastDatetime`][pydantic.types.PastDatetime]: Requires the input to be in the past when validated.\n* [`FutureDatetime`][pydantic.types.FutureDatetime]: Requires the input to be in the future when validated.\n\n<h4>Strictness</h4>\n\nIn [strict mode](../concepts/strict_mode.md), only [`datetime`][datetime.datetime] instances are accepted. In JSON mode, only strings complying to the\n[RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339) format (*only* datetime) or as unix timestamps are accepted.\n\n<h4>Example</h4>\n\n```python\nfrom datetime import datetime\nfrom typing import Annotated\n\nfrom pydantic import AwareDatetime, BaseModel, Field\n\n\nclass Event(BaseModel):\n    dt: Annotated[AwareDatetime, Field(gt=datetime(2000, 1, 1))]\n\n\nevent = Event(dt='2032-04-23T10:20:30.400+02:30')\n\nprint(event.model_dump())\n\"\"\"\n{'dt': datetime.datetime(2032, 4, 23, 10, 20, 30, 400000, tzinfo=TzInfo(9000))}\n\"\"\"\nprint(event.model_dump_json())\n#> {\"dt\":\"2032-04-23T10:20:30.400000+02:30\"}\n```\n\n<!-- old anchor added for backwards compatibility -->\n<!-- markdownlint-disable-next-line no-empty-links -->\n[](){#datetimedate}", "url": "https://docs.pydantic.dev/latest/docs/api/standard_library_types/#datetimes", "page": "docs/api/standard_library_types", "source_site": "pydantic"}
{"title": "Dates", "anchor": "dates", "heading_level": 3, "md_text": "Standard library type: [`datetime.date`][].\n\n<h4>Validation</h4>\n\n* [`date`][datetime.date] instances are validated as is.\n* Strings and bytes are validated in two ways:\n    * Strings complying to the [RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339) date format.\n      See the [speedate](https://docs.rs/speedate/) documentation for more details.\n    * Unix timestamps, both as seconds or milliseconds sinch the [epoch](https://en.wikipedia.org/wiki/Unix_time).\n      See the [`val_temporal_unit`][pydantic.ConfigDict.val_temporal_unit] configuration value for more details.\n* If the validation fails, the input can be [validated as a datetime](#datetimes) (including as numbers),\n  provided that the time component is 0 and that it is naive.\n\n<h4>Serialization</h4>\n\nIn [Python mode](../concepts/serialization.md#python-mode), [`date`][datetime.date] instances are\nserialized as is.\n\nIn [JSON mode](../concepts/serialization.md#json-mode), they are serialized as strings.\n\n<h4>Constraints</h4>\n\nDates support the following constraints (constraint values must be coercible to a [`date`][datetime.date] instance):\n\n| Constraint | Description                                          | JSON Schema |\n| ---------- | ---------------------------------------------------- | ----------- |\n| `le`       | The value must be less than or equal to this date    | N/A         |\n| `ge`       | The value must be greater than or equal to this date | N/A         |\n| `lt`       | The value must be strictly less than this date       | N/A         |\n| `gt`       | The value must be strictly greater than this date    | N/A         |\n\nThese constraints can be provided using the [`Field()`][pydantic.Field] function.\nThe `Le`, `Ge`, `Lt` and `Gt` metadata types from the [`annotated-types`](https://github.com/annotated-types/annotated-types)\nlibrary can also be used.\n\nPydantic also provides the following types to further constrain the allowed date values:\n\n* [`PastDate`][pydantic.types.PastDate]: Requires the input to be in the past when validated.\n* [`FutureDate`][pydantic.types.FutureDate]: Requires the input to be in the future when validated.\n\n<h4>Strictness</h4>\n\nIn [strict mode](../concepts/strict_mode.md), only [`date`][datetime.date] instances are accepted. In JSON mode, only strings complying to the\n[RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339) format (*only* date) or as unix timestamps are accepted.\n\n<h4>Example</h4>\n\n```python\nfrom datetime import date\n\nfrom pydantic import BaseModel\n\n\nclass Birthday(BaseModel):\n    d: date\n\n\nmy_birthday = Birthday(d=1679616000.0)\n\nprint(my_birthday.model_dump())\n#> {'d': datetime.date(2023, 3, 24)}\nprint(my_birthday.model_dump_json())\n#> {\"d\":\"2023-03-24\"}\n```\n\n<!-- old anchor added for backwards compatibility -->\n<!-- markdownlint-disable-next-line no-empty-links -->\n[](){#datetimetime}", "url": "https://docs.pydantic.dev/latest/docs/api/standard_library_types/#dates", "page": "docs/api/standard_library_types", "source_site": "pydantic"}
{"title": "Time", "anchor": "time", "heading_level": 3, "md_text": "Standard library type: [`datetime.time`][].\n\n<h4>Validation</h4>\n\n* [`time`][datetime.time] instances are validated as is.\n* Strings and bytes are validated according to the [RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339) time format.\n* Integers and floats (or values that can be coerced to such numbers) are validated as seconds. The value should not exceed 86 399.\n\n<h4>Serialization</h4>\n\nIn [Python mode](../concepts/serialization.md#python-mode), [`time`][datetime.time] instances are\nserialized as is.\n\nIn [JSON mode](../concepts/serialization.md#json-mode), they are serialized as strings.\n\n!!! note\n    Named timezones from the [IANA time zone database](https://www.iana.org/time-zones) (see the [`zoneinfo`][] module) are *not* serialized\n    with time objects. This is consistent with the [`time.isoformat()`][datetime.time.isoformat] method.\n\n<h4>Constraints</h4>\n\nTime support the following constraints (constraint values must be coercible to a [`time`][datetime.time] instance):\n\n| Constraint | Description                                          | JSON Schema |\n| ---------- | ---------------------------------------------------- | ----------- |\n| `le`       | The value must be less than or equal to this time    | N/A         |\n| `ge`       | The value must be greater than or equal to this time | N/A         |\n| `lt`       | The value must be strictly less than this time       | N/A         |\n| `gt`       | The value must be strictly greater than this time    | N/A         |\n\nThese constraints can be provided using the [`Field()`][pydantic.Field] function.\nThe `Le`, `Ge`, `Lt` and `Gt` metadata types from the [`annotated-types`](https://github.com/annotated-types/annotated-types)\nlibrary can also be used.\n\n<h4>Strictness</h4>\n\nIn [strict mode](../concepts/strict_mode.md), only [`time`][datetime.time] instances are accepted. In JSON mode, only strings complying to the\n[RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339) format are accepted.\n\n<h4>Example</h4>\n\n```python\nfrom datetime import time\n\nfrom pydantic import BaseModel\n\n\nclass Meeting(BaseModel):\n    t: time\n\n\nm = Meeting(t=time(4, 8, 16))\n\nprint(m.model_dump())\n#> {'t': datetime.time(4, 8, 16)}\nprint(m.model_dump_json())\n#> {\"t\":\"04:08:16\"}\n```\n\n<!-- old anchor added for backwards compatibility -->\n<!-- markdownlint-disable-next-line no-empty-links -->\n[](){#datetimetimedelta}", "url": "https://docs.pydantic.dev/latest/docs/api/standard_library_types/#time", "page": "docs/api/standard_library_types", "source_site": "pydantic"}
{"title": "Timedeltas", "anchor": "timedeltas", "heading_level": 3, "md_text": "Standard library type: [`datetime.timedelta`][].\n\n<h4>Validation</h4>\n\n* [`timedelta`][datetime.timedelta] instances are validated as is.\n* Strings and bytes are validated according to the [RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339) time format.\n* Integers and floats (or values that can be coerced to such numbers) are validated as seconds.\n\n<h4>Constraints</h4>\n\nTimedeltas support the following constraints (constraint values must be coercible to a [`timedata`][datetime.timedelta] instance):\n\n| Constraint | Description                                               | JSON Schema |\n| ---------- | ---------------------------------------------------- -----| ----------- |\n| `le`       | The value must be less than or equal to this timedelta    | N/A         |\n| `ge`       | The value must be greater than or equal to this timedelta | N/A         |\n| `lt`       | The value must be strictly less than this timedelta       | N/A         |\n| `gt`       | The value must be strictly greater than this timedelta    | N/A         |\n\nThese constraints can be provided using the [`Field()`][pydantic.Field] function.\nThe `Le`, `Ge`, `Lt` and `Gt` metadata types from the [`annotated-types`](https://github.com/annotated-types/annotated-types)\nlibrary can also be used.\n\n<h4>Serialization</h4>\n\nIn [Python mode](../concepts/serialization.md#python-mode), [`timedelta`][datetime.timedelta] instances are\nserialized as is.\n\nIn [JSON mode](../concepts/serialization.md#json-mode), they are serialized as strings.\n\n<h4>Strictness</h4>\n\nIn [strict mode](../concepts/strict_mode.md), only [`timedelta`][datetime.timedelta] instances are accepted. In JSON mode, only strings complying to the\n[RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339) format are accepted.\n\n<h4>Example</h4>\n\n```python\nfrom datetime import timedelta\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    td: timedelta\n\n\nm = Model(td='P3DT12H30M5S')\n\nprint(m.model_dump())\n#> {'td': datetime.timedelta(days=3, seconds=45005)}\nprint(m.model_dump_json())\n#> {\"td\":\"P3DT12H30M5S\"}\n```\n\n<!-- old anchor added for backwards compatibility -->\n<!-- markdownlint-disable-next-line no-empty-links -->\n[](){#enum}", "url": "https://docs.pydantic.dev/latest/docs/api/standard_library_types/#timedeltas", "page": "docs/api/standard_library_types", "source_site": "pydantic"}
{"title": "Enums", "anchor": "enums", "heading_level": 2, "md_text": "Standard library type: [`enum.Enum`][].\n\n<h3>Validation</h3>\n\n* If the [`enum.Enum`][] type is used directly, any [`enum.Enum`][] instance is validated as-is.\n* Id an [`enum.Enum`][] subclass is used as a type, any enum member or value that correspond to the\n  enum members [values][enum.Enum.value] is validated as-is.\n\n<h3>Serialization</h3>\n\nIn [Python mode](../concepts/serialization.md#python-mode), enum instances are serialized as is.\nThe [`use_enum_values`][pydantic.ConfigDict.use_enum_values] configuration value can be set to\nuse the enum [value][enum.Enum.value] during validation (so that it is also used during serialization).\n\nIn [JSON mode](../concepts/serialization.md#json-mode), enum instances are serialized using\ntheir [value][enum.Enum.value].\n\n<h3>Example</h3>\n\n```python\nfrom enum import Enum, IntEnum\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass FruitEnum(str, Enum):\n    PEAR = 'pear'\n    BANANA = 'banana'\n\n\nclass ToolEnum(IntEnum):\n    SPANNER = 1\n    WRENCH = 2\n\n\nclass CookingModel(BaseModel):\n    fruit: FruitEnum = FruitEnum.PEAR\n    tool: ToolEnum = ToolEnum.SPANNER\n\n\nprint(CookingModel())\n#> fruit=<FruitEnum.PEAR: 'pear'> tool=<ToolEnum.SPANNER: 1>\nprint(CookingModel(tool=2, fruit='banana'))\n#> fruit=<FruitEnum.BANANA: 'banana'> tool=<ToolEnum.WRENCH: 2>\ntry:\n    CookingModel(fruit='other')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for CookingModel\n    fruit\n      Input should be 'pear' or 'banana' [type=enum, input_value='other', input_type=str]\n    \"\"\"\n```", "url": "https://docs.pydantic.dev/latest/docs/api/standard_library_types/#enums", "page": "docs/api/standard_library_types", "source_site": "pydantic"}
{"title": "None types", "anchor": "none-types", "heading_level": 2, "md_text": "Supported types: [`None`][], [`NoneType`][types.NoneType] or `Literal[None]` (they are [equivalent](https://typing.readthedocs.io/en/latest/spec/special-types.html#none)).\n\nAllows only `None` as a value.", "url": "https://docs.pydantic.dev/latest/docs/api/standard_library_types/#none-types", "page": "docs/api/standard_library_types", "source_site": "pydantic"}
{"title": "Generic collection types", "anchor": "generic-collection-types", "heading_level": 2, "md_text": "Pydantic supports a wide variety of generic collection types, both built-ins (such as [`list`][]) and abstract base classes\nfrom the [`collections.abc`][] module (such as [`Sequence`][collections.abc.Sequence]).\n\nIn most cases, it is recommended to make use of the built-in types over the abstract ones. Due to [data coercion](../concepts/models.md#data-conversion),\nusing [`list`][] or [`tuple`][] will allow most other iterables as input, with better performance.\n\n!!! note \"Strictness on collection types\"\n    When applying [strict mode](../concepts/strict_mode.md) on collection types, strictness will *not* apply\n    to the inner types. This may change in the future, see [this issue](https://github.com/pydantic/pydantic/issues/12319).", "url": "https://docs.pydantic.dev/latest/docs/api/standard_library_types/#generic-collection-types", "page": "docs/api/standard_library_types", "source_site": "pydantic"}
{"title": "Lists", "anchor": "lists", "heading_level": 3, "md_text": "Built-in type: [`list`][] (deprecated alias: [`typing.List`][]).\n\n<h4>Validation</h4>\n\n* Allows [`list`][], [`tuple`][], [`set`][] and [`frozenset`][] instances, or any iterable that is *not* a\n  [string][str], [bytes][], [bytearray][], [dict][] or [mapping][]. Produces a [`list`][] instance.\n* If a generic parameter is provided, the appropriate validation is applied to all items of the list.\n\n<h4>Constraints</h4>\n\nLists support the following constraints:\n\n| Constraint   | Description                                 | JSON Schema                                                                                    |\n|--------------|---------------------------------------------|------------------------------------------------------------------------------------------------|\n| `min_length` | The list must have at least this many items | [`minItems`](https://json-schema.org/understanding-json-schema/reference/array#length) keyword |\n| `max_length` | The list must have at most this many items  | [`maxItems`](https://json-schema.org/understanding-json-schema/reference/array#length) keyword |\n\nThese constraints can be provided using the [`Field()`][pydantic.Field] function.\nThe `MinLen` and `MaxLen` metadata types from the [`annotated-types`](https://github.com/annotated-types/annotated-types)\nlibrary can also be used.\n\n<h4>Strictness</h4>\n\nIn [strict mode](../concepts/strict_mode.md), only [`list`][] instances are valid. Strict mode does *not* apply to the items of the list.\nThe strict constraint must be applied to the parameter type for this to work.\n\n<h4>Example</h4>\n\n```python\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    simple_list: Optional[list[object]] = None\n    list_of_ints: Optional[list[int]] = Field(default=None, strict=True)\n\n\nprint(Model(simple_list=('1', '2', '3')).simple_list)\n#> ['1', '2', '3']\nprint(Model(list_of_ints=['1', 2, 3]).list_of_ints)\n#> [1, 2, 3]\n```", "url": "https://docs.pydantic.dev/latest/docs/api/standard_library_types/#lists", "page": "docs/api/standard_library_types", "source_site": "pydantic"}
{"title": "Tuples", "anchor": "tuples", "heading_level": 3, "md_text": "Built-in type: [`tuple`][] (deprecated alias: [`typing.Tuple`][]).\n\n!!! note\n    [Unpacked tuple types](https://typing.python.org/en/latest/spec/generics.html#unpacking-tuple-types)\n    (as specified by [PEP 646](https://peps.python.org/pep-0646/)) are *not* yet supported, and can be\n    tracked in [this issue](https://github.com/pydantic/pydantic/issues/5952).\n\n<h4>Validation</h4>\n\n* Allows [`tuple`][], [`list`][], [`set`][] and [`frozenset`][] instances, or any iterable that is *not* a\n  [string][str], [bytes][], [bytearray][], [dict][] or [mapping][]. Produces a [`tuple`][] instance.\n* Appropriate validation is applied to items of the tuple, if [element types](https://typing.python.org/en/latest/spec/tuples.html#tuple-type-form)\n  are specified.\n\n<h4>Constraints</h4>\n\nLists support the following constraints:\n\n| Constraint   | Description                                  | JSON Schema                                                                                    |\n|--------------|----------------------------------------------|------------------------------------------------------------------------------------------------|\n| `min_length` | The tuple must have at least this many items | [`minItems`](https://json-schema.org/understanding-json-schema/reference/array#length) keyword |\n| `max_length` | The tuple must have at most this many items  | [`maxItems`](https://json-schema.org/understanding-json-schema/reference/array#length) keyword |\n\nThese constraints can be provided using the [`Field()`][pydantic.Field] function.\nThe `MinLen` and `MaxLen` metadata types from the [`annotated-types`](https://github.com/annotated-types/annotated-types)\nlibrary can also be used.\n\nAdditionally, the [`prefixItems`](https://json-schema.org/understanding-json-schema/reference/array#tupleValidation) JSON Schema keyword may be used\ndepending on the tuple shape.\n\n<h4>Strictness</h4>\n\nIn [strict mode](../concepts/strict_mode.md), only [`tuple`][] instances are valid. Strict mode does *not* apply to the items of the tuple.\nThe strict constraint must be applied to the parameter types for this to work.\n\n<h4>Example</h4>\n\n```python\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    simple_tuple: Optional[tuple] = None\n    tuple_of_different_types: Optional[tuple[int, float, bool]] = None\n\n\nprint(Model(simple_tuple=[1, 2, 3, 4]).simple_tuple)\n#> (1, 2, 3, 4)\nprint(Model(tuple_of_different_types=[3, 2, 1]).tuple_of_different_types)\n#> (3, 2.0, True)\n```\n\n<!-- old anchor added for backwards compatibility -->\n<!-- markdownlint-disable-next-line no-empty-links -->\n[](){#typingnamedtuple}", "url": "https://docs.pydantic.dev/latest/docs/api/standard_library_types/#tuples", "page": "docs/api/standard_library_types", "source_site": "pydantic"}
{"title": "Named tuples", "anchor": "named-tuples", "heading_level": 3, "md_text": "Standard library type: [`typing.NamedTuple`][] (and types created by the [`collections.namedtuple()`][collections.namedtuple] factory function\n\u2013 each field will implicitly have the type [`Any`][typing.Any]).\n\n<h4>Validation</h4>\n\n* Allows [`tuple`][] and [`list`][] instances. Validate each item according to the field definition.\n* Allows [`dict`][] instances. Keys must match the named tuple field names, and values are validated according to the field definition.\n\n<h4>Serialization</h4>\n\nIn [Python mode](../concepts/serialization.md#python-mode), named tuples are serialized as tuples. In [JSON mode](../concepts/serialization.md#json-mode),\nthey are serialized as arrays.\n\n<h4>Example</h4>\n\n```python\nfrom typing import NamedTuple\n\nfrom pydantic import BaseModel\n\n\nclass Point(NamedTuple):\n    x: int\n    y: int\n\n\nclass Model(BaseModel):\n    p: Point\n\n\nmodel = Model(p=('1', 2))\n\nprint(model.model_dump())\n#> {'p': (1, 2)}\n```", "url": "https://docs.pydantic.dev/latest/docs/api/standard_library_types/#named-tuples", "page": "docs/api/standard_library_types", "source_site": "pydantic"}
{"title": "Sets", "anchor": "sets", "heading_level": 3, "md_text": "Types: [`set`][] (or [`collections.abc.MutableSet`][]) and [`frozenset`][] (or [`collections.abc.Set`][])\n(deprecated aliases: [`typing.Set`][] and [`typing.FrozenSet`][]).\n\n<h4>Validation</h4>\n\n* Allows [`set`][], [`frozenset`][], [`tuple`][] and [`list`][] instances, or any iterable that is *not* a\n  [string][str], [bytes][], [bytearray][], [dict][] or [mapping][]. Produces a [`set`][] or [`frozenset`][] instance.\n* If a generic parameter is provided, the appropriate validation is applied to all items of the set/frozenset.\n\n<h4>Constraints</h4>\n\nSets support the following constraints:\n\n| Constraint   | Description                                | JSON Schema                                                                                    |\n|--------------|--------------------------------------------|------------------------------------------------------------------------------------------------|\n| `min_length` | The set must have at least this many items | [`minItems`](https://json-schema.org/understanding-json-schema/reference/array#length) keyword |\n| `max_length` | The set must have at most this many items  | [`maxItems`](https://json-schema.org/understanding-json-schema/reference/array#length) keyword |\n\nThese constraints can be provided using the [`Field()`][pydantic.Field] function.\nThe `MinLen` and `MaxLen` metadata types from the [`annotated-types`](https://github.com/annotated-types/annotated-types)\nlibrary can also be used.\n\n<h4>Strictness</h4>\n\nIn [strict mode](../concepts/strict_mode.md), only [`set`][]/[`frozenset`][] instances are valid. Strict mode does *not* apply to the items of the set.\nThe strict constraint must be applied to the parameter type for this to work.\n\n<h4>Serialization</h4>\n\nIn [Python mode](../concepts/serialization.md#python-mode), sets are serialized as is. In [JSON mode](../concepts/serialization.md#json-mode),\nthey are serialized as arrays.\n\n<h4>Example</h4>\n\n```python\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    simple_set: Optional[set] = None\n    set_of_ints: Optional[frozenset[int]] = None\n\n\nprint(Model(simple_set=['1', '2', '3']).simple_set)\n#> {'1', '2', '3'}\nprint(Model(set_of_ints=['1', '2', '3']).set_of_ints)\n#> frozenset({1, 2, 3})\n```", "url": "https://docs.pydantic.dev/latest/docs/api/standard_library_types/#sets", "page": "docs/api/standard_library_types", "source_site": "pydantic"}
{"title": "Deque", "anchor": "deque", "heading_level": 3, "md_text": "Standard library type: [`collections.deque`][] (deprecated alias: [`typing.Deque`][]).\n\n<h4>Validation</h4>\n\nValues are first validated as a [list](#lists), and then passed to the [`deque`][collections.deque] constructor.\n\n<h4>Constraints</h4>\n\nDeques support the following constraints:\n\n| Constraint   | Description                                  | JSON Schema                                                                                    |\n|--------------|----------------------------------------------|------------------------------------------------------------------------------------------------|\n| `min_length` | The deque must have at least this many items | [`minItems`](https://json-schema.org/understanding-json-schema/reference/array#length) keyword |\n| `max_length` | The deque must have at most this many items  | [`maxItems`](https://json-schema.org/understanding-json-schema/reference/array#length) keyword |\n\nThese constraints can be provided using the [`Field()`][pydantic.Field] function.\nThe `MinLen` and `MaxLen` metadata types from the [`annotated-types`](https://github.com/annotated-types/annotated-types)\nlibrary can also be used.\n\n<h4>Strictness</h4>\n\nIn [strict mode](../concepts/strict_mode.md), only [`deque`][collections.deque] instances are valid. Strict mode does *not* apply to the items of the deque.\nThe strict constraint must be applied to the parameter type for this to work.\n\n<h4>Serialization</h4>\n\nIn [Python mode](../concepts/serialization.md#python-mode), deques are serialized as is. In [JSON mode](../concepts/serialization.md#json-mode),\nthey are serialized as arrays.\n\n<h4>Example</h4>\n\n```python\nfrom collections import deque\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    deque: deque[int]\n\n\nprint(Model(deque=[1, 2, 3]).deque)\n#> deque([1, 2, 3])\n```\n\n<!-- old anchor added for backwards compatibility -->\n<!-- markdownlint-disable-next-line no-empty-links -->\n[](){#typingsequence}", "url": "https://docs.pydantic.dev/latest/docs/api/standard_library_types/#deque", "page": "docs/api/standard_library_types", "source_site": "pydantic"}
{"title": "Sequences", "anchor": "sequences", "heading_level": 3, "md_text": "Standard library type: [`collections.abc.Sequence`][] (deprecated alias: [`typing.Sequence`][]).\n\nIn most cases, you will want to use the built-in types (such as [list](#lists) or [tuple](#tuples)) as [type coercion](../concepts/models.md#data-conversion)\nwill apply. The [`Sequence`][collections.abc.Sequence] type can be used when you want to preserve the input type during serialization.\n\n<h4>Validation</h4>\n\nAny [`collections.abc.Sequence`][] instance (expect strings and bytes) is accepted. It is converted to a list using the [`list()`][list]\nconstructor, and then converted back to the original input type.\n\n!!! warning \"Strings aren't treated as sequences\"\n    While strings are technically valid sequence instances, this is frequently not intended as is a common source of bugs.\n\n    As a result, Pydantic will *not* accept strings and bytes for the [`Sequence`][collections.abc.Sequence] type (see example below).\n\n<h4>Constraints</h4>\n\nSequences support the following constraints:\n\n| Constraint   | Description                                     | JSON Schema                                                                                    |\n|--------------|-------------------------------------------------|------------------------------------------------------------------------------------------------|\n| `min_length` | The sequence must have at least this many items | [`minItems`](https://json-schema.org/understanding-json-schema/reference/array#length) keyword |\n| `max_length` | The sequence must have at most this many items  | [`maxItems`](https://json-schema.org/understanding-json-schema/reference/array#length) keyword |\n\nThese constraints can be provided using the [`Field()`][pydantic.Field] function.\nThe `MinLen` and `MaxLen` metadata types from the [`annotated-types`](https://github.com/annotated-types/annotated-types)\nlibrary can also be used.\n\n<h4>Serialization</h4>\n\nIn [Python mode](../concepts/serialization.md#python-mode), sequences are serialized as is. In [JSON mode](../concepts/serialization.md#json-mode),\nthey are serialized as arrays.\n\n<h4>Example</h4>\n\n```python\nfrom collections.abc import Sequence\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    sequence_of_strs: Sequence[str]\n\n\nprint(Model(sequence_of_strs=['a', 'bc']).sequence_of_strs)\n#> ['a', 'bc']\nprint(Model(sequence_of_strs=('a', 'bc')).sequence_of_strs)\n#> ('a', 'bc')\n\ntry:\n    Model(sequence_of_strs='abc')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    sequence_of_strs\n      'str' instances are not allowed as a Sequence value [type=sequence_str, input_value='abc', input_type=str]\n    \"\"\"\n```", "url": "https://docs.pydantic.dev/latest/docs/api/standard_library_types/#sequences", "page": "docs/api/standard_library_types", "source_site": "pydantic"}
{"title": "Dictionaries", "anchor": "dictionaries", "heading_level": 3, "md_text": "Built-in type: [`dict`][].\n\n<h4>Validation</h4>\n\n* [`dict`][] instances are accepted as is.\n* [mappings][mapping] instances are accepted and coerced to a [`dict`][].\n* If generic parameters for keys and values are provided, the appropriate validation is applied.\n\n<h4>Constraints</h4>\n\nDictionaries support the following constraints:\n\n| Constraint   | Description                                       | JSON Schema                                                                                    |\n|--------------|---------------------------------------------------|------------------------------------------------------------------------------------------------|\n| `min_length` | The dictionary must have at least this many items | [`minItems`](https://json-schema.org/understanding-json-schema/reference/array#length) keyword |\n| `max_length` | The dictionary must have at most this many items  | [`maxItems`](https://json-schema.org/understanding-json-schema/reference/array#length) keyword |\n\nThese constraints can be provided using the [`Field()`][pydantic.Field] function.\nThe `MinLen` and `MaxLen` metadata types from the [`annotated-types`](https://github.com/annotated-types/annotated-types)\nlibrary can also be used.\n\n<h4>Strictness</h4>\n\nIn [strict mode](../concepts/strict_mode.md), only [`dict`][] instances are valid. Strict mode does *not* apply to the keys and values of the dictionaries.\nThe strict constraint must be applied to the parameter types for this to work.\n\n<h4>Example</h4>\n\n```python\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: dict[str, int]\n\n\nm = Model(x={'foo': 1})\nprint(m.model_dump())\n#> {'x': {'foo': 1}}\n\ntry:\n    Model(x='test')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    x\n      Input should be a valid dictionary [type=dict_type, input_value='test', input_type=str]\n    \"\"\"\n```\n\n<!-- old anchor added for backwards compatibility -->\n<!-- markdownlint-disable-next-line no-empty-links -->\n[](){#typeddict}", "url": "https://docs.pydantic.dev/latest/docs/api/standard_library_types/#dictionaries", "page": "docs/api/standard_library_types", "source_site": "pydantic"}
{"title": "Typed dictionaries", "anchor": "typed-dictionaries", "heading_level": 3, "md_text": "Standard library type: [`typing.TypedDict`][] (see also: the [typing specification](https://typing.python.org/en/latest/spec/typeddict.html)).\n\n!!! note\n    Because of runtime limitations, Pydantic will require using the [`TypedDict`][typing_extensions.TypedDict] type from\n    [`typing_extensions`][] when using Python 3.12 and lower.\n\n[`TypedDict`][typing.TypedDict] declares a dictionary type that expects all of its instances to have a certain set of keys\n where each key is associated with a value of a consistent type.\n\nThis type [supports configuration](../concepts/config.md#configuration-on-other-supported-types).\n\n<h4>Strictness</h4>\n\nIn [strict mode](../concepts/strict_mode.md), only [`dict`][] instances are valid (unlike mappings in lax mode).\nStrict mode does *not* apply to the values of the typed dictionary. The strict constraint must be applied to the value types for this to work.\n\n<h4>Example</h4>\n\n```python\nfrom typing_extensions import TypedDict\n\nfrom pydantic import TypeAdapter, ValidationError\n\n\nclass User(TypedDict):\n    name: str\n    id: int\n\n\nta = TypeAdapter(User)\n\nprint(ta.validate_python({'name': 'foo', 'id': 1}))\n#> {'name': 'foo', 'id': 1}\n\ntry:\n    ta.validate_python({'name': 'foo'})\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n    id\n      Field required [type=missing, input_value={'name': 'foo'}, input_type=dict]\n    \"\"\"\n```\n\n<!-- old anchor added for backwards compatibility -->\n<!-- markdownlint-disable-next-line no-empty-links -->\n[](){#typingiterable}", "url": "https://docs.pydantic.dev/latest/docs/api/standard_library_types/#typed-dictionaries", "page": "docs/api/standard_library_types", "source_site": "pydantic"}
{"title": "Iterables", "anchor": "iterables", "heading_level": 3, "md_text": "Standard library type: [`collections.abc.Iterable`][] (deprecated alias: [`typing.Iterable`][]).\n\n<h4>Validation</h4>\n\nIterables are lazily validated, and wrapped in an internal datastructure that can be iterated over\n(and will validated the items type while doing so). This means that even if you provide a concrete\ncontainer such as a list, the validated type will *not* be of type [`list`][]. However, Pydantic\nwill ensure that the input value is iterable by getting an [iterator][] from it (by calling\n[`iter()`][iter] on the value).\n\nIt is recommended to use concrete collection types (such as [lists](#lists)) instead, unless\nyou are using an infinite iterator (in which case eagerly validating the input would result\nin an infinite loop).\n\n<h4>Example</h4>\n\n```python\nfrom collections.abc import Iterable\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    f: Iterable[str]\n\n\nm = Model(f=[1, 2])  # Validates fine\n\ntry:\n    next(m.f)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for ValidatorIterator\n    0\n      Input should be a valid string [type=string_type, input_value=1, input_type=int]\n    \"\"\"\n```", "url": "https://docs.pydantic.dev/latest/docs/api/standard_library_types/#iterables", "page": "docs/api/standard_library_types", "source_site": "pydantic"}
{"title": "Callable", "anchor": "callable", "heading_level": 2, "md_text": "Standard library type: [`collections.abc.Callable`][] (deprecated alias: [`typing.Callable`][]).\n\n<h3>Validation</h3>\n\nPydantic only validates that the input is a [callable][] (using the [`callable()`](https://docs.python.org/3/library/functions.html#callable) function).\nIt does *not* validate the number of parameters or their type, nor the type of the return value.\n\n```python\nfrom typing import Callable\n\nfrom pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    callback: Callable[[int], int]\n\n\nm = Foo(callback=lambda x: x)\nprint(m)\n#> callback=<function <lambda> at 0x0123456789ab>\n```\n\n<h3>Serialization</h3>\n\nCallables are serialized as is. Callables can't be serialized in [JSON mode](../concepts/serialization.md#json-mode)\n(a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] is raised).\n\n<!-- old anchor added for backwards compatibility -->\n<!-- markdownlint-disable-next-line no-empty-links -->\n[](){#ip-address-types}", "url": "https://docs.pydantic.dev/latest/docs/api/standard_library_types/#callable", "page": "docs/api/standard_library_types", "source_site": "pydantic"}
{"title": "IP Addresses", "anchor": "ip-addresses", "heading_level": 2, "md_text": "Standard library types:\n\n* [`ipaddress.IPv4Address`][]\n* [`ipaddress.IPv4Interface`][]\n* [`ipaddress.IPv4Network`][]\n* [`ipaddress.IPv6Address`][]\n* [`ipaddress.IPv6Interface`][]\n* [`ipaddress.IPv6Network`][]\n\nSee also: the [`IPvAnyAddress`][pydantic.networks.IPvAnyAddress], [`IPvAnyInterface`][pydantic.networks.IPvAnyInterface]\nand [`IPvAnyNetwork`][pydantic.networks.IPvAnyNetwork] Pydantic types.\n\n<h3>Validation</h3>\n\n* Instances are validated as is.\n* Other input values are passed to the constructor of the relevant address type.\n\n<h3>Strictness</h3>\n\nIn [strict mode](../concepts/strict_mode.md), only the address types are accepted.\nIn JSON mode, strict mode has no effect.\n\n<h3>Serialization</h3>\n\nIn [Python mode](../concepts/serialization.md#python-mode), IP addresses are serialized as is. In [JSON mode](../concepts/serialization.md#json-mode),\nthey are serialized as strings.", "url": "https://docs.pydantic.dev/latest/docs/api/standard_library_types/#ip-addresses", "page": "docs/api/standard_library_types", "source_site": "pydantic"}
{"title": "UUID", "anchor": "uuid", "heading_level": 2, "md_text": "Standard library type: [`uuid.UUID`][].\n\n<h3>Validation</h3>\n\n* [`UUID`][uuid.UUID] instances are validated as is.\n* Strings and bytes are validated as UUIDs, and casted to a [`UUID`][uuid.UUID] instance.\n\n<h3>Constraints</h3>\n\nThe [`UUID`][uuid.UUID] type supports a `version` constraint. The [`UuidVersion`][pydantic.types.UuidVersion] metadata type can be used.\n\nPydantic also provides the following types as convenience aliases: [`UUID1`][pydantic.types.UUID1], [`UUID3`][pydantic.types.UUID3],\n[`UUID4`][pydantic.types.UUID4], [`UUID5`][pydantic.types.UUID5], [`UUID6`][pydantic.types.UUID6], [`UUID7`][pydantic.types.UUID7],\n[`UUID8`][pydantic.types.UUID8].\n\n<h3>Strictness</h3>\n\nIn [strict mode](../concepts/strict_mode.md), only [`UUID`][uuid.UUID] instances are accepted.\nIn JSON mode, strict mode has no effect.\n\n<h3>Serialization</h3>\n\nIn [Python mode](../concepts/serialization.md#python-mode), UUIDs are serialized as is. In [JSON mode](../concepts/serialization.md#json-mode),\nthey are serialized as strings.\n\n<h3>Example</h3>\n\n```python\nfrom typing import Annotated\nfrom uuid import UUID\n\nfrom pydantic import BaseModel\nfrom pydantic.types import UUID7, UuidVersion\n\n\nclass Model(BaseModel):\n    u1: UUID7\n    u2: Annotated[UUID, UuidVersion(4)]\n\n\nprint(\n    Model(\n        u1='01999b2c-8353-749b-8dac-859307fae22b',\n        u2=UUID('125725f3-e1b4-44e3-90c3-1a20eab12da5'),\n    )\n)\n\"\"\"\nu1=UUID('01999b2c-8353-749b-8dac-859307fae22b') u2=UUID('125725f3-e1b4-44e3-90c3-1a20eab12da5')\n\"\"\"\n```", "url": "https://docs.pydantic.dev/latest/docs/api/standard_library_types/#uuid", "page": "docs/api/standard_library_types", "source_site": "pydantic"}
{"title": "Type", "anchor": "type", "heading_level": 2, "md_text": "Built-in type: [`type`][] (deprecated alias: [`typing.Type`][]).\n\n<h3>Validation</h3>\n\nAllows any type that is a subclass of the type argument. For instance, with `type[str]`, allows the [`str`][]\nclass or any [`str`][] subclass as an input. If no type argument is provided (i.e. `type` is used as an annotation),\nallow any class.\n\n<h3>Serialization</h3>\n\nTypes are serialized as is. Types can't be serialized in [JSON mode](../concepts/serialization.md#json-mode)\n(a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] is raised).\n\n```python\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Foo:\n    pass\n\n\nclass Bar(Foo):\n    pass\n\n\nclass Other:\n    pass\n\n\nclass SimpleModel(BaseModel):\n    just_subclasses: type[Foo]\n\n\nSimpleModel(just_subclasses=Foo)\nSimpleModel(just_subclasses=Bar)\ntry:\n    SimpleModel(just_subclasses=Other)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for SimpleModel\n    just_subclasses\n      Input should be a subclass of Foo [type=is_subclass_of, input_value=<class '__main__.Other'>, input_type=type]\n    \"\"\"\n```\n\n<!-- old anchor added for backwards compatibility -->\n<!-- markdownlint-disable-next-line no-empty-links -->\n[](){#typingliteral}", "url": "https://docs.pydantic.dev/latest/docs/api/standard_library_types/#type", "page": "docs/api/standard_library_types", "source_site": "pydantic"}
{"title": "Literals", "anchor": "literals", "heading_level": 2, "md_text": "Typing construct: [`typing.Literal`][] (see also: the [typing specification](https://typing.python.org/en/latest/spec/literal.html#literal)).\n\nLiterals can be used to only allow specific literal values.\n\nNote that Pydantic applies [strict mode](../concepts/strict_mode.md) behavior when validating literal values (see [this issue](https://github.com/pydantic/pydantic/issues/9991)).\n\n<h3>Example</h3>\n\n```python\nfrom typing import Literal\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Pie(BaseModel):\n    flavor: Literal['apple', 'pumpkin']\n    quantity: Literal[1, 2] = 1\n\n\nPie(flavor='apple')\nPie(flavor='pumpkin')\ntry:\n    Pie(flavor='cherry')\nexcept ValidationError as e:\n    print(str(e))\n    \"\"\"\n    1 validation error for Pie\n    flavor\n      Input should be 'apple' or 'pumpkin' [type=literal_error, input_value='cherry', input_type=str]\n    \"\"\"\n\ntry:\n    Pie(flavor='apple', quantity='1')\nexcept ValidationError as e:\n    print(str(e))\n    \"\"\"\n    1 validation error for Pie\n    quantity\n      Input should be 1 or 2 [type=literal_error, input_value='1', input_type=str]\n    \"\"\"\n```\n\n<!-- old anchor added for backwards compatibility -->\n<!-- markdownlint-disable-next-line no-empty-links -->\n[](){#typingany}", "url": "https://docs.pydantic.dev/latest/docs/api/standard_library_types/#literals", "page": "docs/api/standard_library_types", "source_site": "pydantic"}
{"title": "Any", "anchor": "any", "heading_level": 2, "md_text": "Types: [`typing.Any`][] or [`object`][].\n\nAllows any value, including `None`.\n\n<!-- old anchor added for backwards compatibility -->\n<!-- markdownlint-disable-next-line no-empty-links -->\n[](){#typinghashable}", "url": "https://docs.pydantic.dev/latest/docs/api/standard_library_types/#any", "page": "docs/api/standard_library_types", "source_site": "pydantic"}
{"title": "Hashables", "anchor": "hashables", "heading_level": 2, "md_text": "Standard library type: [`collections.abc.Hashable`][] (deprecated alias: [`typing.Hashable`][]).\n\n<h3>Validation</h3>\n\nAny value that is hashable (using `isinstance(value, Hashable)`).\n\n<!-- old anchor added for backwards compatibility -->\n<!-- markdownlint-disable-next-line no-empty-links -->\n[](){#typingpattern}", "url": "https://docs.pydantic.dev/latest/docs/api/standard_library_types/#hashables", "page": "docs/api/standard_library_types", "source_site": "pydantic"}
{"title": "Regex patterns", "anchor": "regex-patterns", "heading_level": 2, "md_text": "Standard library type: [`re.Pattern`][] (deprecated alias: [`typing.Pattern`][]).\n\n<h3>Validation</h3>\n\n* For [`Pattern`][re.Pattern] instances, check that the [`pattern`][re.Pattern.pattern] attribute\n  is of the right type ([`str`][] or [`bytes`][] depending on the [`Pattern`][re.Pattern] type\n  parameter).\n* If the type parameter is [`str`][] or [`bytes`][], input values of type [`str`][] (or [`bytes`][] respectively)\n  are attempted to be compiled using [`re.compile()`][re.compile].\n\n<h3>Serialization</h3>\n\nIn [Python mode](../concepts/serialization.md#python-mode), [`Pattern`][re.Pattern] instances are\nserialized as is.\n\nIn [JSON mode](../concepts/serialization.md#json-mode), they are serialized as strings.\n\n<!-- old anchor added for backwards compatibility -->\n<!-- markdownlint-disable-next-line no-empty-links -->\n[](){#pathlibpath}", "url": "https://docs.pydantic.dev/latest/docs/api/standard_library_types/#regex-patterns", "page": "docs/api/standard_library_types", "source_site": "pydantic"}
{"title": "Paths", "anchor": "paths", "heading_level": 2, "md_text": "Standard library types:\n\n* [`pathlib.Path`][].\n* [`pathlib.PurePath`][].\n* [`pathlib.PosixPath`][].\n* [`pathlib.PurePosixPath`][].\n* [`pathlib.PureWindowsPath`][].\n* [`os.PathLike`][] (must be parameterized with [`str`][], [`bytes`][] or [`Any`][typing.Any]).\n\n<h3>Validation</h3>\n\n* Path instances are validated as is.\n* Strings are accepted and passed to the type constructor. If [`os.PathLike`][] was used,\n  bytes are accepted if it was parameterized with the [`bytes`][] type.\n\n<h3>Strictness</h3>\n\nIn [strict mode](../concepts/strict_mode.md), only Path instances are accepted.\nIn JSON mode, strict mode has no effect.\n\n<h3>Serialization</h3>\n\nIn [Python mode](../concepts/serialization.md#python-mode), Path instances are\nserialized as is.\n\nIn [JSON mode](../concepts/serialization.md#json-mode), they are serialized as strings.", "url": "https://docs.pydantic.dev/latest/docs/api/standard_library_types/#paths", "page": "docs/api/standard_library_types", "source_site": "pydantic"}
{"title": "files", "anchor": null, "heading_level": 0, "md_text": "`pydantic` is a great tool for validating data coming from various sources.\nIn this section, we will look at how to validate data from different types of files.\n\n!!! note\n    If you're using any of the below file formats to parse configuration / settings, you might want to\n    consider using the [`pydantic-settings`][pydantic_settings] library, which offers builtin\n    support for parsing this type of data.", "url": "https://docs.pydantic.dev/latest/docs/examples/files/", "page": "docs/examples/files", "source_site": "pydantic"}
{"title": "JSON data", "anchor": "json-data", "heading_level": 2, "md_text": "`.json` files are a common way to store key / value data in a human-readable format.\nHere is an example of a `.json` file:\n\n```json\n{\n    \"name\": \"John Doe\",\n    \"age\": 30,\n    \"email\": \"john@example.com\"\n}\n```\n\nTo validate this data, we can use a `pydantic` model:\n\n```python {test=\"skip\"}\nimport pathlib\n\nfrom pydantic import BaseModel, EmailStr, PositiveInt\n\n\nclass Person(BaseModel):\n    name: str\n    age: PositiveInt\n    email: EmailStr\n\n\njson_string = pathlib.Path('person.json').read_text()\nperson = Person.model_validate_json(json_string)\nprint(person)\n#> name='John Doe' age=30 email='john@example.com'\n```\n\nIf the data in the file is not valid, `pydantic` will raise a [`ValidationError`][pydantic_core.ValidationError].\nLet's say we have the following `.json` file:\n\n```json\n{\n    \"age\": -30,\n    \"email\": \"not-an-email-address\"\n}\n```\n\nThis data is flawed for three reasons:\n\n1. It's missing the `name` field.\n2. The `age` field is negative.\n3. The `email` field is not a valid email address.\n\nWhen we try to validate this data, `pydantic` raises a [`ValidationError`][pydantic_core.ValidationError] with all of the\nabove issues:\n\n```python {test=\"skip\"}\nimport pathlib\n\nfrom pydantic import BaseModel, EmailStr, PositiveInt, ValidationError\n\n\nclass Person(BaseModel):\n    name: str\n    age: PositiveInt\n    email: EmailStr\n\n\njson_string = pathlib.Path('person.json').read_text()\ntry:\n    person = Person.model_validate_json(json_string)\nexcept ValidationError as err:\n    print(err)\n    \"\"\"\n    3 validation errors for Person\n    name\n    Field required [type=missing, input_value={'age': -30, 'email': 'not-an-email-address'}, input_type=dict]\n        For further information visit https://errors.pydantic.dev/2.10/v/missing\n    age\n    Input should be greater than 0 [type=greater_than, input_value=-30, input_type=int]\n        For further information visit https://errors.pydantic.dev/2.10/v/greater_than\n    email\n    value is not a valid email address: An email address must have an @-sign. [type=value_error, input_value='not-an-email-address', input_type=str]\n    \"\"\"\n```\n\nOften, it's the case that you have an abundance of a certain type of data within a `.json` file.\nFor example, you might have a list of people:\n\n```json\n[\n    {\n        \"name\": \"John Doe\",\n        \"age\": 30,\n        \"email\": \"john@example.com\"\n    },\n    {\n        \"name\": \"Jane Doe\",\n        \"age\": 25,\n        \"email\": \"jane@example.com\"\n    }\n]\n```\n\nIn this case, you can validate the data against a `list[Person]` model:\n\n```python {test=\"skip\"}\nimport pathlib\n\nfrom pydantic import BaseModel, EmailStr, PositiveInt, TypeAdapter\n\n\nclass Person(BaseModel):\n    name: str\n    age: PositiveInt\n    email: EmailStr\n\n\nperson_list_adapter = TypeAdapter(list[Person])  # (1)!\n\njson_string = pathlib.Path('people.json').read_text()\npeople = person_list_adapter.validate_json(json_string)\nprint(people)\n#> [Person(name='John Doe', age=30, email='john@example.com'), Person(name='Jane Doe', age=25, email='jane@example.com')]\n```\n\n1. We use [`TypeAdapter`][pydantic.type_adapter.TypeAdapter] to validate a list of `Person` objects.\n[`TypeAdapter`][pydantic.type_adapter.TypeAdapter] is a Pydantic construct used to validate data against a single type.", "url": "https://docs.pydantic.dev/latest/docs/examples/files/#json-data", "page": "docs/examples/files", "source_site": "pydantic"}
{"title": "JSON lines files", "anchor": "json-lines-files", "heading_level": 2, "md_text": "Similar to validating a list of objects from a `.json` file, you can validate a list of objects from a `.jsonl` file.\n`.jsonl` files are a sequence of JSON objects separated by newlines.\n\nConsider the following `.jsonl` file:\n\n```json\n{\"name\": \"John Doe\", \"age\": 30, \"email\": \"john@example.com\"}\n{\"name\": \"Jane Doe\", \"age\": 25, \"email\": \"jane@example.com\"}\n```\n\nWe can validate this data with a similar approach to the one we used for `.json` files:\n\n```python {test=\"skip\"}\nimport pathlib\n\nfrom pydantic import BaseModel, EmailStr, PositiveInt\n\n\nclass Person(BaseModel):\n    name: str\n    age: PositiveInt\n    email: EmailStr\n\n\njson_lines = pathlib.Path('people.jsonl').read_text().splitlines()\npeople = [Person.model_validate_json(line) for line in json_lines]\nprint(people)\n#> [Person(name='John Doe', age=30, email='john@example.com'), Person(name='Jane Doe', age=25, email='jane@example.com')]\n```", "url": "https://docs.pydantic.dev/latest/docs/examples/files/#json-lines-files", "page": "docs/examples/files", "source_site": "pydantic"}
{"title": "CSV files", "anchor": "csv-files", "heading_level": 2, "md_text": "CSV is one of the most common file formats for storing tabular data.\nTo validate data from a CSV file, you can use the `csv` module from the Python standard library to load\nthe data and validate it against a Pydantic model.\n\nConsider the following CSV file:\n\n```csv\nname,age,email\nJohn Doe,30,john@example.com\nJane Doe,25,jane@example.com\n```\n\nHere's how we validate that data:\n\n```python {test=\"skip\"}\nimport csv\n\nfrom pydantic import BaseModel, EmailStr, PositiveInt\n\n\nclass Person(BaseModel):\n    name: str\n    age: PositiveInt\n    email: EmailStr\n\n\nwith open('people.csv') as f:\n    reader = csv.DictReader(f)\n    people = [Person.model_validate(row) for row in reader]\n\nprint(people)\n#> [Person(name='John Doe', age=30, email='john@example.com'), Person(name='Jane Doe', age=25, email='jane@example.com')]\n```", "url": "https://docs.pydantic.dev/latest/docs/examples/files/#csv-files", "page": "docs/examples/files", "source_site": "pydantic"}
{"title": "TOML files", "anchor": "toml-files", "heading_level": 2, "md_text": "TOML files are often used for configuration due to their simplicity and readability.\n\nConsider the following TOML file:\n\n```toml\nname = \"John Doe\"\nage = 30\nemail = \"john@example.com\"\n```\n\nHere's how we validate that data:\n\n```python {test=\"skip\"}\nimport tomllib\n\nfrom pydantic import BaseModel, EmailStr, PositiveInt\n\n\nclass Person(BaseModel):\n    name: str\n    age: PositiveInt\n    email: EmailStr\n\n\nwith open('person.toml', 'rb') as f:\n    data = tomllib.load(f)\n\nperson = Person.model_validate(data)\nprint(person)\n#> name='John Doe' age=30 email='john@example.com'\n```", "url": "https://docs.pydantic.dev/latest/docs/examples/files/#toml-files", "page": "docs/examples/files", "source_site": "pydantic"}
{"title": "YAML files", "anchor": "yaml-files", "heading_level": 2, "md_text": "YAML (YAML Ain't Markup Language) is a human-readable data serialization format that is often used for configuration files.\n\nConsider the following YAML file:\n\n```yaml\nname: John Doe\nage: 30\nemail: john@example.com\n```\n\nHere's how we validate that data:\n\n```python {test=\"skip\"}\nimport yaml\n\nfrom pydantic import BaseModel, EmailStr, PositiveInt\n\n\nclass Person(BaseModel):\n    name: str\n    age: PositiveInt\n    email: EmailStr\n\n\nwith open('person.yaml') as f:\n    data = yaml.safe_load(f)\n\nperson = Person.model_validate(data)\nprint(person)\n#> name='John Doe' age=30 email='john@example.com'\n```", "url": "https://docs.pydantic.dev/latest/docs/examples/files/#yaml-files", "page": "docs/examples/files", "source_site": "pydantic"}
{"title": "XML files", "anchor": "xml-files", "heading_level": 2, "md_text": "XML (eXtensible Markup Language) is a markup language that defines a set of rules for encoding documents in a format that is both human-readable and machine-readable.\n\nConsider the following XML file:\n\n```xml\n<?xml version=\"1.0\"?>\n<person>\n    <name>John Doe</name>\n    <age>30</age>\n    <email>john@example.com</email>\n</person>\n```\n\nHere's how we validate that data:\n\n```python {test=\"skip\"}\nimport xml.etree.ElementTree as ET\n\nfrom pydantic import BaseModel, EmailStr, PositiveInt\n\n\nclass Person(BaseModel):\n    name: str\n    age: PositiveInt\n    email: EmailStr\n\n\ntree = ET.parse('person.xml').getroot()\ndata = {child.tag: child.text for child in tree}\nperson = Person.model_validate(data)\nprint(person)\n#> name='John Doe' age=30 email='john@example.com'\n```", "url": "https://docs.pydantic.dev/latest/docs/examples/files/#xml-files", "page": "docs/examples/files", "source_site": "pydantic"}
{"title": "INI files", "anchor": "ini-files", "heading_level": 2, "md_text": "INI files are a simple configuration file format that uses sections and key-value pairs. They are commonly used in Windows applications and older software.\n\nConsider the following INI file:\n\n```ini\n[PERSON]\nname = John Doe\nage = 30\nemail = john@example.com\n```\n\nHere's how we validate that data:\n\n```python {test=\"skip\"}\nimport configparser\n\nfrom pydantic import BaseModel, EmailStr, PositiveInt\n\n\nclass Person(BaseModel):\n    name: str\n    age: PositiveInt\n    email: EmailStr\n\n\nconfig = configparser.ConfigParser()\nconfig.read('person.ini')\nperson = Person.model_validate(config['PERSON'])\nprint(person)\n#> name='John Doe' age=30 email='john@example.com'\n```", "url": "https://docs.pydantic.dev/latest/docs/examples/files/#ini-files", "page": "docs/examples/files", "source_site": "pydantic"}
{"title": "dynamic_models", "anchor": null, "heading_level": 0, "md_text": "Models can be [created dynamically](../concepts/models.md#dynamic-model-creation) using the [`create_model()`][pydantic.create_model]\nfactory function.\n\nIn this example, we will show how to dynamically derive a model from an existing one, making every field optional. To achieve this,\nwe will make use of the [`model_fields`][pydantic.main.BaseModel.model_fields] model class attribute, and derive new annotations\nfrom the field definitions to be passed to the [`create_model()`][pydantic.create_model] factory. Of course, this example can apply\nto any use case where you need to derive a new model from another (remove default values, add aliases, etc).\n\n=== \"Python 3.9\"\n\n    ```python {lint=\"skip\" linenums=\"1\"}\n    from typing import Annotated, Union\n\n    from pydantic import BaseModel, Field, create_model\n\n\n    def make_fields_optional(model_cls: type[BaseModel]) -> type[BaseModel]:\n        new_fields = {}\n\n        for f_name, f_info in model_cls.model_fields.items():\n            f_dct = f_info.asdict()\n            new_fields[f_name] = (\n                Annotated[(Union[f_dct['annotation'], None], *f_dct['metadata'], Field(**f_dct['attributes']))],\n                None,\n            )\n\n        return create_model(\n            f'{type.__name__}Optional',\n            __base__=model_cls,  # (1)!\n            **new_fields,\n        )\n    ```\n\n    1. Using the original model as a base will inherit the [validators](../concepts/validators.md), [computed fields](../concepts/fields.md#the-computed_field-decorator), etc.\n    The parent fields are overridden by the ones we define.\n\n=== \"Python 3.10\"\n\n    ```python {lint=\"skip\" requires=\"3.10\" linenums=\"1\"}\n    from typing import Annotated\n\n    from pydantic import BaseModel, Field, create_model\n\n\n    def make_fields_optional(model_cls: type[BaseModel]) -> type[BaseModel]:\n        new_fields = {}\n\n        for f_name, f_info in model_cls.model_fields.items():\n            f_dct = f_info.asdict()\n            new_fields[f_name] = (\n                Annotated[(f_dct['annotation'] | None, *f_dct['metadata'], Field(**f_dct['attributes']))],\n                None,\n            )\n\n        return create_model(\n            f'{type.__name__}Optional',\n            __base__=model_cls,  # (1)!\n            **new_fields,\n        )\n    ```\n\n    1. Using the original model as a base will inherit the [validators](../concepts/validators.md), [computed fields](../concepts/fields.md#the-computed_field-decorator), etc.\n    The parent fields are overridden by the ones we define.\n\n=== \"Python 3.11 and above\"\n\n    ```python {lint=\"skip\" requires=\"3.11\" linenums=\"1\"}\n    from typing import Annotated\n\n    from pydantic import BaseModel, Field, create_model\n\n\n    def make_fields_optional(model_cls: type[BaseModel]) -> type[BaseModel]:\n        new_fields = {}\n\n        for f_name, f_info in model_cls.model_fields.items():\n            f_dct = f_info.asdict()\n            new_fields[f_name] = (\n                Annotated[f_dct['annotation'] | None, *f_dct['metadata'], Field(**f_dct['attributes'])],\n                None,\n            )\n\n        return create_model(\n            f'{type.__name__}Optional',\n            __base__=model_cls,  # (1)!\n            **new_fields,\n        )\n    ```\n\n    1. Using the original model as a base will inherit the [validators](../concepts/validators.md), [computed fields](../concepts/fields.md#the-computed_field-decorator), etc.\n    The parent fields are overridden by the ones we define.\n\nFor each field, we generate a dictionary representation of the [`FieldInfo`][pydantic.fields.FieldInfo] instance\nusing the [`asdict()`][pydantic.fields.FieldInfo.asdict] method, containing the annotation, metadata and attributes.\n\nWith the following model:\n\n```python {lint=\"skip\" test=\"skip\"}\nclass Model(BaseModel):\n    f: Annotated[int, Field(gt=1), WithJsonSchema({'extra': 'data'}), Field(title='F')] = 1\n```\n\nThe [`FieldInfo`][pydantic.fields.FieldInfo] instance of `f` will have three items in its dictionary representation:\n\n* `annotation`: `int`.\n* `metadata`: A list containing the type-specific constraints and other metadata: `[Gt(1), WithJsonSchema({'extra': 'data'})]`.\n* `attributes`: The remaining field-specific attributes: `{'title': 'F'}`.\n\nWith that in mind, we can recreate an annotation that \"simulates\" the one from the original model:\n\n=== \"Python 3.9 and above\"\n\n    ```python {lint=\"skip\" test=\"skip\"}\n    new_annotation = Annotated[(\n        f_dct['annotation'] | None,  # (1)!\n        *f_dct['metadata'],  # (2)!\n        Field(**f_dct['attributes']),  # (3)!\n    )]\n    ```\n\n    1. We create a new annotation from the existing one, but adding `None` as an allowed value\n       (in our previous example, this is equivalent to `int | None`).", "url": "https://docs.pydantic.dev/latest/docs/examples/dynamic_models/", "page": "docs/examples/dynamic_models", "source_site": "pydantic"}
{"title": "dynamic_models", "anchor": null, "heading_level": 0, "md_text": "    2. We unpack the metadata to be reused (in our previous example, this is equivalent to\n       specifying `Field(gt=1)` and `WithJsonSchema({'extra': 'data'})` as [`Annotated`][typing.Annotated]\n       metadata).\n\n    3. We specify the field-specific attributes by using the [`Field()`][pydantic.Field] function\n       (in our previous example, this is equivalent to `Field(title='F')`).\n\n=== \"Python 3.11 and above\"\n\n    ```python {lint=\"skip\" test=\"skip\"}\n    new_annotation = Annotated[\n        f_dct['annotation'] | None,  # (1)!\n        *f_dct['metadata'],  # (2)!\n        Field(**f_dct['attributes']),  # (3)!\n    ]\n    ```\n\n    1. We create a new annotation from the existing one, but adding `None` as an allowed value\n       (in our previous example, this is equivalent to `int | None`).\n\n    2. We unpack the metadata to be reused (in our previous example, this is equivalent to\n       specifying `Field(gt=1)` and `WithJsonSchema({'extra': 'data'})` as [`Annotated`][typing.Annotated]\n       metadata).\n\n    3. We specify the field-specific attributes by using the [`Field()`][pydantic.Field] function\n       (in our previous example, this is equivalent to `Field(title='F')`).\n\nand specify `None` as a default value (the second element of the tuple for the field definition accepted by [`create_model()`][pydantic.create_model]).\n\nHere is a demonstration of our factory function:\n\n```python {lint=\"skip\" test=\"skip\"}\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    a: Annotated[int, Field(gt=1)]\n\n\nModelOptional = make_fields_optional(Model)\n\nm = ModelOptional()\nprint(m.a)\n#> None\n```\n\nA couple notes on the implementation:\n\n* Our `make_fields_optional()` function is defined as returning an arbitrary Pydantic model class (`-> type[BaseModel]`).\n  An alternative solution can be to use a type variable to preserve the input class:\n\n    === \"Python 3.9 and above\"\n\n        ```python {lint=\"skip\" test=\"skip\"}\n        ModelTypeT = TypeVar('ModelTypeT', bound=type[BaseModel])\n\n        def make_fields_optional(model_cls: ModelTypeT) -> ModelTypeT:\n            ...\n        ```\n\n    === \"Python 3.12 and above\"\n\n        ```python {lint=\"skip\" test=\"skip\"}\n        def make_fields_optional[ModelTypeT: type[BaseModel]](model_cls: ModelTypeT) -> ModelTypeT:\n            ...\n        ```\n\n    However, note that static type checkers *won't* be able to understand that all fields are now optional.\n\n* The experimental [`MISSING` sentinel](../concepts/experimental.md#missing-sentinel) can be used as an alternative to `None`\n  for the default values. Simply replace `None` by `MISSING` in the new annotation and default value.\n\n* You might be tempted to make a copy of the original [`FieldInfo`][pydantic.fields.FieldInfo] instances, add a\n  default and/or perform other mutations, to then reuse it as [`Annotated`][typing.Annotated] metadata. While this\n  may work in some cases, it is **not** a supported pattern, and could break or be deprecated at any point. We strongly\n  encourage using the pattern from this example instead.", "url": "https://docs.pydantic.dev/latest/docs/examples/dynamic_models/", "page": "docs/examples/dynamic_models", "source_site": "pydantic"}
{"title": "custom_validators", "anchor": null, "heading_level": 0, "md_text": "This page provides example snippets for creating more complex, custom validators in Pydantic.\nMany of these examples are adapted from Pydantic issues and discussions, and are intended to showcase\nthe flexibility and power of Pydantic's validation system.", "url": "https://docs.pydantic.dev/latest/docs/examples/custom_validators/", "page": "docs/examples/custom_validators", "source_site": "pydantic"}
{"title": "Custom `datetime` Validator via [`Annotated`][typing.Annotated] Metadata", "anchor": "custom-datetime-validator-via-annotatedtypingannotated-metadata", "heading_level": 2, "md_text": "In this example, we'll construct a custom validator, attached to an [`Annotated`][typing.Annotated] type,\nthat ensures a [`datetime`][datetime.datetime] object adheres to a given timezone constraint.\n\nThe custom validator supports string specification of the timezone, and will raise an error if the [`datetime`][datetime.datetime] object does not have the correct timezone.\n\nWe use `__get_pydantic_core_schema__` in the validator to customize the schema of the annotated type (in this case, [`datetime`][datetime.datetime]), which allows us to add custom validation logic. Notably, we use a `wrap` validator function so that we can perform operations both before and after the default `pydantic` validation of a [`datetime`][datetime.datetime].\n\n```python\nimport datetime as dt\nfrom dataclasses import dataclass\nfrom pprint import pprint\nfrom typing import Annotated, Any, Callable, Optional\n\nimport pytz\nfrom pydantic_core import CoreSchema, core_schema\n\nfrom pydantic import (\n    GetCoreSchemaHandler,\n    PydanticUserError,\n    TypeAdapter,\n    ValidationError,\n)\n\n\n@dataclass(frozen=True)\nclass MyDatetimeValidator:\n    tz_constraint: Optional[str] = None\n\n    def tz_constraint_validator(\n        self,\n        value: dt.datetime,\n        handler: Callable,  # (1)!\n    ):\n        \"\"\"Validate tz_constraint and tz_info.\"\"\"\n        # handle naive datetimes\n        if self.tz_constraint is None:\n            assert (\n                value.tzinfo is None\n            ), 'tz_constraint is None, but provided value is tz-aware.'\n            return handler(value)\n\n        # validate tz_constraint and tz-aware tzinfo\n        if self.tz_constraint not in pytz.all_timezones:\n            raise PydanticUserError(\n                f'Invalid tz_constraint: {self.tz_constraint}',\n                code='unevaluable-type-annotation',\n            )\n        result = handler(value)  # (2)!\n        assert self.tz_constraint == str(\n            result.tzinfo\n        ), f'Invalid tzinfo: {str(result.tzinfo)}, expected: {self.tz_constraint}'\n\n        return result\n\n    def __get_pydantic_core_schema__(\n        self,\n        source_type: Any,\n        handler: GetCoreSchemaHandler,\n    ) -> CoreSchema:\n        return core_schema.no_info_wrap_validator_function(\n            self.tz_constraint_validator,\n            handler(source_type),\n        )\n\n\nLA = 'America/Los_Angeles'\nta = TypeAdapter(Annotated[dt.datetime, MyDatetimeValidator(LA)])\nprint(\n    ta.validate_python(dt.datetime(2023, 1, 1, 0, 0, tzinfo=pytz.timezone(LA)))\n)\n#> 2023-01-01 00:00:00-07:53\n\nLONDON = 'Europe/London'\ntry:\n    ta.validate_python(\n        dt.datetime(2023, 1, 1, 0, 0, tzinfo=pytz.timezone(LONDON))\n    )\nexcept ValidationError as ve:\n    pprint(ve.errors(), width=100)\n    \"\"\"\n    [{'ctx': {'error': AssertionError('Invalid tzinfo: Europe/London, expected: America/Los_Angeles')},\n    'input': datetime.datetime(2023, 1, 1, 0, 0, tzinfo=<DstTzInfo 'Europe/London' LMT-1 day, 23:59:00 STD>),\n    'loc': (),\n    'msg': 'Assertion failed, Invalid tzinfo: Europe/London, expected: America/Los_Angeles',\n    'type': 'assertion_error',\n    'url': 'https://errors.pydantic.dev/2.8/v/assertion_error'}]\n    \"\"\"\n```\n\n1. The `handler` function is what we call to validate the input with standard `pydantic` validation\n2. We call the `handler` function to validate the input with standard `pydantic` validation in this wrap validator\n\nWe can also enforce UTC offset constraints in a similar way.  Assuming we have a `lower_bound` and an `upper_bound`, we can create a custom validator to ensure our `datetime` has a UTC offset that is inclusive within the boundary we define:\n\n```python\nimport datetime as dt\nfrom dataclasses import dataclass\nfrom pprint import pprint\nfrom typing import Annotated, Any, Callable\n\nimport pytz\nfrom pydantic_core import CoreSchema, core_schema\n\nfrom pydantic import GetCoreSchemaHandler, TypeAdapter, ValidationError\n\n\n@dataclass(frozen=True)\nclass MyDatetimeValidator:\n    lower_bound: int\n    upper_bound: int\n\n    def validate_tz_bounds(self, value: dt.datetime, handler: Callable):\n        \"\"\"Validate and test bounds\"\"\"\n        assert value.utcoffset() is not None, 'UTC offset must exist'\n        assert self.lower_bound <= self.upper_bound, 'Invalid bounds'\n\n        result = handler(value)\n\n        hours_offset = value.utcoffset().total_seconds() / 3600\n        assert (\n            self.lower_bound <= hours_offset <= self.upper_bound\n        ), 'Value out of bounds'\n\n        return result\n\n    def __get_pydantic_core_schema__(\n        self,\n        source_type: Any,\n        handler: GetCoreSchemaHandler,\n    ) -> CoreSchema:\n        return core_schema.no_info_wrap_validator_function(\n            self.validate_tz_bounds,\n            handler(source_type),\n        )", "url": "https://docs.pydantic.dev/latest/docs/examples/custom_validators/#custom-datetime-validator-via-annotatedtypingannotated-metadata", "page": "docs/examples/custom_validators", "source_site": "pydantic"}
{"title": "Custom `datetime` Validator via [`Annotated`][typing.Annotated] Metadata", "anchor": "custom-datetime-validator-via-annotatedtypingannotated-metadata", "heading_level": 2, "md_text": "\nLA = 'America/Los_Angeles'  # UTC-7 or UTC-8\nta = TypeAdapter(Annotated[dt.datetime, MyDatetimeValidator(-10, -5)])\nprint(\n    ta.validate_python(dt.datetime(2023, 1, 1, 0, 0, tzinfo=pytz.timezone(LA)))\n)\n#> 2023-01-01 00:00:00-07:53\n\nLONDON = 'Europe/London'\ntry:\n    print(\n        ta.validate_python(\n            dt.datetime(2023, 1, 1, 0, 0, tzinfo=pytz.timezone(LONDON))\n        )\n    )\nexcept ValidationError as e:\n    pprint(e.errors(), width=100)\n    \"\"\"\n    [{'ctx': {'error': AssertionError('Value out of bounds')},\n    'input': datetime.datetime(2023, 1, 1, 0, 0, tzinfo=<DstTzInfo 'Europe/London' LMT-1 day, 23:59:00 STD>),\n    'loc': (),\n    'msg': 'Assertion failed, Value out of bounds',\n    'type': 'assertion_error',\n    'url': 'https://errors.pydantic.dev/2.8/v/assertion_error'}]\n    \"\"\"\n```", "url": "https://docs.pydantic.dev/latest/docs/examples/custom_validators/#custom-datetime-validator-via-annotatedtypingannotated-metadata", "page": "docs/examples/custom_validators", "source_site": "pydantic"}
{"title": "Validating Nested Model Fields", "anchor": "validating-nested-model-fields", "heading_level": 2, "md_text": "Here, we demonstrate two ways to validate a field of a nested model, where the validator utilizes data from the parent model.\n\nIn this example, we construct a validator that checks that each user's password is not in a list of forbidden passwords specified by the parent model.\n\nOne way to do this is to place a custom validator on the outer model:\n\n```python\nfrom typing_extensions import Self\n\nfrom pydantic import BaseModel, ValidationError, model_validator\n\n\nclass User(BaseModel):\n    username: str\n    password: str\n\n\nclass Organization(BaseModel):\n    forbidden_passwords: list[str]\n    users: list[User]\n\n    @model_validator(mode='after')\n    def validate_user_passwords(self) -> Self:\n        \"\"\"Check that user password is not in forbidden list. Raise a validation error if a forbidden password is encountered.\"\"\"\n        for user in self.users:\n            current_pw = user.password\n            if current_pw in self.forbidden_passwords:\n                raise ValueError(\n                    f'Password {current_pw} is forbidden. Please choose another password for user {user.username}.'\n                )\n        return self\n\n\ndata = {\n    'forbidden_passwords': ['123'],\n    'users': [\n        {'username': 'Spartacat', 'password': '123'},\n        {'username': 'Iceburgh', 'password': '87'},\n    ],\n}\ntry:\n    org = Organization(**data)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Organization\n      Value error, Password 123 is forbidden. Please choose another password for user Spartacat. [type=value_error, input_value={'forbidden_passwords': [...gh', 'password': '87'}]}, input_type=dict]\n    \"\"\"\n```\n\nAlternatively, a custom validator can be used in the nested model class (`User`), with the forbidden passwords data from the parent model being passed in via validation context.\n\n!!! warning\n    The ability to mutate the context within a validator adds a lot of power to nested validation, but can also lead to confusing or hard-to-debug code. Use this approach at your own risk!\n\n```python\nfrom pydantic import BaseModel, ValidationError, ValidationInfo, field_validator\n\n\nclass User(BaseModel):\n    username: str\n    password: str\n\n    @field_validator('password', mode='after')\n    @classmethod\n    def validate_user_passwords(\n        cls, password: str, info: ValidationInfo\n    ) -> str:\n        \"\"\"Check that user password is not in forbidden list.\"\"\"\n        forbidden_passwords = (\n            info.context.get('forbidden_passwords', []) if info.context else []\n        )\n        if password in forbidden_passwords:\n            raise ValueError(f'Password {password} is forbidden.')\n        return password\n\n\nclass Organization(BaseModel):\n    forbidden_passwords: list[str]\n    users: list[User]\n\n    @field_validator('forbidden_passwords', mode='after')\n    @classmethod\n    def add_context(cls, v: list[str], info: ValidationInfo) -> list[str]:\n        if info.context is not None:\n            info.context.update({'forbidden_passwords': v})\n        return v\n\n\ndata = {\n    'forbidden_passwords': ['123'],\n    'users': [\n        {'username': 'Spartacat', 'password': '123'},\n        {'username': 'Iceburgh', 'password': '87'},\n    ],\n}\n\ntry:\n    org = Organization.model_validate(data, context={})\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Organization\n    users.0.password\n      Value error, Password 123 is forbidden. [type=value_error, input_value='123', input_type=str]\n    \"\"\"\n```\n\nNote that if the context property is not included in `model_validate`, then `info.context` will be `None` and the forbidden passwords list will not get added to the context in the above implementation. As such, `validate_user_passwords` would not carry out the desired password validation.\n\nMore details about validation context can be found in the [validators documentation](../concepts/validators.md#validation-context).", "url": "https://docs.pydantic.dev/latest/docs/examples/custom_validators/#validating-nested-model-fields", "page": "docs/examples/custom_validators", "source_site": "pydantic"}
{"title": "requests", "anchor": null, "heading_level": 0, "md_text": "Pydantic models are a great way to validate and serialize data for requests and responses.\nPydantic is instrumental in many web frameworks and libraries, such as FastAPI, Django, Flask, and HTTPX.", "url": "https://docs.pydantic.dev/latest/docs/examples/requests/", "page": "docs/examples/requests", "source_site": "pydantic"}
{"title": "`httpx` requests", "anchor": "httpx-requests", "heading_level": 2, "md_text": "[`httpx`](https://www.python-httpx.org/) is an HTTP client for Python 3 with synchronous and asynchronous APIs.\nIn the below example, we query the [JSONPlaceholder API](https://jsonplaceholder.typicode.com/) to get a user's data and validate it with a Pydantic model.\n\n```python {test=\"skip\"}\nimport httpx\n\nfrom pydantic import BaseModel, EmailStr\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    email: EmailStr\n\n\nurl = 'https://jsonplaceholder.typicode.com/users/1'\n\nresponse = httpx.get(url)\nresponse.raise_for_status()\n\nuser = User.model_validate(response.json())\nprint(repr(user))\n#> User(id=1, name='Leanne Graham', email='Sincere@april.biz')\n```\n\nThe [`TypeAdapter`][pydantic.type_adapter.TypeAdapter] tool from Pydantic often comes in quite\nhandy when working with HTTP requests. Consider a similar example where we are validating a list of users:\n\n```python {test=\"skip\"}\nfrom pprint import pprint\n\nimport httpx\n\nfrom pydantic import BaseModel, EmailStr, TypeAdapter\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    email: EmailStr\n\n\nurl = 'https://jsonplaceholder.typicode.com/users/'  # (1)!\n\nresponse = httpx.get(url)\nresponse.raise_for_status()\n\nusers_list_adapter = TypeAdapter(list[User])\n\nusers = users_list_adapter.validate_python(response.json())\npprint([u.name for u in users])\n\"\"\"\n['Leanne Graham',\n 'Ervin Howell',\n 'Clementine Bauch',\n 'Patricia Lebsack',\n 'Chelsey Dietrich',\n 'Mrs. Dennis Schulist',\n 'Kurtis Weissnat',\n 'Nicholas Runolfsdottir V',\n 'Glenna Reichert',\n 'Clementina DuBuque']\n\"\"\"\n```\n\n1. Note, we're querying the `/users/` endpoint here to get a list of users.\n\n<!-- TODO: httpx, flask, Django rest framework, FastAPI -->", "url": "https://docs.pydantic.dev/latest/docs/examples/requests/#httpx-requests", "page": "docs/examples/requests", "source_site": "pydantic"}
{"title": "orms", "anchor": null, "heading_level": 0, "md_text": "Pydantic serves as a great tool for defining models for ORM (object relational mapping) libraries.\nORMs are used to map objects to database tables, and vice versa.", "url": "https://docs.pydantic.dev/latest/docs/examples/orms/", "page": "docs/examples/orms", "source_site": "pydantic"}
{"title": "SQLAlchemy", "anchor": "sqlalchemy", "heading_level": 2, "md_text": "Pydantic can pair with SQLAlchemy, as it can be used to define the schema of the database models.\n\n!!! warning \"Code Duplication\"\n    If you use Pydantic with SQLAlchemy, you might experience some frustration with code duplication.\n    If you find yourself experiencing this difficulty, you might also consider [`SQLModel`](https://sqlmodel.tiangolo.com/) which integrates Pydantic with SQLAlchemy such that much of the code duplication is eliminated.\n\nIf you'd prefer to use pure Pydantic with SQLAlchemy, we recommend using Pydantic models alongside of SQLAlchemy models\nas shown in the example below. In this case, we take advantage of Pydantic's aliases feature to name a `Column` after a reserved SQLAlchemy field, thus avoiding conflicts.\n\n```python\nimport sqlalchemy as sa\nfrom sqlalchemy.orm import declarative_base\n\nfrom pydantic import BaseModel, ConfigDict, Field\n\n\nclass MyModel(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n\n    metadata: dict[str, str] = Field(alias='metadata_')\n\n\nBase = declarative_base()\n\n\nclass MyTableModel(Base):\n    __tablename__ = 'my_table'\n    id = sa.Column('id', sa.Integer, primary_key=True)\n    # 'metadata' is reserved by SQLAlchemy, hence the '_'\n    metadata_ = sa.Column('metadata', sa.JSON)\n\n\nsql_model = MyTableModel(metadata_={'key': 'val'}, id=1)\npydantic_model = MyModel.model_validate(sql_model)\n\nprint(pydantic_model.model_dump())\n#> {'metadata': {'key': 'val'}}\nprint(pydantic_model.model_dump(by_alias=True))\n#> {'metadata_': {'key': 'val'}}\n```\n\n!!! note\n    The example above works because aliases have priority over field names for\n    field population. Accessing `SQLModel`'s `metadata` attribute would lead to a `ValidationError`.\n\n<!-- TODO: add examples for Django with Pydantic models -->", "url": "https://docs.pydantic.dev/latest/docs/examples/orms/#sqlalchemy", "page": "docs/examples/orms", "source_site": "pydantic"}
{"title": "queues", "anchor": null, "heading_level": 0, "md_text": "Pydantic is quite helpful for validating data that goes into and comes out of queues. Below,\nwe'll explore how to validate / serialize data with various queue systems.", "url": "https://docs.pydantic.dev/latest/docs/examples/queues/", "page": "docs/examples/queues", "source_site": "pydantic"}
{"title": "Redis queue", "anchor": "redis-queue", "heading_level": 2, "md_text": "Redis is a popular in-memory data structure store.\n\nIn order to run this example locally, you'll first need to [install Redis](https://redis.io/docs/latest/operate/oss_and_stack/install/install-redis/)\nand start your server up locally.\n\nHere's a simple example of how you can use Pydantic to:\n\n1. Serialize data to push to the queue\n2. Deserialize and validate data when it's popped from the queue\n\n```python {test=\"skip\"}\nimport redis\n\nfrom pydantic import BaseModel, EmailStr\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    email: EmailStr\n\n\nr = redis.Redis(host='localhost', port=6379, db=0)\nQUEUE_NAME = 'user_queue'\n\n\ndef push_to_queue(user_data: User) -> None:\n    serialized_data = user_data.model_dump_json()\n    r.rpush(QUEUE_NAME, serialized_data)\n    print(f'Added to queue: {serialized_data}')\n\n\nuser1 = User(id=1, name='John Doe', email='john@example.com')\nuser2 = User(id=2, name='Jane Doe', email='jane@example.com')\n\npush_to_queue(user1)\n#> Added to queue: {\"id\":1,\"name\":\"John Doe\",\"email\":\"john@example.com\"}\n\npush_to_queue(user2)\n#> Added to queue: {\"id\":2,\"name\":\"Jane Doe\",\"email\":\"jane@example.com\"}\n\n\ndef pop_from_queue() -> None:\n    data = r.lpop(QUEUE_NAME)\n\n    if data:\n        user = User.model_validate_json(data)\n        print(f'Validated user: {repr(user)}')\n    else:\n        print('Queue is empty')\n\n\npop_from_queue()\n#> Validated user: User(id=1, name='John Doe', email='john@example.com')\n\npop_from_queue()\n#> Validated user: User(id=2, name='Jane Doe', email='jane@example.com')\n\npop_from_queue()\n#> Queue is empty\n```", "url": "https://docs.pydantic.dev/latest/docs/examples/queues/#redis-queue", "page": "docs/examples/queues", "source_site": "pydantic"}
{"title": "RabbitMQ", "anchor": "rabbitmq", "heading_level": 2, "md_text": "RabbitMQ is a popular message broker that implements the AMQP protocol.\n\nIn order to run this example locally, you'll first need to [install RabbitMQ](https://www.rabbitmq.com/download.html) and start your server.\n\nHere's a simple example of how you can use Pydantic to:\n\n1. Serialize data to push to the queue\n2. Deserialize and validate data when it's popped from the queue\n\nFirst, let's create a sender script.\n\n```python {test=\"skip\"}\nimport pika\n\nfrom pydantic import BaseModel, EmailStr\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    email: EmailStr\n\n\nconnection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))\nchannel = connection.channel()\nQUEUE_NAME = 'user_queue'\nchannel.queue_declare(queue=QUEUE_NAME)\n\n\ndef push_to_queue(user_data: User) -> None:\n    serialized_data = user_data.model_dump_json()\n    channel.basic_publish(\n        exchange='',\n        routing_key=QUEUE_NAME,\n        body=serialized_data,\n    )\n    print(f'Added to queue: {serialized_data}')\n\n\nuser1 = User(id=1, name='John Doe', email='john@example.com')\nuser2 = User(id=2, name='Jane Doe', email='jane@example.com')\n\npush_to_queue(user1)\n#> Added to queue: {\"id\":1,\"name\":\"John Doe\",\"email\":\"john@example.com\"}\n\npush_to_queue(user2)\n#> Added to queue: {\"id\":2,\"name\":\"Jane Doe\",\"email\":\"jane@example.com\"}\n\nconnection.close()\n```\n\nAnd here's the receiver script.\n\n```python {test=\"skip\"}\nimport pika\n\nfrom pydantic import BaseModel, EmailStr\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    email: EmailStr\n\n\ndef main():\n    connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))\n    channel = connection.channel()\n    QUEUE_NAME = 'user_queue'\n    channel.queue_declare(queue=QUEUE_NAME)\n\n    def process_message(\n        ch: pika.channel.Channel,\n        method: pika.spec.Basic.Deliver,\n        properties: pika.spec.BasicProperties,\n        body: bytes,\n    ):\n        user = User.model_validate_json(body)\n        print(f'Validated user: {repr(user)}')\n        ch.basic_ack(delivery_tag=method.delivery_tag)\n\n    channel.basic_consume(queue=QUEUE_NAME, on_message_callback=process_message)\n    channel.start_consuming()\n\n\nif __name__ == '__main__':\n    try:\n        main()\n    except KeyboardInterrupt:\n        pass\n```\n\nTo test this example:\n\n1. Run the receiver script in one terminal to start the consumer.\n2. Run the sender script in another terminal to send messages.", "url": "https://docs.pydantic.dev/latest/docs/examples/queues/#rabbitmq", "page": "docs/examples/queues", "source_site": "pydantic"}
{"title": "ARQ", "anchor": "arq", "heading_level": 2, "md_text": "ARQ is a fast Redis-based job queue for Python.\nIt's built on top of Redis and provides a simple way to handle background tasks.\n\nIn order to run this example locally, you\u2019ll need to [Install Redis](https://redis.io/docs/latest/operate/oss_and_stack/install/install-redis/) and start your server.\n\nHere's a simple example of how you can use Pydantic with ARQ to:\n\n1. Define a model for your job data\n2. Serialize data when enqueueing jobs\n3. Validate and deserialize data when processing jobs\n\n```python {test=\"skip\"}\nimport asyncio\nfrom typing import Any\n\nfrom arq import create_pool\nfrom arq.connections import RedisSettings\n\nfrom pydantic import BaseModel, EmailStr\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    email: EmailStr\n\n\nREDIS_SETTINGS = RedisSettings()\n\n\nasync def process_user(ctx: dict[str, Any], user_data: dict[str, Any]) -> None:\n    user = User.model_validate(user_data)\n    print(f'Processing user: {repr(user)}')\n\n\nasync def enqueue_jobs(redis):\n    user1 = User(id=1, name='John Doe', email='john@example.com')\n    user2 = User(id=2, name='Jane Doe', email='jane@example.com')\n\n    await redis.enqueue_job('process_user', user1.model_dump())\n    print(f'Enqueued user: {repr(user1)}')\n\n    await redis.enqueue_job('process_user', user2.model_dump())\n    print(f'Enqueued user: {repr(user2)}')\n\n\nclass WorkerSettings:\n    functions = [process_user]\n    redis_settings = REDIS_SETTINGS\n\n\nasync def main():\n    redis = await create_pool(REDIS_SETTINGS)\n    await enqueue_jobs(redis)\n\n\nif __name__ == '__main__':\n    asyncio.run(main())\n```\n\nThis script is complete.\nIt should run \"as is\" both to enqueue jobs and to process them.\n<!-- TODO: kafka, celery, etc - better for SEO, great for new contributors! -->", "url": "https://docs.pydantic.dev/latest/docs/examples/queues/#arq", "page": "docs/examples/queues", "source_site": "pydantic"}
{"title": "types", "anchor": null, "heading_level": 0, "md_text": "Pydantic uses types to define how validation and serialization should be performed.\n[Built-in and standard library types](../api/standard_library_types.md) (such as [`int`][],\n[`str`][], [`date`][datetime.date]) can be used as is. [Strictness](./strict_mode.md)\ncan be controlled and constraints can be applied on them.\n\nOn top of these, Pydantic provides extra types, either [directly in the library](../api/types.md)\n(e.g. [`SecretStr`][pydantic.types.SecretStr]) or in the [`pydantic-extra-types`](https://github.com/pydantic/pydantic-extra-types)\nexternal library. These are implemented using the patterns described in the [custom types](#custom-types) section.\nStrictness and constraints *can't* be applied on them.\n\nThe [built-in and standard library types](../api/standard_library_types.md) documentation goes over\nthe supported types: the allowed values, the possible validation constraints, and whether [strictness](./strict_mode.md)\ncan be configured.\n\nSee also the [conversion table](../concepts/conversion_table.md) for a summary of the allowed values for each type.\n\nThis page will go over defining your own custom types.", "url": "https://docs.pydantic.dev/latest/docs/concepts/types/", "page": "docs/concepts/types", "source_site": "pydantic"}
{"title": "Custom Types", "anchor": "custom-types", "heading_level": 2, "md_text": "There are several ways to define your custom types.", "url": "https://docs.pydantic.dev/latest/docs/concepts/types/#custom-types", "page": "docs/concepts/types", "source_site": "pydantic"}
{"title": "Using the annotated pattern", "anchor": "using-the-annotated-pattern", "heading_level": 3, "md_text": "The [annotated pattern](./fields.md#the-annotated-pattern) can be used to make types reusable across your code base.\nFor example, to create a type representing a positive integer:\n\n```python\nfrom typing import Annotated\n\nfrom pydantic import Field, TypeAdapter, ValidationError\n\nPositiveInt = Annotated[int, Field(gt=0)]  # (1)!\n\nta = TypeAdapter(PositiveInt)\n\nprint(ta.validate_python(1))\n#> 1\n\ntry:\n    ta.validate_python(-1)\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for constrained-int\n      Input should be greater than 0 [type=greater_than, input_value=-1, input_type=int]\n    \"\"\"\n```\n\n1. Note that you can also use constraints from the [annotated-types](https://github.com/annotated-types/annotated-types)\n  library to make this Pydantic-agnostic:\n\n    ```python {test=\"skip\" lint=\"skip\"}\n    from annotated_types import Gt\n\n    PositiveInt = Annotated[int, Gt(0)]\n    ```", "url": "https://docs.pydantic.dev/latest/docs/concepts/types/#using-the-annotated-pattern", "page": "docs/concepts/types", "source_site": "pydantic"}
{"title": "Adding validation and serialization", "anchor": "adding-validation-and-serialization", "heading_level": 4, "md_text": "You can add or override validation, serialization, and JSON schemas to an arbitrary type using the markers that\nPydantic exports:\n\n```python\nfrom typing import Annotated\n\nfrom pydantic import (\n    AfterValidator,\n    PlainSerializer,\n    TypeAdapter,\n    WithJsonSchema,\n)\n\nTruncatedFloat = Annotated[\n    float,\n    AfterValidator(lambda x: round(x, 1)),\n    PlainSerializer(lambda x: f'{x:.1e}', return_type=str),\n    WithJsonSchema({'type': 'string'}, mode='serialization'),\n]\n\n\nta = TypeAdapter(TruncatedFloat)\n\ninput = 1.02345\nassert input != 1.0\n\nassert ta.validate_python(input) == 1.0\n\nassert ta.dump_json(input) == b'\"1.0e+00\"'\n\nassert ta.json_schema(mode='validation') == {'type': 'number'}\nassert ta.json_schema(mode='serialization') == {'type': 'string'}\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/types/#adding-validation-and-serialization", "page": "docs/concepts/types", "source_site": "pydantic"}
{"title": "Generics", "anchor": "generics", "heading_level": 4, "md_text": "[Type variables][typing.TypeVar] can be used within the [`Annotated`][typing.Annotated] type:\n\n```python\nfrom typing import Annotated, TypeVar\n\nfrom annotated_types import Gt, Len\n\nfrom pydantic import TypeAdapter, ValidationError\n\nT = TypeVar('T')\n\n\nShortList = Annotated[list[T], Len(max_length=4)]\n\n\nta = TypeAdapter(ShortList[int])\n\nv = ta.validate_python([1, 2, 3, 4])\nassert v == [1, 2, 3, 4]\n\ntry:\n    ta.validate_python([1, 2, 3, 4, 5])\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for list[int]\n      List should have at most 4 items after validation, not 5 [type=too_long, input_value=[1, 2, 3, 4, 5], input_type=list]\n    \"\"\"\n\n\nPositiveList = list[Annotated[T, Gt(0)]]\n\nta = TypeAdapter(PositiveList[float])\n\nv = ta.validate_python([1.0])\nassert type(v[0]) is float\n\n\ntry:\n    ta.validate_python([-1.0])\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for list[constrained-float]\n    0\n      Input should be greater than 0 [type=greater_than, input_value=-1.0, input_type=float]\n    \"\"\"\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/types/#generics", "page": "docs/concepts/types", "source_site": "pydantic"}
{"title": "Named type aliases", "anchor": "named-type-aliases", "heading_level": 3, "md_text": "The above examples make use of *implicit* type aliases, assigned to a variable. At runtime, Pydantic\nhas no way of knowing the name of the variable it was assigned to, and this can be problematic for\ntwo reasons:\n\n* The [JSON Schema](./json_schema.md) of the alias won't be converted into a\n  [definition](https://json-schema.org/understanding-json-schema/structuring#defs).\n  This is mostly useful when you are using the alias more than once in a model definition.\n* In most cases, [recursive type aliases](#named-recursive-types) won't work.\n\nBy leveraging the new [`type` statement](https://typing.readthedocs.io/en/latest/spec/aliases.html#type-statement)\n(introduced in [PEP 695](https://peps.python.org/pep-0695/)), you can define aliases as follows:\n\n=== \"Python 3.9 and above\"\n\n    ```python\n    from typing import Annotated\n\n    from annotated_types import Gt\n    from typing_extensions import TypeAliasType\n\n    from pydantic import BaseModel\n\n    PositiveIntList = TypeAliasType('PositiveIntList', list[Annotated[int, Gt(0)]])\n\n\n    class Model(BaseModel):\n        x: PositiveIntList\n        y: PositiveIntList\n\n\n    print(Model.model_json_schema())  # (1)!\n    \"\"\"\n    {\n        '$defs': {\n            'PositiveIntList': {\n                'items': {'exclusiveMinimum': 0, 'type': 'integer'},\n                'type': 'array',\n            }\n        },\n        'properties': {\n            'x': {'$ref': '#/$defs/PositiveIntList'},\n            'y': {'$ref': '#/$defs/PositiveIntList'},\n        },\n        'required': ['x', 'y'],\n        'title': 'Model',\n        'type': 'object',\n    }\n    \"\"\"\n    ```\n\n    1. If `PositiveIntList` were to be defined as an implicit type alias, its definition\n       would have been duplicated in both `'x'` and `'y'`.\n\n=== \"Python 3.12 and above (new syntax)\"\n\n    ```python {requires=\"3.12\" upgrade=\"skip\" lint=\"skip\"}\n    from typing import Annotated\n\n    from annotated_types import Gt\n\n    from pydantic import BaseModel\n\n    type PositiveIntList = list[Annotated[int, Gt(0)]]\n\n\n    class Model(BaseModel):\n        x: PositiveIntList\n        y: PositiveIntList\n\n\n    print(Model.model_json_schema())  # (1)!\n    \"\"\"\n    {\n        '$defs': {\n            'PositiveIntList': {\n                'items': {'exclusiveMinimum': 0, 'type': 'integer'},\n                'type': 'array',\n            }\n        },\n        'properties': {\n            'x': {'$ref': '#/$defs/PositiveIntList'},\n            'y': {'$ref': '#/$defs/PositiveIntList'},\n        },\n        'required': ['x', 'y'],\n        'title': 'Model',\n        'type': 'object',\n    }\n    \"\"\"\n    ```\n\n    1. If `PositiveIntList` were to be defined as an implicit type alias, its definition\n       would have been duplicated in both `'x'` and `'y'`.\n\n<!-- markdownlint-disable-next-line no-empty-links -->\n[](){#metadata-type-alias-warning}\n\n!!! warning \"When to use named type aliases\"\n\n    While (named) PEP 695 and implicit type aliases are meant to be equivalent for static type checkers,\n    Pydantic will *not* understand field-specific metadata inside named aliases. That is, metadata such as\n    `alias`, `default`, `deprecated`, *cannot* be used:\n\n    === \"Python 3.9 and above\"\n\n        ```python {test=\"skip\"}\n        from typing import Annotated\n\n        from typing_extensions import TypeAliasType\n\n        from pydantic import BaseModel, Field\n\n        MyAlias = TypeAliasType('MyAlias', Annotated[int, Field(default=1)])\n\n\n        class Model(BaseModel):\n            x: MyAlias  # This is not allowed\n        ```\n\n    === \"Python 3.12 and above (new syntax)\"\n\n        ```python {requires=\"3.12\" upgrade=\"skip\" lint=\"skip\" test=\"skip\"}\n        from typing import Annotated\n\n        from pydantic import BaseModel, Field\n\n        type MyAlias = Annotated[int, Field(default=1)]\n\n\n        class Model(BaseModel):\n            x: MyAlias  # This is not allowed\n        ```\n\n    Only metadata that can be applied to the annotated type itself is allowed\n    (e.g. [validation constraints](./fields.md#field-constraints) and JSON metadata).\n    Trying to support field-specific metadata would require eagerly inspecting the\n    type alias's [`__value__`][typing.TypeAliasType.__value__], and as such Pydantic\n    wouldn't be able to have the alias stored as a JSON Schema definition.\n\n!!! note\n    As with implicit type aliases, [type variables][typing.TypeVar] can also be used inside the generic alias:\n\n    === \"Python 3.9 and above\"\n\n        ```python\n        from typing import Annotated, TypeVar\n\n        from annotated_types import Len\n        from typing_extensions import TypeAliasType\n\n        T = TypeVar('T')\n\n        ShortList = TypeAliasType(\n            'ShortList', Annotated[list[T], Len(max_length=4)], type_params=(T,)\n        )\n        ```\n\n    === \"Python 3.12 and above (new syntax)\"\n\n        ```python {requires=\"3.12\" upgrade=\"skip\" lint=\"skip\"}\n        from typing import Annotated, TypeVar\n\n        from annotated_types import Len", "url": "https://docs.pydantic.dev/latest/docs/concepts/types/#named-type-aliases", "page": "docs/concepts/types", "source_site": "pydantic"}
{"title": "Named type aliases", "anchor": "named-type-aliases", "heading_level": 3, "md_text": "        type ShortList[T] = Annotated[list[T], Len(max_length=4)]\n        ```", "url": "https://docs.pydantic.dev/latest/docs/concepts/types/#named-type-aliases", "page": "docs/concepts/types", "source_site": "pydantic"}
{"title": "Named recursive types", "anchor": "named-recursive-types", "heading_level": 4, "md_text": "Named type aliases should be used whenever you need to define recursive type aliases (1).\n{ .annotate }\n\n1. For several reasons, Pydantic isn't able to support implicit recursive aliases. For\n   instance, it won't be able to resolve [forward annotations](./forward_annotations.md)\n   across modules.\n\nFor instance, here is an example definition of a JSON type:\n\n=== \"Python 3.9 and above\"\n\n    ```python\n    from typing import Union\n\n    from typing_extensions import TypeAliasType\n\n    from pydantic import TypeAdapter\n\n    Json = TypeAliasType(\n        'Json',\n        'Union[dict[str, Json], list[Json], str, int, float, bool, None]',  # (1)!\n    )\n\n    ta = TypeAdapter(Json)\n    print(ta.json_schema())\n    \"\"\"\n    {\n        '$defs': {\n            'Json': {\n                'anyOf': [\n                    {\n                        'additionalProperties': {'$ref': '#/$defs/Json'},\n                        'type': 'object',\n                    },\n                    {'items': {'$ref': '#/$defs/Json'}, 'type': 'array'},\n                    {'type': 'string'},\n                    {'type': 'integer'},\n                    {'type': 'number'},\n                    {'type': 'boolean'},\n                    {'type': 'null'},\n                ]\n            }\n        },\n        '$ref': '#/$defs/Json',\n    }\n    \"\"\"\n    ```\n\n    1. Wrapping the annotation in quotes is necessary as it is eagerly evaluated\n       (and `Json` has yet to be defined).\n\n=== \"Python 3.12 and above (new syntax)\"\n\n    ```python {requires=\"3.12\" upgrade=\"skip\" lint=\"skip\"}\n    from pydantic import TypeAdapter\n\n    type Json = dict[str, Json] | list[Json] | str | int | float | bool | None  # (1)!\n\n    ta = TypeAdapter(Json)\n    print(ta.json_schema())\n    \"\"\"\n    {\n        '$defs': {\n            'Json': {\n                'anyOf': [\n                    {\n                        'additionalProperties': {'$ref': '#/$defs/Json'},\n                        'type': 'object',\n                    },\n                    {'items': {'$ref': '#/$defs/Json'}, 'type': 'array'},\n                    {'type': 'string'},\n                    {'type': 'integer'},\n                    {'type': 'number'},\n                    {'type': 'boolean'},\n                    {'type': 'null'},\n                ]\n            }\n        },\n        '$ref': '#/$defs/Json',\n    }\n    \"\"\"\n    ```\n\n    1. The value of a named type alias is lazily evaluated, so there's no need to use forward annotations.\n\n!!! tip\n    Pydantic defines a [`JsonValue`][pydantic.types.JsonValue] type as a convenience.", "url": "https://docs.pydantic.dev/latest/docs/concepts/types/#named-recursive-types", "page": "docs/concepts/types", "source_site": "pydantic"}
{"title": "Customizing validation with `__get_pydantic_core_schema__` <a name=\"customizing_validation_with_get_pydantic_core_schema\"></a>", "anchor": "customizing-validation-with-__get_pydantic_core_schema__-a-namecustomizing_validation_with_get_pydantic_core_schemaa", "heading_level": 3, "md_text": "To do more extensive customization of how Pydantic handles custom classes, and in particular when you have access to the\nclass or can subclass it, you can implement a special `__get_pydantic_core_schema__` to tell Pydantic how to generate the\n`pydantic-core` schema.\n\nWhile `pydantic` uses `pydantic-core` internally to handle validation and serialization, it is a new API for Pydantic V2,\nthus it is one of the areas most likely to be tweaked in the future and you should try to stick to the built-in\nconstructs like those provided by `annotated-types`, `pydantic.Field`, or `BeforeValidator` and so on.\n\nYou can implement `__get_pydantic_core_schema__` both on a custom type and on metadata intended to be put in `Annotated`.\nIn both cases the API is middleware-like and similar to that of \"wrap\" validators: you get a `source_type` (which isn't\nnecessarily the same as the class, in particular for generics) and a `handler` that you can call with a type to either\ncall the next metadata in `Annotated` or call into Pydantic's internal schema generation.\n\nThe simplest no-op implementation calls the handler with the type you are given, then returns that as the result. You can\nalso choose to modify the type before calling the handler, modify the core schema returned by the handler, or not call the\nhandler at all.", "url": "https://docs.pydantic.dev/latest/docs/concepts/types/#customizing-validation-with-__get_pydantic_core_schema__-a-namecustomizing_validation_with_get_pydantic_core_schemaa", "page": "docs/concepts/types", "source_site": "pydantic"}
{"title": "As a method on a custom type", "anchor": "as-a-method-on-a-custom-type", "heading_level": 4, "md_text": "The following is an example of a type that uses `__get_pydantic_core_schema__` to customize how it gets validated.\nThis is equivalent to implementing `__get_validators__` in Pydantic V1.\n\n```python\nfrom typing import Any\n\nfrom pydantic_core import CoreSchema, core_schema\n\nfrom pydantic import GetCoreSchemaHandler, TypeAdapter\n\n\nclass Username(str):\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source_type: Any, handler: GetCoreSchemaHandler\n    ) -> CoreSchema:\n        return core_schema.no_info_after_validator_function(cls, handler(str))\n\n\nta = TypeAdapter(Username)\nres = ta.validate_python('abc')\nassert isinstance(res, Username)\nassert res == 'abc'\n```\n\nSee [JSON Schema](../concepts/json_schema.md) for more details on how to customize JSON schemas for custom types.", "url": "https://docs.pydantic.dev/latest/docs/concepts/types/#as-a-method-on-a-custom-type", "page": "docs/concepts/types", "source_site": "pydantic"}
{"title": "As an annotation", "anchor": "as-an-annotation", "heading_level": 4, "md_text": "Often you'll want to parametrize your custom type by more than just generic type parameters (which you can do via the type system and will be discussed later). Or you may not actually care (or want to) make an instance of your subclass; you actually want the original type, just with some extra validation done.\n\nFor example, if you were to implement `pydantic.AfterValidator` (see [Adding validation and serialization](#adding-validation-and-serialization)) yourself, you'd do something similar to the following:\n\n```python\nfrom dataclasses import dataclass\nfrom typing import Annotated, Any, Callable\n\nfrom pydantic_core import CoreSchema, core_schema\n\nfrom pydantic import BaseModel, GetCoreSchemaHandler\n\n\n@dataclass(frozen=True)  # (1)!\nclass MyAfterValidator:\n    func: Callable[[Any], Any]\n\n    def __get_pydantic_core_schema__(\n        self, source_type: Any, handler: GetCoreSchemaHandler\n    ) -> CoreSchema:\n        return core_schema.no_info_after_validator_function(\n            self.func, handler(source_type)\n        )\n\n\nUsername = Annotated[str, MyAfterValidator(str.lower)]\n\n\nclass Model(BaseModel):\n    name: Username\n\n\nassert Model(name='ABC').name == 'abc'  # (2)!\n```\n\n1. The `frozen=True` specification makes `MyAfterValidator` hashable. Without this, a union such as `Username | None` will raise an error.\n2. Notice that type checkers will not complain about assigning `'ABC'` to `Username` like they did in the previous example because they do not consider `Username` to be a distinct type from `str`.", "url": "https://docs.pydantic.dev/latest/docs/concepts/types/#as-an-annotation", "page": "docs/concepts/types", "source_site": "pydantic"}
{"title": "Handling third-party types", "anchor": "handling-third-party-types", "heading_level": 4, "md_text": "Another use case for the pattern in the previous section is to handle third party types.\n\n```python\nfrom typing import Annotated, Any\n\nfrom pydantic_core import core_schema\n\nfrom pydantic import (\n    BaseModel,\n    GetCoreSchemaHandler,\n    GetJsonSchemaHandler,\n    ValidationError,\n)\nfrom pydantic.json_schema import JsonSchemaValue\n\n\nclass ThirdPartyType:\n    \"\"\"\n    This is meant to represent a type from a third-party library that wasn't designed with Pydantic\n    integration in mind, and so doesn't have a `pydantic_core.CoreSchema` or anything.\n    \"\"\"\n\n    x: int\n\n    def __init__(self):\n        self.x = 0\n\n\nclass _ThirdPartyTypePydanticAnnotation:\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls,\n        _source_type: Any,\n        _handler: GetCoreSchemaHandler,\n    ) -> core_schema.CoreSchema:\n        \"\"\"\n        We return a pydantic_core.CoreSchema that behaves in the following ways:\n\n        * ints will be parsed as `ThirdPartyType` instances with the int as the x attribute\n        * `ThirdPartyType` instances will be parsed as `ThirdPartyType` instances without any changes\n        * Nothing else will pass validation\n        * Serialization will always return just an int\n        \"\"\"\n\n        def validate_from_int(value: int) -> ThirdPartyType:\n            result = ThirdPartyType()\n            result.x = value\n            return result\n\n        from_int_schema = core_schema.chain_schema(\n            [\n                core_schema.int_schema(),\n                core_schema.no_info_plain_validator_function(validate_from_int),\n            ]\n        )\n\n        return core_schema.json_or_python_schema(\n            json_schema=from_int_schema,\n            python_schema=core_schema.union_schema(\n                [\n                    # check if it's an instance first before doing any further work\n                    core_schema.is_instance_schema(ThirdPartyType),\n                    from_int_schema,\n                ]\n            ),\n            serialization=core_schema.plain_serializer_function_ser_schema(\n                lambda instance: instance.x\n            ),\n        )\n\n    @classmethod\n    def __get_pydantic_json_schema__(\n        cls, _core_schema: core_schema.CoreSchema, handler: GetJsonSchemaHandler\n    ) -> JsonSchemaValue:\n        # Use the same schema that would be used for `int`\n        return handler(core_schema.int_schema())", "url": "https://docs.pydantic.dev/latest/docs/concepts/types/#handling-third-party-types", "page": "docs/concepts/types", "source_site": "pydantic"}
{"title": "We now create an `Annotated` wrapper that we'll use as the annotation for fields on `BaseModel`s, etc.", "anchor": "we-now-create-an-annotated-wrapper-that-well-use-as-the-annotation-for-fields-on-basemodels-etc", "heading_level": 1, "md_text": "PydanticThirdPartyType = Annotated[\n    ThirdPartyType, _ThirdPartyTypePydanticAnnotation\n]", "url": "https://docs.pydantic.dev/latest/docs/concepts/types/#we-now-create-an-annotated-wrapper-that-well-use-as-the-annotation-for-fields-on-basemodels-etc", "page": "docs/concepts/types", "source_site": "pydantic"}
{"title": "Create a model class that uses this annotation as a field", "anchor": "create-a-model-class-that-uses-this-annotation-as-a-field", "heading_level": 1, "md_text": "class Model(BaseModel):\n    third_party_type: PydanticThirdPartyType", "url": "https://docs.pydantic.dev/latest/docs/concepts/types/#create-a-model-class-that-uses-this-annotation-as-a-field", "page": "docs/concepts/types", "source_site": "pydantic"}
{"title": "these instances are also \"dumped\" directly into ints as expected.", "anchor": "these-instances-are-also-dumped-directly-into-ints-as-expected", "heading_level": 1, "md_text": "m_int = Model(third_party_type=1)\nassert isinstance(m_int.third_party_type, ThirdPartyType)\nassert m_int.third_party_type.x == 1\nassert m_int.model_dump() == {'third_party_type': 1}", "url": "https://docs.pydantic.dev/latest/docs/concepts/types/#these-instances-are-also-dumped-directly-into-ints-as-expected", "page": "docs/concepts/types", "source_site": "pydantic"}
{"title": "Do the same thing where an instance of ThirdPartyType is passed in", "anchor": "do-the-same-thing-where-an-instance-of-thirdpartytype-is-passed-in", "heading_level": 1, "md_text": "instance = ThirdPartyType()\nassert instance.x == 0\ninstance.x = 10\n\nm_instance = Model(third_party_type=instance)\nassert isinstance(m_instance.third_party_type, ThirdPartyType)\nassert m_instance.third_party_type.x == 10\nassert m_instance.model_dump() == {'third_party_type': 10}", "url": "https://docs.pydantic.dev/latest/docs/concepts/types/#do-the-same-thing-where-an-instance-of-thirdpartytype-is-passed-in", "page": "docs/concepts/types", "source_site": "pydantic"}
{"title": "Demonstrate that validation errors are raised as expected for invalid inputs", "anchor": "demonstrate-that-validation-errors-are-raised-as-expected-for-invalid-inputs", "heading_level": 1, "md_text": "try:\n    Model(third_party_type='a')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for Model\n    third_party_type.is-instance[ThirdPartyType]\n      Input should be an instance of ThirdPartyType [type=is_instance_of, input_value='a', input_type=str]\n    third_party_type.chain[int,function-plain[validate_from_int()]]\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='a', input_type=str]\n    \"\"\"\n\n\nassert Model.model_json_schema() == {\n    'properties': {\n        'third_party_type': {'title': 'Third Party Type', 'type': 'integer'}\n    },\n    'required': ['third_party_type'],\n    'title': 'Model',\n    'type': 'object',\n}\n```\n\nYou can use this approach to e.g. define behavior for Pandas or Numpy types.", "url": "https://docs.pydantic.dev/latest/docs/concepts/types/#demonstrate-that-validation-errors-are-raised-as-expected-for-invalid-inputs", "page": "docs/concepts/types", "source_site": "pydantic"}
{"title": "Using `GetPydanticSchema` to reduce boilerplate", "anchor": "using-getpydanticschema-to-reduce-boilerplate", "heading_level": 4, "md_text": "??? api \"API Documentation\"\n    [`pydantic.types.GetPydanticSchema`][pydantic.types.GetPydanticSchema]<br>\n\nYou may notice that the above examples where we create a marker class require a good amount of boilerplate.\nFor many simple cases you can greatly minimize this by using `pydantic.GetPydanticSchema`:\n\n```python\nfrom typing import Annotated\n\nfrom pydantic_core import core_schema\n\nfrom pydantic import BaseModel, GetPydanticSchema\n\n\nclass Model(BaseModel):\n    y: Annotated[\n        str,\n        GetPydanticSchema(\n            lambda tp, handler: core_schema.no_info_after_validator_function(\n                lambda x: x * 2, handler(tp)\n            )\n        ),\n    ]\n\n\nassert Model(y='ab').y == 'abab'\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/types/#using-getpydanticschema-to-reduce-boilerplate", "page": "docs/concepts/types", "source_site": "pydantic"}
{"title": "Summary", "anchor": "summary", "heading_level": 4, "md_text": "Let's recap:\n\n1. Pydantic provides high level hooks to customize types via `Annotated` like `AfterValidator` and `Field`. Use these when possible.\n2. Under the hood these use `pydantic-core` to customize validation, and you can hook into that directly using `GetPydanticSchema` or a marker class with `__get_pydantic_core_schema__`.\n3. If you really want a custom type you can implement `__get_pydantic_core_schema__` on the type itself.", "url": "https://docs.pydantic.dev/latest/docs/concepts/types/#summary", "page": "docs/concepts/types", "source_site": "pydantic"}
{"title": "Handling custom generic classes", "anchor": "handling-custom-generic-classes", "heading_level": 3, "md_text": "!!! warning\n    This is an advanced technique that you might not need in the beginning. In most of\n    the cases you will probably be fine with standard Pydantic models.\n\nYou can use\n[Generic Classes](https://docs.python.org/3/library/typing.html#typing.Generic) as\nfield types and perform custom validation based on the \"type parameters\" (or sub-types)\nwith `__get_pydantic_core_schema__`.\n\nIf the Generic class that you are using as a sub-type has a classmethod\n`__get_pydantic_core_schema__`, you don't need to use\n[`arbitrary_types_allowed`][pydantic.config.ConfigDict.arbitrary_types_allowed] for it to work.\n\nBecause the `source_type` parameter is not the same as the `cls` parameter, you can use `typing.get_args` (or `typing_extensions.get_args`) to extract the generic parameters.\nThen you can use the `handler` to generate a schema for them by calling `handler.generate_schema`.\nNote that we do not do something like `handler(get_args(source_type)[0])` because we want to generate an unrelated\nschema for that generic parameter, not one that is influenced by the current context of `Annotated` metadata and such.\nThis is less important for custom types, but crucial for annotated metadata that modifies schema building.\n\n```python\nfrom dataclasses import dataclass\nfrom typing import Any, Generic, TypeVar\n\nfrom pydantic_core import CoreSchema, core_schema\nfrom typing_extensions import get_args, get_origin\n\nfrom pydantic import (\n    BaseModel,\n    GetCoreSchemaHandler,\n    ValidationError,\n    ValidatorFunctionWrapHandler,\n)\n\nItemType = TypeVar('ItemType')", "url": "https://docs.pydantic.dev/latest/docs/concepts/types/#handling-custom-generic-classes", "page": "docs/concepts/types", "source_site": "pydantic"}
{"title": "This is not a pydantic model, it's an arbitrary generic class", "anchor": "this-is-not-a-pydantic-model-its-an-arbitrary-generic-class", "heading_level": 1, "md_text": "@dataclass\nclass Owner(Generic[ItemType]):\n    name: str\n    item: ItemType\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source_type: Any, handler: GetCoreSchemaHandler\n    ) -> CoreSchema:\n        origin = get_origin(source_type)\n        if origin is None:  # used as `x: Owner` without params\n            origin = source_type\n            item_tp = Any\n        else:\n            item_tp = get_args(source_type)[0]\n        # both calling handler(...) and handler.generate_schema(...)\n        # would work, but prefer the latter for conceptual and consistency reasons\n        item_schema = handler.generate_schema(item_tp)\n\n        def val_item(\n            v: Owner[Any], handler: ValidatorFunctionWrapHandler\n        ) -> Owner[Any]:\n            v.item = handler(v.item)\n            return v\n\n        python_schema = core_schema.chain_schema(\n            # `chain_schema` means do the following steps in order:\n            [\n                # Ensure the value is an instance of Owner\n                core_schema.is_instance_schema(cls),\n                # Use the item_schema to validate `items`\n                core_schema.no_info_wrap_validator_function(\n                    val_item, item_schema\n                ),\n            ]\n        )\n\n        return core_schema.json_or_python_schema(\n            # for JSON accept an object with name and item keys\n            json_schema=core_schema.chain_schema(\n                [\n                    core_schema.typed_dict_schema(\n                        {\n                            'name': core_schema.typed_dict_field(\n                                core_schema.str_schema()\n                            ),\n                            'item': core_schema.typed_dict_field(item_schema),\n                        }\n                    ),\n                    # after validating the json data convert it to python\n                    core_schema.no_info_before_validator_function(\n                        lambda data: Owner(\n                            name=data['name'], item=data['item']\n                        ),\n                        # note that we reuse the same schema here as below\n                        python_schema,\n                    ),\n                ]\n            ),\n            python_schema=python_schema,\n        )\n\n\nclass Car(BaseModel):\n    color: str\n\n\nclass House(BaseModel):\n    rooms: int\n\n\nclass Model(BaseModel):\n    car_owner: Owner[Car]\n    home_owner: Owner[House]\n\n\nmodel = Model(\n    car_owner=Owner(name='John', item=Car(color='black')),\n    home_owner=Owner(name='James', item=House(rooms=3)),\n)\nprint(model)\n\"\"\"\ncar_owner=Owner(name='John', item=Car(color='black')) home_owner=Owner(name='James', item=House(rooms=3))\n\"\"\"\n\ntry:\n    # If the values of the sub-types are invalid, we get an error\n    Model(\n        car_owner=Owner(name='John', item=House(rooms=3)),\n        home_owner=Owner(name='James', item=Car(color='black')),\n    )\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for Model\n    wine\n      Input should be a valid number, unable to parse string as a number [type=float_parsing, input_value='Kinda good', input_type=str]\n    cheese\n      Input should be a valid boolean, unable to interpret input [type=bool_parsing, input_value='yeah', input_type=str]\n    \"\"\"", "url": "https://docs.pydantic.dev/latest/docs/concepts/types/#this-is-not-a-pydantic-model-its-an-arbitrary-generic-class", "page": "docs/concepts/types", "source_site": "pydantic"}
{"title": "Similarly with JSON", "anchor": "similarly-with-json", "heading_level": 1, "md_text": "model = Model.model_validate_json(\n    '{\"car_owner\":{\"name\":\"John\",\"item\":{\"color\":\"black\"}},\"home_owner\":{\"name\":\"James\",\"item\":{\"rooms\":3}}}'\n)\nprint(model)\n\"\"\"\ncar_owner=Owner(name='John', item=Car(color='black')) home_owner=Owner(name='James', item=House(rooms=3))\n\"\"\"\n\ntry:\n    Model.model_validate_json(\n        '{\"car_owner\":{\"name\":\"John\",\"item\":{\"rooms\":3}},\"home_owner\":{\"name\":\"James\",\"item\":{\"color\":\"black\"}}}'\n    )\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for Model\n    car_owner.item.color\n      Field required [type=missing, input_value={'rooms': 3}, input_type=dict]\n    home_owner.item.rooms\n      Field required [type=missing, input_value={'color': 'black'}, input_type=dict]\n    \"\"\"\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/types/#similarly-with-json", "page": "docs/concepts/types", "source_site": "pydantic"}
{"title": "Generic containers", "anchor": "generic-containers", "heading_level": 4, "md_text": "The same idea can be applied to create generic container types, like a custom `Sequence` type:\n\n```python\nfrom collections.abc import Sequence\nfrom typing import Any, TypeVar\n\nfrom pydantic_core import ValidationError, core_schema\nfrom typing_extensions import get_args\n\nfrom pydantic import BaseModel, GetCoreSchemaHandler\n\nT = TypeVar('T')\n\n\nclass MySequence(Sequence[T]):\n    def __init__(self, v: Sequence[T]):\n        self.v = v\n\n    def __getitem__(self, i):\n        return self.v[i]\n\n    def __len__(self):\n        return len(self.v)\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source: Any, handler: GetCoreSchemaHandler\n    ) -> core_schema.CoreSchema:\n        instance_schema = core_schema.is_instance_schema(cls)\n\n        args = get_args(source)\n        if args:\n            # replace the type and rely on Pydantic to generate the right schema\n            # for `Sequence`\n            sequence_t_schema = handler.generate_schema(Sequence[args[0]])\n        else:\n            sequence_t_schema = handler.generate_schema(Sequence)\n\n        non_instance_schema = core_schema.no_info_after_validator_function(\n            MySequence, sequence_t_schema\n        )\n        return core_schema.union_schema([instance_schema, non_instance_schema])\n\n\nclass M(BaseModel):\n    model_config = dict(validate_default=True)\n\n    s1: MySequence = [3]\n\n\nm = M()\nprint(m)\n#> s1=<__main__.MySequence object at 0x0123456789ab>\nprint(m.s1.v)\n#> [3]\n\n\nclass M(BaseModel):\n    s1: MySequence[int]\n\n\nM(s1=[1])\ntry:\n    M(s1=['a'])\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    2 validation errors for M\n    s1.is-instance[MySequence]\n      Input should be an instance of MySequence [type=is_instance_of, input_value=['a'], input_type=list]\n    s1.function-after[MySequence(), json-or-python[json=list[int],python=chain[is-instance[Sequence],function-wrap[sequence_validator()]]]].0\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='a', input_type=str]\n    \"\"\"\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/types/#generic-containers", "page": "docs/concepts/types", "source_site": "pydantic"}
{"title": "Access to field name", "anchor": "access-to-field-name", "heading_level": 3, "md_text": "!!!note\n    This was not possible with Pydantic V2 to V2.3, it was [re-added](https://github.com/pydantic/pydantic/pull/7542) in Pydantic V2.4.\n\nAs of Pydantic V2.4, you can access the field name via the `handler.field_name` within `__get_pydantic_core_schema__`\nand thereby set the field name which will be available from `info.field_name`.\n\n```python\nfrom typing import Any\n\nfrom pydantic_core import core_schema\n\nfrom pydantic import BaseModel, GetCoreSchemaHandler, ValidationInfo\n\n\nclass CustomType:\n    \"\"\"Custom type that stores the field it was used in.\"\"\"\n\n    def __init__(self, value: int, field_name: str):\n        self.value = value\n        self.field_name = field_name\n\n    def __repr__(self):\n        return f'CustomType<{self.value} {self.field_name!r}>'\n\n    @classmethod\n    def validate(cls, value: int, info: ValidationInfo):\n        return cls(value, info.field_name)\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source_type: Any, handler: GetCoreSchemaHandler\n    ) -> core_schema.CoreSchema:\n        return core_schema.with_info_after_validator_function(\n            cls.validate, handler(int)\n        )\n\n\nclass MyModel(BaseModel):\n    my_field: CustomType\n\n\nm = MyModel(my_field=1)\nprint(m.my_field)\n#> CustomType<1 'my_field'>\n```\n\nYou can also access `field_name` from the markers used with `Annotated`, like [`AfterValidator`][pydantic.functional_validators.AfterValidator].\n\n```python\nfrom typing import Annotated\n\nfrom pydantic import AfterValidator, BaseModel, ValidationInfo\n\n\ndef my_validators(value: int, info: ValidationInfo):\n    return f'<{value} {info.field_name!r}>'\n\n\nclass MyModel(BaseModel):\n    my_field: Annotated[int, AfterValidator(my_validators)]\n\n\nm = MyModel(my_field=1)\nprint(m.my_field)\n#> <1 'my_field'>\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/types/#access-to-field-name", "page": "docs/concepts/types", "source_site": "pydantic"}
{"title": "Json Parsing", "anchor": "json-parsing", "heading_level": 2, "md_text": "??? api \"API Documentation\"\n    [`pydantic.main.BaseModel.model_validate_json`][pydantic.main.BaseModel.model_validate_json]\n    [`pydantic.type_adapter.TypeAdapter.validate_json`][pydantic.type_adapter.TypeAdapter.validate_json]\n    [`pydantic_core.from_json`][pydantic_core.from_json]\n\nPydantic provides builtin JSON parsing, which helps achieve:\n\n* Significant performance improvements without the cost of using a 3rd party library\n* Support for custom errors\n* Support for `strict` specifications\n\nHere's an example of Pydantic's builtin JSON parsing via the [`model_validate_json`][pydantic.main.BaseModel.model_validate_json] method, showcasing the support for `strict` specifications while parsing JSON data that doesn't match the model's type annotations:\n\n```python\nfrom datetime import date\n\nfrom pydantic import BaseModel, ConfigDict, ValidationError\n\n\nclass Event(BaseModel):\n    model_config = ConfigDict(strict=True)\n\n    when: date\n    where: tuple[int, int]\n\n\njson_data = '{\"when\": \"1987-01-28\", \"where\": [51, -1]}'\nprint(Event.model_validate_json(json_data))  # (1)!\n#> when=datetime.date(1987, 1, 28) where=(51, -1)\n\ntry:\n    Event.model_validate({'when': '1987-01-28', 'where': [51, -1]})  # (2)!\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for Event\n    when\n      Input should be a valid date [type=date_type, input_value='1987-01-28', input_type=str]\n    where\n      Input should be a valid tuple [type=tuple_type, input_value=[51, -1], input_type=list]\n    \"\"\"\n```\n\n1. JSON has no `date` or tuple types, but Pydantic knows that so allows strings and arrays as inputs respectively when parsing JSON directly.\n2. If you pass the same values to the [`model_validate`][pydantic.main.BaseModel.model_validate] method, Pydantic will raise a validation error because the `strict` configuration is enabled.\n\nIn v2.5.0 and above, Pydantic uses [`jiter`](https://docs.rs/jiter/latest/jiter/), a fast and iterable JSON parser, to parse JSON data.\nUsing `jiter` compared to `serde` results in modest performance improvements that will get even better in the future.\n\nThe `jiter` JSON parser is almost entirely compatible with the `serde` JSON parser,\nwith one noticeable enhancement being that `jiter` supports deserialization of `inf` and `NaN` values.\nIn the future, `jiter` is intended to enable support validation errors to include the location\nin the original JSON input which contained the invalid value.", "url": "https://docs.pydantic.dev/latest/docs/concepts/json/#json-parsing", "page": "docs/concepts/json", "source_site": "pydantic"}
{"title": "Partial JSON Parsing", "anchor": "partial-json-parsing", "heading_level": 3, "md_text": "**Starting in v2.7.0**, Pydantic's [JSON parser](https://docs.rs/jiter/latest/jiter/) offers support for partial JSON parsing, which is exposed via [`pydantic_core.from_json`][pydantic_core.from_json]. Here's an example of this feature in action:\n\n```python\nfrom pydantic_core import from_json\n\npartial_json_data = '[\"aa\", \"bb\", \"c'  # (1)!\n\ntry:\n    result = from_json(partial_json_data, allow_partial=False)\nexcept ValueError as e:\n    print(e)  # (2)!\n    #> EOF while parsing a string at line 1 column 15\n\nresult = from_json(partial_json_data, allow_partial=True)\nprint(result)  # (3)!\n#> ['aa', 'bb']\n```\n\n1. The JSON list is incomplete - it's missing a closing `\"]`\n2. When `allow_partial` is set to `False` (the default), a parsing error occurs.\n3. When `allow_partial` is set to `True`, part of the input is deserialized successfully.\n\nThis also works for deserializing partial dictionaries. For example:\n\n```python\nfrom pydantic_core import from_json\n\npartial_dog_json = '{\"breed\": \"lab\", \"name\": \"fluffy\", \"friends\": [\"buddy\", \"spot\", \"rufus\"], \"age'\ndog_dict = from_json(partial_dog_json, allow_partial=True)\nprint(dog_dict)\n#> {'breed': 'lab', 'name': 'fluffy', 'friends': ['buddy', 'spot', 'rufus']}\n```\n\n!!! tip \"Validating LLM Output\"\n    This feature is particularly beneficial for validating LLM outputs.\n    We've written some blog posts about this topic, which you can find on [our website](https://pydantic.dev/articles).\n\nIn future versions of Pydantic, we expect to expand support for this feature through either Pydantic's other JSON validation functions\n([`pydantic.main.BaseModel.model_validate_json`][pydantic.main.BaseModel.model_validate_json] and\n[`pydantic.type_adapter.TypeAdapter.validate_json`][pydantic.type_adapter.TypeAdapter.validate_json]) or model configuration. Stay tuned \ud83d\ude80!\n\nFor now, you can use [`pydantic_core.from_json`][pydantic_core.from_json] in combination with [`pydantic.main.BaseModel.model_validate`][pydantic.main.BaseModel.model_validate] to achieve the same result. Here's an example:\n\n```python\nfrom pydantic_core import from_json\n\nfrom pydantic import BaseModel\n\n\nclass Dog(BaseModel):\n    breed: str\n    name: str\n    friends: list\n\n\npartial_dog_json = '{\"breed\": \"lab\", \"name\": \"fluffy\", \"friends\": [\"buddy\", \"spot\", \"rufus\"], \"age'\ndog = Dog.model_validate(from_json(partial_dog_json, allow_partial=True))\nprint(repr(dog))\n#> Dog(breed='lab', name='fluffy', friends=['buddy', 'spot', 'rufus'])\n```\n\n!!! tip\n    For partial JSON parsing to work reliably, all fields on the model should have default values.\n\nCheck out the following example for a more in-depth look at how to use default values with partial JSON parsing:\n\n!!! example \"Using default values with partial JSON parsing\"\n\n    ```python\n    from typing import Annotated, Any, Optional\n\n    import pydantic_core\n\n    from pydantic import BaseModel, ValidationError, WrapValidator\n\n\n    def default_on_error(v, handler) -> Any:\n        \"\"\"\n        Raise a PydanticUseDefault exception if the value is missing.\n\n        This is useful for avoiding errors from partial\n        JSON preventing successful validation.\n        \"\"\"\n        try:\n            return handler(v)\n        except ValidationError as exc:\n            # there might be other types of errors resulting from partial JSON parsing\n            # that you allow here, feel free to customize as needed\n            if all(e['type'] == 'missing' for e in exc.errors()):\n                raise pydantic_core.PydanticUseDefault()\n            else:\n                raise\n\n\n    class NestedModel(BaseModel):\n        x: int\n        y: str\n\n\n    class MyModel(BaseModel):\n        foo: Optional[str] = None\n        bar: Annotated[\n            Optional[tuple[str, int]], WrapValidator(default_on_error)\n        ] = None\n        nested: Annotated[\n            Optional[NestedModel], WrapValidator(default_on_error)\n        ] = None\n\n\n    m = MyModel.model_validate(\n        pydantic_core.from_json('{\"foo\": \"x\", \"bar\": [\"world\",', allow_partial=True)\n    )\n    print(repr(m))\n    #> MyModel(foo='x', bar=None, nested=None)\n\n\n    m = MyModel.model_validate(\n        pydantic_core.from_json(\n            '{\"foo\": \"x\", \"bar\": [\"world\", 1], \"nested\": {\"x\":', allow_partial=True\n        )\n    )\n    print(repr(m))\n    #> MyModel(foo='x', bar=('world', 1), nested=None)\n    ```", "url": "https://docs.pydantic.dev/latest/docs/concepts/json/#partial-json-parsing", "page": "docs/concepts/json", "source_site": "pydantic"}
{"title": "Caching Strings", "anchor": "caching-strings", "heading_level": 3, "md_text": "**Starting in v2.7.0**, Pydantic's [JSON parser](https://docs.rs/jiter/latest/jiter/) offers support for configuring how Python strings are cached during JSON parsing and validation (when Python strings are constructed from Rust strings during Python validation, e.g. after `strip_whitespace=True`).\nThe `cache_strings` setting is exposed via both [model config][pydantic.config.ConfigDict] and [`pydantic_core.from_json`][pydantic_core.from_json].\n\nThe `cache_strings` setting can take any of the following values:\n\n* `True` or `'all'` (the default): cache all strings\n* `'keys'`: cache only dictionary keys, this **only** applies when used with [`pydantic_core.from_json`][pydantic_core.from_json] or when parsing JSON using [`Json`][pydantic.types.Json]\n* `False` or `'none'`: no caching\n\nUsing the string caching feature results in performance improvements, but increases memory usage slightly.\n\n!!! note \"String Caching Details\"\n\n    1. Strings are cached using a fully associative cache with a size of\n    [16,384](https://github.com/pydantic/jiter/blob/5bbdcfd22882b7b286416b22f74abd549c7b2fd7/src/py_string_cache.rs#L113).\n    2. Only strings where `len(string) < 64` are cached.\n    3. There is some overhead to looking up the cache, which is normally worth it to avoid constructing strings.\n    However, if you know there will be very few repeated strings in your data, you might get a performance boost by disabling this setting with `cache_strings=False`.", "url": "https://docs.pydantic.dev/latest/docs/concepts/json/#caching-strings", "page": "docs/concepts/json", "source_site": "pydantic"}
{"title": "JSON Serialization", "anchor": "json-serialization", "heading_level": 2, "md_text": "??? api \"API Documentation\"\n    [`pydantic.main.BaseModel.model_dump_json`][pydantic.main.BaseModel.model_dump_json]<br>\n    [`pydantic.type_adapter.TypeAdapter.dump_json`][pydantic.type_adapter.TypeAdapter.dump_json]<br>\n    [`pydantic_core.to_json`][pydantic_core.to_json]<br>\n\nFor more information on JSON serialization, see the [serialization concepts](./serialization.md) page.", "url": "https://docs.pydantic.dev/latest/docs/concepts/json/#json-serialization", "page": "docs/concepts/json", "source_site": "pydantic"}
{"title": "strict_mode", "anchor": null, "heading_level": 0, "md_text": "??? api \"API Documentation\"\n    [`pydantic.types.Strict`][pydantic.types.Strict]<br>\n\nBy default, Pydantic will attempt to coerce values to the desired type when possible.\nFor example, you can pass the string `'123'` as the input for the [`int` number type](../api/standard_library_types.md#integers),\nand it will be converted to the value `123`.\nThis coercion behavior is useful in many scenarios \u2014 think: UUIDs, URL parameters, HTTP headers, environment variables,\ndates, etc.\n\nHowever, there are also situations where this is not desirable, and you want Pydantic to error instead of coercing data.\n\nTo better support this use case, Pydantic provides a \"strict mode\". When strict mode is enabled, Pydantic will be much\nless lenient when coercing data, and will instead error if the data is not of the correct type.\n\nMost of the time, strict mode will only allow instances of the type to be provided, although looser rules may apply\nto JSON input (for instance, the [date and time types](../api/standard_library_types.md#date-and-time-types) allow strings\neven in strict mode).\n\nThe strict behavior for each type can be found in the [standard library types](../api/standard_library_types.md) documentation,\nand is summarized in the [conversion table](./conversion_table.md).\n\nHere is a brief example showing the validation behavior difference in strict and the default lax mode:\n\n```python\nfrom pydantic import BaseModel, ValidationError\n\n\nclass MyModel(BaseModel):\n    x: int\n\n\nprint(MyModel.model_validate({'x': '123'}))  # lax mode\n#> x=123\n\ntry:\n    MyModel.model_validate({'x': '123'}, strict=True)  # strict mode\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for MyModel\n    x\n      Input should be a valid integer [type=int_type, input_value='123', input_type=str]\n    \"\"\"\n```\n\nStrict mode can be enabled in various ways:\n\n* [As a validation parameter](#as-a-validation-parameter), such as when using [`model_validate()`][pydantic.BaseModel.model_validate],\n  on Pydantic models.\n* [At the field level](#at-the-field-level).\n* [At the configuration level](#as-a-configuration-value) (with the possibility to override at the field level).\n\n<!-- old anchor added for backwards compatibility -->\n<!-- markdownlint-disable-next-line no-empty-links -->\n[](){#strict-mode-in-method-calls}", "url": "https://docs.pydantic.dev/latest/docs/concepts/strict_mode/", "page": "docs/concepts/strict_mode", "source_site": "pydantic"}
{"title": "As a validation parameter", "anchor": "as-a-validation-parameter", "heading_level": 2, "md_text": "Strict mode can be enaled on a per-validation-call basis, when using the [validation methods](./models.md#validating-data)\non [Pydantic models](./models.md) and [type adapters](./type_adapter.md).\n\n```python\nfrom datetime import date\n\nfrom pydantic import TypeAdapter, ValidationError\n\nprint(TypeAdapter(date).validate_python('2000-01-01'))  # OK: lax\n#> 2000-01-01\n\ntry:\n    # Not OK: strict:\n    TypeAdapter(date).validate_python('2000-01-01', strict=True)\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for date\n      Input should be a valid date [type=date_type, input_value='2000-01-01', input_type=str]\n    \"\"\"\n\nTypeAdapter(date).validate_json('\"2000-01-01\"', strict=True)  # (1)!\n#> 2000-01-01\n```\n\n1. As mentioned, strict mode is looser when validating from JSON.\n\n<!-- old anchor added for backwards compatibility -->\n<!-- markdownlint-disable-next-line no-empty-links -->\n[](){#strict-mode-with-field}", "url": "https://docs.pydantic.dev/latest/docs/concepts/strict_mode/#as-a-validation-parameter", "page": "docs/concepts/strict_mode", "source_site": "pydantic"}
{"title": "At the field level", "anchor": "at-the-field-level", "heading_level": 2, "md_text": "Strict mode can be enabled on specific fields, by setting the `strict` parameter of the\n[`Field()`][pydantic.Field] function to `True`. Strict mode will be applied for such fields,\neven when the [validation methods](./models.md#validating-data) are called in lax mode.\n\n```python\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass User(BaseModel):\n    name: str\n    age: int = Field(strict=True)  # (1)!\n\n\nuser = User(name='John', age=42)\nprint(user)\n#> name='John' age=42\n\n\ntry:\n    another_user = User(name='John', age='42')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n    age\n      Input should be a valid integer [type=int_type, input_value='42', input_type=str]\n    \"\"\"\n```\n\n1. The strict constraint can also be applied using the [annotated pattern](./fields.md#the-annotated-pattern):\n   `Annotated[int, Field(strict=True)]`\n\n<!-- old anchor added for backwards compatibility -->\n<!-- markdownlint-disable-next-line no-empty-links -->\n[](){#strict-mode-with-annotated-strict}", "url": "https://docs.pydantic.dev/latest/docs/concepts/strict_mode/#at-the-field-level", "page": "docs/concepts/strict_mode", "source_site": "pydantic"}
{"title": "Using the `Strict()` metadata class", "anchor": "using-the-strict-metadata-class", "heading_level": 3, "md_text": "??? api \"API Documentation\"\n    [`pydantic.types.Strict`][pydantic.types.Strict]<br>\n\nAs an alternative to the [`Field()`][pydantic.Field] function, Pydantic provides the [`Strict`][pydantic.types.Strict]\nmetadata class, meant to be used with the [annotated pattern](./fields.md#the-annotated-pattern). It also provides\nconvenience aliases for the most common types (namely [`StrictBool`][pydantic.types.StrictBool],\n[`StrictInt`][pydantic.types.StrictInt], [`StrictFloat`][pydantic.types.StrictFloat], [`StrictStr`][pydantic.types.StrictStr]\nand [`StrictBytes`][pydantic.types.StrictBytes]).\n\n```python\nfrom typing import Annotated\nfrom uuid import UUID\n\nfrom pydantic import BaseModel, Strict, StrictInt\n\n\nclass User(BaseModel):\n    id: Annotated[UUID, Strict()]\n    age: StrictInt  # (1)!\n```\n\n1. Equivalent to `Annotated[int, Strict()]`.\n\n<!-- old anchor added for backwards compatibility -->\n<!-- markdownlint-disable-next-line no-empty-links -->\n[](){#strict-mode-with-configdict}", "url": "https://docs.pydantic.dev/latest/docs/concepts/strict_mode/#using-the-strict-metadata-class", "page": "docs/concepts/strict_mode", "source_site": "pydantic"}
{"title": "As a configuration value", "anchor": "as-a-configuration-value", "heading_level": 2, "md_text": "Strict mode behavior can be controlled at the [configuration](./config.md) level. When used on\na Pydantic model (or model like class such as [dataclasses](./dataclasses.md)), strictness can still\nbe overridden at the [field level](#at-the-field-level):\n\n```python\nfrom pydantic import BaseModel, ConfigDict, Field\n\n\nclass User(BaseModel):\n    model_config = ConfigDict(strict=True)\n\n    name: str\n    age: int = Field(strict=False)\n\n\nprint(User(name='John', age='18'))\n#> name='John' age=18\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/strict_mode/#as-a-configuration-value", "page": "docs/concepts/strict_mode", "source_site": "pydantic"}
{"title": "validation_decorator", "anchor": null, "heading_level": 0, "md_text": "??? api \"API Documentation\"\n    [`pydantic.validate_call_decorator.validate_call`][pydantic.validate_call_decorator.validate_call]<br>\n\nThe [`validate_call()`][pydantic.validate_call] decorator allows the arguments passed to a function to be parsed\nand validated using the function's annotations before the function is called.\n\nWhile under the hood this uses the same approach of model creation and initialisation\n(see [Validators](validators.md) for more details), it provides an extremely easy way to apply validation\nto your code with minimal boilerplate.\n\nExample of usage:\n\n```python\nfrom pydantic import ValidationError, validate_call\n\n\n@validate_call\ndef repeat(s: str, count: int, *, separator: bytes = b'') -> bytes:\n    b = s.encode()\n    return separator.join(b for _ in range(count))\n\n\na = repeat('hello', 3)\nprint(a)\n#> b'hellohellohello'\n\nb = repeat('x', '4', separator=b' ')\nprint(b)\n#> b'x x x x'\n\ntry:\n    c = repeat('hello', 'wrong')\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for repeat\n    1\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='wrong', input_type=str]\n    \"\"\"\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/validation_decorator/", "page": "docs/concepts/validation_decorator", "source_site": "pydantic"}
{"title": "Parameter types", "anchor": "parameter-types", "heading_level": 2, "md_text": "Parameter types are inferred from type annotations on the function, or as [`Any`][typing.Any] if not annotated. All types listed in [types](types.md) can be validated, including Pydantic models and [custom types](types.md#custom-types).\nAs with the rest of Pydantic, types are by default coerced by the decorator before they're passed to the actual function:\n\n```python\nfrom datetime import date\n\nfrom pydantic import validate_call\n\n\n@validate_call\ndef greater_than(d1: date, d2: date, *, include_equal=False) -> date:  # (1)!\n    if include_equal:\n        return d1 >= d2\n    else:\n        return d1 > d2\n\n\nd1 = '2000-01-01'  # (2)!\nd2 = date(2001, 1, 1)\ngreater_than(d1, d2, include_equal=True)\n```\n\n1. Because `include_equal` has no type annotation, it will be inferred as [`Any`][typing.Any].\n2. Although `d1` is a string, it will be converted to a [`date`][datetime.date] object.\n\nType coercion like this can be extremely helpful, but also confusing or not desired (see [model data conversion](models.md#data-conversion)). [Strict mode](strict_mode.md)\ncan be enabled by using a [custom configuration](#custom-configuration).\n\n!!! note \"Validating the return value\"\n    By default, the return value of the function is **not** validated. To do so, the `validate_return` argument\n    of the decorator can be set to `True`.", "url": "https://docs.pydantic.dev/latest/docs/concepts/validation_decorator/#parameter-types", "page": "docs/concepts/validation_decorator", "source_site": "pydantic"}
{"title": "Function signatures", "anchor": "function-signatures", "heading_level": 2, "md_text": "The [`validate_call()`][pydantic.validate_call] decorator is designed to work with functions\nusing all possible [parameter configurations][parameter] and all possible combinations of these:\n\n* Positional or keyword parameters with or without defaults.\n* Keyword-only parameters: parameters after `*,`.\n* Positional-only parameters: parameters before `, /`.\n* Variable positional parameters defined via `*` (often `*args`).\n* Variable keyword parameters defined via `**` (often `**kwargs`).\n\n??? example\n\n    ```python\n    from pydantic import validate_call\n\n\n    @validate_call\n    def pos_or_kw(a: int, b: int = 2) -> str:\n        return f'a={a} b={b}'\n\n\n    print(pos_or_kw(1, b=3))\n    #> a=1 b=3\n\n\n    @validate_call\n    def kw_only(*, a: int, b: int = 2) -> str:\n        return f'a={a} b={b}'\n\n\n    print(kw_only(a=1))\n    #> a=1 b=2\n    print(kw_only(a=1, b=3))\n    #> a=1 b=3\n\n\n    @validate_call\n    def pos_only(a: int, b: int = 2, /) -> str:\n        return f'a={a} b={b}'\n\n\n    print(pos_only(1))\n    #> a=1 b=2\n\n\n    @validate_call\n    def var_args(*args: int) -> str:\n        return str(args)\n\n\n    print(var_args(1))\n    #> (1,)\n    print(var_args(1, 2, 3))\n    #> (1, 2, 3)\n\n\n    @validate_call\n    def var_kwargs(**kwargs: int) -> str:\n        return str(kwargs)\n\n\n    print(var_kwargs(a=1))\n    #> {'a': 1}\n    print(var_kwargs(a=1, b=2))\n    #> {'a': 1, 'b': 2}\n\n\n    @validate_call\n    def armageddon(\n        a: int,\n        /,\n        b: int,\n        *c: int,\n        d: int,\n        e: int = None,\n        **f: int,\n    ) -> str:\n        return f'a={a} b={b} c={c} d={d} e={e} f={f}'\n\n\n    print(armageddon(1, 2, d=3))\n    #> a=1 b=2 c=() d=3 e=None f={}\n    print(armageddon(1, 2, 3, 4, 5, 6, d=8, e=9, f=10, spam=11))\n    #> a=1 b=2 c=(3, 4, 5, 6) d=8 e=9 f={'f': 10, 'spam': 11}\n    ```\n\n!!! note \"[`Unpack`][typing.Unpack] for keyword parameters\"\n    [`Unpack`][typing.Unpack] and typed dictionaries can be used to annotate the variable\n    keyword parameters of a function:\n\n    ```python\n    from typing_extensions import TypedDict, Unpack\n\n    from pydantic import validate_call\n\n\n    class Point(TypedDict):\n        x: int\n        y: int\n\n\n    @validate_call\n    def add_coords(**kwargs: Unpack[Point]) -> int:\n        return kwargs['x'] + kwargs['y']\n\n\n    add_coords(x=1, y=2)\n    ```\n\n    For reference, see the [related specification section] and [PEP 692].\n\n    [related specification section]: https://typing.readthedocs.io/en/latest/spec/callables.html#unpack-for-keyword-arguments\n    [PEP 692]: https://peps.python.org/pep-0692/", "url": "https://docs.pydantic.dev/latest/docs/concepts/validation_decorator/#function-signatures", "page": "docs/concepts/validation_decorator", "source_site": "pydantic"}
{"title": "Using the [`Field()`][pydantic.Field] function to describe function parameters", "anchor": "using-the-fieldpydanticfield-function-to-describe-function-parameters", "heading_level": 2, "md_text": "The [`Field()` function](fields.md) can also be used with the decorator to provide extra information about\nthe field and validations. If you don't make use of the `default` or `default_factory` parameter, it is\nrecommended to use the [annotated pattern](./fields.md#the-annotated-pattern) (so that type checkers\ninfer the parameter as being required). Otherwise, the [`Field()`][pydantic.Field] function can be used\nas a default value (again, to trick type checkers into thinking a default value is provided for the parameter).\n\n```python\nfrom typing import Annotated\n\nfrom pydantic import Field, ValidationError, validate_call\n\n\n@validate_call\ndef how_many(num: Annotated[int, Field(gt=10)]):\n    return num\n\n\ntry:\n    how_many(1)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for how_many\n    0\n      Input should be greater than 10 [type=greater_than, input_value=1, input_type=int]\n    \"\"\"\n\n\n@validate_call\ndef return_value(value: str = Field(default='default value')):\n    return value\n\n\nprint(return_value())\n#> default value\n```\n\n[Aliases](fields.md#field-aliases) can be used with the decorator as normal:\n\n```python\nfrom typing import Annotated\n\nfrom pydantic import Field, validate_call\n\n\n@validate_call\ndef how_many(num: Annotated[int, Field(gt=10, alias='number')]):\n    return num\n\n\nhow_many(number=42)\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/validation_decorator/#using-the-fieldpydanticfield-function-to-describe-function-parameters", "page": "docs/concepts/validation_decorator", "source_site": "pydantic"}
{"title": "Accessing the original function", "anchor": "accessing-the-original-function", "heading_level": 2, "md_text": "The original function which was decorated can still be accessed by using the `raw_function` attribute.\nThis is useful if in some scenarios you trust your input arguments and want to call the function in the most efficient way (see [notes on performance](#performance) below):\n\n```python\nfrom pydantic import validate_call\n\n\n@validate_call\ndef repeat(s: str, count: int, *, separator: bytes = b'') -> bytes:\n    b = s.encode()\n    return separator.join(b for _ in range(count))\n\n\na = repeat('hello', 3)\nprint(a)\n#> b'hellohellohello'\n\nb = repeat.raw_function('good bye', 2, separator=b', ')\nprint(b)\n#> b'good bye, good bye'\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/validation_decorator/#accessing-the-original-function", "page": "docs/concepts/validation_decorator", "source_site": "pydantic"}
{"title": "Async functions", "anchor": "async-functions", "heading_level": 2, "md_text": "[`validate_call()`][pydantic.validate_call] can also be used on async functions:\n\n```python\nclass Connection:\n    async def execute(self, sql, *args):\n        return 'testing@example.com'\n\n\nconn = Connection()", "url": "https://docs.pydantic.dev/latest/docs/concepts/validation_decorator/#async-functions", "page": "docs/concepts/validation_decorator", "source_site": "pydantic"}
{"title": "ignore-above", "anchor": "ignore-above", "heading_level": 1, "md_text": "import asyncio\n\nfrom pydantic import PositiveInt, ValidationError, validate_call\n\n\n@validate_call\nasync def get_user_email(user_id: PositiveInt):\n    # `conn` is some fictional connection to a database\n    email = await conn.execute('select email from users where id=$1', user_id)\n    if email is None:\n        raise RuntimeError('user not found')\n    else:\n        return email\n\n\nasync def main():\n    email = await get_user_email(123)\n    print(email)\n    #> testing@example.com\n    try:\n        await get_user_email(-4)\n    except ValidationError as exc:\n        print(exc.errors())\n        \"\"\"\n        [\n            {\n                'type': 'greater_than',\n                'loc': (0,),\n                'msg': 'Input should be greater than 0',\n                'input': -4,\n                'ctx': {'gt': 0},\n                'url': 'https://errors.pydantic.dev/2/v/greater_than',\n            }\n        ]\n        \"\"\"\n\n\nasyncio.run(main())", "url": "https://docs.pydantic.dev/latest/docs/concepts/validation_decorator/#ignore-above", "page": "docs/concepts/validation_decorator", "source_site": "pydantic"}
{"title": "requires: `conn.execute()` that will return `'testing@example.com'`", "anchor": "requires-connexecute-that-will-return-testingexamplecom", "heading_level": 1, "md_text": "```", "url": "https://docs.pydantic.dev/latest/docs/concepts/validation_decorator/#requires-connexecute-that-will-return-testingexamplecom", "page": "docs/concepts/validation_decorator", "source_site": "pydantic"}
{"title": "Compatibility with type checkers", "anchor": "compatibility-with-type-checkers", "heading_level": 2, "md_text": "As the [`validate_call()`][pydantic.validate_call] decorator preserves the decorated function's signature,\nit should be compatible with type checkers (such as mypy and pyright). However, due to current limitations in the Python type system,\nthe [`raw_function`](#accessing-the-original-function) or other attributes won't be recognized and you will\nneed to suppress the error using (usually with a `# type: ignore` comment).", "url": "https://docs.pydantic.dev/latest/docs/concepts/validation_decorator/#compatibility-with-type-checkers", "page": "docs/concepts/validation_decorator", "source_site": "pydantic"}
{"title": "Custom configuration", "anchor": "custom-configuration", "heading_level": 2, "md_text": "Similarly to Pydantic models, the `config` parameter of the decorator can be used to specify a custom configuration:\n\n```python\nfrom pydantic import ConfigDict, ValidationError, validate_call\n\n\nclass Foobar:\n    def __init__(self, v: str):\n        self.v = v\n\n    def __add__(self, other: 'Foobar') -> str:\n        return f'{self} + {other}'\n\n    def __str__(self) -> str:\n        return f'Foobar({self.v})'\n\n\n@validate_call(config=ConfigDict(arbitrary_types_allowed=True))\ndef add_foobars(a: Foobar, b: Foobar):\n    return a + b\n\n\nc = add_foobars(Foobar('a'), Foobar('b'))\nprint(c)\n#> Foobar(a) + Foobar(b)\n\ntry:\n    add_foobars(1, 2)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for add_foobars\n    0\n      Input should be an instance of Foobar [type=is_instance_of, input_value=1, input_type=int]\n    1\n      Input should be an instance of Foobar [type=is_instance_of, input_value=2, input_type=int]\n    \"\"\"\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/validation_decorator/#custom-configuration", "page": "docs/concepts/validation_decorator", "source_site": "pydantic"}
{"title": "Extension \u2014 validating arguments before calling a function", "anchor": "extension-validating-arguments-before-calling-a-function", "heading_level": 2, "md_text": "In some cases, it may be helpful to separate validation of a function's arguments from the function call itself.\nThis might be useful when a particular function is costly/time consuming.\n\nHere's an example of a workaround you can use for that pattern:\n\n```python\nfrom pydantic import validate_call\n\n\n@validate_call\ndef validate_foo(a: int, b: int):\n    def foo():\n        return a + b\n\n    return foo\n\n\nfoo = validate_foo(a=1, b=2)\nprint(foo())\n#> 3\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/validation_decorator/#extension-validating-arguments-before-calling-a-function", "page": "docs/concepts/validation_decorator", "source_site": "pydantic"}
{"title": "Validation exception", "anchor": "validation-exception", "heading_level": 3, "md_text": "Currently upon validation failure, a standard Pydantic [`ValidationError`][pydantic_core.ValidationError] is raised\n(see [model error handling](models.md#error-handling) for details). This is also true for missing required arguments,\nwhere Python normally raises a [`TypeError`][].", "url": "https://docs.pydantic.dev/latest/docs/concepts/validation_decorator/#validation-exception", "page": "docs/concepts/validation_decorator", "source_site": "pydantic"}
{"title": "Performance", "anchor": "performance", "heading_level": 3, "md_text": "We've made a big effort to make Pydantic as performant as possible. While the inspection of the decorated\nfunction is only performed once, there will still be a performance impact when making calls to the function\ncompared to using the original function.\n\nIn many situations, this will have little or no noticeable effect. However, be aware that\n[`validate_call()`][pydantic.validate_call] is not an equivalent or alternative to function\ndefinitions in strongly typed languages, and it never will be.", "url": "https://docs.pydantic.dev/latest/docs/concepts/validation_decorator/#performance", "page": "docs/concepts/validation_decorator", "source_site": "pydantic"}
{"title": "json_schema", "anchor": null, "heading_level": 0, "md_text": "??? api \"API Documentation\"\n    [`pydantic.json_schema`][pydantic.json_schema]<br>\n\nPydantic allows automatic creation and customization of JSON schemas from models.\nThe generated JSON schemas are compliant with the following specifications:\n\n* [JSON Schema Draft 2020-12](https://json-schema.org/draft/2020-12/release-notes.html)\n* [OpenAPI Specification v3.1.0](https://github.com/OAI/OpenAPI-Specification).", "url": "https://docs.pydantic.dev/latest/docs/concepts/json_schema/", "page": "docs/concepts/json_schema", "source_site": "pydantic"}
{"title": "Generating JSON Schema", "anchor": "generating-json-schema", "heading_level": 2, "md_text": "Use the following functions to generate JSON schema:\n\n* [`BaseModel.model_json_schema`][pydantic.main.BaseModel.model_json_schema] returns a jsonable dict of a model's schema.\n* [`TypeAdapter.json_schema`][pydantic.type_adapter.TypeAdapter.json_schema] returns a jsonable dict of an adapted type's schema.\n\n!!! note\n    These methods are not to be confused with [`BaseModel.model_dump_json`][pydantic.main.BaseModel.model_dump_json]\n    and [`TypeAdapter.dump_json`][pydantic.type_adapter.TypeAdapter.dump_json], which serialize instances of the\n    model or adapted type, respectively. These methods return JSON strings. In comparison,\n    [`BaseModel.model_json_schema`][pydantic.main.BaseModel.model_json_schema] and\n    [`TypeAdapter.json_schema`][pydantic.type_adapter.TypeAdapter.json_schema] return a jsonable dict\n    representing the JSON schema of the model or adapted type, respectively.\n\n!!! note \"on the \"jsonable\" nature of JSON schema\"\n    Regarding the \"jsonable\" nature of the [`model_json_schema`][pydantic.main.BaseModel.model_json_schema] results,\n    calling `json.dumps(m.model_json_schema())`on some `BaseModel` `m` returns a valid JSON string. Similarly, for\n    [`TypeAdapter.json_schema`][pydantic.type_adapter.TypeAdapter.json_schema], calling\n    `json.dumps(TypeAdapter(<some_type>).json_schema())` returns a valid JSON string.\n\n!!! tip\n    Pydantic offers support for both of:\n\n    1. [Customizing JSON Schema](#customizing-json-schema)\n    2. [Customizing the JSON Schema Generation Process](#customizing-the-json-schema-generation-process)\n\n    The first approach generally has a more narrow scope, allowing for customization of the JSON schema for\n    more specific cases and types. The second approach generally has a more broad scope, allowing for customization\n    of the JSON schema generation process overall. The same effects can be achieved with either approach, but\n    depending on your use case, one approach might offer a more simple solution than the other.\n\nHere's an example of generating JSON schema from a `BaseModel`:\n\n```python {output=\"json\"}\nimport json\nfrom enum import Enum\nfrom typing import Annotated, Union\n\nfrom pydantic import BaseModel, Field\nfrom pydantic.config import ConfigDict\n\n\nclass FooBar(BaseModel):\n    count: int\n    size: Union[float, None] = None\n\n\nclass Gender(str, Enum):\n    male = 'male'\n    female = 'female'\n    other = 'other'\n    not_given = 'not_given'\n\n\nclass MainModel(BaseModel):\n    \"\"\"\n    This is the description of the main model\n    \"\"\"\n\n    model_config = ConfigDict(title='Main')\n\n    foo_bar: FooBar\n    gender: Annotated[Union[Gender, None], Field(alias='Gender')] = None\n    snap: int = Field(\n        default=42,\n        title='The Snap',\n        description='this is the value of snap',\n        gt=30,\n        lt=50,\n    )\n\n\nmain_model_schema = MainModel.model_json_schema()  # (1)!\nprint(json.dumps(main_model_schema, indent=2))  # (2)!\n\"\"\"\n{\n  \"$defs\": {\n    \"FooBar\": {\n      \"properties\": {\n        \"count\": {\n          \"title\": \"Count\",\n          \"type\": \"integer\"\n        },\n        \"size\": {\n          \"anyOf\": [\n            {\n              \"type\": \"number\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ],\n          \"default\": null,\n          \"title\": \"Size\"\n        }\n      },\n      \"required\": [\n        \"count\"\n      ],\n      \"title\": \"FooBar\",\n      \"type\": \"object\"\n    },\n    \"Gender\": {\n      \"enum\": [\n        \"male\",\n        \"female\",\n        \"other\",\n        \"not_given\"\n      ],\n      \"title\": \"Gender\",\n      \"type\": \"string\"\n    }\n  },\n  \"description\": \"This is the description of the main model\",\n  \"properties\": {\n    \"foo_bar\": {\n      \"$ref\": \"#/$defs/FooBar\"\n    },\n    \"Gender\": {\n      \"anyOf\": [\n        {\n          \"$ref\": \"#/$defs/Gender\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"default\": null\n    },\n    \"snap\": {\n      \"default\": 42,\n      \"description\": \"this is the value of snap\",\n      \"exclusiveMaximum\": 50,\n      \"exclusiveMinimum\": 30,\n      \"title\": \"The Snap\",\n      \"type\": \"integer\"\n    }\n  },\n  \"required\": [\n    \"foo_bar\"\n  ],\n  \"title\": \"Main\",\n  \"type\": \"object\"\n}\n\"\"\"\n```\n\n1. This produces a \"jsonable\" dict of `MainModel`'s schema.\n2. Calling `json.dumps` on the schema dict produces a JSON string.\n\nThe [`TypeAdapter`][pydantic.type_adapter.TypeAdapter] class lets you create an object with methods for validating, serializing,\nand producing JSON schemas for arbitrary types. This serves as a complete replacement for `schema_of` in\nPydantic V1 (which is now deprecated).\n\nHere's an example of generating JSON schema from a [`TypeAdapter`][pydantic.type_adapter.TypeAdapter]:\n\n```python\nfrom pydantic import TypeAdapter\n\nadapter = TypeAdapter(list[int])\nprint(adapter.json_schema())\n#> {'items': {'type': 'integer'}, 'type': 'array'}\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/json_schema/#generating-json-schema", "page": "docs/concepts/json_schema", "source_site": "pydantic"}
{"title": "Generating JSON Schema", "anchor": "generating-json-schema", "heading_level": 2, "md_text": "You can also generate JSON schemas for combinations of [`BaseModel`s][pydantic.main.BaseModel]\nand [`TypeAdapter`s][pydantic.type_adapter.TypeAdapter], as shown in this example:\n\n```python {output=\"json\"}\nimport json\nfrom typing import Union\n\nfrom pydantic import BaseModel, TypeAdapter\n\n\nclass Cat(BaseModel):\n    name: str\n    color: str\n\n\nclass Dog(BaseModel):\n    name: str\n    breed: str\n\n\nta = TypeAdapter(Union[Cat, Dog])\nta_schema = ta.json_schema()\nprint(json.dumps(ta_schema, indent=2))\n\"\"\"\n{\n  \"$defs\": {\n    \"Cat\": {\n      \"properties\": {\n        \"name\": {\n          \"title\": \"Name\",\n          \"type\": \"string\"\n        },\n        \"color\": {\n          \"title\": \"Color\",\n          \"type\": \"string\"\n        }\n      },\n      \"required\": [\n        \"name\",\n        \"color\"\n      ],\n      \"title\": \"Cat\",\n      \"type\": \"object\"\n    },\n    \"Dog\": {\n      \"properties\": {\n        \"name\": {\n          \"title\": \"Name\",\n          \"type\": \"string\"\n        },\n        \"breed\": {\n          \"title\": \"Breed\",\n          \"type\": \"string\"\n        }\n      },\n      \"required\": [\n        \"name\",\n        \"breed\"\n      ],\n      \"title\": \"Dog\",\n      \"type\": \"object\"\n    }\n  },\n  \"anyOf\": [\n    {\n      \"$ref\": \"#/$defs/Cat\"\n    },\n    {\n      \"$ref\": \"#/$defs/Dog\"\n    }\n  ]\n}\n\"\"\"\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/json_schema/#generating-json-schema", "page": "docs/concepts/json_schema", "source_site": "pydantic"}
{"title": "Configuring the `JsonSchemaMode`", "anchor": "configuring-the-jsonschemamode", "heading_level": 3, "md_text": "Specify the mode of JSON schema generation via the `mode` parameter in the\n[`model_json_schema`][pydantic.main.BaseModel.model_json_schema] and\n[`TypeAdapter.json_schema`][pydantic.type_adapter.TypeAdapter.json_schema] methods. By default, the mode is set to\n`'validation'`, which produces a JSON schema corresponding to the model's validation schema.\n\nThe [`JsonSchemaMode`][pydantic.json_schema.JsonSchemaMode] is a type alias that represents the available options for the `mode` parameter:\n\n* `'validation'`\n* `'serialization'`\n\nHere's an example of how to specify the `mode` parameter, and how it affects the generated JSON schema:\n\n```python\nfrom decimal import Decimal\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    a: Decimal = Decimal('12.34')\n\n\nprint(Model.model_json_schema(mode='validation'))\n\"\"\"\n{\n    'properties': {\n        'a': {\n            'anyOf': [\n                {'type': 'number'},\n                {\n                    'pattern': '^(?!^[-+.]*$)[+-]?0*\\\\d*\\\\.?\\\\d*$',\n                    'type': 'string',\n                },\n            ],\n            'default': '12.34',\n            'title': 'A',\n        }\n    },\n    'title': 'Model',\n    'type': 'object',\n}\n\"\"\"\n\nprint(Model.model_json_schema(mode='serialization'))\n\"\"\"\n{\n    'properties': {\n        'a': {\n            'default': '12.34',\n            'pattern': '^(?!^[-+.]*$)[+-]?0*\\\\d*\\\\.?\\\\d*$',\n            'title': 'A',\n            'type': 'string',\n        }\n    },\n    'title': 'Model',\n    'type': 'object',\n}\n\"\"\"\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/json_schema/#configuring-the-jsonschemamode", "page": "docs/concepts/json_schema", "source_site": "pydantic"}
{"title": "Customizing JSON Schema", "anchor": "customizing-json-schema", "heading_level": 2, "md_text": "The generated JSON schema can be customized at both the field level and model level via:\n\n1. [Field-level customization](#field-level-customization) with the [`Field`][pydantic.fields.Field] constructor\n2. [Model-level customization](#model-level-customization) with [`model_config`][pydantic.config.ConfigDict]\n\nAt both the field and model levels, you can use the `json_schema_extra` option to add extra information to the JSON schema.\nThe [Using `json_schema_extra`](#using-json_schema_extra) section below provides more details on this option.\n\nFor custom types, Pydantic offers other tools for customizing JSON schema generation:\n\n1. [`WithJsonSchema` annotation](#withjsonschema-annotation)\n2. [`SkipJsonSchema` annotation](#skipjsonschema-annotation)\n3. [Implementing `__get_pydantic_core_schema__`](#implementing_get_pydantic_core_schema)\n4. [Implementing `__get_pydantic_json_schema__`](#implementing_get_pydantic_json_schema)", "url": "https://docs.pydantic.dev/latest/docs/concepts/json_schema/#customizing-json-schema", "page": "docs/concepts/json_schema", "source_site": "pydantic"}
{"title": "Field-Level Customization", "anchor": "field-level-customization", "heading_level": 3, "md_text": "Optionally, the [`Field`][pydantic.fields.Field] function can be used to provide extra information about the field\nand validations.\n\nSome field parameters are used exclusively to customize the generated JSON Schema:\n\n* `title`: The title of the field.\n* `description`: The description of the field.\n* `examples`: The examples of the field.\n* `json_schema_extra`: Extra JSON Schema properties to be added to the field.\n* `field_title_generator`: A function that programmatically sets the field's title, based on its name and info.\n\nHere's an example:\n\n```python {output=\"json\"}\nimport json\n\nfrom pydantic import BaseModel, EmailStr, Field, SecretStr\n\n\nclass User(BaseModel):\n    age: int = Field(description='Age of the user')\n    email: EmailStr = Field(examples=['marcelo@mail.com'])\n    name: str = Field(title='Username')\n    password: SecretStr = Field(\n        json_schema_extra={\n            'title': 'Password',\n            'description': 'Password of the user',\n            'examples': ['123456'],\n        }\n    )\n\n\nprint(json.dumps(User.model_json_schema(), indent=2))\n\"\"\"\n{\n  \"properties\": {\n    \"age\": {\n      \"description\": \"Age of the user\",\n      \"title\": \"Age\",\n      \"type\": \"integer\"\n    },\n    \"email\": {\n      \"examples\": [\n        \"marcelo@mail.com\"\n      ],\n      \"format\": \"email\",\n      \"title\": \"Email\",\n      \"type\": \"string\"\n    },\n    \"name\": {\n      \"title\": \"Username\",\n      \"type\": \"string\"\n    },\n    \"password\": {\n      \"description\": \"Password of the user\",\n      \"examples\": [\n        \"123456\"\n      ],\n      \"format\": \"password\",\n      \"title\": \"Password\",\n      \"type\": \"string\",\n      \"writeOnly\": true\n    }\n  },\n  \"required\": [\n    \"age\",\n    \"email\",\n    \"name\",\n    \"password\"\n  ],\n  \"title\": \"User\",\n  \"type\": \"object\"\n}\n\"\"\"\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/json_schema/#field-level-customization", "page": "docs/concepts/json_schema", "source_site": "pydantic"}
{"title": "Unenforced `Field` constraints", "anchor": "unenforced-field-constraints", "heading_level": 4, "md_text": "If Pydantic finds constraints which are not being enforced, an error will be raised. If you want to force the\nconstraint to appear in the schema, even though it's not being checked upon parsing, you can use variadic arguments\nto [`Field`][pydantic.fields.Field] with the raw schema attribute name:\n\n```python\nfrom pydantic import BaseModel, Field, PositiveInt\n\ntry:\n    # this won't work since `PositiveInt` takes precedence over the\n    # constraints defined in `Field`, meaning they're ignored\n    class Model(BaseModel):\n        foo: PositiveInt = Field(lt=10)\n\nexcept ValueError as e:\n    print(e)", "url": "https://docs.pydantic.dev/latest/docs/concepts/json_schema/#unenforced-field-constraints", "page": "docs/concepts/json_schema", "source_site": "pydantic"}
{"title": "here both constraints will be enforced:", "anchor": "here-both-constraints-will-be-enforced", "heading_level": 1, "md_text": "class ModelB(BaseModel):\n    # Here both constraints will be applied and the schema\n    # will be generated correctly\n    foo: int = Field(gt=0, lt=10)\n\n\nprint(ModelB.model_json_schema())\n\"\"\"\n{\n    'properties': {\n        'foo': {\n            'exclusiveMaximum': 10,\n            'exclusiveMinimum': 0,\n            'title': 'Foo',\n            'type': 'integer',\n        }\n    },\n    'required': ['foo'],\n    'title': 'ModelB',\n    'type': 'object',\n}\n\"\"\"\n```\n\nYou can specify JSON schema modifications via the [`Field`][pydantic.fields.Field] constructor via [`typing.Annotated`][] as well:\n\n```python {output=\"json\"}\nimport json\nfrom typing import Annotated\nfrom uuid import uuid4\n\nfrom pydantic import BaseModel, Field\n\n\nclass Foo(BaseModel):\n    id: Annotated[str, Field(default_factory=lambda: uuid4().hex)]\n    name: Annotated[str, Field(max_length=256)] = Field(\n        'Bar', title='CustomName'\n    )\n\n\nprint(json.dumps(Foo.model_json_schema(), indent=2))\n\"\"\"\n{\n  \"properties\": {\n    \"id\": {\n      \"title\": \"Id\",\n      \"type\": \"string\"\n    },\n    \"name\": {\n      \"default\": \"Bar\",\n      \"maxLength\": 256,\n      \"title\": \"CustomName\",\n      \"type\": \"string\"\n    }\n  },\n  \"title\": \"Foo\",\n  \"type\": \"object\"\n}\n\"\"\"\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/json_schema/#here-both-constraints-will-be-enforced", "page": "docs/concepts/json_schema", "source_site": "pydantic"}
{"title": "Programmatic field title generation", "anchor": "programmatic-field-title-generation", "heading_level": 3, "md_text": "The `field_title_generator` parameter can be used to programmatically generate the title for a field based on its name and info.\n\nSee the following example:\n\n```python\nimport json\n\nfrom pydantic import BaseModel, Field\nfrom pydantic.fields import FieldInfo\n\n\ndef make_title(field_name: str, field_info: FieldInfo) -> str:\n    return field_name.upper()\n\n\nclass Person(BaseModel):\n    name: str = Field(field_title_generator=make_title)\n    age: int = Field(field_title_generator=make_title)\n\n\nprint(json.dumps(Person.model_json_schema(), indent=2))\n\"\"\"\n{\n  \"properties\": {\n    \"name\": {\n      \"title\": \"NAME\",\n      \"type\": \"string\"\n    },\n    \"age\": {\n      \"title\": \"AGE\",\n      \"type\": \"integer\"\n    }\n  },\n  \"required\": [\n    \"name\",\n    \"age\"\n  ],\n  \"title\": \"Person\",\n  \"type\": \"object\"\n}\n\"\"\"\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/json_schema/#programmatic-field-title-generation", "page": "docs/concepts/json_schema", "source_site": "pydantic"}
{"title": "Model-Level Customization", "anchor": "model-level-customization", "heading_level": 3, "md_text": "You can also use [model config][pydantic.config.ConfigDict] to customize JSON schema generation on a model.\nSpecifically, the following config options are relevant:\n\n* [`title`][pydantic.config.ConfigDict.title]\n* [`json_schema_extra`][pydantic.config.ConfigDict.json_schema_extra]\n* [`json_schema_mode_override`][pydantic.config.ConfigDict.json_schema_mode_override]\n* [`field_title_generator`][pydantic.config.ConfigDict.field_title_generator]\n* [`model_title_generator`][pydantic.config.ConfigDict.model_title_generator]", "url": "https://docs.pydantic.dev/latest/docs/concepts/json_schema/#model-level-customization", "page": "docs/concepts/json_schema", "source_site": "pydantic"}
{"title": "Using `json_schema_extra`", "anchor": "using-json_schema_extra", "heading_level": 3, "md_text": "The `json_schema_extra` option can be used to add extra information to the JSON schema, either at the\n[Field level](#field-level-customization) or at the [Model level](#model-level-customization).\nYou can pass a `dict` or a `Callable` to `json_schema_extra`.", "url": "https://docs.pydantic.dev/latest/docs/concepts/json_schema/#using-json_schema_extra", "page": "docs/concepts/json_schema", "source_site": "pydantic"}
{"title": "Using `json_schema_extra` with a `dict`", "anchor": "using-json_schema_extra-with-a-dict", "heading_level": 4, "md_text": "You can pass a `dict` to `json_schema_extra` to add extra information to the JSON schema:\n\n```python {output=\"json\"}\nimport json\n\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass Model(BaseModel):\n    a: str\n\n    model_config = ConfigDict(json_schema_extra={'examples': [{'a': 'Foo'}]})\n\n\nprint(json.dumps(Model.model_json_schema(), indent=2))\n\"\"\"\n{\n  \"examples\": [\n    {\n      \"a\": \"Foo\"\n    }\n  ],\n  \"properties\": {\n    \"a\": {\n      \"title\": \"A\",\n      \"type\": \"string\"\n    }\n  },\n  \"required\": [\n    \"a\"\n  ],\n  \"title\": \"Model\",\n  \"type\": \"object\"\n}\n\"\"\"\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/json_schema/#using-json_schema_extra-with-a-dict", "page": "docs/concepts/json_schema", "source_site": "pydantic"}
{"title": "Using `json_schema_extra` with a `Callable`", "anchor": "using-json_schema_extra-with-a-callable", "heading_level": 4, "md_text": "You can pass a `Callable` to `json_schema_extra` to modify the JSON schema with a function:\n\n```python {output=\"json\"}\nimport json\n\nfrom pydantic import BaseModel, Field\n\n\ndef pop_default(s):\n    s.pop('default')\n\n\nclass Model(BaseModel):\n    a: int = Field(default=1, json_schema_extra=pop_default)\n\n\nprint(json.dumps(Model.model_json_schema(), indent=2))\n\"\"\"\n{\n  \"properties\": {\n    \"a\": {\n      \"title\": \"A\",\n      \"type\": \"integer\"\n    }\n  },\n  \"title\": \"Model\",\n  \"type\": \"object\"\n}\n\"\"\"\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/json_schema/#using-json_schema_extra-with-a-callable", "page": "docs/concepts/json_schema", "source_site": "pydantic"}
{"title": "Merging `json_schema_extra`", "anchor": "merging-json_schema_extra", "heading_level": 4, "md_text": "Starting in v2.9, Pydantic merges `json_schema_extra` dictionaries from annotated types.\nThis pattern offers a more additive approach to merging rather than the previous override behavior.\nThis can be quite helpful for cases of reusing json schema extra information across multiple types.\n\nWe viewed this change largely as a bug fix, as it resolves unintentional differences in the `json_schema_extra` merging behavior\nbetween `BaseModel` and `TypeAdapter` instances - see [this issue](https://github.com/pydantic/pydantic/issues/9210)\nfor more details.\n\n```python\nimport json\nfrom typing import Annotated\n\nfrom typing_extensions import TypeAlias\n\nfrom pydantic import Field, TypeAdapter\n\nExternalType: TypeAlias = Annotated[\n    int, Field(json_schema_extra={'key1': 'value1'})\n]\n\nta = TypeAdapter(\n    Annotated[ExternalType, Field(json_schema_extra={'key2': 'value2'})]\n)\nprint(json.dumps(ta.json_schema(), indent=2))\n\"\"\"\n{\n  \"key1\": \"value1\",\n  \"key2\": \"value2\",\n  \"type\": \"integer\"\n}\n\"\"\"\n```\n\n!!! note\n    We no longer (and never fully did) support composing a mix of `dict` and `callable` type `json_schema_extra` specifications.\n    If this is a requirement for your use case, please [open a pydantic issue](https://github.com/pydantic/pydantic/issues/new/choose) and explain your situation - we'd be happy to reconsider this decision when presented with a compelling case.", "url": "https://docs.pydantic.dev/latest/docs/concepts/json_schema/#merging-json_schema_extra", "page": "docs/concepts/json_schema", "source_site": "pydantic"}
{"title": "`WithJsonSchema` annotation", "anchor": "withjsonschema-annotation", "heading_level": 3, "md_text": "??? api \"API Documentation\"\n    [`pydantic.json_schema.WithJsonSchema`][pydantic.json_schema.WithJsonSchema]<br>\n\n!!! tip\n    Using [`WithJsonSchema`][pydantic.json_schema.WithJsonSchema] is preferred over\n    [implementing `__get_pydantic_json_schema__`](#implementing_get_pydantic_json_schema) for custom types,\n    as it's more simple and less error-prone.\n\nThe [`WithJsonSchema`][pydantic.json_schema.WithJsonSchema] annotation can be used to override the generated (base)\nJSON schema for a given type without the need to implement `__get_pydantic_core_schema__`\nor `__get_pydantic_json_schema__` on the type itself. Note that this overrides the whole JSON Schema generation process\nfor the field (in the following example, the `'type'` also needs to be provided).\n\n```python {output=\"json\"}\nimport json\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, WithJsonSchema\n\nMyInt = Annotated[\n    int,\n    WithJsonSchema({'type': 'integer', 'examples': [1, 0, -1]}),\n]\n\n\nclass Model(BaseModel):\n    a: MyInt\n\n\nprint(json.dumps(Model.model_json_schema(), indent=2))\n\"\"\"\n{\n  \"properties\": {\n    \"a\": {\n      \"examples\": [\n        1,\n        0,\n        -1\n      ],\n      \"title\": \"A\",\n      \"type\": \"integer\"\n    }\n  },\n  \"required\": [\n    \"a\"\n  ],\n  \"title\": \"Model\",\n  \"type\": \"object\"\n}\n\"\"\"\n```\n\n!!! note\n    You might be tempted to use the [`WithJsonSchema`][pydantic.json_schema.WithJsonSchema] annotation\n    to fine-tune the JSON Schema of fields having [validators](./validators.md) attached. Instead, it\n    is recommended to use [the `json_schema_input_type` argument](./validators.md#json-schema-and-field-validators).", "url": "https://docs.pydantic.dev/latest/docs/concepts/json_schema/#withjsonschema-annotation", "page": "docs/concepts/json_schema", "source_site": "pydantic"}
{"title": "`SkipJsonSchema` annotation", "anchor": "skipjsonschema-annotation", "heading_level": 3, "md_text": "??? api \"API Documentation\"\n    [`pydantic.json_schema.SkipJsonSchema`][pydantic.json_schema.SkipJsonSchema]<br>\n\nThe [`SkipJsonSchema`][pydantic.json_schema.SkipJsonSchema] annotation can be used to skip an included field (or part of a field's specifications)\nfrom the generated JSON schema. See the API docs for more details.", "url": "https://docs.pydantic.dev/latest/docs/concepts/json_schema/#skipjsonschema-annotation", "page": "docs/concepts/json_schema", "source_site": "pydantic"}
{"title": "Implementing `__get_pydantic_core_schema__` <a name=\"implementing_get_pydantic_core_schema\"></a>", "anchor": "implementing-__get_pydantic_core_schema__-a-nameimplementing_get_pydantic_core_schemaa", "heading_level": 3, "md_text": "Custom types (used as `field_name: TheType` or `field_name: Annotated[TheType, ...]`) as well as `Annotated` metadata\n(used as `field_name: Annotated[int, SomeMetadata]`)\ncan modify or override the generated schema by implementing `__get_pydantic_core_schema__`.\nThis method receives two positional arguments:\n\n1. The type annotation that corresponds to this type (so in the case of `TheType[T][int]` it would be `TheType[int]`).\n2. A handler/callback to call the next implementer of `__get_pydantic_core_schema__`.\n\nThe handler system works just like [*wrap* field validators](validators.md#field-wrap-validator).\nIn this case the input is the type and the output is a `core_schema`.\n\nHere is an example of a custom type that *overrides* the generated `core_schema`:\n\n```python\nfrom dataclasses import dataclass\nfrom typing import Any\n\nfrom pydantic_core import core_schema\n\nfrom pydantic import BaseModel, GetCoreSchemaHandler\n\n\n@dataclass\nclass CompressedString:\n    dictionary: dict[int, str]\n    text: list[int]\n\n    def build(self) -> str:\n        return ' '.join([self.dictionary[key] for key in self.text])\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source: type[Any], handler: GetCoreSchemaHandler\n    ) -> core_schema.CoreSchema:\n        assert source is CompressedString\n        return core_schema.no_info_after_validator_function(\n            cls._validate,\n            core_schema.str_schema(),\n            serialization=core_schema.plain_serializer_function_ser_schema(\n                cls._serialize,\n                info_arg=False,\n                return_schema=core_schema.str_schema(),\n            ),\n        )\n\n    @staticmethod\n    def _validate(value: str) -> 'CompressedString':\n        inverse_dictionary: dict[str, int] = {}\n        text: list[int] = []\n        for word in value.split(' '):\n            if word not in inverse_dictionary:\n                inverse_dictionary[word] = len(inverse_dictionary)\n            text.append(inverse_dictionary[word])\n        return CompressedString(\n            {v: k for k, v in inverse_dictionary.items()}, text\n        )\n\n    @staticmethod\n    def _serialize(value: 'CompressedString') -> str:\n        return value.build()\n\n\nclass MyModel(BaseModel):\n    value: CompressedString\n\n\nprint(MyModel.model_json_schema())\n\"\"\"\n{\n    'properties': {'value': {'title': 'Value', 'type': 'string'}},\n    'required': ['value'],\n    'title': 'MyModel',\n    'type': 'object',\n}\n\"\"\"\nprint(MyModel(value='fox fox fox dog fox'))\n\"\"\"\nvalue = CompressedString(dictionary={0: 'fox', 1: 'dog'}, text=[0, 0, 0, 1, 0])\n\"\"\"\n\nprint(MyModel(value='fox fox fox dog fox').model_dump(mode='json'))\n#> {'value': 'fox fox fox dog fox'}\n```\n\nSince Pydantic would not know how to generate a schema for `CompressedString`, if you call `handler(source)` in its\n`__get_pydantic_core_schema__` method you would get a `pydantic.errors.PydanticSchemaGenerationError` error.\nThis will be the case for most custom types, so you almost never want to call into `handler` for custom types.\n\nThe process for `Annotated` metadata is much the same except that you can generally call into `handler` to have\nPydantic handle generating the schema.\n\n```python\nfrom collections.abc import Sequence\nfrom dataclasses import dataclass\nfrom typing import Annotated, Any\n\nfrom pydantic_core import core_schema\n\nfrom pydantic import BaseModel, GetCoreSchemaHandler, ValidationError\n\n\n@dataclass\nclass RestrictCharacters:\n    alphabet: Sequence[str]\n\n    def __get_pydantic_core_schema__(\n        self, source: type[Any], handler: GetCoreSchemaHandler\n    ) -> core_schema.CoreSchema:\n        if not self.alphabet:\n            raise ValueError('Alphabet may not be empty')\n        schema = handler(\n            source\n        )  # get the CoreSchema from the type / inner constraints\n        if schema['type'] != 'str':\n            raise TypeError('RestrictCharacters can only be applied to strings')\n        return core_schema.no_info_after_validator_function(\n            self.validate,\n            schema,\n        )\n\n    def validate(self, value: str) -> str:\n        if any(c not in self.alphabet for c in value):\n            raise ValueError(\n                f'{value!r} is not restricted to {self.alphabet!r}'\n            )\n        return value\n\n\nclass MyModel(BaseModel):\n    value: Annotated[str, RestrictCharacters('ABC')]\n\n\nprint(MyModel.model_json_schema())\n\"\"\"\n{\n    'properties': {'value': {'title': 'Value', 'type': 'string'}},\n    'required': ['value'],\n    'title': 'MyModel',\n    'type': 'object',\n}\n\"\"\"\nprint(MyModel(value='CBA'))\n#> value='CBA'\n\ntry:\n    MyModel(value='XYZ')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for MyModel\n    value\n      Value error, 'XYZ' is not restricted to 'ABC' [type=value_error, input_value='XYZ', input_type=str]\n    \"\"\"\n```\n\nSo far we have been wrapping the schema, but if you just want to *modify* it or *ignore* it you can as well.\n\nTo modify the schema, first call the handler, then mutate the result:\n\n```python\nfrom typing import Annotated, Any\n\nfrom pydantic_core import ValidationError, core_schema", "url": "https://docs.pydantic.dev/latest/docs/concepts/json_schema/#implementing-__get_pydantic_core_schema__-a-nameimplementing_get_pydantic_core_schemaa", "page": "docs/concepts/json_schema", "source_site": "pydantic"}
{"title": "Implementing `__get_pydantic_core_schema__` <a name=\"implementing_get_pydantic_core_schema\"></a>", "anchor": "implementing-__get_pydantic_core_schema__-a-nameimplementing_get_pydantic_core_schemaa", "heading_level": 3, "md_text": "from pydantic import BaseModel, GetCoreSchemaHandler\n\n\nclass SmallString:\n    def __get_pydantic_core_schema__(\n        self,\n        source: type[Any],\n        handler: GetCoreSchemaHandler,\n    ) -> core_schema.CoreSchema:\n        schema = handler(source)\n        assert schema['type'] == 'str'\n        schema['max_length'] = 10  # modify in place\n        return schema\n\n\nclass MyModel(BaseModel):\n    value: Annotated[str, SmallString()]\n\n\ntry:\n    MyModel(value='too long!!!!!')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for MyModel\n    value\n      String should have at most 10 characters [type=string_too_long, input_value='too long!!!!!', input_type=str]\n    \"\"\"\n```\n\n!!! tip\n    Note that you *must* return a schema, even if you are just mutating it in place.\n\nTo override the schema completely, do not call the handler and return your own\n`CoreSchema`:\n\n```python\nfrom typing import Annotated, Any\n\nfrom pydantic_core import ValidationError, core_schema\n\nfrom pydantic import BaseModel, GetCoreSchemaHandler\n\n\nclass AllowAnySubclass:\n    def __get_pydantic_core_schema__(\n        self, source: type[Any], handler: GetCoreSchemaHandler\n    ) -> core_schema.CoreSchema:\n        # we can't call handler since it will fail for arbitrary types\n        def validate(value: Any) -> Any:\n            if not isinstance(value, source):\n                raise ValueError(\n                    f'Expected an instance of {source}, got an instance of {type(value)}'\n                )\n\n        return core_schema.no_info_plain_validator_function(validate)\n\n\nclass Foo:\n    pass\n\n\nclass Model(BaseModel):\n    f: Annotated[Foo, AllowAnySubclass()]\n\n\nprint(Model(f=Foo()))\n#> f=None\n\n\nclass NotFoo:\n    pass\n\n\ntry:\n    Model(f=NotFoo())\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    f\n      Value error, Expected an instance of <class '__main__.Foo'>, got an instance of <class '__main__.NotFoo'> [type=value_error, input_value=<__main__.NotFoo object at 0x0123456789ab>, input_type=NotFoo]\n    \"\"\"\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/json_schema/#implementing-__get_pydantic_core_schema__-a-nameimplementing_get_pydantic_core_schemaa", "page": "docs/concepts/json_schema", "source_site": "pydantic"}
{"title": "Implementing `__get_pydantic_json_schema__` <a name=\"implementing_get_pydantic_json_schema\"></a>", "anchor": "implementing-__get_pydantic_json_schema__-a-nameimplementing_get_pydantic_json_schemaa", "heading_level": 3, "md_text": "You can also implement `__get_pydantic_json_schema__` to modify or override the generated json schema.\nModifying this method only affects the JSON schema - it doesn't affect the core schema, which is used for validation and serialization.\n\nHere's an example of modifying the generated JSON schema:\n\n```python {output=\"json\"}\nimport json\nfrom typing import Any\n\nfrom pydantic_core import core_schema as cs\n\nfrom pydantic import GetCoreSchemaHandler, GetJsonSchemaHandler, TypeAdapter\nfrom pydantic.json_schema import JsonSchemaValue\n\n\nclass Person:\n    name: str\n    age: int\n\n    def __init__(self, name: str, age: int):\n        self.name = name\n        self.age = age\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source_type: Any, handler: GetCoreSchemaHandler\n    ) -> cs.CoreSchema:\n        return cs.typed_dict_schema(\n            {\n                'name': cs.typed_dict_field(cs.str_schema()),\n                'age': cs.typed_dict_field(cs.int_schema()),\n            },\n        )\n\n    @classmethod\n    def __get_pydantic_json_schema__(\n        cls, core_schema: cs.CoreSchema, handler: GetJsonSchemaHandler\n    ) -> JsonSchemaValue:\n        json_schema = handler(core_schema)\n        json_schema = handler.resolve_ref_schema(json_schema)\n        json_schema['examples'] = [\n            {\n                'name': 'John Doe',\n                'age': 25,\n            }\n        ]\n        json_schema['title'] = 'Person'\n        return json_schema\n\n\nprint(json.dumps(TypeAdapter(Person).json_schema(), indent=2))\n\"\"\"\n{\n  \"examples\": [\n    {\n      \"age\": 25,\n      \"name\": \"John Doe\"\n    }\n  ],\n  \"properties\": {\n    \"name\": {\n      \"title\": \"Name\",\n      \"type\": \"string\"\n    },\n    \"age\": {\n      \"title\": \"Age\",\n      \"type\": \"integer\"\n    }\n  },\n  \"required\": [\n    \"name\",\n    \"age\"\n  ],\n  \"title\": \"Person\",\n  \"type\": \"object\"\n}\n\"\"\"\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/json_schema/#implementing-__get_pydantic_json_schema__-a-nameimplementing_get_pydantic_json_schemaa", "page": "docs/concepts/json_schema", "source_site": "pydantic"}
{"title": "Using `field_title_generator`", "anchor": "using-field_title_generator", "heading_level": 3, "md_text": "The `field_title_generator` parameter can be used to programmatically generate the title for a field based on its name and info.\nThis is similar to the field level `field_title_generator`, but the `ConfigDict` option will be applied to all fields of the class.\n\nSee the following example:\n\n```python\nimport json\n\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass Person(BaseModel):\n    model_config = ConfigDict(\n        field_title_generator=lambda field_name, field_info: field_name.upper()\n    )\n    name: str\n    age: int\n\n\nprint(json.dumps(Person.model_json_schema(), indent=2))\n\"\"\"\n{\n  \"properties\": {\n    \"name\": {\n      \"title\": \"NAME\",\n      \"type\": \"string\"\n    },\n    \"age\": {\n      \"title\": \"AGE\",\n      \"type\": \"integer\"\n    }\n  },\n  \"required\": [\n    \"name\",\n    \"age\"\n  ],\n  \"title\": \"Person\",\n  \"type\": \"object\"\n}\n\"\"\"\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/json_schema/#using-field_title_generator", "page": "docs/concepts/json_schema", "source_site": "pydantic"}
{"title": "Using `model_title_generator`", "anchor": "using-model_title_generator", "heading_level": 3, "md_text": "The `model_title_generator` config option is similar to the `field_title_generator` option, but it applies to the title of the model itself,\nand accepts the model class as input.\n\nSee the following example:\n\n```python\nimport json\n\nfrom pydantic import BaseModel, ConfigDict\n\n\ndef make_title(model: type) -> str:\n    return f'Title-{model.__name__}'\n\n\nclass Person(BaseModel):\n    model_config = ConfigDict(model_title_generator=make_title)\n    name: str\n    age: int\n\n\nprint(json.dumps(Person.model_json_schema(), indent=2))\n\"\"\"\n{\n  \"properties\": {\n    \"name\": {\n      \"title\": \"Name\",\n      \"type\": \"string\"\n    },\n    \"age\": {\n      \"title\": \"Age\",\n      \"type\": \"integer\"\n    }\n  },\n  \"required\": [\n    \"name\",\n    \"age\"\n  ],\n  \"title\": \"Title-Person\",\n  \"type\": \"object\"\n}\n\"\"\"\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/json_schema/#using-model_title_generator", "page": "docs/concepts/json_schema", "source_site": "pydantic"}
{"title": "JSON schema types", "anchor": "json-schema-types", "heading_level": 2, "md_text": "Types, custom field types, and constraints (like `max_length`) are mapped to the corresponding spec formats in the\nfollowing priority order (when there is an equivalent available):\n\n1. [JSON Schema Core](https://json-schema.org/draft/2020-12/json-schema-core)\n2. [JSON Schema Validation](https://json-schema.org/draft/2020-12/json-schema-validation)\n3. [OpenAPI Data Types](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md#data-types)\n4. The standard `format` JSON field is used to define Pydantic extensions for more complex `string` sub-types.\n\nThe field schema mapping from Python or Pydantic to JSON schema is done as follows:\n\n{{ schema_mappings_table }}", "url": "https://docs.pydantic.dev/latest/docs/concepts/json_schema/#json-schema-types", "page": "docs/concepts/json_schema", "source_site": "pydantic"}
{"title": "Top-level schema generation", "anchor": "top-level-schema-generation", "heading_level": 2, "md_text": "You can also generate a top-level JSON schema that only includes a list of models and related\nsub-models in its `$defs`:\n\n```python {output=\"json\"}\nimport json\n\nfrom pydantic import BaseModel\nfrom pydantic.json_schema import models_json_schema\n\n\nclass Foo(BaseModel):\n    a: str = None\n\n\nclass Model(BaseModel):\n    b: Foo\n\n\nclass Bar(BaseModel):\n    c: int\n\n\n_, top_level_schema = models_json_schema(\n    [(Model, 'validation'), (Bar, 'validation')], title='My Schema'\n)\nprint(json.dumps(top_level_schema, indent=2))\n\"\"\"\n{\n  \"$defs\": {\n    \"Bar\": {\n      \"properties\": {\n        \"c\": {\n          \"title\": \"C\",\n          \"type\": \"integer\"\n        }\n      },\n      \"required\": [\n        \"c\"\n      ],\n      \"title\": \"Bar\",\n      \"type\": \"object\"\n    },\n    \"Foo\": {\n      \"properties\": {\n        \"a\": {\n          \"default\": null,\n          \"title\": \"A\",\n          \"type\": \"string\"\n        }\n      },\n      \"title\": \"Foo\",\n      \"type\": \"object\"\n    },\n    \"Model\": {\n      \"properties\": {\n        \"b\": {\n          \"$ref\": \"#/$defs/Foo\"\n        }\n      },\n      \"required\": [\n        \"b\"\n      ],\n      \"title\": \"Model\",\n      \"type\": \"object\"\n    }\n  },\n  \"title\": \"My Schema\"\n}\n\"\"\"\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/json_schema/#top-level-schema-generation", "page": "docs/concepts/json_schema", "source_site": "pydantic"}
{"title": "Customizing the JSON Schema Generation Process", "anchor": "customizing-the-json-schema-generation-process", "heading_level": 2, "md_text": "??? api \"API Documentation\"\n    [`pydantic.json_schema`][pydantic.json_schema.GenerateJsonSchema]<br>\n\nIf you need custom schema generation, you can use a `schema_generator`, modifying the\n[`GenerateJsonSchema`][pydantic.json_schema.GenerateJsonSchema] class as necessary for your application.\n\nThe various methods that can be used to produce JSON schema accept a keyword argument `schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema`, and you can pass your custom subclass to these methods in order to use your own approach to generating JSON schema.\n\n`GenerateJsonSchema` implements the translation of a type's `pydantic-core` schema into a JSON schema.\nBy design, this class breaks the JSON schema generation process into smaller methods that can be easily overridden in\nsubclasses to modify the \"global\" approach to generating JSON schema.\n\n```python\nfrom pydantic import BaseModel\nfrom pydantic.json_schema import GenerateJsonSchema\n\n\nclass MyGenerateJsonSchema(GenerateJsonSchema):\n    def generate(self, schema, mode='validation'):\n        json_schema = super().generate(schema, mode=mode)\n        json_schema['title'] = 'Customize title'\n        json_schema['$schema'] = self.schema_dialect\n        return json_schema\n\n\nclass MyModel(BaseModel):\n    x: int\n\n\nprint(MyModel.model_json_schema(schema_generator=MyGenerateJsonSchema))\n\"\"\"\n{\n    'properties': {'x': {'title': 'X', 'type': 'integer'}},\n    'required': ['x'],\n    'title': 'Customize title',\n    'type': 'object',\n    '$schema': 'https://json-schema.org/draft/2020-12/schema',\n}\n\"\"\"\n```\n\nBelow is an approach you can use to exclude any fields from the schema that don't have valid json schemas:\n\n```python\nfrom typing import Callable\n\nfrom pydantic_core import PydanticOmit, core_schema\n\nfrom pydantic import BaseModel\nfrom pydantic.json_schema import GenerateJsonSchema, JsonSchemaValue\n\n\nclass MyGenerateJsonSchema(GenerateJsonSchema):\n    def handle_invalid_for_json_schema(\n        self, schema: core_schema.CoreSchema, error_info: str\n    ) -> JsonSchemaValue:\n        raise PydanticOmit\n\n\ndef example_callable():\n    return 1\n\n\nclass Example(BaseModel):\n    name: str = 'example'\n    function: Callable = example_callable\n\n\ninstance_example = Example()\n\nvalidation_schema = instance_example.model_json_schema(\n    schema_generator=MyGenerateJsonSchema, mode='validation'\n)\nprint(validation_schema)\n\"\"\"\n{\n    'properties': {\n        'name': {'default': 'example', 'title': 'Name', 'type': 'string'}\n    },\n    'title': 'Example',\n    'type': 'object',\n}\n\"\"\"\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/json_schema/#customizing-the-json-schema-generation-process", "page": "docs/concepts/json_schema", "source_site": "pydantic"}
{"title": "JSON schema sorting", "anchor": "json-schema-sorting", "heading_level": 3, "md_text": "By default, Pydantic recursively sorts JSON schemas by alphabetically sorting keys. Notably, Pydantic skips sorting the values of the `properties` key,\nto preserve the order of the fields as they were defined in the model.\n\nIf you would like to customize this behavior, you can override the `sort` method in your custom `GenerateJsonSchema` subclass. The below example\nuses a no-op `sort` method to disable sorting entirely, which is reflected in the preserved order of the model fields and `json_schema_extra` keys:\n\n```python\nimport json\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field\nfrom pydantic.json_schema import GenerateJsonSchema, JsonSchemaValue\n\n\nclass MyGenerateJsonSchema(GenerateJsonSchema):\n    def sort(\n        self, value: JsonSchemaValue, parent_key: Optional[str] = None\n    ) -> JsonSchemaValue:\n        \"\"\"No-op, we don't want to sort schema values at all.\"\"\"\n        return value\n\n\nclass Bar(BaseModel):\n    c: str\n    b: str\n    a: str = Field(json_schema_extra={'c': 'hi', 'b': 'hello', 'a': 'world'})\n\n\njson_schema = Bar.model_json_schema(schema_generator=MyGenerateJsonSchema)\nprint(json.dumps(json_schema, indent=2))\n\"\"\"\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"c\": {\n      \"type\": \"string\",\n      \"title\": \"C\"\n    },\n    \"b\": {\n      \"type\": \"string\",\n      \"title\": \"B\"\n    },\n    \"a\": {\n      \"type\": \"string\",\n      \"c\": \"hi\",\n      \"b\": \"hello\",\n      \"a\": \"world\",\n      \"title\": \"A\"\n    }\n  },\n  \"required\": [\n    \"c\",\n    \"b\",\n    \"a\"\n  ],\n  \"title\": \"Bar\"\n}\n\"\"\"\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/json_schema/#json-schema-sorting", "page": "docs/concepts/json_schema", "source_site": "pydantic"}
{"title": "Customizing the `$ref`s in JSON Schema", "anchor": "customizing-the-refs-in-json-schema", "heading_level": 2, "md_text": "The format of `$ref`s can be altered by calling [`model_json_schema()`][pydantic.main.BaseModel.model_json_schema]\nor [`model_dump_json()`][pydantic.main.BaseModel.model_dump_json] with the `ref_template` keyword argument.\nThe definitions are always stored under the key `$defs`, but a specified prefix can be used for the references.\n\nThis is useful if you need to extend or modify the JSON schema default definitions location. For example, with OpenAPI:\n\n```python {output=\"json\"}\nimport json\n\nfrom pydantic import BaseModel\nfrom pydantic.type_adapter import TypeAdapter\n\n\nclass Foo(BaseModel):\n    a: int\n\n\nclass Model(BaseModel):\n    a: Foo\n\n\nadapter = TypeAdapter(Model)\n\nprint(\n    json.dumps(\n        adapter.json_schema(ref_template='#/components/schemas/{model}'),\n        indent=2,\n    )\n)\n\"\"\"\n{\n  \"$defs\": {\n    \"Foo\": {\n      \"properties\": {\n        \"a\": {\n          \"title\": \"A\",\n          \"type\": \"integer\"\n        }\n      },\n      \"required\": [\n        \"a\"\n      ],\n      \"title\": \"Foo\",\n      \"type\": \"object\"\n    }\n  },\n  \"properties\": {\n    \"a\": {\n      \"$ref\": \"#/components/schemas/Foo\"\n    }\n  },\n  \"required\": [\n    \"a\"\n  ],\n  \"title\": \"Model\",\n  \"type\": \"object\"\n}\n\"\"\"\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/json_schema/#customizing-the-refs-in-json-schema", "page": "docs/concepts/json_schema", "source_site": "pydantic"}
{"title": "Miscellaneous Notes on JSON Schema Generation", "anchor": "miscellaneous-notes-on-json-schema-generation", "heading_level": 2, "md_text": "* The JSON schema for `Optional` fields indicates that the value `null` is allowed.\n* The `Decimal` type is exposed in JSON schema (and serialized) as a string.\n* Since the `namedtuple` type doesn't exist in JSON, a model's JSON schema does not preserve `namedtuple`s as `namedtuple`s.\n* Sub-models used are added to the `$defs` JSON attribute and referenced, as per the spec.\n* Sub-models with modifications (via the `Field` class) like a custom title, description, or default value,\n    are recursively included instead of referenced.\n* The `description` for models is taken from either the docstring of the class or the argument `description` to\n    the `Field` class.\n* The schema is generated by default using aliases as keys, but it can be generated using model\n    property names instead by calling [`model_json_schema()`][pydantic.main.BaseModel.model_json_schema] or\n    [`model_dump_json()`][pydantic.main.BaseModel.model_dump_json] with the `by_alias=False` keyword argument.", "url": "https://docs.pydantic.dev/latest/docs/concepts/json_schema/#miscellaneous-notes-on-json-schema-generation", "page": "docs/concepts/json_schema", "source_site": "pydantic"}
{"title": "fields", "anchor": null, "heading_level": 0, "md_text": "??? api \"API Documentation\"\n    [`pydantic.fields.Field`][pydantic.fields.Field]<br>\n\nIn this section, we will go through the available mechanisms to customize Pydantic model fields:\n[default values](#default-values), [JSON Schema metadata](#customizing-json-schema),\n[constraints](#field-constraints), etc.\n\nTo do so, the [`Field()`][pydantic.fields.Field] function is used a lot, and behaves the same way as\nthe standard library [`field()`][dataclasses.field] function for dataclasses \u2013 by assigning to the\nannotated attribute:\n\n```python\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    name: str = Field(frozen=True)\n```\n\n!!! note\n    Even though `name` is assigned a value, it is still required and has no default value. If you want\n    to emphasize on the fact that a value must be provided, you can use the [ellipsis][Ellipsis]:\n\n    ```python {lint=\"skip\" test=\"skip\"}\n    class Model(BaseModel):\n        name: str = Field(..., frozen=True)\n    ```\n\n    However, its usage is discouraged as it doesn't play well with static type checkers.", "url": "https://docs.pydantic.dev/latest/docs/concepts/fields/", "page": "docs/concepts/fields", "source_site": "pydantic"}
{"title": "The annotated pattern", "anchor": "the-annotated-pattern", "heading_level": 2, "md_text": "To apply constraints or attach [`Field()`][pydantic.fields.Field] functions to a model field, Pydantic\nalso supports the [`Annotated`][typing.Annotated] typing construct to attach metadata to an annotation:\n\n```python\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Field, WithJsonSchema\n\n\nclass Model(BaseModel):\n    name: Annotated[str, Field(strict=True), WithJsonSchema({'extra': 'data'})]\n```\n\nAs far as static type checkers are concerned, `name` is still typed as `str`, but Pydantic leverages\nthe available metadata to add validation logic, type constraints, etc.\n\nUsing this pattern has some advantages:\n\n* Using the `f: <type> = Field(...)` form can be confusing and might trick users into thinking `f`\n  has a default value, while in reality it is still required.\n* You can provide an arbitrary amount of metadata elements for a field. As shown in the example above,\n  the [`Field()`][pydantic.fields.Field] function only supports a limited set of constraints/metadata,\n  and you may have to use different Pydantic utilities such as [`WithJsonSchema`][pydantic.WithJsonSchema]\n  in some cases.\n* Types can be made reusable (see the documentation on [custom types](./types.md#using-the-annotated-pattern)\n  using this pattern).\n\nHowever, note that certain arguments to the [`Field()`][pydantic.fields.Field] function (namely, `default`,\n`default_factory`, and `alias`) are taken into account by static type checkers to synthesize a correct\n`__init__()` method. The annotated pattern is *not* understood by them, so you should use the normal\nassignment form instead.\n\n!!! tip\n    The annotated pattern can also be used to add metadata to specific parts of the type. For instance,\n    [validation constraints](#field-constraints) can be added this way:\n\n    ```python\n    from typing import Annotated\n\n    from pydantic import BaseModel, Field\n\n\n    class Model(BaseModel):\n        int_list: list[Annotated[int, Field(gt=0)]]\n        # Valid: [1, 3]\n        # Invalid: [-1, 2]\n    ```\n\n    Be careful not mixing *field* and *type* metadata:\n\n    ```python {test=\"skip\" lint=\"skip\"}\n    class Model(BaseModel):\n        field_bad: Annotated[int, Field(deprecated=True)] | None = None  # (1)!\n        field_ok: Annotated[int | None, Field(deprecated=True)] = None  # (2)!\n    ```\n\n      1. The [`Field()`][pydantic.fields.Field] function is applied to `int` type, hence the\n         `deprecated` flag won't have any effect. While this may be confusing given that the name of\n         the [`Field()`][pydantic.fields.Field] function would imply it should apply to the field,\n         the API was designed when this function was the only way to provide metadata. You can\n         alternatively make use of the [`annotated_types`](https://github.com/annotated-types/annotated-types)\n         library which is now supported by Pydantic.\n\n      2. The [`Field()`][pydantic.fields.Field] function is applied to the \"top-level\" union type,\n         hence the `deprecated` flag will be applied to the field.", "url": "https://docs.pydantic.dev/latest/docs/concepts/fields/#the-annotated-pattern", "page": "docs/concepts/fields", "source_site": "pydantic"}
{"title": "Inspecting model fields", "anchor": "inspecting-model-fields", "heading_level": 2, "md_text": "The fields of a model can be inspected using the [`model_fields`][pydantic.main.BaseModel.model_fields] class attribute\n(or the `__pydantic_fields__` attribute for [Pydantic dataclasses](./dataclasses.md)). It is a mapping of field names\nto their definition (represented as [`FieldInfo`][pydantic.fields.FieldInfo] instances).\n\n```python\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Field, WithJsonSchema\n\n\nclass Model(BaseModel):\n    a: Annotated[\n        int, Field(gt=1), WithJsonSchema({'extra': 'data'}), Field(alias='b')\n    ] = 1\n\n\nfield_info = Model.model_fields['a']\nprint(field_info.annotation)\n#> <class 'int'>\nprint(field_info.alias)\n#> b\nprint(field_info.metadata)\n#> [Gt(gt=1), WithJsonSchema(json_schema={'extra': 'data'}, mode=None)]\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/fields/#inspecting-model-fields", "page": "docs/concepts/fields", "source_site": "pydantic"}
{"title": "Default values", "anchor": "default-values", "heading_level": 2, "md_text": "Default values for fields can be provided using the normal assignment syntax or by providing a value\nto the `default` argument:\n\n```python\nfrom pydantic import BaseModel, Field\n\n\nclass User(BaseModel):\n    # Both fields aren't required:\n    name: str = 'John Doe'\n    age: int = Field(default=20)\n```\n\n!!! warning\n    [In Pydantic V1](../migration.md#required-optional-and-nullable-fields), a type annotated as [`Any`][typing.Any]\n    or wrapped by [`Optional`][typing.Optional] would be given an implicit default of `None` even if no\n    default was explicitly specified. This is no longer the case in Pydantic V2.\n\nYou can also pass a callable to the `default_factory` argument that will be called to generate a default value:\n\n```python\nfrom uuid import uuid4\n\nfrom pydantic import BaseModel, Field\n\n\nclass User(BaseModel):\n    id: str = Field(default_factory=lambda: uuid4().hex)\n```\n\n<!-- markdownlint-disable-next-line no-empty-links -->\n[](){#default-factory-validated-data}\n\nThe default factory can also take a single required argument, in which case the already validated data will be passed as a dictionary.\n\n```python\nfrom pydantic import BaseModel, EmailStr, Field\n\n\nclass User(BaseModel):\n    email: EmailStr\n    username: str = Field(default_factory=lambda data: data['email'])\n\n\nuser = User(email='user@example.com')\nprint(user.username)\n#> user@example.com\n```\n\nThe `data` argument will *only* contain the already validated data, based on the [order of model fields](./models.md#field-ordering)\n(the above example would fail if `username` were to be defined before `email`).", "url": "https://docs.pydantic.dev/latest/docs/concepts/fields/#default-values", "page": "docs/concepts/fields", "source_site": "pydantic"}
{"title": "Validate default values", "anchor": "validate-default-values", "heading_level": 2, "md_text": "By default, Pydantic will *not* validate default values. The `validate_default` field parameter\n(or the [`validate_default`][pydantic.ConfigDict.validate_default] configuration value) can be used\nto enable this behavior:\n\n```python\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass User(BaseModel):\n    age: int = Field(default='twelve', validate_default=True)\n\n\ntry:\n    user = User()\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n    age\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='twelve', input_type=str]\n    \"\"\"\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/fields/#validate-default-values", "page": "docs/concepts/fields", "source_site": "pydantic"}
{"title": "Mutable default values", "anchor": "mutable-default-values", "heading_level": 3, "md_text": "A common source of bugs in Python is to use a mutable object as a default value for a function or method argument,\nas the same instance ends up being reused in each call.\n\nThe [`dataclasses`][dataclasses] module actually raises an error in this case, indicating that you should use\na [default factory](https://docs.python.org/3/library/dataclasses.html#default-factory-functions) instead.\n\nWhile the same thing can be done in Pydantic, it is not required. In the event that the default value is not hashable,\nPydantic will create a deep copy of the default value when creating each instance of the model:\n\n```python\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    item_counts: list[dict[str, int]] = [{}]\n\n\nm1 = Model()\nm1.item_counts[0]['a'] = 1\nprint(m1.item_counts)\n#> [{'a': 1}]\n\nm2 = Model()\nprint(m2.item_counts)\n#> [{}]\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/fields/#mutable-default-values", "page": "docs/concepts/fields", "source_site": "pydantic"}
{"title": "Field aliases", "anchor": "field-aliases", "heading_level": 2, "md_text": "!!! tip\n    Read more about aliases in the [dedicated section](./alias.md).\n\nFor validation and serialization, you can define an alias for a field.\n\nThere are three ways to define an alias:\n\n* `Field(alias='foo')`\n* `Field(validation_alias='foo')`\n* `Field(serialization_alias='foo')`\n\nThe `alias` parameter is used for both validation *and* serialization. If you want to use\n*different* aliases for validation and serialization respectively, you can use the `validation_alias`\nand `serialization_alias` parameters, which will apply only in their respective use cases.\n\nHere is an example of using the `alias` parameter:\n\n```python\nfrom pydantic import BaseModel, Field\n\n\nclass User(BaseModel):\n    name: str = Field(alias='username')\n\n\nuser = User(username='johndoe')  # (1)!\nprint(user)\n#> name='johndoe'\nprint(user.model_dump(by_alias=True))  # (2)!\n#> {'username': 'johndoe'}\n```\n\n1. The alias `'username'` is used for instance creation and validation.\n2. We are using [`model_dump()`][pydantic.main.BaseModel.model_dump] to convert the model into a serializable format.\n\n    Note that the `by_alias` keyword argument defaults to `False`, and must be specified explicitly to dump\n    models using the field (serialization) aliases.\n\n    You can also use [`ConfigDict.serialize_by_alias`][pydantic.config.ConfigDict.serialize_by_alias] to\n    configure this behavior at the model level.\n\n    When `by_alias=True`, the alias `'username'` used during serialization.\n\nIf you want to use an alias *only* for validation, you can use the `validation_alias` parameter:\n\n```python\nfrom pydantic import BaseModel, Field\n\n\nclass User(BaseModel):\n    name: str = Field(validation_alias='username')\n\n\nuser = User(username='johndoe')  # (1)!\nprint(user)\n#> name='johndoe'\nprint(user.model_dump(by_alias=True))  # (2)!\n#> {'name': 'johndoe'}\n```\n\n1. The validation alias `'username'` is used during validation.\n2. The field name `'name'` is used during serialization.\n\nIf you only want to define an alias for *serialization*, you can use the `serialization_alias` parameter:\n\n```python\nfrom pydantic import BaseModel, Field\n\n\nclass User(BaseModel):\n    name: str = Field(serialization_alias='username')\n\n\nuser = User(name='johndoe')  # (1)!\nprint(user)\n#> name='johndoe'\nprint(user.model_dump(by_alias=True))  # (2)!\n#> {'username': 'johndoe'}\n```\n\n1. The field name `'name'` is used for validation.\n2. The serialization alias `'username'` is used for serialization.\n\n!!! note \"Alias precedence and priority\"\n    In case you use `alias` together with `validation_alias` or `serialization_alias` at the same time,\n    the `validation_alias` will have priority over `alias` for validation, and `serialization_alias` will have priority\n    over `alias` for serialization.\n\n    If you provide a value for the [`alias_generator`][pydantic.config.ConfigDict.alias_generator] model setting, you can control the order of precedence for field alias and generated aliases via the `alias_priority` field parameter. You can read more about alias precedence [here](../concepts/alias.md#alias-precedence).\n\n??? tip \"Static type checking/IDE support\"\n    If you provide a value for the `alias` field parameter, static type checkers will use this alias instead\n    of the actual field name to synthesize the `__init__` method:\n\n    ```python\n    from pydantic import BaseModel, Field\n\n\n    class User(BaseModel):\n        name: str = Field(alias='username')\n\n\n    user = User(username='johndoe')  # (1)!\n    ```\n\n    1. Accepted by type checkers.\n\n    This means that when using the [`validate_by_name`][pydantic.config.ConfigDict.validate_by_name] model setting (which allows both the field name and alias to be used during model validation), type checkers will error when the actual field name is used:\n\n    ```python\n    from pydantic import BaseModel, ConfigDict, Field\n\n\n    class User(BaseModel):\n        model_config = ConfigDict(validate_by_name=True)\n\n        name: str = Field(alias='username')\n\n\n    user = User(name='johndoe')  # (1)!\n    ```\n\n    1. *Not* accepted by type checkers.\n\n    If you still want type checkers to use the field name and not the alias, the [annotated pattern](#the-annotated-pattern)\n    can be used (which is only understood by Pydantic):\n\n    ```python\n    from typing import Annotated\n\n    from pydantic import BaseModel, ConfigDict, Field\n\n\n    class User(BaseModel):\n        model_config = ConfigDict(validate_by_name=True, validate_by_alias=True)\n\n        name: Annotated[str, Field(alias='username')]\n\n\n    user = User(name='johndoe')  # (1)!\n    user = User(username='johndoe')  # (2)!\n    ```\n\n    1. Accepted by type checkers.\n    2. *Not* accepted by type checkers.\n\n    <h3>Validation Alias</h3>", "url": "https://docs.pydantic.dev/latest/docs/concepts/fields/#field-aliases", "page": "docs/concepts/fields", "source_site": "pydantic"}
{"title": "Field aliases", "anchor": "field-aliases", "heading_level": 2, "md_text": "    Even though Pydantic treats `alias` and `validation_alias` the same when creating model instances, type checkers\n    only understand the `alias` field parameter. As a workaround, you can instead specify both an `alias` and\n    `serialization_alias` (identical to the field name), as the `serialization_alias` will override the `alias` during\n    serialization:\n\n    ```python\n    from pydantic import BaseModel, Field\n\n\n    class MyModel(BaseModel):\n        my_field: int = Field(validation_alias='myValidationAlias')\n    ```\n\n    with:\n\n    ```python\n    from pydantic import BaseModel, Field\n\n\n    class MyModel(BaseModel):\n        my_field: int = Field(\n            alias='myValidationAlias',\n            serialization_alias='my_field',\n        )\n\n\n    m = MyModel(myValidationAlias=1)\n    print(m.model_dump(by_alias=True))\n    #> {'my_field': 1}\n    ```\n\n<!-- old anchor added for backwards compatibility -->\n<!-- markdownlint-disable-next-line no-empty-links -->\n[](){#numeric-constraints}\n<!-- markdownlint-disable-next-line no-empty-links -->\n[](){#string-constraints}\n<!-- markdownlint-disable-next-line no-empty-links -->\n[](){#decimal-constraints}", "url": "https://docs.pydantic.dev/latest/docs/concepts/fields/#field-aliases", "page": "docs/concepts/fields", "source_site": "pydantic"}
{"title": "Field constraints", "anchor": "field-constraints", "heading_level": 2, "md_text": "The [`Field()`][pydantic.Field] function can also be used to add constraints to specific types:\n\n```python\nfrom decimal import Decimal\n\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    positive: int = Field(gt=0)\n    short_str: str = Field(max_length=3)\n    precise_decimal: Decimal = Field(max_digits=5, decimal_places=2)\n```\n\nThe available constraints for each type (and the way they affect the JSON Schema) are described\nin the [standard library types](../api/standard_library_types.md) documentation.\n\n<!-- old anchor added for backwards compatibility -->\n<!-- markdownlint-disable-next-line no-empty-links -->\n[](){#strict-mode}", "url": "https://docs.pydantic.dev/latest/docs/concepts/fields/#field-constraints", "page": "docs/concepts/fields", "source_site": "pydantic"}
{"title": "Strict fields", "anchor": "strict-fields", "heading_level": 2, "md_text": "The `strict` parameter of the [`Field()`][pydantic.Field] function specifies whether the field should be validated in\n[strict mode](./strict_mode.md).\n\n```python\nfrom pydantic import BaseModel, Field\n\n\nclass User(BaseModel):\n    name: str = Field(strict=True)\n    age: int = Field(strict=False)  # (1)!\n\n\nuser = User(name='John', age='42')  # (2)!\nprint(user)\n#> name='John' age=42\n```\n\n1. This is the default value.\n2. The `age` field is validated in lax mode. Therefore, it can be assigned a string.\n\nThe [standard library types](../api/standard_library_types.md) documentation describes the strict behavior for each type.\n\n<!-- old anchor added for backwards compatibility -->\n<!-- markdownlint-disable-next-line no-empty-links -->\n[](){#dataclass-constraints}", "url": "https://docs.pydantic.dev/latest/docs/concepts/fields/#strict-fields", "page": "docs/concepts/fields", "source_site": "pydantic"}
{"title": "Dataclass fields", "anchor": "dataclass-fields", "heading_level": 2, "md_text": "Some parameters of the [`Field()`][pydantic.Field] function can be used on [dataclasses](./dataclasses.md):\n\n* `init`: Whether the field should be included in the synthesized `__init__()` method of the dataclass.\n* `init_var`: Whether the field should be [init-only][dataclasses-init-only-variables] in the dataclass.\n* `kw_only`: Whether the field should be a keyword-only argument in the constructor of the dataclass.\n\nHere is an example:\n\n```python\nfrom pydantic import BaseModel, Field\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass Foo:\n    bar: str\n    baz: str = Field(init_var=True)\n    qux: str = Field(kw_only=True)\n\n\nclass Model(BaseModel):\n    foo: Foo\n\n\nmodel = Model(foo=Foo('bar', baz='baz', qux='qux'))\nprint(model.model_dump())  # (1)!\n#> {'foo': {'bar': 'bar', 'qux': 'qux'}}\n```\n\n1. The `baz` field is not included in the serialized output, since it is an init-only field.", "url": "https://docs.pydantic.dev/latest/docs/concepts/fields/#dataclass-fields", "page": "docs/concepts/fields", "source_site": "pydantic"}
{"title": "Field Representation", "anchor": "field-representation", "heading_level": 2, "md_text": "The parameter `repr` can be used to control whether the field should be included in the string\nrepresentation of the model.\n\n```python\nfrom pydantic import BaseModel, Field\n\n\nclass User(BaseModel):\n    name: str = Field(repr=True)  # (1)!\n    age: int = Field(repr=False)\n\n\nuser = User(name='John', age=42)\nprint(user)\n#> name='John'\n```\n\n1. This is the default value.", "url": "https://docs.pydantic.dev/latest/docs/concepts/fields/#field-representation", "page": "docs/concepts/fields", "source_site": "pydantic"}
{"title": "Discriminator", "anchor": "discriminator", "heading_level": 2, "md_text": "The parameter `discriminator` can be used to control the field that will be used to discriminate between different\nmodels in a union. It takes either the name of a field or a `Discriminator` instance. The `Discriminator`\napproach can be useful when the discriminator fields aren't the same for all the models in the `Union`.\n\nThe following example shows how to use `discriminator` with a field name:\n\n```python\nfrom typing import Literal, Union\n\nfrom pydantic import BaseModel, Field\n\n\nclass Cat(BaseModel):\n    pet_type: Literal['cat']\n    age: int\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n    age: int\n\n\nclass Model(BaseModel):\n    pet: Union[Cat, Dog] = Field(discriminator='pet_type')\n\n\nprint(Model.model_validate({'pet': {'pet_type': 'cat', 'age': 12}}))  # (1)!\n#> pet=Cat(pet_type='cat', age=12)\n```\n\n1. See more about [Validating data] in the [Models] page.\n\nThe following example shows how to use the `discriminator` keyword argument with a `Discriminator` instance:\n\n```python\nfrom typing import Annotated, Literal, Union\n\nfrom pydantic import BaseModel, Discriminator, Field, Tag\n\n\nclass Cat(BaseModel):\n    pet_type: Literal['cat']\n    age: int\n\n\nclass Dog(BaseModel):\n    pet_kind: Literal['dog']\n    age: int\n\n\ndef pet_discriminator(v):\n    if isinstance(v, dict):\n        return v.get('pet_type', v.get('pet_kind'))\n    return getattr(v, 'pet_type', getattr(v, 'pet_kind', None))\n\n\nclass Model(BaseModel):\n    pet: Union[Annotated[Cat, Tag('cat')], Annotated[Dog, Tag('dog')]] = Field(\n        discriminator=Discriminator(pet_discriminator)\n    )\n\n\nprint(repr(Model.model_validate({'pet': {'pet_type': 'cat', 'age': 12}})))\n#> Model(pet=Cat(pet_type='cat', age=12))\n\nprint(repr(Model.model_validate({'pet': {'pet_kind': 'dog', 'age': 12}})))\n#> Model(pet=Dog(pet_kind='dog', age=12))\n```\n\nYou can also take advantage of `Annotated` to define your discriminated unions.\nSee the [Discriminated Unions] docs for more details.", "url": "https://docs.pydantic.dev/latest/docs/concepts/fields/#discriminator", "page": "docs/concepts/fields", "source_site": "pydantic"}
{"title": "Immutability", "anchor": "immutability", "heading_level": 2, "md_text": "The parameter `frozen` is used to emulate the frozen dataclass behaviour. It is used to prevent the field from being\nassigned a new value after the model is created (immutability).\n\nSee the [frozen dataclass documentation] for more details.\n\n```python\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass User(BaseModel):\n    name: str = Field(frozen=True)\n    age: int\n\n\nuser = User(name='John', age=42)\n\ntry:\n    user.name = 'Jane'  # (1)!\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n    name\n      Field is frozen [type=frozen_field, input_value='Jane', input_type=str]\n    \"\"\"\n```\n\n1. Since `name` field is frozen, the assignment is not allowed.\n\n<!-- old anchor added for backwards compatibility -->\n<!-- markdownlint-disable-next-line no-empty-links -->\n[](){#exclude}", "url": "https://docs.pydantic.dev/latest/docs/concepts/fields/#immutability", "page": "docs/concepts/fields", "source_site": "pydantic"}
{"title": "Excluding fields", "anchor": "excluding-fields", "heading_level": 2, "md_text": "The `exclude` and `exclude_if` parameters can be used to control which fields should be excluded from the\nmodel when exporting the model.\n\nSee the following example:\n\n```python\nfrom pydantic import BaseModel, Field\n\n\nclass User(BaseModel):\n    name: str\n    age: int = Field(exclude=True)\n\n\nuser = User(name='John', age=42)\nprint(user.model_dump())  # (1)!\n#> {'name': 'John'}\n```\n\n1. The `age` field is not included in the [`model_dump()`][pydantic.BaseModel.model_dump] output, since it is excluded.\n\nSee the dedicated [serialization section](./serialization.md#field-inclusion-and-exclusion) for more details.", "url": "https://docs.pydantic.dev/latest/docs/concepts/fields/#excluding-fields", "page": "docs/concepts/fields", "source_site": "pydantic"}
{"title": "Deprecated fields", "anchor": "deprecated-fields", "heading_level": 2, "md_text": "The `deprecated` parameter can be used to mark a field as being deprecated. Doing so will result in:\n\n* a runtime deprecation warning emitted when accessing the field.\n* The [deprecated](https://json-schema.org/draft/2020-12/json-schema-validation#section-9.3) keyword\n  being set in the generated JSON schema.\n\nThis parameter accepts different types, described below.", "url": "https://docs.pydantic.dev/latest/docs/concepts/fields/#deprecated-fields", "page": "docs/concepts/fields", "source_site": "pydantic"}
{"title": "`deprecated` as a string", "anchor": "deprecated-as-a-string", "heading_level": 3, "md_text": "The value will be used as the deprecation message.\n\n```python\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    deprecated_field: Annotated[int, Field(deprecated='This is deprecated')]\n\n\nprint(Model.model_json_schema()['properties']['deprecated_field'])\n#> {'deprecated': True, 'title': 'Deprecated Field', 'type': 'integer'}\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/fields/#deprecated-as-a-string", "page": "docs/concepts/fields", "source_site": "pydantic"}
{"title": "`deprecated` via the `@warnings.deprecated` decorator", "anchor": "deprecated-via-the-warningsdeprecated-decorator", "heading_level": 3, "md_text": "The [`@warnings.deprecated`][warnings.deprecated] decorator (or the\n[`typing_extensions` backport][typing_extensions.deprecated] on Python\n3.12 and lower) can be used as an instance.\n\n<!-- TODO: tabs should be auto-generated if using Ruff (https://github.com/pydantic/pydantic/issues/10083) -->\n\n=== \"Python 3.9 and above\"\n\n    ```python\n    from typing import Annotated\n\n    from typing_extensions import deprecated\n\n    from pydantic import BaseModel, Field\n\n\n    class Model(BaseModel):\n        deprecated_field: Annotated[int, deprecated('This is deprecated')]\n\n        # Or explicitly using `Field`:\n        alt_form: Annotated[int, Field(deprecated=deprecated('This is deprecated'))]\n    ```\n\n=== \"Python 3.13 and above\"\n\n    ```python {requires=\"3.13\"}\n    from typing import Annotated\n    from warnings import deprecated\n\n    from pydantic import BaseModel, Field\n\n\n    class Model(BaseModel):\n        deprecated_field: Annotated[int, deprecated('This is deprecated')]\n\n        # Or explicitly using `Field`:\n        alt_form: Annotated[int, Field(deprecated=deprecated('This is deprecated'))]\n    ```\n\n!!! note \"Support for `category` and `stacklevel`\"\n    The current implementation of this feature does not take into account the `category` and `stacklevel`\n    arguments to the `deprecated` decorator. This might land in a future version of Pydantic.", "url": "https://docs.pydantic.dev/latest/docs/concepts/fields/#deprecated-via-the-warningsdeprecated-decorator", "page": "docs/concepts/fields", "source_site": "pydantic"}
{"title": "`deprecated` as a boolean", "anchor": "deprecated-as-a-boolean", "heading_level": 3, "md_text": "```python\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    deprecated_field: Annotated[int, Field(deprecated=True)]\n\n\nprint(Model.model_json_schema()['properties']['deprecated_field'])\n#> {'deprecated': True, 'title': 'Deprecated Field', 'type': 'integer'}\n```\n\n!!! warning \"Accessing a deprecated field in validators\"\n    When accessing a deprecated field inside a validator, the deprecation warning will be emitted. You can use\n    [`catch_warnings`][warnings.catch_warnings] to explicitly ignore it:\n\n    ```python\n    import warnings\n\n    from typing_extensions import Self\n\n    from pydantic import BaseModel, Field, model_validator\n\n\n    class Model(BaseModel):\n        deprecated_field: int = Field(deprecated='This is deprecated')\n\n        @model_validator(mode='after')\n        def validate_model(self) -> Self:\n            with warnings.catch_warnings():\n                warnings.simplefilter('ignore', DeprecationWarning)\n                self.deprecated_field = self.deprecated_field * 2\n    ```", "url": "https://docs.pydantic.dev/latest/docs/concepts/fields/#deprecated-as-a-boolean", "page": "docs/concepts/fields", "source_site": "pydantic"}
{"title": "Customizing JSON Schema", "anchor": "customizing-json-schema", "heading_level": 2, "md_text": "Some field parameters are used exclusively to customize the generated JSON schema. The parameters in question are:\n\n* `title`\n* `description`\n* `examples`\n* `json_schema_extra`\n\nRead more about JSON schema customization / modification with fields in the [Customizing JSON Schema] section of the JSON schema docs.", "url": "https://docs.pydantic.dev/latest/docs/concepts/fields/#customizing-json-schema", "page": "docs/concepts/fields", "source_site": "pydantic"}
{"title": "The `computed_field` decorator", "anchor": "the-computed_field-decorator", "heading_level": 2, "md_text": "??? api \"API Documentation\"\n    [`computed_field`][pydantic.fields.computed_field]<br>\n\nThe [`computed_field`][pydantic.fields.computed_field] decorator can be used to include [`property`][] or\n[`cached_property`][functools.cached_property] attributes when serializing a model or dataclass.\nThe property will also be taken into account in the JSON Schema (in serialization mode).\n\n!!! note\n    Properties can be useful for fields that are computed from other fields, or for fields that\n    are expensive to be computed (and thus, are cached if using [`cached_property`][functools.cached_property]).\n\n    However, note that Pydantic will *not* perform any additional logic on the wrapped property\n    (validation, cache invalidation, etc.).\n\nHere's an example of the JSON schema (in serialization mode) generated for a model with a computed field:\n\n```python\nfrom pydantic import BaseModel, computed_field\n\n\nclass Box(BaseModel):\n    width: float\n    height: float\n    depth: float\n\n    @computed_field\n    @property  # (1)!\n    def volume(self) -> float:\n        return self.width * self.height * self.depth\n\n\nprint(Box.model_json_schema(mode='serialization'))\n\"\"\"\n{\n    'properties': {\n        'width': {'title': 'Width', 'type': 'number'},\n        'height': {'title': 'Height', 'type': 'number'},\n        'depth': {'title': 'Depth', 'type': 'number'},\n        'volume': {'readOnly': True, 'title': 'Volume', 'type': 'number'},\n    },\n    'required': ['width', 'height', 'depth', 'volume'],\n    'title': 'Box',\n    'type': 'object',\n}\n\"\"\"\n```\n\n1. If not specified, [`computed_field`][pydantic.fields.computed_field] will implicitly convert the method\n   to a [`property`][]. However, it is preferable to explicitly use the [`@property`][property] decorator\n   for type checking purposes.\n\nHere's an example using the `model_dump` method with a computed field:\n\n```python\nfrom pydantic import BaseModel, computed_field\n\n\nclass Box(BaseModel):\n    width: float\n    height: float\n    depth: float\n\n    @computed_field\n    @property\n    def volume(self) -> float:\n        return self.width * self.height * self.depth\n\n\nb = Box(width=1, height=2, depth=3)\nprint(b.model_dump())\n#> {'width': 1.0, 'height': 2.0, 'depth': 3.0, 'volume': 6.0}\n```\n\nAs with regular fields, computed fields can be marked as being deprecated:\n\n```python\nfrom typing_extensions import deprecated\n\nfrom pydantic import BaseModel, computed_field\n\n\nclass Box(BaseModel):\n    width: float\n    height: float\n    depth: float\n\n    @computed_field\n    @property\n    @deprecated(\"'volume' is deprecated\")\n    def volume(self) -> float:\n        return self.width * self.height * self.depth\n```\n\n[Discriminated Unions]: ../concepts/unions.md#discriminated-unions\n[Validating data]: models.md#validating-data\n[Models]: models.md\n[frozen dataclass documentation]: https://docs.python.org/3/library/dataclasses.html#frozen-instances\n[Customizing JSON Schema]: json_schema.md#field-level-customization", "url": "https://docs.pydantic.dev/latest/docs/concepts/fields/#the-computed_field-decorator", "page": "docs/concepts/fields", "source_site": "pydantic"}
{"title": "models", "anchor": null, "heading_level": 0, "md_text": "??? api \"API Documentation\"\n    [`pydantic.main.BaseModel`][pydantic.main.BaseModel]<br>\n\nOne of the primary ways of defining schema in Pydantic is via models. Models are simply classes which inherit from\n[`BaseModel`][pydantic.main.BaseModel] and define fields as annotated attributes.\n\nYou can think of models as similar to structs in languages like C, or as the requirements of a single endpoint\nin an API.\n\nModels share many similarities with Python's [dataclasses][dataclasses], but have been designed with some subtle-yet-important\ndifferences that streamline certain workflows related to validation, serialization, and JSON schema generation.\nYou can find more discussion of this in the [Dataclasses](dataclasses.md) section of the docs.\n\nUntrusted data can be passed to a model and, after parsing and validation, Pydantic guarantees that the fields\nof the resultant model instance will conform to the field types defined on the model.\n\n!!! note \"Validation \u2014 a *deliberate* misnomer\"\n    <h3>TL;DR</h3>\n\n    We use the term \"validation\" to refer to the process of instantiating a model (or other type) that adheres to specified types and\n    constraints. This task, which Pydantic is well known for, is most widely recognized as \"validation\" in colloquial terms,\n    even though in other contexts the term \"validation\" may be more restrictive.\n\n    ---\n\n    <h3>The long version</h3>\n\n    The potential confusion around the term \"validation\" arises from the fact that, strictly speaking, Pydantic's\n    primary focus doesn't align precisely with the dictionary definition of \"validation\":\n\n    > <h3>validation</h3>\n    > _noun_\n    > the action of checking or proving the validity or accuracy of something.\n\n    In Pydantic, the term \"validation\" refers to the process of instantiating a model (or other type) that adheres to specified\n    types and constraints. Pydantic guarantees the types and constraints of the output, not the input data.\n    This distinction becomes apparent when considering that Pydantic's `ValidationError` is raised\n    when data cannot be successfully parsed into a model instance.\n\n    While this distinction may initially seem subtle, it holds practical significance.\n    In some cases, \"validation\" goes beyond just model creation, and can include the copying and coercion of data.\n    This can involve copying arguments passed to the constructor in order to perform coercion to a new type\n    without mutating the original input data. For a more in-depth understanding of the implications for your usage,\n    refer to the [Data Conversion](#data-conversion) and [Attribute Copies](#attribute-copies) sections below.\n\n    In essence, Pydantic's primary goal is to assure that the resulting structure post-processing (termed \"validation\")\n    precisely conforms to the applied type hints. Given the widespread adoption of \"validation\" as the colloquial term\n    for this process, we will consistently use it in our documentation.\n\n    While the terms \"parse\" and \"validation\" were previously used interchangeably, moving forward, we aim to exclusively employ \"validate\",\n    with \"parse\" reserved specifically for discussions related to [JSON parsing](../concepts/json.md).", "url": "https://docs.pydantic.dev/latest/docs/concepts/models/", "page": "docs/concepts/models", "source_site": "pydantic"}
{"title": "Basic model usage", "anchor": "basic-model-usage", "heading_level": 2, "md_text": "!!! note\n\n    Pydantic relies heavily on the existing Python typing constructs to define models. If you are not familiar with those, the following resources\n    can be useful:\n\n    * The [Type System Guides](https://typing.readthedocs.io/en/latest/guides/index.html)\n    * The [mypy documentation](https://mypy.readthedocs.io/en/latest/)\n\n```python {group=\"basic-model\"}\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass User(BaseModel):\n    id: int\n    name: str = 'Jane Doe'\n\n    model_config = ConfigDict(str_max_length=10)  # (1)!\n```\n\n1. Pydantic models support a variety of [configuration values](./config.md)\n   (see [here][pydantic.ConfigDict] for the available configuration values).\n\nIn this example, `User` is a model with two fields:\n\n* `id`, which is an integer (defined using the [`int`][] type) and is required\n* `name`, which is a string (defined using the [`str`][] type) and is not required (it has a default value).\n\nThe documentation on [types](./types.md) expands on the supported types.\n\nFields can be customized in a number of ways using the [`Field()`][pydantic.Field] function.\nSee the [documentation on fields](./fields.md) for more information.\n\nThe model can then be instantiated:\n\n```python {group=\"basic-model\"}\nuser = User(id='123')\n```\n\n`user` is an instance of `User`. Initialization of the object will perform all parsing and validation.\nIf no [`ValidationError`][pydantic_core.ValidationError] exception is raised,\nyou know the resulting model instance is valid.\n\nFields of a model can be accessed as normal attributes of the `user` object:\n\n```python {group=\"basic-model\"}\nassert user.name == 'Jane Doe'  # (1)!\nassert user.id == 123  # (2)!\nassert isinstance(user.id, int)\n```\n\n1. `name` wasn't set when `user` was initialized, so the default value was used.\n   The [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute can be\n   inspected to check the field names explicitly set during instantiation.\n2. Note that the string `'123'` was coerced to an integer and its value is `123`.\n   More details on Pydantic's coercion logic can be found in the [data conversion](#data-conversion) section.\n\nThe model instance can be serialized using the [`model_dump()`][pydantic.BaseModel.model_dump] method:\n\n```python {group=\"basic-model\"}\nassert user.model_dump() == {'id': 123, 'name': 'Jane Doe'}\n```\n\nCalling [dict][] on the instance will also provide a dictionary, but nested fields will not be\nrecursively converted into dictionaries. [`model_dump()`][pydantic.BaseModel.model_dump] also\nprovides numerous arguments to customize the serialization result.\n\nBy default, models are mutable and field values can be changed through attribute assignment:\n\n```python {group=\"basic-model\"}\nuser.id = 321\nassert user.id == 321\n```\n\n!!! warning\n    When defining your models, watch out for naming collisions between your field name and its type annotation.\n\n    For example, the following will not behave as expected and would yield a validation error:\n\n    ```python {test=\"skip\"}\n    from typing import Optional\n\n    from pydantic import BaseModel\n\n\n    class Boo(BaseModel):\n        int: Optional[int] = None\n\n\n    m = Boo(int=123)  # Will fail to validate.\n    ```\n\n    Because of how Python evaluates [annotated assignment statements][annassign], the statement is equivalent to `int: None = None`, thus\n    leading to a validation error.", "url": "https://docs.pydantic.dev/latest/docs/concepts/models/#basic-model-usage", "page": "docs/concepts/models", "source_site": "pydantic"}
{"title": "Model methods and properties", "anchor": "model-methods-and-properties", "heading_level": 3, "md_text": "The example above only shows the tip of the iceberg of what models can do.\nModels possess the following methods and attributes:\n\n* [`model_validate()`][pydantic.main.BaseModel.model_validate]: Validates the given object against the Pydantic model. See [Validating data](#validating-data).\n* [`model_validate_json()`][pydantic.main.BaseModel.model_validate_json]: Validates the given JSON data against the Pydantic model. See\n    [Validating data](#validating-data).\n* [`model_construct()`][pydantic.main.BaseModel.model_construct]: Creates models without running validation. See\n    [Creating models without validation](#creating-models-without-validation).\n* [`model_dump()`][pydantic.main.BaseModel.model_dump]: Returns a dictionary of the model's fields and values. See\n    [Serialization](serialization.md#python-mode).\n* [`model_dump_json()`][pydantic.main.BaseModel.model_dump_json]: Returns a JSON string representation of [`model_dump()`][pydantic.main.BaseModel.model_dump]. See [Serialization](serialization.md#json-mode).\n* [`model_copy()`][pydantic.main.BaseModel.model_copy]: Returns a copy (by default, shallow copy) of the model. See\n    [Model copy](#model-copy).\n* [`model_json_schema()`][pydantic.main.BaseModel.model_json_schema]: Returns a jsonable dictionary representing the model's JSON Schema. See [JSON Schema](json_schema.md).\n* [`model_fields`][pydantic.main.BaseModel.model_fields]: A mapping between field names and their definitions ([`FieldInfo`][pydantic.fields.FieldInfo] instances).\n* [`model_computed_fields`][pydantic.main.BaseModel.model_computed_fields]: A mapping between computed field names and their definitions ([`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] instances).\n* [`model_extra`][pydantic.main.BaseModel.model_extra]: The extra fields set during validation.\n* [`model_fields_set`][pydantic.main.BaseModel.model_fields_set]: The set of fields which were explicitly provided when the model was initialized.\n* [`model_parametrized_name()`][pydantic.main.BaseModel.model_parametrized_name]: Computes the class name for parametrizations of generic classes.\n* [`model_post_init()`][pydantic.main.BaseModel.model_post_init]: Performs additional actions after the model is instantiated and all field validators are applied.\n* [`model_rebuild()`][pydantic.main.BaseModel.model_rebuild]: Rebuilds the model schema, which also supports building recursive generic models.\n    See [Rebuilding model schema](#rebuilding-model-schema).\n\n!!! note\n    See the API documentation of [`BaseModel`][pydantic.main.BaseModel] for the class definition including a full list of methods and attributes.\n\n!!! tip\n    See [Changes to `pydantic.BaseModel`](../migration.md#changes-to-pydanticbasemodel) in the\n    [Migration Guide](../migration.md) for details on changes from Pydantic V1.", "url": "https://docs.pydantic.dev/latest/docs/concepts/models/#model-methods-and-properties", "page": "docs/concepts/models", "source_site": "pydantic"}
{"title": "Data conversion", "anchor": "data-conversion", "heading_level": 2, "md_text": "Pydantic may cast input data to force it to conform to model field types,\nand in some cases this may result in a loss of information.\nFor example:\n\n```python\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    a: int\n    b: float\n    c: str\n\n\nprint(Model(a=3.000, b='2.72', c=b'binary data').model_dump())\n#> {'a': 3, 'b': 2.72, 'c': 'binary data'}\n```\n\nThis is a deliberate decision of Pydantic, and is frequently the most useful approach. See\n[this issue](https://github.com/pydantic/pydantic/issues/578) for a longer discussion on the subject.\n\nNevertheless, Pydantic provides a [strict mode](strict_mode.md), where no data conversion is performed.\nValues must be of the same type as the declared field type.\n\nThis is also the case for collections. In most cases, you shouldn't make use of abstract container classes\nand just use a concrete type, such as [`list`][]:\n\n```python\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    items: list[int]  # (1)!\n\n\nprint(Model(items=(1, 2, 3)))\n#> items=[1, 2, 3]\n```\n\n1. In this case, you might be tempted to use the abstract [`Sequence`][collections.abc.Sequence] type\n   to allow both lists and tuples. But Pydantic takes care of converting the tuple input to a list, so\n   in most cases this isn't necessary.\n\nBesides, using these abstract types can also lead to [poor validation performance](./performance.md#sequence-vs-list-or-tuple-with-mapping-vs-dict), and in general using concrete container types\nwill avoid unnecessary checks.\n\n<!-- old anchor added for backwards compatibility -->\n<!-- markdownlint-disable-next-line no-empty-links -->\n[](){#extra-fields}", "url": "https://docs.pydantic.dev/latest/docs/concepts/models/#data-conversion", "page": "docs/concepts/models", "source_site": "pydantic"}
{"title": "Extra data", "anchor": "extra-data", "heading_level": 2, "md_text": "By default, Pydantic models **won't error when you provide extra data**, and these values will simply be ignored:\n\n```python\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    x: int\n\n\nm = Model(x=1, y='a')\nassert m.model_dump() == {'x': 1}\n```\n\nThe [`extra`][pydantic.ConfigDict.extra] configuration value can be used to control this behavior:\n\n```python\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass Model(BaseModel):\n    x: int\n\n    model_config = ConfigDict(extra='allow')\n\n\nm = Model(x=1, y='a')  # (1)!\nassert m.model_dump() == {'x': 1, 'y': 'a'}\nassert m.__pydantic_extra__ == {'y': 'a'}\n```\n\n1. If [`extra`][pydantic.ConfigDict.extra] was set to `'forbid'`, this would fail.\n\nThe configuration can take three values:\n\n* `'ignore'`: Providing extra data is ignored (the default).\n* `'forbid'`: Providing extra data is not permitted.\n* `'allow'`: Providing extra data is allowed and stored in the `__pydantic_extra__` dictionary attribute.\n  The `__pydantic_extra__` can explicitly be annotated to provide validation for extra fields.\n\nThe validation methods (e.g. [`model_validate()`][pydantic.main.BaseModel.model_validate]) have an optional `extra` argument\nthat will override the `extra` configuration value of the model for that validation call.\n\nFor more details, refer to the [`extra`][pydantic.ConfigDict.extra] API documentation.\n\nPydantic dataclasses also support extra data (see the [dataclass configuration](./dataclasses.md#dataclass-config) section).", "url": "https://docs.pydantic.dev/latest/docs/concepts/models/#extra-data", "page": "docs/concepts/models", "source_site": "pydantic"}
{"title": "Nested models", "anchor": "nested-models", "heading_level": 2, "md_text": "More complex hierarchical data structures can be defined using models themselves as types in annotations.\n\n```python\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    count: int\n    size: Optional[float] = None\n\n\nclass Bar(BaseModel):\n    apple: str = 'x'\n    banana: str = 'y'\n\n\nclass Spam(BaseModel):\n    foo: Foo\n    bars: list[Bar]\n\n\nm = Spam(foo={'count': 4}, bars=[{'apple': 'x1'}, {'apple': 'x2'}])\nprint(m)\n\"\"\"\nfoo=Foo(count=4, size=None) bars=[Bar(apple='x1', banana='y'), Bar(apple='x2', banana='y')]\n\"\"\"\nprint(m.model_dump())\n\"\"\"\n{\n    'foo': {'count': 4, 'size': None},\n    'bars': [{'apple': 'x1', 'banana': 'y'}, {'apple': 'x2', 'banana': 'y'}],\n}\n\"\"\"\n```\n\nSelf-referencing models are supported. For more details, see  the documentation related to\n[forward annotations](forward_annotations.md#self-referencing-or-recursive-models).", "url": "https://docs.pydantic.dev/latest/docs/concepts/models/#nested-models", "page": "docs/concepts/models", "source_site": "pydantic"}
{"title": "Rebuilding model schema", "anchor": "rebuilding-model-schema", "heading_level": 2, "md_text": "When you define a model class in your code, Pydantic will analyze the body of the class to collect a variety of information\nrequired to perform validation and serialization, gathered in a core schema. Notably, the model's type annotations are evaluated to\nunderstand the valid types for each field (more information can be found in the [Architecture](../internals/architecture.md) documentation).\nHowever, it might be the case that annotations refer to symbols not defined when the model class is being created.\nTo circumvent this issue, the [`model_rebuild()`][pydantic.main.BaseModel.model_rebuild] method can be used:\n\n```python\nfrom pydantic import BaseModel, PydanticUserError\n\n\nclass Foo(BaseModel):\n    x: 'Bar'  # (1)!\n\n\ntry:\n    Foo.model_json_schema()\nexcept PydanticUserError as e:\n    print(e)\n    \"\"\"\n    `Foo` is not fully defined; you should define `Bar`, then call `Foo.model_rebuild()`.\n\n    For further information visit https://errors.pydantic.dev/2/u/class-not-fully-defined\n    \"\"\"\n\n\nclass Bar(BaseModel):\n    pass\n\n\nFoo.model_rebuild()\nprint(Foo.model_json_schema())\n\"\"\"\n{\n    '$defs': {'Bar': {'properties': {}, 'title': 'Bar', 'type': 'object'}},\n    'properties': {'x': {'$ref': '#/$defs/Bar'}},\n    'required': ['x'],\n    'title': 'Foo',\n    'type': 'object',\n}\n\"\"\"\n```\n\n1. `Bar` is not yet defined when the `Foo` class is being created. For this reason,\n    a [forward annotation](forward_annotations.md) is being used.\n\nPydantic tries to determine when this is necessary automatically and error if it wasn't done, but you may want to\ncall [`model_rebuild()`][pydantic.main.BaseModel.model_rebuild] proactively when dealing with recursive models or generics.\n\nIn V2, [`model_rebuild()`][pydantic.main.BaseModel.model_rebuild] replaced `update_forward_refs()` from V1. There are some slight differences with the new behavior.\nThe biggest change is that when calling [`model_rebuild()`][pydantic.main.BaseModel.model_rebuild] on the outermost model, it builds a core schema used for validation of the\nwhole model (nested models and all), so all types at all levels need to be ready before [`model_rebuild()`][pydantic.main.BaseModel.model_rebuild] is called.", "url": "https://docs.pydantic.dev/latest/docs/concepts/models/#rebuilding-model-schema", "page": "docs/concepts/models", "source_site": "pydantic"}
{"title": "Arbitrary class instances", "anchor": "arbitrary-class-instances", "heading_level": 2, "md_text": "(Formerly known as \"ORM Mode\"/`from_orm`).\n\nPydantic models can also be created from arbitrary class instances by reading the instance attributes corresponding\nto the model field names. One common application of this functionality is integration with object-relational mappings\n(ORMs).\n\nTo do this, set the [`from_attributes`][pydantic.config.ConfigDict.from_attributes] config value to `True`\n(see the documentation on [Configuration](./config.md) for more details).\n\nThe example here uses [SQLAlchemy](https://www.sqlalchemy.org/), but the same approach should work for any ORM.\n\n```python\nfrom typing import Annotated\n\nfrom sqlalchemy import ARRAY, String\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\n\nfrom pydantic import BaseModel, ConfigDict, StringConstraints\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass CompanyOrm(Base):\n    __tablename__ = 'companies'\n\n    id: Mapped[int] = mapped_column(primary_key=True, nullable=False)\n    public_key: Mapped[str] = mapped_column(\n        String(20), index=True, nullable=False, unique=True\n    )\n    domains: Mapped[list[str]] = mapped_column(ARRAY(String(255)))\n\n\nclass CompanyModel(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n\n    id: int\n    public_key: Annotated[str, StringConstraints(max_length=20)]\n    domains: list[Annotated[str, StringConstraints(max_length=255)]]\n\n\nco_orm = CompanyOrm(\n    id=123,\n    public_key='foobar',\n    domains=['example.com', 'foobar.com'],\n)\nprint(co_orm)\n#> <__main__.CompanyOrm object at 0x0123456789ab>\nco_model = CompanyModel.model_validate(co_orm)\nprint(co_model)\n#> id=123 public_key='foobar' domains=['example.com', 'foobar.com']\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/models/#arbitrary-class-instances", "page": "docs/concepts/models", "source_site": "pydantic"}
{"title": "Nested attributes", "anchor": "nested-attributes", "heading_level": 3, "md_text": "When using attributes to parse models, model instances will be created from both top-level attributes and\ndeeper-nested attributes as appropriate.\n\nHere is an example demonstrating the principle:\n\n```python\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass PetCls:\n    def __init__(self, *, name: str, species: str):\n        self.name = name\n        self.species = species\n\n\nclass PersonCls:\n    def __init__(self, *, name: str, age: float = None, pets: list[PetCls]):\n        self.name = name\n        self.age = age\n        self.pets = pets\n\n\nclass Pet(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n\n    name: str\n    species: str\n\n\nclass Person(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n\n    name: str\n    age: float = None\n    pets: list[Pet]\n\n\nbones = PetCls(name='Bones', species='dog')\norion = PetCls(name='Orion', species='cat')\nanna = PersonCls(name='Anna', age=20, pets=[bones, orion])\nanna_model = Person.model_validate(anna)\nprint(anna_model)\n\"\"\"\nname='Anna' age=20.0 pets=[Pet(name='Bones', species='dog'), Pet(name='Orion', species='cat')]\n\"\"\"\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/models/#nested-attributes", "page": "docs/concepts/models", "source_site": "pydantic"}
{"title": "Error handling", "anchor": "error-handling", "heading_level": 2, "md_text": "Pydantic will raise a [`ValidationError`][pydantic_core.ValidationError] exception whenever it finds an error in the data it's validating.\n\nA single exception will be raised regardless of the number of errors found, and that validation error\nwill contain information about all of the errors and how they happened.\n\nSee [Error Handling](../errors/errors.md) for details on standard and custom errors.\n\nAs a demonstration:\n\n```python\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    list_of_ints: list[int]\n    a_float: float\n\n\ndata = dict(\n    list_of_ints=['1', 2, 'bad'],\n    a_float='not a float',\n)\n\ntry:\n    Model(**data)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for Model\n    list_of_ints.2\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='bad', input_type=str]\n    a_float\n      Input should be a valid number, unable to parse string as a number [type=float_parsing, input_value='not a float', input_type=str]\n    \"\"\"\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/models/#error-handling", "page": "docs/concepts/models", "source_site": "pydantic"}
{"title": "Validating data", "anchor": "validating-data", "heading_level": 2, "md_text": "Pydantic provides three methods on models classes for parsing data:\n\n* [`model_validate()`][pydantic.main.BaseModel.model_validate]: this is very similar to the `__init__` method of the model,\n  except it takes a dictionary or an object rather than keyword arguments. If the object passed cannot be validated,\n  or if it's not a dictionary or instance of the model in question, a [`ValidationError`][pydantic_core.ValidationError] will be raised.\n* [`model_validate_json()`][pydantic.main.BaseModel.model_validate_json]: this validates the provided data as a JSON string or `bytes` object.\n  If your incoming data is a JSON payload, this is generally considered faster (instead of manually parsing the data as a dictionary).\n  Learn more about JSON parsing in the [JSON](../concepts/json.md) section of the docs.\n* [`model_validate_strings()`][pydantic.main.BaseModel.model_validate_strings]: this takes a dictionary (can be nested) with string keys and values and validates the data in JSON mode so that said strings can be coerced into the correct types.\n\n```python\nfrom datetime import datetime\nfrom typing import Optional\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass User(BaseModel):\n    id: int\n    name: str = 'John Doe'\n    signup_ts: Optional[datetime] = None\n\n\nm = User.model_validate({'id': 123, 'name': 'James'})\nprint(m)\n#> id=123 name='James' signup_ts=None\n\ntry:\n    User.model_validate(['not', 'a', 'dict'])\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n      Input should be a valid dictionary or instance of User [type=model_type, input_value=['not', 'a', 'dict'], input_type=list]\n    \"\"\"\n\nm = User.model_validate_json('{\"id\": 123, \"name\": \"James\"}')\nprint(m)\n#> id=123 name='James' signup_ts=None\n\ntry:\n    m = User.model_validate_json('{\"id\": 123, \"name\": 123}')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n    name\n      Input should be a valid string [type=string_type, input_value=123, input_type=int]\n    \"\"\"\n\ntry:\n    m = User.model_validate_json('invalid JSON')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n      Invalid JSON: expected value at line 1 column 1 [type=json_invalid, input_value='invalid JSON', input_type=str]\n    \"\"\"\n\nm = User.model_validate_strings({'id': '123', 'name': 'James'})\nprint(m)\n#> id=123 name='James' signup_ts=None\n\nm = User.model_validate_strings(\n    {'id': '123', 'name': 'James', 'signup_ts': '2024-04-01T12:00:00'}\n)\nprint(m)\n#> id=123 name='James' signup_ts=datetime.datetime(2024, 4, 1, 12, 0)\n\ntry:\n    m = User.model_validate_strings(\n        {'id': '123', 'name': 'James', 'signup_ts': '2024-04-01'}, strict=True\n    )\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n    signup_ts\n      Input should be a valid datetime, invalid datetime separator, expected `T`, `t`, `_` or space [type=datetime_parsing, input_value='2024-04-01', input_type=str]\n    \"\"\"\n```\n\nIf you want to validate serialized data in a format other than JSON, you should load the data into a dictionary yourself and\nthen pass it to [`model_validate`][pydantic.main.BaseModel.model_validate].\n\n!!! note\n    Depending on the types and model configs involved, [`model_validate`][pydantic.main.BaseModel.model_validate]\n    and [`model_validate_json`][pydantic.main.BaseModel.model_validate_json] may have different validation behavior.\n    If you have data coming from a non-JSON source, but want the same validation\n    behavior and errors you'd get from [`model_validate_json`][pydantic.main.BaseModel.model_validate_json],\n    our recommendation for now is to use either use `model_validate_json(json.dumps(data))`, or use [`model_validate_strings`][pydantic.main.BaseModel.model_validate_strings] if the data takes the form of a (potentially nested) dictionary with string keys and values.\n\n!!! note\n    If you're passing in an instance of a model to [`model_validate`][pydantic.main.BaseModel.model_validate], you will want to consider setting\n    [`revalidate_instances`][pydantic.ConfigDict.revalidate_instances] in the model's config.\n    If you don't set this value, then validation will be skipped on model instances. See the below example:\n\n    === \":x: `revalidate_instances='never'`\"\n        ```python\n        from pydantic import BaseModel\n\n\n        class Model(BaseModel):\n            a: int\n\n\n        m = Model(a=0)\n        # note: setting `validate_assignment` to `True` in the config can prevent this kind of misbehavior.\n        m.a = 'not an int'\n\n        # doesn't raise a validation error even though m is invalid\n        m2 = Model.model_validate(m)\n        ```\n\n    === \":white_check_mark: `revalidate_instances='always'`\"\n        ```python\n        from pydantic import BaseModel, ConfigDict, ValidationError\n\n\n        class Model(BaseModel):\n            a: int\n\n            model_config = ConfigDict(revalidate_instances='always')", "url": "https://docs.pydantic.dev/latest/docs/concepts/models/#validating-data", "page": "docs/concepts/models", "source_site": "pydantic"}
{"title": "Validating data", "anchor": "validating-data", "heading_level": 2, "md_text": "\n        m = Model(a=0)\n        # note: setting `validate_assignment` to `True` in the config can prevent this kind of misbehavior.\n        m.a = 'not an int'\n\n        try:\n            m2 = Model.model_validate(m)\n        except ValidationError as e:\n            print(e)\n            \"\"\"\n            1 validation error for Model\n            a\n              Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='not an int', input_type=str]\n            \"\"\"\n        ```", "url": "https://docs.pydantic.dev/latest/docs/concepts/models/#validating-data", "page": "docs/concepts/models", "source_site": "pydantic"}
{"title": "Creating models without validation", "anchor": "creating-models-without-validation", "heading_level": 3, "md_text": "Pydantic also provides the [`model_construct()`][pydantic.main.BaseModel.model_construct] method, which allows models to be created **without validation**.\nThis can be useful in at least a few cases:\n\n* when working with complex data that is already known to be valid (for performance reasons)\n* when one or more of the validator functions are non-idempotent\n* when one or more of the validator functions have side effects that you don't want to be triggered.\n\n!!! warning\n    [`model_construct()`][pydantic.main.BaseModel.model_construct] does not do any validation, meaning it can create\n    models which are invalid. **You should only ever use the [`model_construct()`][pydantic.main.BaseModel.model_construct]\n    method with data which has already been validated, or that you definitely trust.**\n\n!!! note\n    In Pydantic V2, the performance gap between validation (either with direct instantiation or the `model_validate*` methods)\n    and [`model_construct()`][pydantic.main.BaseModel.model_construct] has been narrowed\n    considerably. For simple models, going with validation may even be faster. If you are using [`model_construct()`][pydantic.main.BaseModel.model_construct]\n    for performance reasons, you may want to profile your use case before assuming it is actually faster.\n\nNote that for [root models](#rootmodel-and-custom-root-types), the root value can be passed to\n[`model_construct()`][pydantic.main.BaseModel.model_construct] positionally, instead of using a keyword argument.\n\nHere are some additional notes on the behavior of [`model_construct()`][pydantic.main.BaseModel.model_construct]:\n\n* When we say \"no validation is performed\" \u2014 this includes converting dictionaries to model instances. So if you have a field\n  referring to a model type, you will need to convert the inner dictionary to a model yourself.\n* If you do not pass keyword arguments for fields with defaults, the default values will still be used.\n* For models with private attributes, the `__pydantic_private__` dictionary will be populated the same as it would be when\n  creating the model with validation.\n* No `__init__` method from the model or any of its parent classes will be called, even when a custom `__init__` method is defined.\n\n!!! note \"On [extra data](#extra-data) behavior with [`model_construct()`][pydantic.main.BaseModel.model_construct]\"\n\n    * For models with [`extra`][pydantic.ConfigDict.extra] set to `'allow'`, data not corresponding to fields will be correctly stored in\n    the `__pydantic_extra__` dictionary and saved to the model's `__dict__` attribute.\n    * For models with [`extra`][pydantic.ConfigDict.extra] set to `'ignore'`, data not corresponding to fields will be ignored \u2014 that is,\n    not stored in `__pydantic_extra__` or `__dict__` on the instance.\n    * Unlike when instantiating the model with validation, a call to [`model_construct()`][pydantic.main.BaseModel.model_construct] with [`extra`][pydantic.ConfigDict.extra] set to `'forbid'` doesn't raise an error in the presence of data not corresponding to fields. Rather, said input data is simply ignored.", "url": "https://docs.pydantic.dev/latest/docs/concepts/models/#creating-models-without-validation", "page": "docs/concepts/models", "source_site": "pydantic"}
{"title": "Model copy", "anchor": "model-copy", "heading_level": 2, "md_text": "??? api \"API Documentation\"\n    [`pydantic.main.BaseModel.model_copy`][pydantic.main.BaseModel.model_copy]<br>\n\nThe [`model_copy()`][pydantic.BaseModel.model_copy] method allows models to be duplicated (with optional updates),\nwhich is particularly useful when working with frozen models.\n\n```python\nfrom pydantic import BaseModel\n\n\nclass BarModel(BaseModel):\n    whatever: int\n\n\nclass FooBarModel(BaseModel):\n    banana: float\n    foo: str\n    bar: BarModel\n\n\nm = FooBarModel(banana=3.14, foo='hello', bar={'whatever': 123})\n\nprint(m.model_copy(update={'banana': 0}))\n#> banana=0 foo='hello' bar=BarModel(whatever=123)", "url": "https://docs.pydantic.dev/latest/docs/concepts/models/#model-copy", "page": "docs/concepts/models", "source_site": "pydantic"}
{"title": "normal copy gives the same object reference for bar:", "anchor": "normal-copy-gives-the-same-object-reference-for-bar", "heading_level": 1, "md_text": "print(id(m.bar) == id(m.model_copy().bar))\n#> True", "url": "https://docs.pydantic.dev/latest/docs/concepts/models/#normal-copy-gives-the-same-object-reference-for-bar", "page": "docs/concepts/models", "source_site": "pydantic"}
{"title": "deep copy gives a new object reference for `bar`:", "anchor": "deep-copy-gives-a-new-object-reference-for-bar", "heading_level": 1, "md_text": "print(id(m.bar) == id(m.model_copy(deep=True).bar))\n#> False\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/models/#deep-copy-gives-a-new-object-reference-for-bar", "page": "docs/concepts/models", "source_site": "pydantic"}
{"title": "Generic models", "anchor": "generic-models", "heading_level": 2, "md_text": "Pydantic supports the creation of generic models to make it easier to reuse a common model structure. Both the new\n[type parameter syntax][type-params] (introduced by [PEP 695](https://peps.python.org/pep-0695/) in Python 3.12)\nand the old syntax are supported (refer to\n[the Python documentation](https://docs.python.org/3/library/typing.html#building-generic-types-and-type-aliases)\nfor more details).\n\nHere is an example using a generic Pydantic model to create an easily-reused HTTP response payload wrapper:\n\n<!-- TODO: tabs should be auto-generated if using Ruff (https://github.com/pydantic/pydantic/issues/10083) -->\n\n=== \"Python 3.9 and above\"\n\n    ```python {upgrade=\"skip\"}\n    from typing import Generic, TypeVar\n\n    from pydantic import BaseModel, ValidationError\n\n    DataT = TypeVar('DataT')  # (1)!\n\n\n    class DataModel(BaseModel):\n        number: int\n\n\n    class Response(BaseModel, Generic[DataT]):  # (2)!\n        data: DataT  # (3)!\n\n\n    print(Response[int](data=1))\n    #> data=1\n    print(Response[str](data='value'))\n    #> data='value'\n    print(Response[str](data='value').model_dump())\n    #> {'data': 'value'}\n\n    data = DataModel(number=1)\n    print(Response[DataModel](data=data).model_dump())\n    #> {'data': {'number': 1}}\n    try:\n        Response[int](data='value')\n    except ValidationError as e:\n        print(e)\n        \"\"\"\n        1 validation error for Response[int]\n        data\n          Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='value', input_type=str]\n        \"\"\"\n    ```\n\n    1. Declare one or more [type variables][typing.TypeVar] to use to parameterize your model.\n    2. Declare a Pydantic model that inherits from [`BaseModel`][pydantic.BaseModel] and [`typing.Generic`][]\n       (in this specific order), and add the list of type variables you declared previously as parameters to the\n       [`Generic`][typing.Generic] parent.\n    3. Use the type variables as annotations where you will want to replace them with other types.\n\n=== \"Python 3.12 and above (new syntax)\"\n\n    ```python {requires=\"3.12\" upgrade=\"skip\" lint=\"skip\"}\n    from pydantic import BaseModel, ValidationError\n\n\n    class DataModel(BaseModel):\n        number: int\n\n\n    class Response[DataT](BaseModel):  # (1)!\n        data: DataT  # (2)!\n\n\n    print(Response[int](data=1))\n    #> data=1\n    print(Response[str](data='value'))\n    #> data='value'\n    print(Response[str](data='value').model_dump())\n    #> {'data': 'value'}\n\n    data = DataModel(number=1)\n    print(Response[DataModel](data=data).model_dump())\n    #> {'data': {'number': 1}}\n    try:\n        Response[int](data='value')\n    except ValidationError as e:\n        print(e)\n        \"\"\"\n        1 validation error for Response[int]\n        data\n          Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='value', input_type=str]\n        \"\"\"\n    ```\n\n    1. Declare a Pydantic model and add the list of type variables as type parameters.\n    2. Use the type variables as annotations where you will want to replace them with other types.\n\n!!! warning\n    When parametrizing a model with a concrete type, Pydantic **does not** validate that the provided type\n    is [assignable to the type variable][spec-typevars-bound] if it has an upper bound.\n\n    [spec-typevars-bound]: https://typing.readthedocs.io/en/latest/spec/generics.html#type-variables-with-an-upper-bound\n\nAny [configuration](./config.md), [validation](./validators.md) or [serialization](./serialization.md) logic\nset on the generic model will also be applied to the parametrized classes, in the same way as when inheriting from\na model class. Any custom methods or attributes will also be inherited.\n\nGeneric models also integrate properly with type checkers, so you get all the type checking\nyou would expect if you were to declare a distinct type for each parametrization.\n\n!!! note\n    Internally, Pydantic creates subclasses of the generic model at runtime when the generic model class is parametrized.\n    These classes are cached, so there should be minimal overhead introduced by the use of generics models.\n\nTo inherit from a generic model and preserve the fact that it is generic, the subclass must also inherit from\n[`Generic`][typing.Generic]:\n\n```python\nfrom typing import Generic, TypeVar\n\nfrom pydantic import BaseModel\n\nTypeX = TypeVar('TypeX')\n\n\nclass BaseClass(BaseModel, Generic[TypeX]):\n    X: TypeX\n\n\nclass ChildClass(BaseClass[TypeX], Generic[TypeX]):\n    pass", "url": "https://docs.pydantic.dev/latest/docs/concepts/models/#generic-models", "page": "docs/concepts/models", "source_site": "pydantic"}
{"title": "Parametrize `TypeX` with `int`:", "anchor": "parametrize-typex-with-int", "heading_level": 1, "md_text": "print(ChildClass[int](X=1))\n#> X=1\n```\n\nYou can also create a generic subclass of a model that partially or fully replaces the type variables in the\nsuperclass:\n\n```python\nfrom typing import Generic, TypeVar\n\nfrom pydantic import BaseModel\n\nTypeX = TypeVar('TypeX')\nTypeY = TypeVar('TypeY')\nTypeZ = TypeVar('TypeZ')\n\n\nclass BaseClass(BaseModel, Generic[TypeX, TypeY]):\n    x: TypeX\n    y: TypeY\n\n\nclass ChildClass(BaseClass[int, TypeY], Generic[TypeY, TypeZ]):\n    z: TypeZ", "url": "https://docs.pydantic.dev/latest/docs/concepts/models/#parametrize-typex-with-int", "page": "docs/concepts/models", "source_site": "pydantic"}
{"title": "Parametrize `TypeY` with `str`:", "anchor": "parametrize-typey-with-str", "heading_level": 1, "md_text": "print(ChildClass[str, int](x='1', y='y', z='3'))\n#> x=1 y='y' z=3\n```\n\nIf the name of the concrete subclasses is important, you can also override the default name generation\nby overriding the [`model_parametrized_name()`][pydantic.main.BaseModel.model_parametrized_name] method:\n\n```python\nfrom typing import Any, Generic, TypeVar\n\nfrom pydantic import BaseModel\n\nDataT = TypeVar('DataT')\n\n\nclass Response(BaseModel, Generic[DataT]):\n    data: DataT\n\n    @classmethod\n    def model_parametrized_name(cls, params: tuple[type[Any], ...]) -> str:\n        return f'{params[0].__name__.title()}Response'\n\n\nprint(repr(Response[int](data=1)))\n#> IntResponse(data=1)\nprint(repr(Response[str](data='a')))\n#> StrResponse(data='a')\n```\n\nYou can use parametrized generic models as types in other models:\n\n```python\nfrom typing import Generic, TypeVar\n\nfrom pydantic import BaseModel\n\nT = TypeVar('T')\n\n\nclass ResponseModel(BaseModel, Generic[T]):\n    content: T\n\n\nclass Product(BaseModel):\n    name: str\n    price: float\n\n\nclass Order(BaseModel):\n    id: int\n    product: ResponseModel[Product]\n\n\nproduct = Product(name='Apple', price=0.5)\nresponse = ResponseModel[Product](content=product)\norder = Order(id=1, product=response)\nprint(repr(order))\n\"\"\"\nOrder(id=1, product=ResponseModel[Product](content=Product(name='Apple', price=0.5)))\n\"\"\"\n```\n\nUsing the same type variable in nested models allows you to enforce typing relationships at different points in your model:\n\n```python\nfrom typing import Generic, TypeVar\n\nfrom pydantic import BaseModel, ValidationError\n\nT = TypeVar('T')\n\n\nclass InnerT(BaseModel, Generic[T]):\n    inner: T\n\n\nclass OuterT(BaseModel, Generic[T]):\n    outer: T\n    nested: InnerT[T]\n\n\nnested = InnerT[int](inner=1)\nprint(OuterT[int](outer=1, nested=nested))\n#> outer=1 nested=InnerT[int](inner=1)\ntry:\n    print(OuterT[int](outer='a', nested=InnerT(inner='a')))  # (1)!\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for OuterT[int]\n    outer\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='a', input_type=str]\n    nested.inner\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='a', input_type=str]\n    \"\"\"\n```\n\n1. The `OuterT` model is parametrized with `int`, but the data associated with the the `T` annotations during validation is of type `str`, leading to validation errors.\n\n!!! warning\n    While it may not raise an error, we strongly advise against using parametrized generics in [`isinstance()`](https://docs.python.org/3/library/functions.html#isinstance) checks.\n\n    For example, you should not do `isinstance(my_model, MyGenericModel[int])`. However, it is fine to do `isinstance(my_model, MyGenericModel)` (note that, for standard generics, it would raise an error to do a subclass check with a parameterized generic class).\n\n    If you need to perform [`isinstance()`](https://docs.python.org/3/library/functions.html#isinstance) checks against parametrized generics, you can do this by subclassing the parametrized generic class:\n\n    ```python {test=\"skip\" lint=\"skip\"}\n    class MyIntModel(MyGenericModel[int]): ...\n\n    isinstance(my_model, MyIntModel)\n    ```\n\n??? note \"Implementation Details\"\n    When using nested generic models, Pydantic sometimes performs revalidation in an attempt to produce the most intuitive validation result.\n    Specifically, if you have a field of type `GenericModel[SomeType]` and you validate data like `GenericModel[SomeCompatibleType]` against this field,\n    we will inspect the data, recognize that the input data is sort of a \"loose\" subclass of `GenericModel`, and revalidate the contained `SomeCompatibleType` data.\n\n    This adds some validation overhead, but makes things more intuitive for cases like that shown below.\n\n    ```python\n    from typing import Any, Generic, TypeVar\n\n    from pydantic import BaseModel\n\n    T = TypeVar('T')\n\n\n    class GenericModel(BaseModel, Generic[T]):\n        a: T\n\n\n    class Model(BaseModel):\n        inner: GenericModel[Any]\n\n\n    print(repr(Model.model_validate(Model(inner=GenericModel[int](a=1)))))\n    #> Model(inner=GenericModel[Any](a=1))\n    ```\n\n    Note, validation will still fail if you, for example are validating against `GenericModel[int]` and pass in an instance `GenericModel[str](a='not an int')`.", "url": "https://docs.pydantic.dev/latest/docs/concepts/models/#parametrize-typey-with-str", "page": "docs/concepts/models", "source_site": "pydantic"}
{"title": "Parametrize `TypeY` with `str`:", "anchor": "parametrize-typey-with-str", "heading_level": 1, "md_text": "    It's also worth noting that this pattern will re-trigger any custom validation as well, like additional model validators and the like.\n    Validators will be called once on the first pass, validating directly against `GenericModel[Any]`. That validation fails, as `GenericModel[int]` is not a subclass of `GenericModel[Any]`. This relates to the warning above about the complications of using parametrized generics in `isinstance()` and `issubclass()` checks.\n    Then, the validators will be called again on the second pass, during more lax force-revalidation phase, which succeeds.\n    To better understand this consequence, see below:\n\n    ```python {test=\"skip\"}\n    from typing import Any, Generic, Self, TypeVar\n\n    from pydantic import BaseModel, model_validator\n\n    T = TypeVar('T')\n\n\n    class GenericModel(BaseModel, Generic[T]):\n        a: T\n\n        @model_validator(mode='after')\n        def validate_after(self: Self) -> Self:\n            print('after validator running custom validation...')\n            return self\n\n\n    class Model(BaseModel):\n        inner: GenericModel[Any]\n\n\n    m = Model.model_validate(Model(inner=GenericModel[int](a=1)))\n    #> after validator running custom validation...\n    #> after validator running custom validation...\n    print(repr(m))\n    #> Model(inner=GenericModel[Any](a=1))\n    ```", "url": "https://docs.pydantic.dev/latest/docs/concepts/models/#parametrize-typey-with-str", "page": "docs/concepts/models", "source_site": "pydantic"}
{"title": "Validation of unparametrized type variables", "anchor": "validation-of-unparametrized-type-variables", "heading_level": 3, "md_text": "When leaving type variables unparametrized, Pydantic treats generic models similarly to how it treats built-in generic\ntypes like [`list`][] and [`dict`][]:\n\n* If the type variable is [bound](https://typing.readthedocs.io/en/latest/reference/generics.html#type-variables-with-upper-bounds)\n  or [constrained](https://typing.readthedocs.io/en/latest/reference/generics.html#type-variables-with-constraints) to a specific type,\n  it will be used.\n* If the type variable has a default type (as specified by [PEP 696](https://peps.python.org/pep-0696/)), it will be used.\n* For unbound or unconstrained type variables, Pydantic will fallback to [`Any`][typing.Any].\n\n```python\nfrom typing import Generic\n\nfrom typing_extensions import TypeVar\n\nfrom pydantic import BaseModel, ValidationError\n\nT = TypeVar('T')\nU = TypeVar('U', bound=int)\nV = TypeVar('V', default=str)\n\n\nclass Model(BaseModel, Generic[T, U, V]):\n    t: T\n    u: U\n    v: V\n\n\nprint(Model(t='t', u=1, v='v'))\n#> t='t' u=1 v='v'\n\ntry:\n    Model(t='t', u='u', v=1)\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    2 validation errors for Model\n    u\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='u', input_type=str]\n    v\n      Input should be a valid string [type=string_type, input_value=1, input_type=int]\n    \"\"\"\n```\n\n!!! warning\n\n    In some cases, validation against an unparametrized generic model can lead to data loss. Specifically, if a subtype of the type variable upper bound, constraints, or default is being used and the model isn't explicitly parametrized, the resulting type **will not be** the one being provided:\n\n    ```python\n    from typing import Generic, TypeVar\n\n    from pydantic import BaseModel\n\n    ItemT = TypeVar('ItemT', bound='ItemBase')\n\n\n    class ItemBase(BaseModel): ...\n\n\n    class IntItem(ItemBase):\n        value: int\n\n\n    class ItemHolder(BaseModel, Generic[ItemT]):\n        item: ItemT\n\n\n    loaded_data = {'item': {'value': 1}}\n\n\n    print(ItemHolder(**loaded_data))  # (1)!\n    #> item=ItemBase()\n\n    print(ItemHolder[IntItem](**loaded_data))  # (2)!\n    #> item=IntItem(value=1)\n    ```\n\n    1. When the generic isn't parametrized, the input data is validated against the `ItemT` upper bound.\n       Given that `ItemBase` has no fields, the `item` field information is lost.\n    2. In this case, the type variable is explicitly parametrized, so the input data is validated against the `IntItem` class.", "url": "https://docs.pydantic.dev/latest/docs/concepts/models/#validation-of-unparametrized-type-variables", "page": "docs/concepts/models", "source_site": "pydantic"}
{"title": "Serialization of unparametrized type variables", "anchor": "serialization-of-unparametrized-type-variables", "heading_level": 3, "md_text": "The behavior of serialization differs when using type variables with [upper bounds](https://typing.readthedocs.io/en/latest/reference/generics.html#type-variables-with-upper-bounds), [constraints](https://typing.readthedocs.io/en/latest/reference/generics.html#type-variables-with-constraints), or a default value:\n\nIf a Pydantic model is used in a type variable upper bound and the type variable is never parametrized, then Pydantic will use the upper bound for validation but treat the value as [`Any`][typing.Any] in terms of serialization:\n\n```python\nfrom typing import Generic, TypeVar\n\nfrom pydantic import BaseModel\n\n\nclass ErrorDetails(BaseModel):\n    foo: str\n\n\nErrorDataT = TypeVar('ErrorDataT', bound=ErrorDetails)\n\n\nclass Error(BaseModel, Generic[ErrorDataT]):\n    message: str\n    details: ErrorDataT\n\n\nclass MyErrorDetails(ErrorDetails):\n    bar: str", "url": "https://docs.pydantic.dev/latest/docs/concepts/models/#serialization-of-unparametrized-type-variables", "page": "docs/concepts/models", "source_site": "pydantic"}
{"title": "serialized as Any", "anchor": "serialized-as-any", "heading_level": 1, "md_text": "error = Error(\n    message='We just had an error',\n    details=MyErrorDetails(foo='var', bar='var2'),\n)\nassert error.model_dump() == {\n    'message': 'We just had an error',\n    'details': {\n        'foo': 'var',\n        'bar': 'var2',\n    },\n}", "url": "https://docs.pydantic.dev/latest/docs/concepts/models/#serialized-as-any", "page": "docs/concepts/models", "source_site": "pydantic"}
{"title": "note that `'bar': 'var2'` is missing", "anchor": "note-that-bar-var2-is-missing", "heading_level": 1, "md_text": "error = Error[ErrorDetails](\n    message='We just had an error',\n    details=ErrorDetails(foo='var'),\n)\nassert error.model_dump() == {\n    'message': 'We just had an error',\n    'details': {\n        'foo': 'var',\n    },\n}\n```\n\nHere's another example of the above behavior, enumerating all permutations regarding bound specification and generic type parametrization:\n\n```python\nfrom typing import Generic, TypeVar\n\nfrom pydantic import BaseModel\n\nTBound = TypeVar('TBound', bound=BaseModel)\nTNoBound = TypeVar('TNoBound')\n\n\nclass IntValue(BaseModel):\n    value: int\n\n\nclass ItemBound(BaseModel, Generic[TBound]):\n    item: TBound\n\n\nclass ItemNoBound(BaseModel, Generic[TNoBound]):\n    item: TNoBound\n\n\nitem_bound_inferred = ItemBound(item=IntValue(value=3))\nitem_bound_explicit = ItemBound[IntValue](item=IntValue(value=3))\nitem_no_bound_inferred = ItemNoBound(item=IntValue(value=3))\nitem_no_bound_explicit = ItemNoBound[IntValue](item=IntValue(value=3))", "url": "https://docs.pydantic.dev/latest/docs/concepts/models/#note-that-bar-var2-is-missing", "page": "docs/concepts/models", "source_site": "pydantic"}
{"title": "calling `print(x.model_dump())` on any of the above instances results in the following:", "anchor": "calling-printxmodel_dump-on-any-of-the-above-instances-results-in-the-following", "heading_level": 1, "md_text": "#> {'item': {'value': 3}}\n```\n\nHowever, if [constraints](https://typing.readthedocs.io/en/latest/reference/generics.html#type-variables-with-constraints)\nor a default value (as per [PEP 696](https://peps.python.org/pep-0696/)) is being used, then the default type or constraints\nwill be used for both validation and serialization if the type variable is not parametrized. You can override this behavior\nusing [`SerializeAsAny`](./serialization.md#serializeasany-annotation):\n\n```python\nfrom typing import Generic\n\nfrom typing_extensions import TypeVar\n\nfrom pydantic import BaseModel, SerializeAsAny\n\n\nclass ErrorDetails(BaseModel):\n    foo: str\n\n\nErrorDataT = TypeVar('ErrorDataT', default=ErrorDetails)\n\n\nclass Error(BaseModel, Generic[ErrorDataT]):\n    message: str\n    details: ErrorDataT\n\n\nclass MyErrorDetails(ErrorDetails):\n    bar: str", "url": "https://docs.pydantic.dev/latest/docs/concepts/models/#calling-printxmodel_dump-on-any-of-the-above-instances-results-in-the-following", "page": "docs/concepts/models", "source_site": "pydantic"}
{"title": "serialized using the default's serializer", "anchor": "serialized-using-the-defaults-serializer", "heading_level": 1, "md_text": "error = Error(\n    message='We just had an error',\n    details=MyErrorDetails(foo='var', bar='var2'),\n)\nassert error.model_dump() == {\n    'message': 'We just had an error',\n    'details': {\n        'foo': 'var',\n    },\n}", "url": "https://docs.pydantic.dev/latest/docs/concepts/models/#serialized-using-the-defaults-serializer", "page": "docs/concepts/models", "source_site": "pydantic"}
{"title": "If `ErrorDataT` was using an upper bound, `bar` would be present in `details`.", "anchor": "if-errordatat-was-using-an-upper-bound-bar-would-be-present-in-details", "heading_level": 1, "md_text": "class SerializeAsAnyError(BaseModel, Generic[ErrorDataT]):\n    message: str\n    details: SerializeAsAny[ErrorDataT]", "url": "https://docs.pydantic.dev/latest/docs/concepts/models/#if-errordatat-was-using-an-upper-bound-bar-would-be-present-in-details", "page": "docs/concepts/models", "source_site": "pydantic"}
{"title": "serialized as Any", "anchor": "serialized-as-any", "heading_level": 1, "md_text": "error = SerializeAsAnyError(\n    message='We just had an error',\n    details=MyErrorDetails(foo='var', bar='baz'),\n)\nassert error.model_dump() == {\n    'message': 'We just had an error',\n    'details': {\n        'foo': 'var',\n        'bar': 'baz',\n    },\n}\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/models/#serialized-as-any", "page": "docs/concepts/models", "source_site": "pydantic"}
{"title": "Dynamic model creation", "anchor": "dynamic-model-creation", "heading_level": 2, "md_text": "??? api \"API Documentation\"\n    [`pydantic.main.create_model`][pydantic.main.create_model]<br>\n\nThere are some occasions where it is desirable to create a model using runtime information to specify the fields.\nPydantic provides the [`create_model()`][pydantic.create_model] function to allow models to be created dynamically:\n\n```python\nfrom pydantic import BaseModel, create_model\n\nDynamicFoobarModel = create_model('DynamicFoobarModel', foo=str, bar=(int, 123))", "url": "https://docs.pydantic.dev/latest/docs/concepts/models/#dynamic-model-creation", "page": "docs/concepts/models", "source_site": "pydantic"}
{"title": "Equivalent to:", "anchor": "equivalent-to", "heading_level": 1, "md_text": "class StaticFoobarModel(BaseModel):\n    foo: str\n    bar: int = 123\n```\n\nField definitions are specified as keyword arguments, and should either be:\n\n* A single element, representing the type annotation of the field.\n* A two-tuple, the first element being the type and the second element the assigned value\n  (either a default or the [`Field()`][pydantic.Field] function).\n\nHere is a more advanced example:\n\n```python\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Field, PrivateAttr, create_model\n\nDynamicModel = create_model(\n    'DynamicModel',\n    foo=(str, Field(alias='FOO')),\n    bar=Annotated[str, Field(description='Bar field')],\n    _private=(int, PrivateAttr(default=1)),\n)\n\n\nclass StaticModel(BaseModel):\n    foo: str = Field(alias='FOO')\n    bar: Annotated[str, Field(description='Bar field')]\n    _private: int = PrivateAttr(default=1)\n```\n\nThe special keyword arguments `__config__` and `__base__` can be used to customize the new model.\nThis includes extending a base model with extra fields.\n\n```python\nfrom pydantic import BaseModel, create_model\n\n\nclass FooModel(BaseModel):\n    foo: str\n    bar: int = 123\n\n\nBarModel = create_model(\n    'BarModel',\n    apple=(str, 'russet'),\n    banana=(str, 'yellow'),\n    __base__=FooModel,\n)\nprint(BarModel)\n#> <class '__main__.BarModel'>\nprint(BarModel.model_fields.keys())\n#> dict_keys(['foo', 'bar', 'apple', 'banana'])\n```\n\nYou can also add validators by passing a dictionary to the `__validators__` argument.\n\n```python {rewrite_assert=\"false\"}\nfrom pydantic import ValidationError, create_model, field_validator\n\n\ndef alphanum(cls, v):\n    assert v.isalnum(), 'must be alphanumeric'\n    return v\n\n\nvalidators = {\n    'username_validator': field_validator('username')(alphanum)  # (1)!\n}\n\nUserModel = create_model(\n    'UserModel', username=(str, ...), __validators__=validators\n)\n\nuser = UserModel(username='scolvin')\nprint(user)\n#> username='scolvin'\n\ntry:\n    UserModel(username='scolvi%n')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for UserModel\n    username\n      Assertion failed, must be alphanumeric [type=assertion_error, input_value='scolvi%n', input_type=str]\n    \"\"\"\n```\n\n1. Make sure that the validators names do not clash with any of the field names as\n   internally, Pydantic gathers all members into a namespace and mimics the normal\n   creation of a class using the [`types` module utilities](https://docs.python.org/3/library/types.html#dynamic-type-creation).\n\n!!! note\n    To pickle a dynamically created model:\n\n    * the model must be defined globally\n    * the `__module__` argument must be provided\n\nSee also: the [dynamic model example](../examples/dynamic_models.md), providing guidelines to derive an optional model from another one.", "url": "https://docs.pydantic.dev/latest/docs/concepts/models/#equivalent-to", "page": "docs/concepts/models", "source_site": "pydantic"}
{"title": "`RootModel` and custom root types", "anchor": "rootmodel-and-custom-root-types", "heading_level": 2, "md_text": "??? api \"API Documentation\"\n    [`pydantic.root_model.RootModel`][pydantic.root_model.RootModel]<br>\n\nPydantic models can be defined with a \"custom root type\" by subclassing [`pydantic.RootModel`][pydantic.RootModel].\n\nThe root type can be any type supported by Pydantic, and is specified by the generic parameter to `RootModel`.\nThe root value can be passed to the model `__init__` or [`model_validate`][pydantic.main.BaseModel.model_validate]\nvia the first and only argument.\n\nHere's an example of how this works:\n\n```python\nfrom pydantic import RootModel\n\nPets = RootModel[list[str]]\nPetsByName = RootModel[dict[str, str]]\n\n\nprint(Pets(['dog', 'cat']))\n#> root=['dog', 'cat']\nprint(Pets(['dog', 'cat']).model_dump_json())\n#> [\"dog\",\"cat\"]\nprint(Pets.model_validate(['dog', 'cat']))\n#> root=['dog', 'cat']\nprint(Pets.model_json_schema())\n\"\"\"\n{'items': {'type': 'string'}, 'title': 'RootModel[list[str]]', 'type': 'array'}\n\"\"\"\n\nprint(PetsByName({'Otis': 'dog', 'Milo': 'cat'}))\n#> root={'Otis': 'dog', 'Milo': 'cat'}\nprint(PetsByName({'Otis': 'dog', 'Milo': 'cat'}).model_dump_json())\n#> {\"Otis\":\"dog\",\"Milo\":\"cat\"}\nprint(PetsByName.model_validate({'Otis': 'dog', 'Milo': 'cat'}))\n#> root={'Otis': 'dog', 'Milo': 'cat'}\n```\n\nIf you want to access items in the `root` field directly or to iterate over the items, you can implement\ncustom `__iter__` and `__getitem__` functions, as shown in the following example.\n\n```python\nfrom pydantic import RootModel\n\n\nclass Pets(RootModel):\n    root: list[str]\n\n    def __iter__(self):\n        return iter(self.root)\n\n    def __getitem__(self, item):\n        return self.root[item]\n\n\npets = Pets.model_validate(['dog', 'cat'])\nprint(pets[0])\n#> dog\nprint([pet for pet in pets])\n#> ['dog', 'cat']\n```\n\nYou can also create subclasses of the parametrized root model directly:\n\n```python\nfrom pydantic import RootModel\n\n\nclass Pets(RootModel[list[str]]):\n    def describe(self) -> str:\n        return f'Pets: {\", \".join(self.root)}'\n\n\nmy_pets = Pets.model_validate(['dog', 'cat'])\n\nprint(my_pets.describe())\n#> Pets: dog, cat\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/models/#rootmodel-and-custom-root-types", "page": "docs/concepts/models", "source_site": "pydantic"}
{"title": "Faux immutability", "anchor": "faux-immutability", "heading_level": 2, "md_text": "Models can be configured to be immutable via `model_config['frozen'] = True`. When this is set, attempting to change the\nvalues of instance attributes will raise errors. See the [API reference][pydantic.config.ConfigDict.frozen] for more details.\n\n!!! note\n    This behavior was achieved in Pydantic V1 via the config setting `allow_mutation = False`.\n    This config flag is deprecated in Pydantic V2, and has been replaced with `frozen`.\n\n!!! warning\n    In Python, immutability is not enforced. Developers have the ability to modify objects\n    that are conventionally considered \"immutable\" if they choose to do so.\n\n```python\nfrom pydantic import BaseModel, ConfigDict, ValidationError\n\n\nclass FooBarModel(BaseModel):\n    model_config = ConfigDict(frozen=True)\n\n    a: str\n    b: dict\n\n\nfoobar = FooBarModel(a='hello', b={'apple': 'pear'})\n\ntry:\n    foobar.a = 'different'\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for FooBarModel\n    a\n      Instance is frozen [type=frozen_instance, input_value='different', input_type=str]\n    \"\"\"\n\nprint(foobar.a)\n#> hello\nprint(foobar.b)\n#> {'apple': 'pear'}\nfoobar.b['apple'] = 'grape'\nprint(foobar.b)\n#> {'apple': 'grape'}\n```\n\nTrying to change `a` caused an error, and `a` remains unchanged. However, the dict `b` is mutable, and the\nimmutability of `foobar` doesn't stop `b` from being changed.", "url": "https://docs.pydantic.dev/latest/docs/concepts/models/#faux-immutability", "page": "docs/concepts/models", "source_site": "pydantic"}
{"title": "Abstract base classes", "anchor": "abstract-base-classes", "heading_level": 2, "md_text": "Pydantic models can be used alongside Python's\n[Abstract Base Classes](https://docs.python.org/3/library/abc.html) (ABCs).\n\n```python\nimport abc\n\nfrom pydantic import BaseModel\n\n\nclass FooBarModel(BaseModel, abc.ABC):\n    a: str\n    b: int\n\n    @abc.abstractmethod\n    def my_abstract_method(self):\n        pass\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/models/#abstract-base-classes", "page": "docs/concepts/models", "source_site": "pydantic"}
{"title": "Field ordering", "anchor": "field-ordering", "heading_level": 2, "md_text": "Field order affects models in the following ways:\n\n* field order is preserved in the model [JSON Schema](json_schema.md)\n* field order is preserved in [validation errors](#error-handling)\n* field order is preserved when [serializing data](serialization.md#serializing-data)\n\n```python\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    a: int\n    b: int = 2\n    c: int = 1\n    d: int = 0\n    e: float\n\n\nprint(Model.model_fields.keys())\n#> dict_keys(['a', 'b', 'c', 'd', 'e'])\nm = Model(e=2, a=1)\nprint(m.model_dump())\n#> {'a': 1, 'b': 2, 'c': 1, 'd': 0, 'e': 2.0}\ntry:\n    Model(a='x', b='x', c='x', d='x', e='x')\nexcept ValidationError as err:\n    error_locations = [e['loc'] for e in err.errors()]\n\nprint(error_locations)\n#> [('a',), ('b',), ('c',), ('d',), ('e',)]\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/models/#field-ordering", "page": "docs/concepts/models", "source_site": "pydantic"}
{"title": "Class variables", "anchor": "class-variables", "heading_level": 3, "md_text": "Attributes annotated with [`ClassVar`][typing.ClassVar] are properly treated by Pydantic as class variables, and will not\nbecome fields on model instances:\n\n```python\nfrom typing import ClassVar\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    x: ClassVar[int] = 1\n\n    y: int = 2\n\n\nm = Model()\nprint(m)\n#> y=2\nprint(Model.x)\n#> 1\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/models/#class-variables", "page": "docs/concepts/models", "source_site": "pydantic"}
{"title": "Private model attributes", "anchor": "private-model-attributes", "heading_level": 3, "md_text": "??? api \"API Documentation\"\n    [`pydantic.fields.PrivateAttr`][pydantic.fields.PrivateAttr]<br>\n\nAttributes whose name has a leading underscore are not treated as fields by Pydantic, and are not included in the\nmodel schema. Instead, these are converted into a \"private attribute\" which is not validated or even set during\ncalls to `__init__`, `model_validate`, etc.\n\nHere is an example of usage:\n\n```python\nfrom datetime import datetime\nfrom random import randint\nfrom typing import Any\n\nfrom pydantic import BaseModel, PrivateAttr\n\n\nclass TimeAwareModel(BaseModel):\n    _processed_at: datetime = PrivateAttr(default_factory=datetime.now)\n    _secret_value: str\n\n    def model_post_init(self, context: Any) -> None:\n        # this could also be done with `default_factory`:\n        self._secret_value = randint(1, 5)\n\n\nm = TimeAwareModel()\nprint(m._processed_at)\n#> 2032-01-02 03:04:05.000006\nprint(m._secret_value)\n#> 3\n```\n\nPrivate attribute names must start with underscore to prevent conflicts with model fields. However, dunder names\n(such as `__attr__`) are not supported, and will be completely ignored from the model definition.", "url": "https://docs.pydantic.dev/latest/docs/concepts/models/#private-model-attributes", "page": "docs/concepts/models", "source_site": "pydantic"}
{"title": "Model signature", "anchor": "model-signature", "heading_level": 2, "md_text": "All Pydantic models will have their signature generated based on their fields:\n\n```python\nimport inspect\n\nfrom pydantic import BaseModel, Field\n\n\nclass FooModel(BaseModel):\n    id: int\n    name: str = None\n    description: str = 'Foo'\n    apple: int = Field(alias='pear')\n\n\nprint(inspect.signature(FooModel))\n#> (*, id: int, name: str = None, description: str = 'Foo', pear: int) -> None\n```\n\nAn accurate signature is useful for introspection purposes and libraries like `FastAPI` or `hypothesis`.\n\nThe generated signature will also respect custom `__init__` functions:\n\n```python\nimport inspect\n\nfrom pydantic import BaseModel\n\n\nclass MyModel(BaseModel):\n    id: int\n    info: str = 'Foo'\n\n    def __init__(self, id: int = 1, *, bar: str, **data) -> None:\n        \"\"\"My custom init!\"\"\"\n        super().__init__(id=id, bar=bar, **data)\n\n\nprint(inspect.signature(MyModel))\n#> (id: int = 1, *, bar: str, info: str = 'Foo') -> None\n```\n\nTo be included in the signature, a field's alias or name must be a valid Python identifier.\nPydantic will prioritize a field's alias over its name when generating the signature, but may use the field name if the\nalias is not a valid Python identifier.\n\nIf a field's alias and name are *both* not valid identifiers (which may be possible through exotic use of `create_model`),\na `**data` argument will be added. In addition, the `**data` argument will always be present in the signature if\n`model_config['extra'] == 'allow'`.", "url": "https://docs.pydantic.dev/latest/docs/concepts/models/#model-signature", "page": "docs/concepts/models", "source_site": "pydantic"}
{"title": "Structural pattern matching", "anchor": "structural-pattern-matching", "heading_level": 2, "md_text": "Pydantic supports structural pattern matching for models, as introduced by [PEP 636](https://peps.python.org/pep-0636/) in Python 3.10.\n\n```python {requires=\"3.10\" lint=\"skip\"}\nfrom pydantic import BaseModel\n\n\nclass Pet(BaseModel):\n    name: str\n    species: str\n\n\na = Pet(name='Bones', species='dog')\n\nmatch a:\n    # match `species` to 'dog', declare and initialize `dog_name`\n    case Pet(species='dog', name=dog_name):\n        print(f'{dog_name} is a dog')\n#> Bones is a dog\n    # default case\n    case _:\n        print('No dog matched')\n```\n\n!!! note\n    A match-case statement may seem as if it creates a new model, but don't be fooled;\n    it is just syntactic sugar for getting an attribute and either comparing it or declaring and initializing it.", "url": "https://docs.pydantic.dev/latest/docs/concepts/models/#structural-pattern-matching", "page": "docs/concepts/models", "source_site": "pydantic"}
{"title": "Attribute copies", "anchor": "attribute-copies", "heading_level": 2, "md_text": "In many cases, arguments passed to the constructor will be copied in order to perform validation and, where necessary,\ncoercion.\n\nIn this example, note that the ID of the list changes after the class is constructed because it has been\ncopied during validation:\n\n```python\nfrom pydantic import BaseModel\n\n\nclass C1:\n    arr = []\n\n    def __init__(self, in_arr):\n        self.arr = in_arr\n\n\nclass C2(BaseModel):\n    arr: list[int]\n\n\narr_orig = [1, 9, 10, 3]\n\n\nc1 = C1(arr_orig)\nc2 = C2(arr=arr_orig)\nprint(f'{id(c1.arr) == id(c2.arr)=}')\n#> id(c1.arr) == id(c2.arr)=False\n```\n\n!!! note\n    There are some situations where Pydantic does not copy attributes, such as when passing models &mdash; we use the\n    model as is. You can override this behaviour by setting\n    [`model_config['revalidate_instances'] = 'always'`](../api/config.md#pydantic.config.ConfigDict).", "url": "https://docs.pydantic.dev/latest/docs/concepts/models/#attribute-copies", "page": "docs/concepts/models", "source_site": "pydantic"}
{"title": "serialization", "anchor": null, "heading_level": 0, "md_text": "Beyond accessing model attributes directly via their field names (e.g. `model.foobar`), models can be converted, dumped,\nserialized, and exported in a number of ways. Serialization can be customized for the whole model, or on a per-field\nor per-type basis.\n\n??? abstract \"Serialize versus dump\"\n    Pydantic uses the terms \"serialize\" and \"dump\" interchangeably. Both refer to the process of converting a model to a\n    dictionary or JSON-encoded string.\n\n    Outside of Pydantic, the word \"serialize\" usually refers to converting in-memory data into a string or bytes.\n    However, in the context of Pydantic, there is a very close relationship between converting an object from a more\n    structured form &mdash; such as a Pydantic model, a dataclass, etc. &mdash; into a less structured form comprised of\n    Python built-ins such as dict.\n\n    While we could (and on occasion, do) distinguish between these scenarios by using the word \"dump\" when converting to\n    primitives and \"serialize\" when converting to string, for practical purposes, we frequently use the word \"serialize\"\n    to refer to both of these situations, even though it does not always imply conversion to a string or bytes.\n\n!!! tip\n    Want to quickly jump to the relevant serializer section?\n\n    <div class=\"grid cards\" markdown>\n\n    *   Field serializer\n\n        ---\n\n        * [field *plain* serializer](#field-plain-serializer)\n        * [field *wrap* serializer](#field-wrap-serializer)\n\n    *   Model serializer\n\n        ---\n\n        * [model *plain* serializer](#model-plain-serializer)\n        * [model *wrap* serializer](#model-wrap-serializer)\n\n    </div>", "url": "https://docs.pydantic.dev/latest/docs/concepts/serialization/", "page": "docs/concepts/serialization", "source_site": "pydantic"}
{"title": "Serializing data", "anchor": "serializing-data", "heading_level": 2, "md_text": "Pydantic allows models (and any other type using [type adapters](./type_adapter.md)) to be serialized in *two* modes:\n[Python](#python-mode) and [JSON](#json-mode). The Python output may contain non-JSON serializable data (although this\ncan be emulated).\n\n<!-- old anchor added for backwards compatibility -->\n<!-- markdownlint-disable-next-line no-empty-links -->\n[](){#modelmodel_dump}", "url": "https://docs.pydantic.dev/latest/docs/concepts/serialization/#serializing-data", "page": "docs/concepts/serialization", "source_site": "pydantic"}
{"title": "Python mode", "anchor": "python-mode", "heading_level": 3, "md_text": "When using the Python mode, Pydantic models (and model-like types such as [dataclasses][]) (1) will be (recursively) converted to dictionaries. This is achievable by using the [`model_dump()`][pydantic.BaseModel.model_dump] method:\n{ .annotate }\n\n1. With the exception of [root models](./models.md#rootmodel-and-custom-root-types), where the root value is dumped directly.\n\n```python {group=\"python-dump\"}\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field\n\n\nclass BarModel(BaseModel):\n    whatever: tuple[int, ...]\n\n\nclass FooBarModel(BaseModel):\n    banana: Optional[float] = 1.1\n    foo: str = Field(serialization_alias='foo_alias')\n    bar: BarModel\n\n\nm = FooBarModel(banana=3.14, foo='hello', bar={'whatever': (1, 2)})", "url": "https://docs.pydantic.dev/latest/docs/concepts/serialization/#python-mode", "page": "docs/concepts/serialization", "source_site": "pydantic"}
{"title": "returns a dictionary:", "anchor": "returns-a-dictionary", "heading_level": 1, "md_text": "print(m.model_dump())\n#> {'banana': 3.14, 'foo': 'hello', 'bar': {'whatever': (1, 2)}}\n\nprint(m.model_dump(by_alias=True))\n#> {'banana': 3.14, 'foo_alias': 'hello', 'bar': {'whatever': (1, 2)}}\n```\n\nNotice that the value of `whatever` was dumped as tuple, which isn't a known JSON type. The `mode` argument can be set to `'json'`\nto ensure JSON-compatible types are used:\n\n```python {group=\"python-dump\"}\nprint(m.model_dump(mode='json'))\n#> {'banana': 3.14, 'foo': 'hello', 'bar': {'whatever': [1, 2]}}\n```\n\n!!! info \"See also\"\n    The [`TypeAdapter.dump_python()`][pydantic.TypeAdapter.dump_python] method, useful when *not* dealing with Pydantic models.\n\n<!-- old anchor added for backwards compatibility -->\n<!-- markdownlint-disable-next-line no-empty-links -->\n[](){#modelmodel_dump_json}", "url": "https://docs.pydantic.dev/latest/docs/concepts/serialization/#returns-a-dictionary", "page": "docs/concepts/serialization", "source_site": "pydantic"}
{"title": "JSON mode", "anchor": "json-mode", "heading_level": 3, "md_text": "Pydantic allows data to be serialized directly to a JSON-encoded string, by trying its best to convert Python values to valid\nJSON data. This is achievable by using the [`model_dump_json()`][pydantic.BaseModel.model_dump_json] method:\n\n```python\nfrom datetime import datetime\n\nfrom pydantic import BaseModel\n\n\nclass BarModel(BaseModel):\n    whatever: tuple[int, ...]\n\n\nclass FooBarModel(BaseModel):\n    foo: datetime\n    bar: BarModel\n\n\nm = FooBarModel(foo=datetime(2032, 6, 1, 12, 13, 14), bar={'whatever': (1, 2)})\n\nprint(m.model_dump_json(indent=2))\n\"\"\"\n{\n  \"foo\": \"2032-06-01T12:13:14\",\n  \"bar\": {\n    \"whatever\": [\n      1,\n      2\n    ]\n  }\n}\n\"\"\"\n```\n\nIn addition to the [supported types][json.JSONEncoder] by the standard library [`json`][] module, Pydantic supports a wide\nvariety of types ([date and time types][datetime], [`UUID`][uuid.UUID] objects, [sets][set], etc). If an unsupported type\nis used and can't be serialized to JSON, a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] exception\nis raised.\n\n!!! info \"See also\"\n    The [`TypeAdapter.dump_json()`][pydantic.TypeAdapter.dump_json] method, useful when *not* dealing with Pydantic models.\n\n<!-- old anchor added for backwards compatibility -->\n<!-- markdownlint-disable-next-line no-empty-links -->\n[](){#dictmodel-and-iteration}", "url": "https://docs.pydantic.dev/latest/docs/concepts/serialization/#json-mode", "page": "docs/concepts/serialization", "source_site": "pydantic"}
{"title": "Iterating over models", "anchor": "iterating-over-models", "heading_level": 2, "md_text": "Pydantic models can also be iterated over, yielding `(field_name, field_value)` pairs. Note that field values\nare left as is, so sub-models will *not* be converted to dictionaries:\n\n```python {group=\"iterating-model\"}\nfrom pydantic import BaseModel\n\n\nclass BarModel(BaseModel):\n    whatever: int\n\n\nclass FooBarModel(BaseModel):\n    banana: float\n    foo: str\n    bar: BarModel\n\n\nm = FooBarModel(banana=3.14, foo='hello', bar={'whatever': 123})\n\nfor name, value in m:\n    print(f'{name}: {value}')\n    #> banana: 3.14\n    #> foo: hello\n    #> bar: whatever=123\n```\n\nThis means that calling [`dict()`][dict] on a model can be used to construct a dictionary of the model:\n\n```python {group=\"iterating-model\"}\nprint(dict(m))\n#> {'banana': 3.14, 'foo': 'hello', 'bar': BarModel(whatever=123)}\n```\n\n!!! note\n    [Root models](models.md#rootmodel-and-custom-root-types) *does* get converted to a dictionary with the key `'root'`.\n\n<!-- old anchor added for backwards compatibility -->\n<!-- markdownlint-disable-next-line no-empty-links -->\n[](){#pickledumpsmodel}", "url": "https://docs.pydantic.dev/latest/docs/concepts/serialization/#iterating-over-models", "page": "docs/concepts/serialization", "source_site": "pydantic"}
{"title": "Pickling support", "anchor": "pickling-support", "heading_level": 2, "md_text": "Pydantic models support efficient pickling and unpickling.\n\n<!-- TODO need to get pickling doctest to work -->\n```python {test=\"skip\"}\nimport pickle\n\nfrom pydantic import BaseModel\n\n\nclass FooBarModel(BaseModel):\n    a: str\n    b: int\n\n\nm = FooBarModel(a='hello', b=123)\nprint(m)\n#> a='hello' b=123\ndata = pickle.dumps(m)\nprint(data[:20])\n#> b'\\x80\\x04\\x95\\x95\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x8c\\x08__main_'\nm2 = pickle.loads(data)\nprint(m2)\n#> a='hello' b=123\n```\n\n<!-- old anchor added for backwards compatibility -->\n<!-- markdownlint-disable-next-line no-empty-links -->\n[](){#custom-serializers}", "url": "https://docs.pydantic.dev/latest/docs/concepts/serialization/#pickling-support", "page": "docs/concepts/serialization", "source_site": "pydantic"}
{"title": "Serializers", "anchor": "serializers", "heading_level": 2, "md_text": "Similar to [custom validators](./validators.md), you can leverage custom serializers at the field and model levels to further\ncontrol the serialization behavior.\n\n!!! warning\n    Only *one* serializer can be defined per field/model. It is not possible to combine multiple serializers together\n    (including *plain* and *wrap* serializers).", "url": "https://docs.pydantic.dev/latest/docs/concepts/serialization/#serializers", "page": "docs/concepts/serialization", "source_site": "pydantic"}
{"title": "Field serializers", "anchor": "field-serializers", "heading_level": 3, "md_text": "??? api \"API Documentation\"\n    [`pydantic.functional_serializers.PlainSerializer`][pydantic.functional_serializers.PlainSerializer]<br>\n    [`pydantic.functional_serializers.WrapSerializer`][pydantic.functional_serializers.WrapSerializer]<br>\n    [`pydantic.functional_serializers.field_serializer`][pydantic.functional_serializers.field_serializer]<br>\n\nIn its simplest form, a field serializer is a callable taking the value to be serialized as an argument and\n**returning the serialized value**.\n\nIf the `return_type` argument is provided to the serializer (or if a return type annotation is available on the serializer function),\nit will be used to build an extra serializer, to ensure that the serialized field value complies with this return type.\n\n**Two** different types of serializers can be used. They can all be defined using the\n[annotated pattern](./fields.md#the-annotated-pattern) or using the\n[`@field_serializer`][pydantic.field_serializer] decorator, applied on instance or [static methods][staticmethod].\n\n* ***Plain* serializers**: are called unconditionally to serialize a field. The serialization logic for types supported\n  by Pydantic will *not* be called. Using such serializers is also useful to specify the logic for arbitrary types.\n  {#field-plain-serializer}\n\n    === \"Annotated pattern\"\n\n        ```python\n        from typing import Annotated, Any\n\n        from pydantic import BaseModel, PlainSerializer\n\n\n        def ser_number(value: Any) -> Any:\n            if isinstance(value, int):\n                return value * 2\n            else:\n                return value\n\n\n        class Model(BaseModel):\n            number: Annotated[int, PlainSerializer(ser_number)]\n\n\n        print(Model(number=4).model_dump())\n        #> {'number': 8}\n        m = Model(number=1)\n        m.number = 'invalid'\n        print(m.model_dump())  # (1)!\n        #> {'number': 'invalid'}\n        ```\n\n        1. Pydantic will *not* validate that the serialized value complies with the `int` type.\n\n    === \"Decorator\"\n\n        ```python\n        from typing import Any\n\n        from pydantic import BaseModel, field_serializer\n\n\n        class Model(BaseModel):\n            number: int\n\n            @field_serializer('number', mode='plain')  # (1)!\n            def ser_number(self, value: Any) -> Any:\n                if isinstance(value, int):\n                    return value * 2\n                else:\n                    return value\n\n\n        print(Model(number=4).model_dump())\n        #> {'number': 8}\n        m = Model(number=1)\n        m.number = 'invalid'\n        print(m.model_dump())  # (2)!\n        #> {'number': 'invalid'}\n        ```\n\n        1. `'plain'` is the default mode for the decorator, and can be omitted.\n        2. Pydantic will *not* validate that the serialized value complies with the `int` type.\n\n* ***Wrap* serializers**: give more flexibility to customize the serialization behavior. You can run code before or after\n  the Pydantic serialization logic.\n  {#field-wrap-serializer}\n\n    Such serializers must be defined with a **mandatory** extra *handler* parameter: a callable taking the value to be serialized\n    as an argument. Internally, this handler will delegate serialization of the value to Pydantic. You are free to *not* call the\n    handler at all.\n\n    === \"Annotated pattern\"\n\n        ```python\n        from typing import Annotated, Any\n\n        from pydantic import BaseModel, SerializerFunctionWrapHandler, WrapSerializer\n\n\n        def ser_number(value: Any, handler: SerializerFunctionWrapHandler) -> int:\n            return handler(value) + 1\n\n\n        class Model(BaseModel):\n            number: Annotated[int, WrapSerializer(ser_number)]\n\n\n        print(Model(number=4).model_dump())\n        #> {'number': 5}\n        ```\n\n    === \"Decorator\"\n\n        ```python\n        from typing import Any\n\n        from pydantic import BaseModel, SerializerFunctionWrapHandler, field_serializer\n\n\n        class Model(BaseModel):\n            number: int\n\n            @field_serializer('number', mode='wrap')\n            def ser_number(\n                self, value: Any, handler: SerializerFunctionWrapHandler\n            ) -> int:\n                return handler(value) + 1\n\n\n        print(Model(number=4).model_dump())\n        #> {'number': 5}\n        ```\n\n<!-- Note: keep this section updated with [the validator one](./validators.md#which-validator-pattern-to-use) -->", "url": "https://docs.pydantic.dev/latest/docs/concepts/serialization/#field-serializers", "page": "docs/concepts/serialization", "source_site": "pydantic"}
{"title": "Which serializer pattern to use", "anchor": "which-serializer-pattern-to-use", "heading_level": 4, "md_text": "While both approaches can achieve the same thing, each pattern provides different benefits.", "url": "https://docs.pydantic.dev/latest/docs/concepts/serialization/#which-serializer-pattern-to-use", "page": "docs/concepts/serialization", "source_site": "pydantic"}
{"title": "Using the annotated pattern", "anchor": "using-the-annotated-pattern", "heading_level": 5, "md_text": "One of the key benefits of using the [annotated pattern](./fields.md#the-annotated-pattern) is to make\nserializers reusable:\n\n```python\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Field, PlainSerializer\n\nDoubleNumber = Annotated[int, PlainSerializer(lambda v: v * 2)]\n\n\nclass Model1(BaseModel):\n    my_number: DoubleNumber\n\n\nclass Model2(BaseModel):\n    other_number: Annotated[DoubleNumber, Field(description='My other number')]\n\n\nclass Model3(BaseModel):\n    list_of_even_numbers: list[DoubleNumber]  # (1)!\n```\n\n1. As mentioned in the [annotated pattern](./fields.md#the-annotated-pattern) documentation,\n   we can also make use of serializers for specific parts of the annotation (in this case,\n   serialization is applied for list items, but not the whole list).\n\nIt is also easier to understand which serializers are applied to a type, by just looking at the field annotation.", "url": "https://docs.pydantic.dev/latest/docs/concepts/serialization/#using-the-annotated-pattern", "page": "docs/concepts/serialization", "source_site": "pydantic"}
{"title": "Using the decorator pattern", "anchor": "using-the-decorator-pattern", "heading_level": 5, "md_text": "One of the key benefits of using the [`@field_serializer`][pydantic.field_serializer] decorator is to apply\nthe function to multiple fields:\n\n```python\nfrom pydantic import BaseModel, field_serializer\n\n\nclass Model(BaseModel):\n    f1: str\n    f2: str\n\n    @field_serializer('f1', 'f2', mode='plain')\n    def capitalize(self, value: str) -> str:\n        return value.capitalize()\n```\n\nHere are a couple additional notes about the decorator usage:\n\n* If you want the serializer to apply to all fields (including the ones defined in subclasses), you can pass\n  `'*'` as the field name argument.\n* By default, the decorator will ensure the provided field name(s) are defined on the model. If you want to\n  disable this check during class creation, you can do so by passing `False` to the `check_fields` argument.\n  This is useful when the field serializer is defined on a base class, and the field is expected to exist on\n  subclasses.", "url": "https://docs.pydantic.dev/latest/docs/concepts/serialization/#using-the-decorator-pattern", "page": "docs/concepts/serialization", "source_site": "pydantic"}
{"title": "Model serializers", "anchor": "model-serializers", "heading_level": 3, "md_text": "??? api \"API Documentation\"\n    [`pydantic.functional_serializers.model_serializer`][pydantic.functional_serializers.model_serializer]<br>\n\nSerialization can also be customized on the entire model using the [`@model_serializer`][pydantic.model_serializer]\ndecorator.\n\nIf the `return_type` argument is provided to the [`@model_serializer`][pydantic.model_serializer] decorator\n(or if a return type annotation is available on the serializer function), it will be used to build an extra serializer,\nto ensure that the serialized model value complies with this return type.\n\nAs with [field serializers](#field-serializers), **two** different types of model serializers can be used:\n\n* ***Plain* serializers**: are called unconditionally to serialize the model.\n  {#model-plain-serializer}\n\n    ```python\n    from pydantic import BaseModel, model_serializer\n\n\n    class UserModel(BaseModel):\n        username: str\n        password: str\n\n        @model_serializer(mode='plain')  # (1)!\n        def serialize_model(self) -> str:  # (2)!\n            return f'{self.username} - {self.password}'\n\n\n    print(UserModel(username='foo', password='bar').model_dump())\n    #> foo - bar\n    ```\n\n      1. `'plain'` is the default mode for the decorator, and can be omitted.\n      2. You are free to return a value that *isn't* a dictionary.\n\n* ***Wrap* serializers**: give more flexibility to customize the serialization behavior. You can run code before or after\n  the Pydantic serialization logic.\n  {#model-wrap-serializer}\n\n    Such serializers must be defined with a **mandatory** extra *handler* parameter: a callable taking the instance of the model\n    as an argument. Internally, this handler will delegate serialization of the model to Pydantic. You are free to *not* call the\n    handler at all.\n\n      ```python\n      from pydantic import BaseModel, SerializerFunctionWrapHandler, model_serializer\n\n\n      class UserModel(BaseModel):\n          username: str\n          password: str\n\n          @model_serializer(mode='wrap')\n          def serialize_model(\n              self, handler: SerializerFunctionWrapHandler\n          ) -> dict[str, object]:\n              serialized = handler(self)\n              serialized['fields'] = list(serialized)\n              return serialized\n\n\n      print(UserModel(username='foo', password='bar').model_dump())\n      #> {'username': 'foo', 'password': 'bar', 'fields': ['username', 'password']}\n      ```", "url": "https://docs.pydantic.dev/latest/docs/concepts/serialization/#model-serializers", "page": "docs/concepts/serialization", "source_site": "pydantic"}
{"title": "Serialization info", "anchor": "serialization-info", "heading_level": 2, "md_text": "Both the field and model serializers callables (in all modes) can optionally take an extra `info` argument,\nproviding useful extra information, such as:\n\n* [user defined context](#serialization-context)\n* the current serialization mode: either `'python'` or `'json'` (see the [`mode`][pydantic.SerializationInfo.mode] property)\n* the various parameters set during serialization using the [serialization methods](#serializing-data)\n  (e.g. [`exclude_unset`][pydantic.SerializationInfo.exclude_unset], [`serialize_as_any`][pydantic.SerializationInfo.serialize_as_any])\n* the current field name, if using a [field serializer](#field-serializers) (see the\n  [`field_name`][pydantic.FieldSerializationInfo.field_name] property).", "url": "https://docs.pydantic.dev/latest/docs/concepts/serialization/#serialization-info", "page": "docs/concepts/serialization", "source_site": "pydantic"}
{"title": "Serialization context", "anchor": "serialization-context", "heading_level": 3, "md_text": "You can pass a context object to the [serialization methods](#serializing-data), which can be accessed\ninside the serializer functions using the [`context`][pydantic.SerializationInfo.context] property:\n\n```python\nfrom pydantic import BaseModel, FieldSerializationInfo, field_serializer\n\n\nclass Model(BaseModel):\n    text: str\n\n    @field_serializer('text', mode='plain')\n    @classmethod\n    def remove_stopwords(cls, v: str, info: FieldSerializationInfo) -> str:\n        if isinstance(info.context, dict):\n            stopwords = info.context.get('stopwords', set())\n            v = ' '.join(w for w in v.split() if w.lower() not in stopwords)\n        return v\n\n\nmodel = Model(text='This is an example document')\nprint(model.model_dump())  # no context\n#> {'text': 'This is an example document'}\nprint(model.model_dump(context={'stopwords': ['this', 'is', 'an']}))\n#> {'text': 'example document'}\n```\n\nSimilarly, you can [use a context for validation](../concepts/validators.md#validation-context).", "url": "https://docs.pydantic.dev/latest/docs/concepts/serialization/#serialization-context", "page": "docs/concepts/serialization", "source_site": "pydantic"}
{"title": "Serializing subclasses", "anchor": "serializing-subclasses", "heading_level": 2, "md_text": "<!-- old anchor added for backwards compatibility -->\n<!-- markdownlint-disable-next-line no-empty-links -->\n[](){#subclasses-of-standard-types}", "url": "https://docs.pydantic.dev/latest/docs/concepts/serialization/#serializing-subclasses", "page": "docs/concepts/serialization", "source_site": "pydantic"}
{"title": "Subclasses of supported types", "anchor": "subclasses-of-supported-types", "heading_level": 3, "md_text": "Subclasses of supported types are serialized according to their super class:\n\n```python\nfrom datetime import date\n\nfrom pydantic import BaseModel\n\n\nclass MyDate(date):\n    @property\n    def my_date_format(self) -> str:\n        return self.strftime('%d/%m/%Y')\n\n\nclass FooModel(BaseModel):\n    date: date\n\n\nm = FooModel(date=MyDate(2023, 1, 1))\nprint(m.model_dump_json())\n#> {\"date\":\"2023-01-01\"}\n```\n\n<!-- old anchor added for backwards compatibility -->\n<!-- markdownlint-disable-next-line no-empty-links -->\n[](){#subclass-instances-for-fields-of-basemodel-dataclasses-typeddict}", "url": "https://docs.pydantic.dev/latest/docs/concepts/serialization/#subclasses-of-supported-types", "page": "docs/concepts/serialization", "source_site": "pydantic"}
{"title": "Subclasses of model-like types", "anchor": "subclasses-of-model-like-types", "heading_level": 3, "md_text": "When using model-like classes (Pydantic models, dataclasses, etc.) as field annotations, the default behavior is to\nserializer the field value as though it was an instance of the class, even if it is a subclass. More specifically,\nonly the fields declared on the type annotation will be included in the serialization result:\n\n```python\nfrom pydantic import BaseModel\n\n\nclass User(BaseModel):\n    name: str\n\n\nclass UserLogin(User):\n    password: str\n\n\nclass OuterModel(BaseModel):\n    user: User\n\n\nuser = UserLogin(name='pydantic', password='hunter2')\n\nm = OuterModel(user=user)\nprint(m)\n#> user=UserLogin(name='pydantic', password='hunter2')\nprint(m.model_dump())  # (1)!\n#> {'user': {'name': 'pydantic'}}\n```\n\n1. Note: the password field is not included\n\n!!! warning \"Migration Warning\"\n    This behavior is different from how things worked in Pydantic V1, where we would always include\n    all (subclass) fields when recursively serializing models to dictionaries. The motivation behind this change\n    in behavior is that it helps ensure that you know precisely which fields could be included when serializing,\n    even if subclasses get passed when instantiating the object. In particular, this can help prevent surprises\n    when adding sensitive information like secrets as fields of subclasses. To enable the old V1 behavior, refer\n    to the next section.", "url": "https://docs.pydantic.dev/latest/docs/concepts/serialization/#subclasses-of-model-like-types", "page": "docs/concepts/serialization", "source_site": "pydantic"}
{"title": "Serializing with duck typing \ud83e\udd86", "anchor": "serializing-with-duck-typing-", "heading_level": 3, "md_text": "Duck typing serialization is the behavior of serializing a model instance based on the actual field values, rather\nthan the field definitions. This means that for a field annotated with a model-like class, all the fields present\nin subclasses of such class will be included in the serialized output.\n\nTo achieve duck typing serialization, Pydantic can apply *serialize as any* behavior. In this mode, Pydantic does\n*not* make use of the type annotation (more precisely, the serialization schema derived from the type) to infer\nhow the value should be serialized, but instead inspects the actual type of the value at runtime to do so.\n\nWhen a subclass of a model is used as a value, Pydantic will *not* serialize it according to the schema of the\nparent class, but rather use the value itself and preserve all of its fields.\n\nThis behavior can be configured at the field level and at runtime, for a specific serialization call:\n\n* Field level: use the [`SerializeAsAny`][pydantic.functional_serializers.SerializeAsAny] annotation.\n* Runtime level: use the `serialize_as_any` argument when calling the [serialization methods](#serializing-data).\n\nWe discuss these options below in more detail:", "url": "https://docs.pydantic.dev/latest/docs/concepts/serialization/#serializing-with-duck-typing-", "page": "docs/concepts/serialization", "source_site": "pydantic"}
{"title": "`SerializeAsAny` annotation", "anchor": "serializeasany-annotation", "heading_level": 4, "md_text": "If you want duck typing serialization behavior, this can be done using the\n[`SerializeAsAny`][pydantic.functional_serializers.SerializeAsAny] annotation\non a type:\n\n```python\nfrom pydantic import BaseModel, SerializeAsAny\n\n\nclass User(BaseModel):\n    name: str\n\n\nclass UserLogin(User):\n    password: str\n\n\nclass OuterModel(BaseModel):\n    as_any: SerializeAsAny[User]\n    as_user: User\n\n\nuser = UserLogin(name='pydantic', password='password')\n\nprint(OuterModel(as_any=user, as_user=user).model_dump())\n\"\"\"\n{\n    'as_any': {'name': 'pydantic', 'password': 'password'},\n    'as_user': {'name': 'pydantic'},\n}\n\"\"\"\n```\n\nWhen a type is annotated as `SerializeAsAny[<type>]`, the validation behavior will be the same as if it was\nannotated as `<type>`, and static type checkers will treat the annotation as if it was simply `<type>`.\nWhen serializing, the field will be serialized as though the type hint for the field was [`Any`][typing.Any],\nwhich is where the name comes from.", "url": "https://docs.pydantic.dev/latest/docs/concepts/serialization/#serializeasany-annotation", "page": "docs/concepts/serialization", "source_site": "pydantic"}
{"title": "`serialize_as_any` runtime setting", "anchor": "serialize_as_any-runtime-setting", "heading_level": 4, "md_text": "The `serialize_as_any` runtime setting can be used to serialize model data with or without duck typed serialization behavior.\n`serialize_as_any` can be passed as a keyword argument to the various [serialization methods](#serializing-data) (such as\n[`model_dump()`][pydantic.BaseModel.model_dump] and [`model_dump_json()`][pydantic.BaseModel.model_dump_json] on Pydantic models).\n\n```python\nfrom pydantic import BaseModel\n\n\nclass User(BaseModel):\n    name: str\n\n\nclass UserLogin(User):\n    password: str\n\n\nclass OuterModel(BaseModel):\n    user1: User\n    user2: User\n\n\nuser = UserLogin(name='pydantic', password='password')\n\nouter_model = OuterModel(user1=user, user2=user)\nprint(outer_model.model_dump(serialize_as_any=True))  # (1)!\n\"\"\"\n{\n    'user1': {'name': 'pydantic', 'password': 'password'},\n    'user2': {'name': 'pydantic', 'password': 'password'},\n}\n\"\"\"\n\nprint(outer_model.model_dump(serialize_as_any=False))  # (2)!\n#> {'user1': {'name': 'pydantic'}, 'user2': {'name': 'pydantic'}}\n```\n\n1. With `serialize_as_any` set to `True`, the result matches that of V1.\n2. With `serialize_as_any` set to `False` (the V2 default), fields present on the subclass,\n   but not the base class, are not included in serialization.\n\nHowever, do note that the *serialize as any* behavior will apply to *all* values, not only the values where duck typing\nis relevant. You may want to prefer using the `SerializeAsAny` annotation when required instead.\n\n<!-- old anchor added for backwards compatibility -->\n<!-- markdownlint-disable-next-line no-empty-links -->\n[](){#advanced-include-and-exclude}\n<!-- markdownlint-disable-next-line no-empty-links -->\n[](){#model-and-field-level-include-and-exclude}", "url": "https://docs.pydantic.dev/latest/docs/concepts/serialization/#serialize_as_any-runtime-setting", "page": "docs/concepts/serialization", "source_site": "pydantic"}
{"title": "Field inclusion and exclusion", "anchor": "field-inclusion-and-exclusion", "heading_level": 2, "md_text": "For serialization, field inclusion and exclusion can be configured in two ways:\n\n* at the field level, using the `exclude` and `exclude_if` parameters on [the `Field()` function](fields.md).\n* using the various serialization parameters on the [serialization methods](#serializing-data).", "url": "https://docs.pydantic.dev/latest/docs/concepts/serialization/#field-inclusion-and-exclusion", "page": "docs/concepts/serialization", "source_site": "pydantic"}
{"title": "At the field level", "anchor": "at-the-field-level", "heading_level": 3, "md_text": "At the field level, the `exclude` and `exclude_if` parameters can be used:\n\n```python\nfrom pydantic import BaseModel, Field\n\n\nclass Transaction(BaseModel):\n    id: int\n    private_id: int = Field(exclude=True)\n    value: int = Field(ge=0, exclude_if=lambda v: v == 0)\n\n\nprint(Transaction(id=1, private_id=2, value=0).model_dump())\n#> {'id': 1}\n```\n\nExclusion at the field level takes priority over the `include` serialization parameter described below.", "url": "https://docs.pydantic.dev/latest/docs/concepts/serialization/#at-the-field-level", "page": "docs/concepts/serialization", "source_site": "pydantic"}
{"title": "As parameters to the serialization methods", "anchor": "as-parameters-to-the-serialization-methods", "heading_level": 3, "md_text": "When using the [serialization methods](#serializing-data) (such as [`model_dump()`][pydantic.BaseModel.model_dump]),\nseveral parameters can be used to exclude or include fields.", "url": "https://docs.pydantic.dev/latest/docs/concepts/serialization/#as-parameters-to-the-serialization-methods", "page": "docs/concepts/serialization", "source_site": "pydantic"}
{"title": "Excluding and including specific fields", "anchor": "excluding-and-including-specific-fields", "heading_level": 4, "md_text": "Consider the following models:\n\n```python {group=\"simple-exclude-include\"}\nfrom pydantic import BaseModel, Field, SecretStr\n\n\nclass User(BaseModel):\n    id: int\n    username: str\n    password: SecretStr\n\n\nclass Transaction(BaseModel):\n    id: str\n    private_id: str = Field(exclude=True)\n    user: User\n    value: int\n\n\nt = Transaction(\n    id='1234567890',\n    private_id='123',\n    user=User(id=42, username='JohnDoe', password='hashedpassword'),\n    value=9876543210,\n)\n```\n\nThe `exclude` parameter can be used to specify which fields should be excluded (including the others), and vice-versa\nusing the `include` parameter.\n\n```python {group=\"simple-exclude-include\"}", "url": "https://docs.pydantic.dev/latest/docs/concepts/serialization/#excluding-and-including-specific-fields", "page": "docs/concepts/serialization", "source_site": "pydantic"}
{"title": "using a set:", "anchor": "using-a-set", "heading_level": 1, "md_text": "print(t.model_dump(exclude={'user', 'value'}))\n#> {'id': '1234567890'}", "url": "https://docs.pydantic.dev/latest/docs/concepts/serialization/#using-a-set", "page": "docs/concepts/serialization", "source_site": "pydantic"}
{"title": "using a dictionary:", "anchor": "using-a-dictionary", "heading_level": 1, "md_text": "print(t.model_dump(exclude={'user': {'username', 'password'}, 'value': True}))\n#> {'id': '1234567890', 'user': {'id': 42}}", "url": "https://docs.pydantic.dev/latest/docs/concepts/serialization/#using-a-dictionary", "page": "docs/concepts/serialization", "source_site": "pydantic"}
{"title": "same configuration using `include`:", "anchor": "same-configuration-using-include", "heading_level": 1, "md_text": "print(t.model_dump(include={'id': True, 'user': {'id'}}))\n#> {'id': '1234567890', 'user': {'id': 42}}\n```\n\nNote that using `False` to *include* a field in `exclude` (or to *exclude* a field in `include`) is not supported.\n\nIt is also possible to exclude or include specific items from sequence and dictionaries:\n\n```python {group=\"advanced-include-exclude\"}\nfrom pydantic import BaseModel\n\n\nclass Hobby(BaseModel):\n    name: str\n    info: str\n\n\nclass User(BaseModel):\n    hobbies: list[Hobby]\n\n\nuser = User(\n    hobbies=[\n        Hobby(name='Programming', info='Writing code and stuff'),\n        Hobby(name='Gaming', info='Hell Yeah!!!'),\n    ],\n)\n\nprint(user.model_dump(exclude={'hobbies': {-1: {'info'}}}))  # (1)!\n\"\"\"\n{\n    'hobbies': [\n        {'name': 'Programming', 'info': 'Writing code and stuff'},\n        {'name': 'Gaming'},\n    ]\n}\n\"\"\"\n```\n\n1. The equivalent call with `include` would be:\n\n     ```python {lint=\"skip\" group=\"advanced-include-exclude\"}\n     user.model_dump(\n        include={'hobbies': {0: True, -1: {'name'}}}\n     )\n     ```\n\nThe special key `'__all__'` can be used to apply an exclusion/inclusion pattern to all members:\n\n```python {group=\"advanced-include-exclude\"}\nprint(user.model_dump(exclude={'hobbies': {'__all__': {'info'}}}))\n#> {'hobbies': [{'name': 'Programming'}, {'name': 'Gaming'}]}\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/serialization/#same-configuration-using-include", "page": "docs/concepts/serialization", "source_site": "pydantic"}
{"title": "Excluding and including fields based on their value", "anchor": "excluding-and-including-fields-based-on-their-value", "heading_level": 4, "md_text": "When using the [serialization methods](#serializing-data), it is possible to exclude fields based on their value,\nusing the following parameters:\n\n* `exclude_defaults`: Exclude all fields whose value compares equal to the default value\n  (using the equality (`==`) comparison operator).\n* `exclude_none`: Exclude all fields whose value is `None`.\n* `exclude_unset`: Pydantic keeps track of fields that were *explicitly* set during instantiation (using the\n  [`model_fields_set`][pydantic.BaseModel.model_fields_set] property). Using `exclude_unset`, any field that\n  was not explicitly provided will be excluded:\n\n    ```python {group=\"exclude-unset\"}\n    from pydantic import BaseModel\n\n\n    class UserModel(BaseModel):\n        name: str\n        age: int = 18\n\n\n    user = UserModel(name='John')\n    print(user.model_fields_set)\n    #> {'name'}\n\n    print(user.model_dump(exclude_unset=True))\n    #> {'name': 'John'}\n    ```\n\n    Note that altering a field *after* the instance has been created will remove it from the unset fields:\n\n    ```python {group=\"exclude-unset\"}\n    user.age = 21\n\n    print(user.model_dump(exclude_unset=True))\n    #> {'name': 'John', 'age': 21}\n    ```\n\n    !!! tip\n        The experimental [`MISSING` sentinel](./experimental.md#missing-sentinel) can be used as an alternative to `exclude_unset`.\n        Any field with `MISSING` as a value is automatically excluded from the serialization output.", "url": "https://docs.pydantic.dev/latest/docs/concepts/serialization/#excluding-and-including-fields-based-on-their-value", "page": "docs/concepts/serialization", "source_site": "pydantic"}
{"title": "config", "anchor": null, "heading_level": 0, "md_text": "The behaviour of Pydantic can be controlled via a variety of configuration values, documented\non the [`ConfigDict`][pydantic.ConfigDict] class. This page describes how configuration can be\nspecified for Pydantic's supported types.", "url": "https://docs.pydantic.dev/latest/docs/concepts/config/", "page": "docs/concepts/config", "source_site": "pydantic"}
{"title": "Configuration on Pydantic models", "anchor": "configuration-on-pydantic-models", "heading_level": 2, "md_text": "On Pydantic models, configuration can be specified in two ways:\n\n* Using the [`model_config`][pydantic.BaseModel.model_config] class attribute:\n\n    ```python\n    from pydantic import BaseModel, ConfigDict, ValidationError\n\n\n    class Model(BaseModel):\n        model_config = ConfigDict(str_max_length=5)  # (1)!\n\n        v: str\n\n\n    try:\n        m = Model(v='abcdef')\n    except ValidationError as e:\n        print(e)\n        \"\"\"\n        1 validation error for Model\n        v\n          String should have at most 5 characters [type=string_too_long, input_value='abcdef', input_type=str]\n        \"\"\"\n    ```\n\n    1. A plain dictionary (i.e. `{'str_max_length': 5}`) can also be used.\n\n    !!! note\n        In Pydantic V1, the `Config` class was used. This is still supported, but **deprecated**.\n\n* Using class arguments:\n\n    ```python\n    from pydantic import BaseModel\n\n\n    class Model(BaseModel, frozen=True):\n        a: str\n    ```\n\n  Unlike the [`model_config`][pydantic.BaseModel.model_config] class attribute,\n  static type checkers will recognize class arguments. For `frozen`, any instance\n  mutation will be flagged as an type checking error.", "url": "https://docs.pydantic.dev/latest/docs/concepts/config/#configuration-on-pydantic-models", "page": "docs/concepts/config", "source_site": "pydantic"}
{"title": "Configuration on Pydantic dataclasses", "anchor": "configuration-on-pydantic-dataclasses", "heading_level": 2, "md_text": "[Pydantic dataclasses](./dataclasses.md) also support configuration (read more in the\n[dedicated section](./dataclasses.md#dataclass-config)).\n\n```python\nfrom pydantic import ConfigDict, ValidationError\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass(config=ConfigDict(str_max_length=10, validate_assignment=True))\nclass User:\n    name: str\n\n\nuser = User(name='John Doe')\ntry:\n    user.name = 'x' * 20\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n    name\n      String should have at most 10 characters [type=string_too_long, input_value='xxxxxxxxxxxxxxxxxxxx', input_type=str]\n    \"\"\"\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/config/#configuration-on-pydantic-dataclasses", "page": "docs/concepts/config", "source_site": "pydantic"}
{"title": "Configuration on `TypeAdapter`", "anchor": "configuration-on-typeadapter", "heading_level": 2, "md_text": "[Type adapters](./type_adapter.md) (using the [`TypeAdapter`][pydantic.TypeAdapter] class) support configuration,\nby providing the `config` argument.\n\n```python\nfrom pydantic import ConfigDict, TypeAdapter\n\nta = TypeAdapter(list[str], config=ConfigDict(coerce_numbers_to_str=True))\n\nprint(ta.validate_python([1, 2]))\n#> ['1', '2']\n```\n\nConfiguration can't be provided if the type adapter directly wraps a type that support it, and a\n[usage error](../errors/usage_errors.md) is raised in this case.\nThe [configuration propagation](#configuration-propagation) rules also apply.", "url": "https://docs.pydantic.dev/latest/docs/concepts/config/#configuration-on-typeadapter", "page": "docs/concepts/config", "source_site": "pydantic"}
{"title": "Configuration on other supported types", "anchor": "configuration-on-other-supported-types", "heading_level": 2, "md_text": "If you are using [standard library dataclasses][dataclasses] or [`TypedDict`][typing.TypedDict] classes,\nthe configuration can be set in two ways:\n\n* Using the `__pydantic_config__` class attribute:\n\n    ```python\n    from dataclasses import dataclass\n\n    from pydantic import ConfigDict\n\n\n    @dataclass\n    class User:\n        __pydantic_config__ = ConfigDict(strict=True)\n\n        id: int\n        name: str = 'John Doe'\n    ```\n\n* Using the [`@with_config`][pydantic.config.with_config] decorator (this avoids static type checking errors with\n  [`TypedDict`][typing.TypedDict]):\n\n    ```python\n    from typing_extensions import TypedDict\n\n    from pydantic import ConfigDict, with_config\n\n\n    @with_config(ConfigDict(str_to_lower=True))\n    class Model(TypedDict):\n        x: str\n    ```", "url": "https://docs.pydantic.dev/latest/docs/concepts/config/#configuration-on-other-supported-types", "page": "docs/concepts/config", "source_site": "pydantic"}
{"title": "Configuration on the `@validate_call` decorator", "anchor": "configuration-on-the-validate_call-decorator", "heading_level": 2, "md_text": "The [`@validate_call`](./validation_decorator.md) also supports setting custom configuration. See the\n[dedicated section](./validation_decorator.md#custom-configuration) for more details.", "url": "https://docs.pydantic.dev/latest/docs/concepts/config/#configuration-on-the-validate_call-decorator", "page": "docs/concepts/config", "source_site": "pydantic"}
{"title": "Change behaviour globally", "anchor": "change-behaviour-globally", "heading_level": 2, "md_text": "If you wish to change the behaviour of Pydantic globally, you can create your own custom parent class\nwith a custom configuration, as the configuration is inherited:\n\n```python\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass Parent(BaseModel):\n    model_config = ConfigDict(extra='allow')\n\n\nclass Model(Parent):\n    x: str\n\n\nm = Model(x='foo', y='bar')\nprint(m.model_dump())\n#> {'x': 'foo', 'y': 'bar'}\n```\n\nIf you provide configuration to the subclasses, it will be *merged* with the parent configuration:\n\n```python\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass Parent(BaseModel):\n    model_config = ConfigDict(extra='allow', str_to_lower=False)\n\n\nclass Model(Parent):\n    model_config = ConfigDict(str_to_lower=True)\n\n    x: str\n\n\nm = Model(x='FOO', y='bar')\nprint(m.model_dump())\n#> {'x': 'foo', 'y': 'bar'}\nprint(Model.model_config)\n#> {'extra': 'allow', 'str_to_lower': True}\n```\n\n!!! warning\n    If your model inherits from multiple bases, Pydantic currently *doesn't* follow the\n    [MRO]. For more details, see [this issue](https://github.com/pydantic/pydantic/issues/9992).\n\n    [MRO]: https://docs.python.org/3/glossary.html#term-method-resolution-order", "url": "https://docs.pydantic.dev/latest/docs/concepts/config/#change-behaviour-globally", "page": "docs/concepts/config", "source_site": "pydantic"}
{"title": "Configuration propagation", "anchor": "configuration-propagation", "heading_level": 2, "md_text": "When using types that support configuration as field annotations, configuration may not be propagated:\n\n* For Pydantic models and dataclasses, configuration will *not* be propagated, each model has its own\n  \"configuration boundary\":\n\n    ```python\n    from pydantic import BaseModel, ConfigDict\n\n\n    class User(BaseModel):\n        name: str\n\n\n    class Parent(BaseModel):\n        user: User\n\n        model_config = ConfigDict(str_to_lower=True)\n\n\n    print(Parent(user={'name': 'JOHN'}))\n    #> user=User(name='JOHN')\n    ```\n\n* For stdlib types (dataclasses and typed dictionaries), configuration will be propagated, unless\n  the type has its own configuration set:\n\n    ```python\n    from dataclasses import dataclass\n\n    from pydantic import BaseModel, ConfigDict, with_config\n\n\n    @dataclass\n    class UserWithoutConfig:\n        name: str\n\n\n    @dataclass\n    @with_config(str_to_lower=False)\n    class UserWithConfig:\n        name: str\n\n\n    class Parent(BaseModel):\n        user_1: UserWithoutConfig\n        user_2: UserWithConfig\n\n        model_config = ConfigDict(str_to_lower=True)\n\n\n    print(Parent(user_1={'name': 'JOHN'}, user_2={'name': 'JOHN'}))\n    #> user_1=UserWithoutConfig(name='john') user_2=UserWithConfig(name='JOHN')\n    ```", "url": "https://docs.pydantic.dev/latest/docs/concepts/config/#configuration-propagation", "page": "docs/concepts/config", "source_site": "pydantic"}
{"title": "pydantic_settings", "anchor": null, "heading_level": 0, "md_text": "---\ndescription: Support for loading a settings or config class from environment variables or secrets files.\n---", "url": "https://docs.pydantic.dev/latest/docs/concepts/pydantic_settings/", "page": "docs/concepts/pydantic_settings", "source_site": "pydantic"}
{"title": "Settings Management", "anchor": "settings-management", "heading_level": 1, "md_text": "[Pydantic Settings](https://github.com/pydantic/pydantic-settings) provides optional Pydantic features for loading a settings or config class from environment variables or secrets files.\n\n{{ pydantic_settings }}", "url": "https://docs.pydantic.dev/latest/docs/concepts/pydantic_settings/#settings-management", "page": "docs/concepts/pydantic_settings", "source_site": "pydantic"}
{"title": "conversion_table", "anchor": null, "heading_level": 0, "md_text": "The following table provides details on how Pydantic converts data during validation in both strict and lax modes.\n\nThe \"Strict\" column contains checkmarks for type conversions that are allowed when validating in\n[Strict Mode](strict_mode.md).\n\n=== \"All\"\n{{ conversion_table_all }}\n\n=== \"JSON\"\n{{ conversion_table_json }}\n\n=== \"JSON - Strict\"\n{{ conversion_table_json_strict }}\n\n=== \"Python\"\n{{ conversion_table_python }}\n\n=== \"Python - Strict\"\n{{ conversion_table_python_strict }}", "url": "https://docs.pydantic.dev/latest/docs/concepts/conversion_table/", "page": "docs/concepts/conversion_table", "source_site": "pydantic"}
{"title": "validators", "anchor": null, "heading_level": 0, "md_text": "In addition to Pydantic's [built-in validation capabilities](./fields.md#field-constraints),\nyou can leverage custom validators at the field and model levels to enforce more complex constraints\nand ensure the integrity of your data.\n\n!!! tip\n    Want to quickly jump to the relevant validator section?\n\n    <div class=\"grid cards\" markdown>\n\n    *   Field validators\n\n        ---\n\n        * [field *after* validators](#field-after-validator)\n        * [field *before* validators](#field-before-validator)\n        * [field *plain* validators](#field-plain-validator)\n        * [field *wrap* validators](#field-wrap-validator)\n\n    *   Model validators\n\n        ---\n\n        * [model *before* validators](#model-before-validator)\n        * [model *after* validators](#model-after-validator)\n        * [model *wrap* validators](#model-wrap-validator)\n\n    </div>", "url": "https://docs.pydantic.dev/latest/docs/concepts/validators/", "page": "docs/concepts/validators", "source_site": "pydantic"}
{"title": "Field validators", "anchor": "field-validators", "heading_level": 2, "md_text": "??? api \"API Documentation\"\n    [`pydantic.functional_validators.WrapValidator`][pydantic.functional_validators.WrapValidator]<br>\n    [`pydantic.functional_validators.PlainValidator`][pydantic.functional_validators.PlainValidator]<br>\n    [`pydantic.functional_validators.BeforeValidator`][pydantic.functional_validators.BeforeValidator]<br>\n    [`pydantic.functional_validators.AfterValidator`][pydantic.functional_validators.AfterValidator]<br>\n    [`pydantic.functional_validators.field_validator`][pydantic.functional_validators.field_validator]<br>\n\nIn its simplest form, a field validator is a callable taking the value to be validated as an argument and\n**returning the validated value**. The callable can perform checks for specific conditions (see\n[raising validation errors](#raising-validation-errors)) and make changes to the validated value (coercion or mutation).\n\n**Four** different types of validators can be used. They can all be defined using the\n[annotated pattern](./fields.md#the-annotated-pattern) or using the\n[`field_validator()`][pydantic.field_validator] decorator, applied on a [class method][classmethod]:\n\n* ***After* validators**: run after Pydantic's internal validation. They are generally more type safe and thus easier to implement.\n{#field-after-validator}\n\n    === \"Annotated pattern\"\n\n        Here is an example of a validator performing a validation check, and returning the value unchanged.\n\n        ```python\n        from typing import Annotated\n\n        from pydantic import AfterValidator, BaseModel, ValidationError\n\n\n        def is_even(value: int) -> int:\n            if value % 2 == 1:\n                raise ValueError(f'{value} is not an even number')\n            return value  # (1)!\n\n\n        class Model(BaseModel):\n            number: Annotated[int, AfterValidator(is_even)]\n\n\n        try:\n            Model(number=1)\n        except ValidationError as err:\n            print(err)\n            \"\"\"\n            1 validation error for Model\n            number\n              Value error, 1 is not an even number [type=value_error, input_value=1, input_type=int]\n            \"\"\"\n        ```\n\n        1. Note that it is important to return the validated value.\n\n    === \"Decorator\"\n\n        Here is an example of a validator performing a validation check, and returning the value unchanged,\n        this time using the [`field_validator()`][pydantic.field_validator] decorator.\n\n        ```python\n        from pydantic import BaseModel, ValidationError, field_validator\n\n\n        class Model(BaseModel):\n            number: int\n\n            @field_validator('number', mode='after')  # (1)!\n            @classmethod\n            def is_even(cls, value: int) -> int:\n                if value % 2 == 1:\n                    raise ValueError(f'{value} is not an even number')\n                return value  # (2)!\n\n\n        try:\n            Model(number=1)\n        except ValidationError as err:\n            print(err)\n            \"\"\"\n            1 validation error for Model\n            number\n              Value error, 1 is not an even number [type=value_error, input_value=1, input_type=int]\n            \"\"\"\n        ```\n\n        1. `'after'` is the default mode for the decorator, and can be omitted.\n        2. Note that it is important to return the validated value.\n\n    ??? example \"Example mutating the value\"\n        Here is an example of a validator making changes to the validated value (no exception is raised).\n\n        === \"Annotated pattern\"\n\n            ```python\n            from typing import Annotated\n\n            from pydantic import AfterValidator, BaseModel\n\n\n            def double_number(value: int) -> int:\n                return value * 2\n\n\n            class Model(BaseModel):\n                number: Annotated[int, AfterValidator(double_number)]\n\n\n            print(Model(number=2))\n            #> number=4\n            ```\n\n        === \"Decorator\"\n\n            ```python\n            from pydantic import BaseModel, field_validator\n\n\n            class Model(BaseModel):\n                number: int\n\n                @field_validator('number', mode='after')  # (1)!\n                @classmethod\n                def double_number(cls, value: int) -> int:\n                    return value * 2\n\n\n            print(Model(number=2))\n            #> number=4\n            ```\n\n            1. `'after'` is the default mode for the decorator, and can be omitted.\n\n* ***Before* validators**: run before Pydantic's internal parsing and validation (e.g. coercion of a `str` to an `int`).\n  These are more flexible than [*after* validators](#field-after-validator), but they also have to deal with the raw input, which\n  in theory could be any arbitrary object. You should also avoid mutating the value directly if you are raising a\n  [validation error](#raising-validation-errors) later in your validator function, as the mutated value may be passed to other\n  validators if using [unions](./unions.md).\n  {#field-before-validator}\n\n    The value returned from this callable is then validated against the provided type annotation by Pydantic.\n\n    === \"Annotated pattern\"\n\n        ```python\n        from typing import Annotated, Any\n\n        from pydantic import BaseModel, BeforeValidator, ValidationError\n\n\n        def ensure_list(value: Any) -> Any:  # (1)!\n            if not isinstance(value, list):  # (2)!\n                return [value]\n            else:\n                return value\n\n\n        class Model(BaseModel):\n            numbers: Annotated[list[int], BeforeValidator(ensure_list)]", "url": "https://docs.pydantic.dev/latest/docs/concepts/validators/#field-validators", "page": "docs/concepts/validators", "source_site": "pydantic"}
{"title": "Field validators", "anchor": "field-validators", "heading_level": 2, "md_text": "\n        print(Model(numbers=2))\n        #> numbers=[2]\n        try:\n            Model(numbers='str')\n        except ValidationError as err:\n            print(err)  # (3)!\n            \"\"\"\n            1 validation error for Model\n            numbers.0\n              Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='str', input_type=str]\n            \"\"\"\n        ```\n\n        1. Notice the use of [`Any`][typing.Any] as a type hint for `value`. *Before* validators take the raw input, which\n           can be anything.\n\n        2. Note that you might want to check for other sequence types (such as tuples) that would normally successfully\n           validate against the `list` type. *Before* validators give you more flexibility, but you have to account for\n           every possible case.\n\n        3. Pydantic still performs validation against the `int` type, no matter if our `ensure_list` validator\n           did operations on the original input type.\n\n    === \"Decorator\"\n\n        ```python\n        from typing import Any\n\n        from pydantic import BaseModel, ValidationError, field_validator\n\n\n        class Model(BaseModel):\n            numbers: list[int]\n\n            @field_validator('numbers', mode='before')\n            @classmethod\n            def ensure_list(cls, value: Any) -> Any:  # (1)!\n                if not isinstance(value, list):  # (2)!\n                    return [value]\n                else:\n                    return value\n\n\n        print(Model(numbers=2))\n        #> numbers=[2]\n        try:\n            Model(numbers='str')\n        except ValidationError as err:\n            print(err)  # (3)!\n            \"\"\"\n            1 validation error for Model\n            numbers.0\n              Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='str', input_type=str]\n            \"\"\"\n        ```\n\n        1. Notice the use of [`Any`][typing.Any] as a type hint for `value`. *Before* validators take the raw input, which\n           can be anything.\n\n        2. Note that you might want to check for other sequence types (such as tuples) that would normally successfully\n           validate against the `list` type. *Before* validators give you more flexibility, but you have to account for\n           every possible case.\n\n        3. Pydantic still performs validation against the `int` type, no matter if our `ensure_list` validator\n           did operations on the original input type.\n\n* ***Plain* validators**: act similarly to *before* validators but they **terminate validation immediately** after returning,\n  so no further validators are called and Pydantic does not do any of its internal validation against the field type.\n  {#field-plain-validator}\n\n    === \"Annotated pattern\"\n\n        ```python\n        from typing import Annotated, Any\n\n        from pydantic import BaseModel, PlainValidator\n\n\n        def val_number(value: Any) -> Any:\n            if isinstance(value, int):\n                return value * 2\n            else:\n                return value\n\n\n        class Model(BaseModel):\n            number: Annotated[int, PlainValidator(val_number)]\n\n\n        print(Model(number=4))\n        #> number=8\n        print(Model(number='invalid'))  # (1)!\n        #> number='invalid'\n        ```\n\n        1. Although `'invalid'` shouldn't validate against the `int` type, Pydantic accepts the input.\n\n    === \"Decorator\"\n\n        ```python\n        from typing import Any\n\n        from pydantic import BaseModel, field_validator\n\n\n        class Model(BaseModel):\n            number: int\n\n            @field_validator('number', mode='plain')\n            @classmethod\n            def val_number(cls, value: Any) -> Any:\n                if isinstance(value, int):\n                    return value * 2\n                else:\n                    return value\n\n\n        print(Model(number=4))\n        #> number=8\n        print(Model(number='invalid'))  # (1)!\n        #> number='invalid'\n        ```\n\n        1. Although `'invalid'` shouldn't validate against the `int` type, Pydantic accepts the input.\n\n* ***Wrap* validators**: are the most flexible of all. You can run code before or after Pydantic and other validators\n  process the input, or you can terminate validation immediately, either by returning the value early or by raising an\n  error.\n  {#field-wrap-validator}\n\n    Such validators must be defined with a **mandatory** extra *handler* parameter: a callable taking the value to be validated\n    as an argument. Internally, this handler will delegate validation of the value to Pydantic. You are free to wrap the call\n    to the handler in a [`try..except`][handling exceptions] block, or not call it at all.\n\n    [handling exceptions]: https://docs.python.org/3/tutorial/errors.html#handling-exceptions\n\n    === \"Annotated pattern\"\n\n        ```python {lint=\"skip\"}\n        from typing import Any\n\n        from typing import Annotated\n\n        from pydantic import BaseModel, Field, ValidationError, ValidatorFunctionWrapHandler, WrapValidator\n\n\n        def truncate(value: Any, handler: ValidatorFunctionWrapHandler) -> str:\n            try:\n                return handler(value)\n            except ValidationError as err:\n                if err.errors()[0]['type'] == 'string_too_long':\n                    return handler(value[:5])\n                else:\n                    raise\n\n\n        class Model(BaseModel):\n            my_string: Annotated[str, Field(max_length=5), WrapValidator(truncate)]", "url": "https://docs.pydantic.dev/latest/docs/concepts/validators/#field-validators", "page": "docs/concepts/validators", "source_site": "pydantic"}
{"title": "Field validators", "anchor": "field-validators", "heading_level": 2, "md_text": "\n        print(Model(my_string='abcde'))\n        #> my_string='abcde'\n        print(Model(my_string='abcdef'))\n        #> my_string='abcde'\n        ```\n\n    === \"Decorator\"\n\n        ```python {lint=\"skip\"}\n        from typing import Any\n\n        from typing import Annotated\n\n        from pydantic import BaseModel, Field, ValidationError, ValidatorFunctionWrapHandler, field_validator\n\n\n        class Model(BaseModel):\n            my_string: Annotated[str, Field(max_length=5)]\n\n            @field_validator('my_string', mode='wrap')\n            @classmethod\n            def truncate(cls, value: Any, handler: ValidatorFunctionWrapHandler) -> str:\n                try:\n                    return handler(value)\n                except ValidationError as err:\n                    if err.errors()[0]['type'] == 'string_too_long':\n                        return handler(value[:5])\n                    else:\n                        raise\n\n\n        print(Model(my_string='abcde'))\n        #> my_string='abcde'\n        print(Model(my_string='abcdef'))\n        #> my_string='abcde'\n        ```\n\n!!! note \"Validation of default values\"\n    As mentioned in the [fields documentation](./fields.md#validate-default-values), default values of fields\n    are *not* validated unless configured to do so, and thus custom validators will not be applied as well.", "url": "https://docs.pydantic.dev/latest/docs/concepts/validators/#field-validators", "page": "docs/concepts/validators", "source_site": "pydantic"}
{"title": "Which validator pattern to use", "anchor": "which-validator-pattern-to-use", "heading_level": 3, "md_text": "While both approaches can achieve the same thing, each pattern provides different benefits.", "url": "https://docs.pydantic.dev/latest/docs/concepts/validators/#which-validator-pattern-to-use", "page": "docs/concepts/validators", "source_site": "pydantic"}
{"title": "Using the annotated pattern", "anchor": "using-the-annotated-pattern", "heading_level": 4, "md_text": "One of the key benefits of using the [annotated pattern](./fields.md#the-annotated-pattern) is to make\nvalidators reusable:\n\n```python\nfrom typing import Annotated\n\nfrom pydantic import AfterValidator, BaseModel\n\n\ndef is_even(value: int) -> int:\n    if value % 2 == 1:\n        raise ValueError(f'{value} is not an even number')\n    return value\n\n\nEvenNumber = Annotated[int, AfterValidator(is_even)]\n\n\nclass Model1(BaseModel):\n    my_number: EvenNumber\n\n\nclass Model2(BaseModel):\n    other_number: Annotated[EvenNumber, AfterValidator(lambda v: v + 2)]\n\n\nclass Model3(BaseModel):\n    list_of_even_numbers: list[EvenNumber]  # (1)!\n```\n\n1. As mentioned in the [annotated pattern](./fields.md#the-annotated-pattern) documentation,\n   we can also make use of validators for specific parts of the annotation (in this case,\n   validation is applied for list items, but not the whole list).\n\nIt is also easier to understand which validators are applied to a type, by just looking at the field annotation.", "url": "https://docs.pydantic.dev/latest/docs/concepts/validators/#using-the-annotated-pattern", "page": "docs/concepts/validators", "source_site": "pydantic"}
{"title": "Using the decorator pattern", "anchor": "using-the-decorator-pattern", "heading_level": 4, "md_text": "One of the key benefits of using the [`field_validator()`][pydantic.field_validator] decorator is to apply\nthe function to multiple fields:\n\n```python\nfrom pydantic import BaseModel, field_validator\n\n\nclass Model(BaseModel):\n    f1: str\n    f2: str\n\n    @field_validator('f1', 'f2', mode='before')\n    @classmethod\n    def capitalize(cls, value: str) -> str:\n        return value.capitalize()\n```\n\nHere are a couple additional notes about the decorator usage:\n\n* If you want the validator to apply to all fields (including the ones defined in subclasses), you can pass\n  `'*'` as the field name argument.\n* By default, the decorator will ensure the provided field name(s) are defined on the model. If you want to\n  disable this check during class creation, you can do so by passing `False` to the `check_fields` argument.\n  This is useful when the field validator is defined on a base class, and the field is expected to exist on\n  subclasses.", "url": "https://docs.pydantic.dev/latest/docs/concepts/validators/#using-the-decorator-pattern", "page": "docs/concepts/validators", "source_site": "pydantic"}
{"title": "Model validators", "anchor": "model-validators", "heading_level": 2, "md_text": "??? api \"API Documentation\"\n    [`pydantic.functional_validators.model_validator`][pydantic.functional_validators.model_validator]<br>\n\nValidation can also be performed on the entire model's data using the [`model_validator()`][pydantic.model_validator]\ndecorator.\n\n**Three** different types of model validators can be used:\n\n* ***After* validators**: run after the whole model has been validated. As such, they are defined as\n  *instance* methods and can be seen as post-initialization hooks. Important note: the validated instance\n  should be returned.\n  {#model-after-validator}\n\n    ```python\n    from typing_extensions import Self\n\n    from pydantic import BaseModel, model_validator\n\n\n    class UserModel(BaseModel):\n        username: str\n        password: str\n        password_repeat: str\n\n        @model_validator(mode='after')\n        def check_passwords_match(self) -> Self:\n            if self.password != self.password_repeat:\n                raise ValueError('Passwords do not match')\n            return self\n    ```\n\n* ***Before* validators**: are run before the model is instantiated. These are more flexible than *after* validators,\n  but they also have to deal with the raw input, which in theory could be any arbitrary object. You should also avoid\n  mutating the value directly if you are raising a [validation error](#raising-validation-errors) later in your validator\n  function, as the mutated value may be passed to other validators if using [unions](./unions.md).\n  {#model-before-validator}\n\n    ```python\n    from typing import Any\n\n    from pydantic import BaseModel, model_validator\n\n\n    class UserModel(BaseModel):\n        username: str\n\n        @model_validator(mode='before')\n        @classmethod\n        def check_card_number_not_present(cls, data: Any) -> Any:  # (1)!\n            if isinstance(data, dict):  # (2)!\n                if 'card_number' in data:\n                    raise ValueError(\"'card_number' should not be included\")\n            return data\n    ```\n\n    1. Notice the use of [`Any`][typing.Any] as a type hint for `data`. *Before* validators take the raw input, which\n       can be anything.\n    2. Most of the time, the input data will be a dictionary (e.g. when calling `UserModel(username='...')`). However,\n       this is not always the case. For instance, if the [`from_attributes`][pydantic.ConfigDict.from_attributes]\n       configuration value is set, you might receive an arbitrary class instance for the `data` argument.\n\n* ***Wrap* validators**: are the most flexible of all. You can run code before or after Pydantic and\n  other validators process the input data, or you can terminate validation immediately, either by returning\n  the data early or by raising an error.\n  {#model-wrap-validator}\n\n    ```python {lint=\"skip\"}\n    import logging\n    from typing import Any\n\n    from typing_extensions import Self\n\n    from pydantic import BaseModel, ModelWrapValidatorHandler, ValidationError, model_validator\n\n\n    class UserModel(BaseModel):\n        username: str\n\n        @model_validator(mode='wrap')\n        @classmethod\n        def log_failed_validation(cls, data: Any, handler: ModelWrapValidatorHandler[Self]) -> Self:\n            try:\n                return handler(data)\n            except ValidationError:\n                logging.error('Model %s failed to validate with data %s', cls, data)\n                raise\n    ```\n\n!!! note \"On inheritance\"\n    A model validator defined in a base class will be called during the validation of a subclass instance.\n\n    Overriding a model validator in a subclass will override the base class' validator, and thus only the subclass' version of said validator will be called.", "url": "https://docs.pydantic.dev/latest/docs/concepts/validators/#model-validators", "page": "docs/concepts/validators", "source_site": "pydantic"}
{"title": "Raising validation errors", "anchor": "raising-validation-errors", "heading_level": 2, "md_text": "To raise a validation error, three types of exceptions can be used:\n\n* [`ValueError`][]: this is the most common exception raised inside validators.\n* [`AssertionError`][]: using the [assert][] statement also works, but be aware that these statements\n  are skipped when Python is run with the [-O][] optimization flag.\n* [`PydanticCustomError`][pydantic_core.PydanticCustomError]: a bit more verbose, but provides extra flexibility:\n\n    ```python\n    from pydantic_core import PydanticCustomError\n\n    from pydantic import BaseModel, ValidationError, field_validator\n\n\n    class Model(BaseModel):\n        x: int\n\n        @field_validator('x', mode='after')\n        @classmethod\n        def validate_x(cls, v: int) -> int:\n            if v % 42 == 0:\n                raise PydanticCustomError(\n                    'the_answer_error',\n                    '{number} is the answer!',\n                    {'number': v},\n                )\n            return v\n\n\n    try:\n        Model(x=42 * 2)\n    except ValidationError as e:\n        print(e)\n        \"\"\"\n        1 validation error for Model\n        x\n          84 is the answer! [type=the_answer_error, input_value=84, input_type=int]\n        \"\"\"\n    ```", "url": "https://docs.pydantic.dev/latest/docs/concepts/validators/#raising-validation-errors", "page": "docs/concepts/validators", "source_site": "pydantic"}
{"title": "Validation info", "anchor": "validation-info", "heading_level": 2, "md_text": "Both the field and model validators callables (in all modes) can optionally take an extra\n[`ValidationInfo`][pydantic.ValidationInfo] argument, providing useful extra information, such as:\n\n* [already validated data](#validation-data)\n* [user defined context](#validation-context)\n* the current validation mode: either `'python'` or `'json'` (see the [`mode`][pydantic.ValidationInfo.mode] property)\n* the current field name, if using a [field validator](#field-validators) (see the [`field_name`][pydantic.ValidationInfo.field_name] property).", "url": "https://docs.pydantic.dev/latest/docs/concepts/validators/#validation-info", "page": "docs/concepts/validators", "source_site": "pydantic"}
{"title": "Validation data", "anchor": "validation-data", "heading_level": 3, "md_text": "For field validators, the already validated data can be accessed using the [`data`][pydantic.ValidationInfo.data]\nproperty. Here is an example than can be used as an alternative to the [*after* model validator](#model-after-validator)\nexample:\n\n```python\nfrom pydantic import BaseModel, ValidationInfo, field_validator\n\n\nclass UserModel(BaseModel):\n    password: str\n    password_repeat: str\n    username: str\n\n    @field_validator('password_repeat', mode='after')\n    @classmethod\n    def check_passwords_match(cls, value: str, info: ValidationInfo) -> str:\n        if value != info.data['password']:\n            raise ValueError('Passwords do not match')\n        return value\n```\n\n!!! warning\n    As validation is performed in the [order fields are defined](./models.md#field-ordering), you have to\n    make sure you are not accessing a field that hasn't been validated yet. In the code above, for example,\n    the `username` validated value is not available yet, as it is defined *after* `password_repeat`.\n\nThe [`data`][pydantic.ValidationInfo.data] property is `None` for [model validators](#model-validators).", "url": "https://docs.pydantic.dev/latest/docs/concepts/validators/#validation-data", "page": "docs/concepts/validators", "source_site": "pydantic"}
{"title": "Validation context", "anchor": "validation-context", "heading_level": 3, "md_text": "You can pass a context object to the [validation methods](./models.md#validating-data), which can be accessed\ninside the validator functions using the [`context`][pydantic.ValidationInfo.context] property:\n\n```python\nfrom pydantic import BaseModel, ValidationInfo, field_validator\n\n\nclass Model(BaseModel):\n    text: str\n\n    @field_validator('text', mode='after')\n    @classmethod\n    def remove_stopwords(cls, v: str, info: ValidationInfo) -> str:\n        if isinstance(info.context, dict):\n            stopwords = info.context.get('stopwords', set())\n            v = ' '.join(w for w in v.split() if w.lower() not in stopwords)\n        return v\n\n\ndata = {'text': 'This is an example document'}\nprint(Model.model_validate(data))  # no context\n#> text='This is an example document'\nprint(Model.model_validate(data, context={'stopwords': ['this', 'is', 'an']}))\n#> text='example document'\n```\n\nSimilarly, you can [use a context for serialization](../concepts/serialization.md#serialization-context).\n\n??? note \"Providing context when directly instantiating a model\"\n    It is currently not possible to provide a context when directly instantiating a model\n    (i.e. when calling `Model(...)`). You can work around this through the use of a\n    [`ContextVar`][contextvars.ContextVar] and a custom `__init__` method:\n\n    ```python\n    from __future__ import annotations\n\n    from collections.abc import Generator\n    from contextlib import contextmanager\n    from contextvars import ContextVar\n    from typing import Any\n\n    from pydantic import BaseModel, ValidationInfo, field_validator\n\n    _init_context_var = ContextVar('_init_context_var', default=None)\n\n\n    @contextmanager\n    def init_context(value: dict[str, Any]) -> Generator[None]:\n        token = _init_context_var.set(value)\n        try:\n            yield\n        finally:\n            _init_context_var.reset(token)\n\n\n    class Model(BaseModel):\n        my_number: int\n\n        def __init__(self, /, **data: Any) -> None:\n            self.__pydantic_validator__.validate_python(\n                data,\n                self_instance=self,\n                context=_init_context_var.get(),\n            )\n\n        @field_validator('my_number')\n        @classmethod\n        def multiply_with_context(cls, value: int, info: ValidationInfo) -> int:\n            if isinstance(info.context, dict):\n                multiplier = info.context.get('multiplier', 1)\n                value = value * multiplier\n            return value\n\n\n    print(Model(my_number=2))\n    #> my_number=2\n\n    with init_context({'multiplier': 3}):\n        print(Model(my_number=2))\n        #> my_number=6\n\n    print(Model(my_number=2))\n    #> my_number=2\n    ```", "url": "https://docs.pydantic.dev/latest/docs/concepts/validators/#validation-context", "page": "docs/concepts/validators", "source_site": "pydantic"}
{"title": "Ordering of validators", "anchor": "ordering-of-validators", "heading_level": 2, "md_text": "When using the [annotated pattern](#using-the-annotated-pattern), the order in which validators are applied\nis defined as follows: [*before*](#field-before-validator) and [*wrap*](#field-wrap-validator) validators\nare run from right to left, and [*after*](#field-after-validator) validators are then run from left to right:\n\n```python {lint=\"skip\" test=\"skip\"}\nfrom pydantic import AfterValidator, BaseModel, BeforeValidator, WrapValidator\n\n\nclass Model(BaseModel):\n    name: Annotated[\n        str,\n        AfterValidator(runs_3rd),\n        AfterValidator(runs_4th),\n        BeforeValidator(runs_2nd),\n        WrapValidator(runs_1st),\n    ]\n```\n\nInternally, validators defined using [the decorator](#using-the-decorator-pattern) are converted to their annotated\nform counterpart and added last after the existing metadata for the field. This means that the same ordering\nlogic applies.", "url": "https://docs.pydantic.dev/latest/docs/concepts/validators/#ordering-of-validators", "page": "docs/concepts/validators", "source_site": "pydantic"}
{"title": "Special types", "anchor": "special-types", "heading_level": 2, "md_text": "Pydantic provides a few special utilities that can be used to customize validation.\n\n* [`InstanceOf`][pydantic.functional_validators.InstanceOf] can be used to validate that a value is an instance of a given class.\n\n    ```python\n    from pydantic import BaseModel, InstanceOf, ValidationError\n\n\n    class Fruit:\n        def __repr__(self):\n            return self.__class__.__name__\n\n\n    class Banana(Fruit): ...\n\n\n    class Apple(Fruit): ...\n\n\n    class Basket(BaseModel):\n        fruits: list[InstanceOf[Fruit]]\n\n\n    print(Basket(fruits=[Banana(), Apple()]))\n    #> fruits=[Banana, Apple]\n    try:\n        Basket(fruits=[Banana(), 'Apple'])\n    except ValidationError as e:\n        print(e)\n        \"\"\"\n        1 validation error for Basket\n        fruits.1\n          Input should be an instance of Fruit [type=is_instance_of, input_value='Apple', input_type=str]\n        \"\"\"\n    ```\n\n* [`SkipValidation`][pydantic.functional_validators.SkipValidation] can be used to skip validation on a field.\n\n    ```python\n    from pydantic import BaseModel, SkipValidation\n\n\n    class Model(BaseModel):\n        names: list[SkipValidation[str]]\n\n\n    m = Model(names=['foo', 'bar'])\n    print(m)\n    #> names=['foo', 'bar']\n\n    m = Model(names=['foo', 123])  # (1)!\n    print(m)\n    #> names=['foo', 123]\n    ```\n\n    1. Note that the validation of the second item is skipped. If it has the wrong type it will emit a\n       warning during serialization.\n\n* [`ValidateAs`][pydantic.functional_validators.ValidateAs] can be used to validate an custom type from a\n  type natively supported by Pydantic. This is particularly useful when using custom types with multiple fields.\n\n    ```python {lint=\"skip\"}\n    from typing import Annotated\n\n    from pydantic import BaseModel, TypeAdapter, ValidateAs\n\n    class MyCls:\n        def __init__(self, a: int) -> None:\n            self.a = a\n\n        def __repr__(self) -> str:\n            return f\"MyCls(a={self.a})\"\n\n    class ValModel(BaseModel):\n        a: int\n\n\n    ta = TypeAdapter(\n        Annotated[MyCls, ValidateAs(ValModel, lambda v: MyCls(a=v.a))]\n    )\n\n    print(ta.validate_python({'a': 1}))\n    #> MyCls(a=1)\n    ```\n\n* [`PydanticUseDefault`][pydantic_core.PydanticUseDefault] can be used to notify Pydantic that the default value\n  should be used.\n\n    ```python\n    from typing import Annotated, Any\n\n    from pydantic_core import PydanticUseDefault\n\n    from pydantic import BaseModel, BeforeValidator\n\n\n    def default_if_none(value: Any) -> Any:\n        if value is None:\n            raise PydanticUseDefault()\n        return value\n\n\n    class Model(BaseModel):\n        name: Annotated[str, BeforeValidator(default_if_none)] = 'default_name'\n\n\n    print(Model(name=None))\n    #> name='default_name'\n    ```", "url": "https://docs.pydantic.dev/latest/docs/concepts/validators/#special-types", "page": "docs/concepts/validators", "source_site": "pydantic"}
{"title": "JSON Schema and field validators", "anchor": "json-schema-and-field-validators", "heading_level": 2, "md_text": "When using [*before*](#field-before-validator), [*plain*](#field-plain-validator) or [*wrap*](#field-wrap-validator)\nfield validators, the accepted input type may be different from the field annotation.\n\nConsider the following example:\n\n```python\nfrom typing import Any\n\nfrom pydantic import BaseModel, field_validator\n\n\nclass Model(BaseModel):\n    value: str\n\n    @field_validator('value', mode='before')\n    @classmethod\n    def cast_ints(cls, value: Any) -> Any:\n        if isinstance(value, int):\n            return str(value)\n        else:\n            return value\n\n\nprint(Model(value='a'))\n#> value='a'\nprint(Model(value=1))\n#> value='1'\n```\n\nWhile the type hint for `value` is `str`, the `cast_ints` validator also allows integers. To specify the correct\ninput type, the `json_schema_input_type` argument can be provided:\n\n```python\nfrom typing import Any, Union\n\nfrom pydantic import BaseModel, field_validator\n\n\nclass Model(BaseModel):\n    value: str\n\n    @field_validator(\n        'value', mode='before', json_schema_input_type=Union[int, str]\n    )\n    @classmethod\n    def cast_ints(cls, value: Any) -> Any:\n        if isinstance(value, int):\n            return str(value)\n        else:\n            return value\n\n\nprint(Model.model_json_schema()['properties']['value'])\n#> {'anyOf': [{'type': 'integer'}, {'type': 'string'}], 'title': 'Value'}\n```\n\nAs a convenience, Pydantic will use the field type if the argument is not provided (unless you are using\na [*plain*](#field-plain-validator) validator, in which case `json_schema_input_type` defaults to\n[`Any`][typing.Any] as the field type is completely discarded).", "url": "https://docs.pydantic.dev/latest/docs/concepts/validators/#json-schema-and-field-validators", "page": "docs/concepts/validators", "source_site": "pydantic"}
{"title": "type_adapter", "anchor": null, "heading_level": 0, "md_text": "You may have types that are not `BaseModel`s that you want to validate data against.\nOr you may want to validate a `list[SomeModel]`, or dump it to JSON.\n\n??? api \"API Documentation\"\n    [`pydantic.type_adapter.TypeAdapter`][pydantic.type_adapter.TypeAdapter]<br>\n\nFor use cases like this, Pydantic provides [`TypeAdapter`][pydantic.type_adapter.TypeAdapter],\nwhich can be used for type validation, serialization, and JSON schema generation without needing to create a\n[`BaseModel`][pydantic.main.BaseModel].\n\nA [`TypeAdapter`][pydantic.type_adapter.TypeAdapter] instance exposes some of the functionality from\n[`BaseModel`][pydantic.main.BaseModel] instance methods for types that do not have such methods\n(such as dataclasses, primitive types, and more):\n\n```python\nfrom typing_extensions import TypedDict\n\nfrom pydantic import TypeAdapter, ValidationError\n\n\nclass User(TypedDict):\n    name: str\n    id: int\n\n\nuser_list_adapter = TypeAdapter(list[User])\nuser_list = user_list_adapter.validate_python([{'name': 'Fred', 'id': '3'}])\nprint(repr(user_list))\n#> [{'name': 'Fred', 'id': 3}]\n\ntry:\n    user_list_adapter.validate_python(\n        [{'name': 'Fred', 'id': 'wrong', 'other': 'no'}]\n    )\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for list[User]\n    0.id\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='wrong', input_type=str]\n    \"\"\"\n\nprint(repr(user_list_adapter.dump_json(user_list)))\n#> b'[{\"name\":\"Fred\",\"id\":3}]'\n```\n\n!!! info \"`dump_json` returns `bytes`\"\n    `TypeAdapter`'s `dump_json` methods returns a `bytes` object, unlike the corresponding method for `BaseModel`, `model_dump_json`, which returns a `str`.\n    The reason for this discrepancy is that in V1, model dumping returned a str type, so this behavior is retained in V2 for backwards compatibility.\n    For the `BaseModel` case, `bytes` are coerced to `str` types, but `bytes` are often the desired end type.\n    Hence, for the new `TypeAdapter` class in V2, the return type is simply `bytes`, which can easily be coerced to a `str` type if desired.\n\n!!! note\n    Despite some overlap in use cases with [`RootModel`][pydantic.root_model.RootModel],\n    [`TypeAdapter`][pydantic.type_adapter.TypeAdapter] should not be used as a type annotation for\n    specifying fields of a `BaseModel`, etc.", "url": "https://docs.pydantic.dev/latest/docs/concepts/type_adapter/", "page": "docs/concepts/type_adapter", "source_site": "pydantic"}
{"title": "Parsing data into a specified type", "anchor": "parsing-data-into-a-specified-type", "heading_level": 2, "md_text": "[`TypeAdapter`][pydantic.type_adapter.TypeAdapter] can be used to apply the parsing logic to populate Pydantic models\nin a more ad-hoc way. This function behaves similarly to\n[`BaseModel.model_validate`][pydantic.main.BaseModel.model_validate],\nbut works with arbitrary Pydantic-compatible types.\n\nThis is especially useful when you want to parse results into a type that is not a direct subclass of\n[`BaseModel`][pydantic.main.BaseModel]. For example:\n\n```python\nfrom pydantic import BaseModel, TypeAdapter\n\n\nclass Item(BaseModel):\n    id: int\n    name: str", "url": "https://docs.pydantic.dev/latest/docs/concepts/type_adapter/#parsing-data-into-a-specified-type", "page": "docs/concepts/type_adapter", "source_site": "pydantic"}
{"title": "item_data = requests.get('https://my-api.com/items').json()", "anchor": "item_data-requestsgethttpsmy-apicomitemsjson", "heading_level": 1, "md_text": "item_data = [{'id': 1, 'name': 'My Item'}]\n\nitems = TypeAdapter(list[Item]).validate_python(item_data)\nprint(items)\n#> [Item(id=1, name='My Item')]\n```\n\n[`TypeAdapter`][pydantic.type_adapter.TypeAdapter] is capable of parsing data into any of the types Pydantic can\nhandle as fields of a [`BaseModel`][pydantic.main.BaseModel].\n\n!!! info \"Performance considerations\"\n    When creating an instance of [`TypeAdapter`][pydantic.type_adapter.TypeAdapter], the provided type must be analyzed and converted into a pydantic-core\n    schema. This comes with some non-trivial overhead, so it is recommended to create a `TypeAdapter` for a given type\n    just once and reuse it in loops or other performance-critical code.", "url": "https://docs.pydantic.dev/latest/docs/concepts/type_adapter/#item_data-requestsgethttpsmy-apicomitemsjson", "page": "docs/concepts/type_adapter", "source_site": "pydantic"}
{"title": "Rebuilding a `TypeAdapter`'s schema", "anchor": "rebuilding-a-typeadapters-schema", "heading_level": 2, "md_text": "In v2.10+, [`TypeAdapter`][pydantic.type_adapter.TypeAdapter]'s support deferred schema building and manual rebuilds. This is helpful for the case of:\n\n* Types with forward references\n* Types for which core schema builds are expensive\n\nWhen you initialize a [`TypeAdapter`][pydantic.type_adapter.TypeAdapter] with a type, Pydantic analyzes the type and creates a core schema for it.\nThis core schema contains the information needed to validate and serialize data for that type.\nSee the [architecture documentation](../internals/architecture.md) for more information on core schemas.\n\nIf you set [`defer_build`][pydantic.config.ConfigDict.defer_build] to `True` when initializing a `TypeAdapter`,\nPydantic will defer building the core schema until the first time it is needed (for validation or serialization).\n\nIn order to manually trigger the building of the core schema, you can call the\n[`rebuild`][pydantic.type_adapter.TypeAdapter.rebuild] method on the [`TypeAdapter`][pydantic.type_adapter.TypeAdapter] instance:\n\n```python\nfrom pydantic import ConfigDict, TypeAdapter\n\nta = TypeAdapter('MyInt', config=ConfigDict(defer_build=True))", "url": "https://docs.pydantic.dev/latest/docs/concepts/type_adapter/#rebuilding-a-typeadapters-schema", "page": "docs/concepts/type_adapter", "source_site": "pydantic"}
{"title": "some time later, the forward reference is defined", "anchor": "some-time-later-the-forward-reference-is-defined", "heading_level": 1, "md_text": "MyInt = int\n\nta.rebuild()\nassert ta.validate_python(1) == 1\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/type_adapter/#some-time-later-the-forward-reference-is-defined", "page": "docs/concepts/type_adapter", "source_site": "pydantic"}
{"title": "unions", "anchor": null, "heading_level": 0, "md_text": "Unions are fundamentally different to all other types Pydantic validates - instead of requiring all fields/items/values to be valid, unions require only one member to be valid.\n\nThis leads to some nuance around how to validate unions:\n\n* which member(s) of the union should you validate data against, and in which order?\n* which errors to raise when validation fails?\n\nValidating unions feels like adding another orthogonal dimension to the validation process.\n\nTo solve these problems, Pydantic supports three fundamental approaches to validating unions:\n\n1. [left to right mode](#left-to-right-mode) - the simplest approach, each member of the union is tried in order and the first match is returned\n2. [smart mode](#smart-mode) - similar to \"left to right mode\" members are tried in order; however, validation will proceed past the first match to attempt to find a better match, this is the default mode for most union validation\n3. [discriminated unions](#discriminated-unions) - only one member of the union is tried, based on a discriminator\n\n!!! tip\n\n    In general, we recommend using [discriminated unions](#discriminated-unions). They are both more performant and more predictable than untagged unions, as they allow you to control which member of the union to validate against.\n\n    For complex cases, if you're using untagged unions, it's recommended to use `union_mode='left_to_right'` if you need guarantees about the order of validation attempts against the union members.\n\n    If you're looking for incredibly specialized behavior, you can use a [custom validator](../concepts/validators.md#field-validators).", "url": "https://docs.pydantic.dev/latest/docs/concepts/unions/", "page": "docs/concepts/unions", "source_site": "pydantic"}
{"title": "Left to Right Mode", "anchor": "left-to-right-mode", "heading_level": 3, "md_text": "!!! note\n    Because this mode often leads to unexpected validation results, it is not the default in Pydantic >=2, instead `union_mode='smart'` is the default.\n\nWith this approach, validation is attempted against each member of the union in their order they're defined, and the first successful validation is accepted as input.\n\nIf validation fails on all members, the validation error includes the errors from all members of the union.\n\n`union_mode='left_to_right'` must be set as a [`Field`](../concepts/fields.md) parameter on union fields where you want to use it.\n\n```python {title=\"Union with left to right mode\"}\nfrom typing import Union\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass User(BaseModel):\n    id: Union[str, int] = Field(union_mode='left_to_right')\n\n\nprint(User(id=123))\n#> id=123\nprint(User(id='hello'))\n#> id='hello'\n\ntry:\n    User(id=[])\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for User\n    id.str\n      Input should be a valid string [type=string_type, input_value=[], input_type=list]\n    id.int\n      Input should be a valid integer [type=int_type, input_value=[], input_type=list]\n    \"\"\"\n```\n\nThe order of members is very important in this case, as demonstrated by tweak the above example:\n\n```python {title=\"Union with left to right - unexpected results\"}\nfrom typing import Union\n\nfrom pydantic import BaseModel, Field\n\n\nclass User(BaseModel):\n    id: Union[int, str] = Field(union_mode='left_to_right')\n\n\nprint(User(id=123))  # (1)\n#> id=123\nprint(User(id='456'))  # (2)\n#> id=456\n```\n\n1. As expected the input is validated against the `int` member and the result is as expected.\n2. We're in lax mode and the numeric string `'123'` is valid as input to the first member of the union, `int`.\n   Since that is tried first, we get the surprising result of `id` being an `int` instead of a `str`.", "url": "https://docs.pydantic.dev/latest/docs/concepts/unions/#left-to-right-mode", "page": "docs/concepts/unions", "source_site": "pydantic"}
{"title": "Smart Mode", "anchor": "smart-mode", "heading_level": 3, "md_text": "Because of the potentially surprising results of `union_mode='left_to_right'`, in Pydantic >=2 the default mode for `Union` validation is `union_mode='smart'`.\n\nIn this mode, pydantic attempts to select the best match for the input from the union members. The exact algorithm may change between Pydantic minor releases to allow for improvements in both performance and accuracy.\n\n!!! note\n\n    We reserve the right to tweak the internal `smart` matching algorithm in future versions of Pydantic. If you rely on very specific\n    matching behavior, it's recommended to use `union_mode='left_to_right'` or [discriminated unions](#discriminated-unions).\n\n??? info \"Smart Mode Algorithm\"\n\n    The smart mode algorithm uses two metrics to determine the best match for the input:\n\n    1. The number of valid fields set (relevant for models, dataclasses, and typed dicts)\n    2. The exactness of the match (relevant for all types)\n\n    #### Number of valid fields set\n\n    !!! note\n        This metric was introduced in Pydantic v2.8.0. Prior to this version, only exactness was used to determine the best match.\n\n    This metric is currently only relevant for models, dataclasses, and typed dicts.\n\n    The greater the number of valid fields set, the better the match. The number of fields set on nested models is also taken into account.\n    These counts bubble up to the top-level union, where the union member with the highest count is considered the best match.\n\n    For data types where this metric is relevant, we prioritize this count over exactness. For all other types, we use solely exactness.\n\n    #### Exactness\n\n    For `exactness`, Pydantic scores a match of a union member into one of the following three groups (from highest score to lowest score):\n\n    * An exact type match, for example an `int` input to a `float | int` union validation is an exact type match for the `int` member\n    * Validation would have succeeded in [`strict` mode](../concepts/strict_mode.md)\n    * Validation would have succeeded in lax mode\n\n    The union match which produced the highest exactness score will be considered the best match.\n\n    In smart mode, the following steps are taken to try to select the best match for the input:\n\n    === \"`BaseModel`, `dataclass`, and `TypedDict`\"\n\n        1. Union members are attempted left to right, with any successful matches scored into one of the three exactness categories described above,\n        with the valid fields set count also tallied.\n        2. After all members have been evaluated, the member with the highest \"valid fields set\" count is returned.\n        3. If there's a tie for the highest \"valid fields set\" count, the exactness score is used as a tiebreaker, and the member with the highest exactness score is returned.\n        4. If validation failed on all the members, return all the errors.\n\n    === \"All other data types\"\n\n        1. Union members are attempted left to right, with any successful matches scored into one of the three exactness categories described above.\n            * If validation succeeds with an exact type match, that member is returned immediately and following members will not be attempted.\n        2. If validation succeeded on at least one member as a \"strict\" match, the leftmost of those \"strict\" matches is returned.\n        3. If validation succeeded on at least one member in \"lax\" mode, the leftmost match is returned.\n        4. Validation failed on all the members, return all the errors.\n\n```python\nfrom typing import Union\nfrom uuid import UUID\n\nfrom pydantic import BaseModel\n\n\nclass User(BaseModel):\n    id: Union[int, str, UUID]\n    name: str\n\n\nuser_01 = User(id=123, name='John Doe')\nprint(user_01)\n#> id=123 name='John Doe'\nprint(user_01.id)\n#> 123\nuser_02 = User(id='1234', name='John Doe')\nprint(user_02)\n#> id='1234' name='John Doe'\nprint(user_02.id)\n#> 1234\nuser_03_uuid = UUID('cf57432e-809e-4353-adbd-9d5c0d733868')\nuser_03 = User(id=user_03_uuid, name='John Doe')\nprint(user_03)\n#> id=UUID('cf57432e-809e-4353-adbd-9d5c0d733868') name='John Doe'\nprint(user_03.id)\n#> cf57432e-809e-4353-adbd-9d5c0d733868\nprint(user_03_uuid.int)\n#> 275603287559914445491632874575877060712\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/unions/#smart-mode", "page": "docs/concepts/unions", "source_site": "pydantic"}
{"title": "Discriminated Unions", "anchor": "discriminated-unions", "heading_level": 2, "md_text": "**Discriminated unions are sometimes referred to as \"Tagged Unions\".**\n\nWe can use discriminated unions to more efficiently validate `Union` types, by choosing which member of the union to validate against.\n\nThis makes validation more efficient and also avoids a proliferation of errors when validation fails.\n\nAdding discriminator to unions also means the generated JSON schema implements the [associated OpenAPI specification](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#discriminator-object).", "url": "https://docs.pydantic.dev/latest/docs/concepts/unions/#discriminated-unions", "page": "docs/concepts/unions", "source_site": "pydantic"}
{"title": "Discriminated Unions with `str` discriminators", "anchor": "discriminated-unions-with-str-discriminators", "heading_level": 3, "md_text": "Frequently, in the case of a `Union` with multiple models,\nthere is a common field to all members of the union that can be used to distinguish\nwhich union case the data should be validated against; this is referred to as the \"discriminator\" in\n[OpenAPI](https://swagger.io/docs/specification/data-models/inheritance-and-polymorphism/).\n\nTo validate models based on that information you can set the same field - let's call it `my_discriminator` -\nin each of the models with a discriminated value, which is one (or many) `Literal` value(s).\nFor your `Union`, you can set the discriminator in its value: `Field(discriminator='my_discriminator')`.\n\n```python\nfrom typing import Literal, Union\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Cat(BaseModel):\n    pet_type: Literal['cat']\n    meows: int\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n    barks: float\n\n\nclass Lizard(BaseModel):\n    pet_type: Literal['reptile', 'lizard']\n    scales: bool\n\n\nclass Model(BaseModel):\n    pet: Union[Cat, Dog, Lizard] = Field(discriminator='pet_type')\n    n: int\n\n\nprint(Model(pet={'pet_type': 'dog', 'barks': 3.14}, n=1))\n#> pet=Dog(pet_type='dog', barks=3.14) n=1\ntry:\n    Model(pet={'pet_type': 'dog'}, n=1)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    pet.dog.barks\n      Field required [type=missing, input_value={'pet_type': 'dog'}, input_type=dict]\n    \"\"\"\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/unions/#discriminated-unions-with-str-discriminators", "page": "docs/concepts/unions", "source_site": "pydantic"}
{"title": "Discriminated Unions with callable `Discriminator`", "anchor": "discriminated-unions-with-callable-discriminator", "heading_level": 3, "md_text": "??? api \"API Documentation\"\n    [`pydantic.types.Discriminator`][pydantic.types.Discriminator]<br>\n\nIn the case of a `Union` with multiple models, sometimes there isn't a single uniform field\nacross all models that you can use as a discriminator.\nThis is the perfect use case for a callable `Discriminator`.\n\n!!! tip\n    When you're designing callable discriminators, remember that you might have to account\n    for both `dict` and model type inputs. This pattern is similar to that of `mode='before'` validators,\n    where you have to anticipate various forms of input.\n\n    But wait! You ask, I only anticipate passing in `dict` types, why do I need to account for models?\n    Pydantic uses callable discriminators for serialization as well, at which point the input to your callable is\n    very likely to be a model instance.\n\n    In the following examples, you'll see that the callable discriminators are designed to handle both `dict` and model inputs.\n    If you don't follow this practice, it's likely that you'll, in the best case, get warnings during serialization,\n    and in the worst case, get runtime errors during validation.\n\n```python\nfrom typing import Annotated, Any, Literal, Union\n\nfrom pydantic import BaseModel, Discriminator, Tag\n\n\nclass Pie(BaseModel):\n    time_to_cook: int\n    num_ingredients: int\n\n\nclass ApplePie(Pie):\n    fruit: Literal['apple'] = 'apple'\n\n\nclass PumpkinPie(Pie):\n    filling: Literal['pumpkin'] = 'pumpkin'\n\n\ndef get_discriminator_value(v: Any) -> str:\n    if isinstance(v, dict):\n        return v.get('fruit', v.get('filling'))\n    return getattr(v, 'fruit', getattr(v, 'filling', None))\n\n\nclass ThanksgivingDinner(BaseModel):\n    dessert: Annotated[\n        Union[\n            Annotated[ApplePie, Tag('apple')],\n            Annotated[PumpkinPie, Tag('pumpkin')],\n        ],\n        Discriminator(get_discriminator_value),\n    ]\n\n\napple_variation = ThanksgivingDinner.model_validate(\n    {'dessert': {'fruit': 'apple', 'time_to_cook': 60, 'num_ingredients': 8}}\n)\nprint(repr(apple_variation))\n\"\"\"\nThanksgivingDinner(dessert=ApplePie(time_to_cook=60, num_ingredients=8, fruit='apple'))\n\"\"\"\n\npumpkin_variation = ThanksgivingDinner.model_validate(\n    {\n        'dessert': {\n            'filling': 'pumpkin',\n            'time_to_cook': 40,\n            'num_ingredients': 6,\n        }\n    }\n)\nprint(repr(pumpkin_variation))\n\"\"\"\nThanksgivingDinner(dessert=PumpkinPie(time_to_cook=40, num_ingredients=6, filling='pumpkin'))\n\"\"\"\n```\n\n`Discriminator`s can also be used to validate `Union` types with combinations of models and primitive types.\n\nFor example:\n\n```python\nfrom typing import Annotated, Any, Union\n\nfrom pydantic import BaseModel, Discriminator, Tag, ValidationError\n\n\ndef model_x_discriminator(v: Any) -> str:\n    if isinstance(v, int):\n        return 'int'\n    if isinstance(v, (dict, BaseModel)):\n        return 'model'\n    else:\n        # return None if the discriminator value isn't found\n        return None\n\n\nclass SpecialValue(BaseModel):\n    value: int\n\n\nclass DiscriminatedModel(BaseModel):\n    value: Annotated[\n        Union[\n            Annotated[int, Tag('int')],\n            Annotated['SpecialValue', Tag('model')],\n        ],\n        Discriminator(model_x_discriminator),\n    ]\n\n\nmodel_data = {'value': {'value': 1}}\nm = DiscriminatedModel.model_validate(model_data)\nprint(m)\n#> value=SpecialValue(value=1)\n\nint_data = {'value': 123}\nm = DiscriminatedModel.model_validate(int_data)\nprint(m)\n#> value=123\n\ntry:\n    DiscriminatedModel.model_validate({'value': 'not an int or a model'})\nexcept ValidationError as e:\n    print(e)  # (1)!\n    \"\"\"\n    1 validation error for DiscriminatedModel\n    value\n      Unable to extract tag using discriminator model_x_discriminator() [type=union_tag_not_found, input_value='not an int or a model', input_type=str]\n    \"\"\"\n```\n\n1. Notice the callable discriminator function returns `None` if a discriminator value is not found.\n   When `None` is returned, this `union_tag_not_found` error is raised.\n\n!!! note\n    Using the [annotated pattern](./fields.md#the-annotated-pattern) can be handy to regroup\n    the `Union` and `discriminator` information. See the next example for more details.\n\n    There are a few ways to set a discriminator for a field, all varying slightly in syntax.\n\n    For `str` discriminators:\n\n    ```python {lint=\"skip\" test=\"skip\"}\n    some_field: Union[...] = Field(discriminator='my_discriminator')\n    some_field: Annotated[Union[...], Field(discriminator='my_discriminator')]\n    ```\n\n    For callable `Discriminator`s:\n\n    ```python {lint=\"skip\" test=\"skip\"}\n    some_field: Union[...] = Field(discriminator=Discriminator(...))\n    some_field: Annotated[Union[...], Discriminator(...)]\n    some_field: Annotated[Union[...], Field(discriminator=Discriminator(...))]\n    ```\n\n!!! warning\n    Discriminated unions cannot be used with only a single variant, such as `Union[Cat]`.", "url": "https://docs.pydantic.dev/latest/docs/concepts/unions/#discriminated-unions-with-callable-discriminator", "page": "docs/concepts/unions", "source_site": "pydantic"}
{"title": "Discriminated Unions with callable `Discriminator`", "anchor": "discriminated-unions-with-callable-discriminator", "heading_level": 3, "md_text": "    Python changes `Union[T]` into `T` at interpretation time, so it is not possible for `pydantic` to\n    distinguish fields of `Union[T]` from `T`.", "url": "https://docs.pydantic.dev/latest/docs/concepts/unions/#discriminated-unions-with-callable-discriminator", "page": "docs/concepts/unions", "source_site": "pydantic"}
{"title": "Nested Discriminated Unions", "anchor": "nested-discriminated-unions", "heading_level": 3, "md_text": "Only one discriminator can be set for a field but sometimes you want to combine multiple discriminators.\nYou can do it by creating nested `Annotated` types, e.g.:\n\n```python\nfrom typing import Annotated, Literal, Union\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass BlackCat(BaseModel):\n    pet_type: Literal['cat']\n    color: Literal['black']\n    black_name: str\n\n\nclass WhiteCat(BaseModel):\n    pet_type: Literal['cat']\n    color: Literal['white']\n    white_name: str\n\n\nCat = Annotated[Union[BlackCat, WhiteCat], Field(discriminator='color')]\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n    name: str\n\n\nPet = Annotated[Union[Cat, Dog], Field(discriminator='pet_type')]\n\n\nclass Model(BaseModel):\n    pet: Pet\n    n: int\n\n\nm = Model(pet={'pet_type': 'cat', 'color': 'black', 'black_name': 'felix'}, n=1)\nprint(m)\n#> pet=BlackCat(pet_type='cat', color='black', black_name='felix') n=1\ntry:\n    Model(pet={'pet_type': 'cat', 'color': 'red'}, n='1')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    pet.cat\n      Input tag 'red' found using 'color' does not match any of the expected tags: 'black', 'white' [type=union_tag_invalid, input_value={'pet_type': 'cat', 'color': 'red'}, input_type=dict]\n    \"\"\"\ntry:\n    Model(pet={'pet_type': 'cat', 'color': 'black'}, n='1')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    pet.cat.black.black_name\n      Field required [type=missing, input_value={'pet_type': 'cat', 'color': 'black'}, input_type=dict]\n    \"\"\"\n```\n\n!!! tip\n    If you want to validate data against a union, and solely a union, you can use pydantic's [`TypeAdapter`](../concepts/type_adapter.md) construct instead of inheriting from the standard `BaseModel`.\n\n    In the context of the previous example, we have the following:\n\n    ```python {lint=\"skip\" test=\"skip\"}\n    type_adapter = TypeAdapter(Pet)\n\n    pet = type_adapter.validate_python(\n        {'pet_type': 'cat', 'color': 'black', 'black_name': 'felix'}\n    )\n    print(repr(pet))\n    #> BlackCat(pet_type='cat', color='black', black_name='felix')\n    ```", "url": "https://docs.pydantic.dev/latest/docs/concepts/unions/#nested-discriminated-unions", "page": "docs/concepts/unions", "source_site": "pydantic"}
{"title": "Union Validation Errors", "anchor": "union-validation-errors", "heading_level": 2, "md_text": "When `Union` validation fails, error messages can be quite verbose, as they will produce validation errors for\neach case in the union.\nThis is especially noticeable when dealing with recursive models, where reasons may be generated at each level of\nrecursion.\nDiscriminated unions help to simplify error messages in this case, as validation errors are only produced for\nthe case with a matching discriminator value.\n\nYou can also customize the error type, message, and context for a `Discriminator` by passing\nthese specifications as parameters to the `Discriminator` constructor, as seen in the example below.\n\n```python\nfrom typing import Annotated, Union\n\nfrom pydantic import BaseModel, Discriminator, Tag, ValidationError", "url": "https://docs.pydantic.dev/latest/docs/concepts/unions/#union-validation-errors", "page": "docs/concepts/unions", "source_site": "pydantic"}
{"title": "Errors are quite verbose with a normal Union:", "anchor": "errors-are-quite-verbose-with-a-normal-union", "heading_level": 1, "md_text": "class Model(BaseModel):\n    x: Union[str, 'Model']\n\n\ntry:\n    Model.model_validate({'x': {'x': {'x': 1}}})\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    4 validation errors for Model\n    x.str\n      Input should be a valid string [type=string_type, input_value={'x': {'x': 1}}, input_type=dict]\n    x.Model.x.str\n      Input should be a valid string [type=string_type, input_value={'x': 1}, input_type=dict]\n    x.Model.x.Model.x.str\n      Input should be a valid string [type=string_type, input_value=1, input_type=int]\n    x.Model.x.Model.x.Model\n      Input should be a valid dictionary or instance of Model [type=model_type, input_value=1, input_type=int]\n    \"\"\"\n\ntry:\n    Model.model_validate({'x': {'x': {'x': {}}}})\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    4 validation errors for Model\n    x.str\n      Input should be a valid string [type=string_type, input_value={'x': {'x': {}}}, input_type=dict]\n    x.Model.x.str\n      Input should be a valid string [type=string_type, input_value={'x': {}}, input_type=dict]\n    x.Model.x.Model.x.str\n      Input should be a valid string [type=string_type, input_value={}, input_type=dict]\n    x.Model.x.Model.x.Model.x\n      Field required [type=missing, input_value={}, input_type=dict]\n    \"\"\"", "url": "https://docs.pydantic.dev/latest/docs/concepts/unions/#errors-are-quite-verbose-with-a-normal-union", "page": "docs/concepts/unions", "source_site": "pydantic"}
{"title": "Errors are much simpler with a discriminated union:", "anchor": "errors-are-much-simpler-with-a-discriminated-union", "heading_level": 1, "md_text": "def model_x_discriminator(v):\n    if isinstance(v, str):\n        return 'str'\n    if isinstance(v, (dict, BaseModel)):\n        return 'model'\n\n\nclass DiscriminatedModel(BaseModel):\n    x: Annotated[\n        Union[\n            Annotated[str, Tag('str')],\n            Annotated['DiscriminatedModel', Tag('model')],\n        ],\n        Discriminator(\n            model_x_discriminator,\n            custom_error_type='invalid_union_member',  # (1)!\n            custom_error_message='Invalid union member',  # (2)!\n            custom_error_context={'discriminator': 'str_or_model'},  # (3)!\n        ),\n    ]\n\n\ntry:\n    DiscriminatedModel.model_validate({'x': {'x': {'x': 1}}})\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for DiscriminatedModel\n    x.model.x.model.x\n      Invalid union member [type=invalid_union_member, input_value=1, input_type=int]\n    \"\"\"\n\ntry:\n    DiscriminatedModel.model_validate({'x': {'x': {'x': {}}}})\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for DiscriminatedModel\n    x.model.x.model.x.model.x\n      Field required [type=missing, input_value={}, input_type=dict]\n    \"\"\"", "url": "https://docs.pydantic.dev/latest/docs/concepts/unions/#errors-are-much-simpler-with-a-discriminated-union", "page": "docs/concepts/unions", "source_site": "pydantic"}
{"title": "The data is still handled properly when valid:", "anchor": "the-data-is-still-handled-properly-when-valid", "heading_level": 1, "md_text": "data = {'x': {'x': {'x': 'a'}}}\nm = DiscriminatedModel.model_validate(data)\nprint(m.model_dump())\n#> {'x': {'x': {'x': 'a'}}}\n```\n\n1. `custom_error_type` is the `type` attribute of the `ValidationError` raised when validation fails.\n2. `custom_error_message` is the `msg` attribute of the `ValidationError` raised when validation fails.\n3. `custom_error_context` is the `ctx` attribute of the `ValidationError` raised when validation fails.\n\nYou can also simplify error messages by labeling each case with a [`Tag`][pydantic.types.Tag].\nThis is especially useful when you have complex types like those in this example:\n\n```python\nfrom typing import Annotated, Union\n\nfrom pydantic import AfterValidator, Tag, TypeAdapter, ValidationError\n\nDoubledList = Annotated[list[int], AfterValidator(lambda x: x * 2)]\nStringsMap = dict[str, str]", "url": "https://docs.pydantic.dev/latest/docs/concepts/unions/#the-data-is-still-handled-properly-when-valid", "page": "docs/concepts/unions", "source_site": "pydantic"}
{"title": "Not using any `Tag`s for each union case, the errors are not so nice to look at", "anchor": "not-using-any-tags-for-each-union-case-the-errors-are-not-so-nice-to-look-at", "heading_level": 1, "md_text": "adapter = TypeAdapter(Union[DoubledList, StringsMap])\n\ntry:\n    adapter.validate_python(['a'])\nexcept ValidationError as exc_info:\n    print(exc_info)\n    \"\"\"\n    2 validation errors for union[function-after[<lambda>(), list[int]],dict[str,str]]\n    function-after[<lambda>(), list[int]].0\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='a', input_type=str]\n    dict[str,str]\n      Input should be a valid dictionary [type=dict_type, input_value=['a'], input_type=list]\n    \"\"\"\n\ntag_adapter = TypeAdapter(\n    Union[\n        Annotated[DoubledList, Tag('DoubledList')],\n        Annotated[StringsMap, Tag('StringsMap')],\n    ]\n)\n\ntry:\n    tag_adapter.validate_python(['a'])\nexcept ValidationError as exc_info:\n    print(exc_info)\n    \"\"\"\n    2 validation errors for union[DoubledList,StringsMap]\n    DoubledList.0\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='a', input_type=str]\n    StringsMap\n      Input should be a valid dictionary [type=dict_type, input_value=['a'], input_type=list]\n    \"\"\"\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/unions/#not-using-any-tags-for-each-union-case-the-errors-are-not-so-nice-to-look-at", "page": "docs/concepts/unions", "source_site": "pydantic"}
{"title": "alias", "anchor": null, "heading_level": 0, "md_text": "An alias is an alternative name for a field, used when serializing and deserializing data.\n\nYou can specify an alias in the following ways:\n\n* `alias` on the [`Field`][pydantic.fields.Field]\n    * must be a `str`\n* `validation_alias` on the [`Field`][pydantic.fields.Field]\n    * can be an instance of `str`, [`AliasPath`][pydantic.aliases.AliasPath], or [`AliasChoices`][pydantic.aliases.AliasChoices]\n* `serialization_alias` on the [`Field`][pydantic.fields.Field]\n    * must be a `str`\n* `alias_generator` on the [`Config`][pydantic.config.ConfigDict.alias_generator]\n    * can be a callable or an instance of [`AliasGenerator`][pydantic.aliases.AliasGenerator]\n\nFor examples of how to use `alias`, `validation_alias`, and `serialization_alias`, see [Field aliases](../concepts/fields.md#field-aliases).", "url": "https://docs.pydantic.dev/latest/docs/concepts/alias/", "page": "docs/concepts/alias", "source_site": "pydantic"}
{"title": "`AliasPath` and `AliasChoices`", "anchor": "aliaspath-and-aliaschoices", "heading_level": 2, "md_text": "??? api \"API Documentation\"\n\n    [`pydantic.aliases.AliasPath`][pydantic.aliases.AliasPath]<br>\n    [`pydantic.aliases.AliasChoices`][pydantic.aliases.AliasChoices]<br>\n\nPydantic provides two special types for convenience when using `validation_alias`: `AliasPath` and `AliasChoices`.\n\nThe `AliasPath` is used to specify a path to a field using aliases. For example:\n\n```python {lint=\"skip\"}\nfrom pydantic import BaseModel, Field, AliasPath\n\n\nclass User(BaseModel):\n    first_name: str = Field(validation_alias=AliasPath('names', 0))\n    last_name: str = Field(validation_alias=AliasPath('names', 1))\n    address: str = Field(validation_alias=AliasPath('contact', 'address'))\n\nuser = User.model_validate({  # (1)!\n    'names': ['John', 'Doe'],\n    'contact': {'address': '221B Baker Street'}\n})\nprint(user)\n#> first_name='John' last_name='Doe' address='221B Baker Street'\n```\n\n1. We are using [`model_validate()`][pydantic.BaseModel.model_validate] to validate a dictionary using the field aliases.\n   Refer to documentation about [validating data](./models.md#validating-data) for more details.\n\nIn the `'first_name'` field, we are using the alias `'names'` and the index `0` to specify the path to the first name.\nIn the `'last_name'` field, we are using the alias `'names'` and the index `1` to specify the path to the last name.\n\n`AliasChoices` is used to specify a choice of aliases. For example:\n\n```python {lint=\"skip\"}\nfrom pydantic import BaseModel, Field, AliasChoices\n\n\nclass User(BaseModel):\n    first_name: str = Field(validation_alias=AliasChoices('first_name', 'fname'))\n    last_name: str = Field(validation_alias=AliasChoices('last_name', 'lname'))\n\nuser = User.model_validate({'fname': 'John', 'lname': 'Doe'})  # (1)!\nprint(user)\n#> first_name='John' last_name='Doe'\nuser = User.model_validate({'first_name': 'John', 'lname': 'Doe'})  # (2)!\nprint(user)\n#> first_name='John' last_name='Doe'\n```\n\n1. We are using the second alias choice for both fields.\n2. We are using the first alias choice for the field `'first_name'` and the second alias choice\n   for the field `'last_name'`.\n\nYou can also use `AliasChoices` with `AliasPath`:\n\n```python {lint=\"skip\"}\nfrom pydantic import BaseModel, Field, AliasPath, AliasChoices\n\n\nclass User(BaseModel):\n    first_name: str = Field(validation_alias=AliasChoices('first_name', AliasPath('names', 0)))\n    last_name: str = Field(validation_alias=AliasChoices('last_name', AliasPath('names', 1)))\n\n\nuser = User.model_validate({'first_name': 'John', 'last_name': 'Doe'})\nprint(user)\n#> first_name='John' last_name='Doe'\nuser = User.model_validate({'names': ['John', 'Doe']})\nprint(user)\n#> first_name='John' last_name='Doe'\nuser = User.model_validate({'names': ['John'], 'last_name': 'Doe'})\nprint(user)\n#> first_name='John' last_name='Doe'\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/alias/#aliaspath-and-aliaschoices", "page": "docs/concepts/alias", "source_site": "pydantic"}
{"title": "Using alias generators", "anchor": "using-alias-generators", "heading_level": 2, "md_text": "You can use the `alias_generator` parameter of [`Config`][pydantic.config.ConfigDict.alias_generator] to specify\na callable (or group of callables, via `AliasGenerator`) that will generate aliases for all fields in a model.\nThis is useful if you want to use a consistent naming convention for all fields in a model, but do not\nwant to specify the alias for each field individually.\n\n!!! note\n    Pydantic offers three built-in alias generators that you can use out of the box:\n\n    [`to_pascal`][pydantic.alias_generators.to_pascal]<br>\n    [`to_camel`][pydantic.alias_generators.to_camel]<br>\n    [`to_snake`][pydantic.alias_generators.to_snake]<br>", "url": "https://docs.pydantic.dev/latest/docs/concepts/alias/#using-alias-generators", "page": "docs/concepts/alias", "source_site": "pydantic"}
{"title": "Using a callable", "anchor": "using-a-callable", "heading_level": 3, "md_text": "Here's a basic example using a callable:\n\n```python\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass Tree(BaseModel):\n    model_config = ConfigDict(\n        alias_generator=lambda field_name: field_name.upper()\n    )\n\n    age: int\n    height: float\n    kind: str\n\n\nt = Tree.model_validate({'AGE': 12, 'HEIGHT': 1.2, 'KIND': 'oak'})\nprint(t.model_dump(by_alias=True))\n#> {'AGE': 12, 'HEIGHT': 1.2, 'KIND': 'oak'}\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/alias/#using-a-callable", "page": "docs/concepts/alias", "source_site": "pydantic"}
{"title": "Using an `AliasGenerator`", "anchor": "using-an-aliasgenerator", "heading_level": 3, "md_text": "??? api \"API Documentation\"\n\n    [`pydantic.aliases.AliasGenerator`][pydantic.aliases.AliasGenerator]<br>\n\n`AliasGenerator` is a class that allows you to specify multiple alias generators for a model.\nYou can use an `AliasGenerator` to specify different alias generators for validation and serialization.\n\nThis is particularly useful if you need to use different naming conventions for loading and saving data,\nbut you don't want to specify the validation and serialization aliases for each field individually.\n\nFor example:\n\n```python\nfrom pydantic import AliasGenerator, BaseModel, ConfigDict\n\n\nclass Tree(BaseModel):\n    model_config = ConfigDict(\n        alias_generator=AliasGenerator(\n            validation_alias=lambda field_name: field_name.upper(),\n            serialization_alias=lambda field_name: field_name.title(),\n        )\n    )\n\n    age: int\n    height: float\n    kind: str\n\n\nt = Tree.model_validate({'AGE': 12, 'HEIGHT': 1.2, 'KIND': 'oak'})\nprint(t.model_dump(by_alias=True))\n#> {'Age': 12, 'Height': 1.2, 'Kind': 'oak'}\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/alias/#using-an-aliasgenerator", "page": "docs/concepts/alias", "source_site": "pydantic"}
{"title": "Alias Precedence", "anchor": "alias-precedence", "heading_level": 2, "md_text": "If you specify an `alias` on the [`Field`][pydantic.fields.Field], it will take precedence over the generated alias by default:\n\n```python\nfrom pydantic import BaseModel, ConfigDict, Field\n\n\ndef to_camel(string: str) -> str:\n    return ''.join(word.capitalize() for word in string.split('_'))\n\n\nclass Voice(BaseModel):\n    model_config = ConfigDict(alias_generator=to_camel)\n\n    name: str\n    language_code: str = Field(alias='lang')\n\n\nvoice = Voice(Name='Filiz', lang='tr-TR')\nprint(voice.language_code)\n#> tr-TR\nprint(voice.model_dump(by_alias=True))\n#> {'Name': 'Filiz', 'lang': 'tr-TR'}\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/alias/#alias-precedence", "page": "docs/concepts/alias", "source_site": "pydantic"}
{"title": "Alias Priority", "anchor": "alias-priority", "heading_level": 3, "md_text": "You may set `alias_priority` on a field to change this behavior:\n\n* `alias_priority=2` the alias will *not* be overridden by the alias generator.\n* `alias_priority=1` the alias *will* be overridden by the alias generator.\n* `alias_priority` not set:\n    * alias is set: the alias will *not* be overridden by the alias generator.\n    * alias is not set: the alias *will* be overridden by the alias generator.\n\nThe same precedence applies to `validation_alias` and `serialization_alias`.\nSee more about the different field aliases under [field aliases](../concepts/fields.md#field-aliases).", "url": "https://docs.pydantic.dev/latest/docs/concepts/alias/#alias-priority", "page": "docs/concepts/alias", "source_site": "pydantic"}
{"title": "Alias Configuration", "anchor": "alias-configuration", "heading_level": 2, "md_text": "You can use [`ConfigDict`](./config.md) settings or runtime validation/serialization\nsettings to control whether or not aliases are used.", "url": "https://docs.pydantic.dev/latest/docs/concepts/alias/#alias-configuration", "page": "docs/concepts/alias", "source_site": "pydantic"}
{"title": "`ConfigDict` Settings", "anchor": "configdict-settings", "heading_level": 3, "md_text": "You can use [configuration settings](./config.md) to control, at the model level,\nwhether or not aliases are used for validation and serialization. If you would like to control\nthis behavior for nested models/surpassing the config-model boundary, use [runtime settings](#runtime-settings).", "url": "https://docs.pydantic.dev/latest/docs/concepts/alias/#configdict-settings", "page": "docs/concepts/alias", "source_site": "pydantic"}
{"title": "Validation", "anchor": "validation", "heading_level": 4, "md_text": "When validating data, you can enable population of attributes by attribute name, alias, or both.\n**By default**, Pydantic uses aliases for validation. Further configuration is available via:\n\n* [`ConfigDict.validate_by_alias`][pydantic.config.ConfigDict.validate_by_alias]: `True` by default\n* [`ConfigDict.validate_by_name`][pydantic.config.ConfigDict.validate_by_name]: `False` by default\n\n=== \"`validate_by_alias`\"\n\n    ```python\n    from pydantic import BaseModel, ConfigDict, Field\n\n\n    class Model(BaseModel):\n        my_field: str = Field(validation_alias='my_alias')\n\n        model_config = ConfigDict(validate_by_alias=True, validate_by_name=False)\n\n\n    print(repr(Model(my_alias='foo')))  # (1)!\n    #> Model(my_field='foo')\n    ```\n\n    1. The alias `my_alias` is used for validation.\n\n=== \"`validate_by_name`\"\n\n    ```python\n    from pydantic import BaseModel, ConfigDict, Field\n\n\n    class Model(BaseModel):\n        my_field: str = Field(validation_alias='my_alias')\n\n        model_config = ConfigDict(validate_by_alias=False, validate_by_name=True)\n\n\n    print(repr(Model(my_field='foo')))  # (1)!\n    #> Model(my_field='foo')\n    ```\n\n    1. the attribute identifier `my_field` is used for validation.\n\n=== \"`validate_by_alias` and `validate_by_name`\"\n\n    ```python\n    from pydantic import BaseModel, ConfigDict, Field\n\n\n    class Model(BaseModel):\n        my_field: str = Field(validation_alias='my_alias')\n\n        model_config = ConfigDict(validate_by_alias=True, validate_by_name=True)\n\n\n    print(repr(Model(my_alias='foo')))  # (1)!\n    #> Model(my_field='foo')\n\n    print(repr(Model(my_field='foo')))  # (2)!\n    #> Model(my_field='foo')\n    ```\n\n    1. The alias `my_alias` is used for validation.\n    2. the attribute identifier `my_field` is used for validation.\n\n!!! warning\n    You cannot set both `validate_by_alias` and `validate_by_name` to `False`.\n    A [user error](../errors/usage_errors.md#validate-by-alias-and-name-false) is raised in this case.", "url": "https://docs.pydantic.dev/latest/docs/concepts/alias/#validation", "page": "docs/concepts/alias", "source_site": "pydantic"}
{"title": "Serialization", "anchor": "serialization", "heading_level": 4, "md_text": "When serializing data, you can enable serialization by alias, which is disabled by default.\nSee the [`ConfigDict.serialize_by_alias`][pydantic.config.ConfigDict.serialize_by_alias] API documentation\nfor more details.\n\n```python\nfrom pydantic import BaseModel, ConfigDict, Field\n\n\nclass Model(BaseModel):\n    my_field: str = Field(serialization_alias='my_alias')\n\n    model_config = ConfigDict(serialize_by_alias=True)\n\n\nm = Model(my_field='foo')\nprint(m.model_dump())  # (1)!\n#> {'my_alias': 'foo'}\n```\n\n1. The alias `my_alias` is used for serialization.\n\n!!! note\n    The fact that serialization by alias is disabled by default is notably inconsistent with the default for\n    validation (where aliases are used by default). We anticipate changing this default in V3.", "url": "https://docs.pydantic.dev/latest/docs/concepts/alias/#serialization", "page": "docs/concepts/alias", "source_site": "pydantic"}
{"title": "Runtime Settings", "anchor": "runtime-settings", "heading_level": 3, "md_text": "You can use runtime alias flags to control alias use for validation and serialization\non a per-call basis. If you would like to control this behavior on a model level, use\n[`ConfigDict` settings](#configdict-settings).", "url": "https://docs.pydantic.dev/latest/docs/concepts/alias/#runtime-settings", "page": "docs/concepts/alias", "source_site": "pydantic"}
{"title": "Validation", "anchor": "validation", "heading_level": 4, "md_text": "When validating data, you can enable population of attributes by attribute name, alias, or both.\n\nThe `by_alias` and `by_name` flags are available on the [`model_validate()`][pydantic.main.BaseModel.model_validate],\n[`model_validate_json()`][pydantic.main.BaseModel.model_validate_json], and [`model_validate_strings()`][pydantic.main.BaseModel.model_validate_strings] methods, as well as the [`TypeAdapter`][pydantic.type_adapter.TypeAdapter] validation methods.\n\nBy default:\n\n* `by_alias` is `True`\n* `by_name` is `False`\n\n=== \"`by_alias`\"\n\n    ```python\n    from pydantic import BaseModel, Field\n\n\n    class Model(BaseModel):\n        my_field: str = Field(validation_alias='my_alias')\n\n\n    m = Model.model_validate(\n        {'my_alias': 'foo'},  # (1)!\n        by_alias=True,\n        by_name=False,\n    )\n    print(repr(m))\n    #> Model(my_field='foo')\n    ```\n\n    1. The alias `my_alias` is used for validation.\n\n=== \"`by_name`\"\n\n    ```python\n    from pydantic import BaseModel, Field\n\n\n    class Model(BaseModel):\n        my_field: str = Field(validation_alias='my_alias')\n\n\n    m = Model.model_validate(\n        {'my_field': 'foo'}, by_alias=False, by_name=True  # (1)!\n    )\n    print(repr(m))\n    #> Model(my_field='foo')\n    ```\n\n    1. The attribute name `my_field` is used for validation.\n\n=== \"`validate_by_alias` and `validate_by_name`\"\n\n    ```python\n    from pydantic import BaseModel, Field\n\n\n    class Model(BaseModel):\n        my_field: str = Field(validation_alias='my_alias')\n\n\n    m = Model.model_validate(\n        {'my_alias': 'foo'}, by_alias=True, by_name=True  # (1)!\n    )\n    print(repr(m))\n    #> Model(my_field='foo')\n\n    m = Model.model_validate(\n        {'my_field': 'foo'}, by_alias=True, by_name=True  # (2)!\n    )\n    print(repr(m))\n    #> Model(my_field='foo')\n    ```\n\n    1. The alias `my_alias` is used for validation.\n    2. The attribute name `my_field` is used for validation.\n\n!!! warning\n    You cannot set both `by_alias` and `by_name` to `False`.\n    A [user error](../errors/usage_errors.md#validate-by-alias-and-name-false) is raised in this case.", "url": "https://docs.pydantic.dev/latest/docs/concepts/alias/#validation", "page": "docs/concepts/alias", "source_site": "pydantic"}
{"title": "Serialization", "anchor": "serialization", "heading_level": 4, "md_text": "When serializing data, you can enable serialization by alias via the `by_alias` flag\nwhich is available on the [`model_dump()`][pydantic.main.BaseModel.model_dump] and\n[`model_dump_json()`][pydantic.main.BaseModel.model_dump_json] methods, as well as\nthe [`TypeAdapter`][pydantic.type_adapter.TypeAdapter] ones.\n\nBy default, `by_alias` is `False`.\n\n```py\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    my_field: str = Field(serialization_alias='my_alias')\n\n\nm = Model(my_field='foo')\nprint(m.model_dump(by_alias=True))  # (1)!\n#> {'my_alias': 'foo'}\n```\n\n1. The alias `my_alias` is used for serialization.\n\n!!! note\n    The fact that serialization by alias is disabled by default is notably inconsistent with the default for\n    validation (where aliases are used by default). We anticipate changing this default in V3.", "url": "https://docs.pydantic.dev/latest/docs/concepts/alias/#serialization", "page": "docs/concepts/alias", "source_site": "pydantic"}
{"title": "forward_annotations", "anchor": null, "heading_level": 0, "md_text": "Forward annotations (wrapped in quotes) or using the `from __future__ import annotations` [future statement]\n(as introduced in [PEP563](https://www.python.org/dev/peps/pep-0563/)) are supported:\n\n```python\nfrom __future__ import annotations\n\nfrom pydantic import BaseModel\n\nMyInt = int\n\n\nclass Model(BaseModel):\n    a: MyInt\n    # Without the future import, equivalent to:\n    # a: 'MyInt'\n\n\nprint(Model(a='1'))\n#> a=1\n```\n\nAs shown in the following sections, forward annotations are useful when you want to reference\na type that is not yet defined in your code.\n\nThe internal logic to resolve forward annotations is described in detail in [this section](../internals/resolving_annotations.md).", "url": "https://docs.pydantic.dev/latest/docs/concepts/forward_annotations/", "page": "docs/concepts/forward_annotations", "source_site": "pydantic"}
{"title": "Self-referencing (or \"Recursive\") Models", "anchor": "self-referencing-or-recursive-models", "heading_level": 2, "md_text": "Models with self-referencing fields are also supported. These annotations will be resolved during model creation.\n\nWithin the model, you can either add the `from __future__ import annotations` import or wrap the annotation\nin a string:\n\n```python\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    a: int = 123\n    sibling: 'Optional[Foo]' = None\n\n\nprint(Foo())\n#> a=123 sibling=None\nprint(Foo(sibling={'a': '321'}))\n#> a=123 sibling=Foo(a=321, sibling=None)\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/forward_annotations/#self-referencing-or-recursive-models", "page": "docs/concepts/forward_annotations", "source_site": "pydantic"}
{"title": "Cyclic references", "anchor": "cyclic-references", "heading_level": 3, "md_text": "When working with self-referencing recursive models, it is possible that you might encounter cyclic references\nin validation inputs. For example, this can happen when validating ORM instances with back-references from\nattributes.\n\nRather than raising a [`RecursionError`][] while attempting to validate data with cyclic references, Pydantic is able\nto detect the cyclic reference and raise an appropriate [`ValidationError`][pydantic_core.ValidationError]:\n\n```python\nfrom typing import Optional\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass ModelA(BaseModel):\n    b: 'Optional[ModelB]' = None\n\n\nclass ModelB(BaseModel):\n    a: Optional[ModelA] = None\n\n\ncyclic_data = {}\ncyclic_data['a'] = {'b': cyclic_data}\nprint(cyclic_data)\n#> {'a': {'b': {...}}}\n\ntry:\n    ModelB.model_validate(cyclic_data)\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for ModelB\n    a.b\n      Recursion error - cyclic reference detected [type=recursion_loop, input_value={'a': {'b': {...}}}, input_type=dict]\n    \"\"\"\n```\n\nBecause this error is raised without actually exceeding the maximum recursion depth, you can catch and\nhandle the raised [`ValidationError`][pydantic_core.ValidationError] without needing to worry about the limited\nremaining recursion depth:\n\n```python\nfrom __future__ import annotations\n\nfrom collections.abc import Generator\nfrom contextlib import contextmanager\nfrom dataclasses import field\n\nfrom pydantic import BaseModel, ValidationError, field_validator\n\n\ndef is_recursion_validation_error(exc: ValidationError) -> bool:\n    errors = exc.errors()\n    return len(errors) == 1 and errors[0]['type'] == 'recursion_loop'\n\n\n@contextmanager\ndef suppress_recursion_validation_error() -> Generator[None]:\n    try:\n        yield\n    except ValidationError as exc:\n        if not is_recursion_validation_error(exc):\n            raise exc\n\n\nclass Node(BaseModel):\n    id: int\n    children: list[Node] = field(default_factory=list)\n\n    @field_validator('children', mode='wrap')\n    @classmethod\n    def drop_cyclic_references(cls, children, h):\n        try:\n            return h(children)\n        except ValidationError as exc:\n            if not (\n                is_recursion_validation_error(exc)\n                and isinstance(children, list)\n            ):\n                raise exc\n\n            value_without_cyclic_refs = []\n            for child in children:\n                with suppress_recursion_validation_error():\n                    value_without_cyclic_refs.extend(h([child]))\n            return h(value_without_cyclic_refs)", "url": "https://docs.pydantic.dev/latest/docs/concepts/forward_annotations/#cyclic-references", "page": "docs/concepts/forward_annotations", "source_site": "pydantic"}
{"title": "Create data with cyclic references representing the graph 1 -> 2 -> 3 -> 1", "anchor": "create-data-with-cyclic-references-representing-the-graph-1-2-3-1", "heading_level": 1, "md_text": "node_data = {'id': 1, 'children': [{'id': 2, 'children': [{'id': 3}]}]}\nnode_data['children'][0]['children'][0]['children'] = [node_data]\n\nprint(Node.model_validate(node_data))\n#> id=1 children=[Node(id=2, children=[Node(id=3, children=[])])]\n```\n\nSimilarly, if Pydantic encounters a recursive reference during *serialization*, rather than waiting\nfor the maximum recursion depth to be exceeded, a [`ValueError`][] is raised immediately:\n\n```python\nfrom pydantic import TypeAdapter", "url": "https://docs.pydantic.dev/latest/docs/concepts/forward_annotations/#create-data-with-cyclic-references-representing-the-graph-1-2-3-1", "page": "docs/concepts/forward_annotations", "source_site": "pydantic"}
{"title": "Create data with cyclic references representing the graph 1 -> 2 -> 3 -> 1", "anchor": "create-data-with-cyclic-references-representing-the-graph-1-2-3-1", "heading_level": 1, "md_text": "node_data = {'id': 1, 'children': [{'id': 2, 'children': [{'id': 3}]}]}\nnode_data['children'][0]['children'][0]['children'] = [node_data]\n\ntry:\n    # Try serializing the circular reference as JSON\n    TypeAdapter(dict).dump_json(node_data)\nexcept ValueError as exc:\n    print(exc)\n    \"\"\"\n    Error serializing to JSON: ValueError: Circular reference detected (id repeated)\n    \"\"\"\n```\n\nThis can also be handled if desired:\n\n```python\nfrom dataclasses import field\nfrom typing import Any\n\nfrom pydantic import (\n    SerializerFunctionWrapHandler,\n    TypeAdapter,\n    field_serializer,\n)\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass NodeReference:\n    id: int\n\n\n@dataclass\nclass Node(NodeReference):\n    children: list['Node'] = field(default_factory=list)\n\n    @field_serializer('children', mode='wrap')\n    def serialize(\n        self, children: list['Node'], handler: SerializerFunctionWrapHandler\n    ) -> Any:\n        \"\"\"\n        Serialize a list of nodes, handling circular references by excluding the children.\n        \"\"\"\n        try:\n            return handler(children)\n        except ValueError as exc:\n            if not str(exc).startswith('Circular reference'):\n                raise exc\n\n            result = []\n            for node in children:\n                try:\n                    serialized = handler([node])\n                except ValueError as exc:\n                    if not str(exc).startswith('Circular reference'):\n                        raise exc\n                    result.append({'id': node.id})\n                else:\n                    result.append(serialized)\n            return result", "url": "https://docs.pydantic.dev/latest/docs/concepts/forward_annotations/#create-data-with-cyclic-references-representing-the-graph-1-2-3-1", "page": "docs/concepts/forward_annotations", "source_site": "pydantic"}
{"title": "Create a cyclic graph:", "anchor": "create-a-cyclic-graph", "heading_level": 1, "md_text": "nodes = [Node(id=1), Node(id=2), Node(id=3)]\nnodes[0].children.append(nodes[1])\nnodes[1].children.append(nodes[2])\nnodes[2].children.append(nodes[0])\n\nprint(nodes[0])\n#> Node(id=1, children=[Node(id=2, children=[Node(id=3, children=[...])])])", "url": "https://docs.pydantic.dev/latest/docs/concepts/forward_annotations/#create-a-cyclic-graph", "page": "docs/concepts/forward_annotations", "source_site": "pydantic"}
{"title": "Serialize the cyclic graph:", "anchor": "serialize-the-cyclic-graph", "heading_level": 1, "md_text": "print(TypeAdapter(Node).dump_python(nodes[0]))\n\"\"\"\n{\n    'id': 1,\n    'children': [{'id': 2, 'children': [{'id': 3, 'children': [{'id': 1}]}]}],\n}\n\"\"\"\n```\n\n[future statement]: https://docs.python.org/3/reference/simple_stmts.html#future", "url": "https://docs.pydantic.dev/latest/docs/concepts/forward_annotations/#serialize-the-cyclic-graph", "page": "docs/concepts/forward_annotations", "source_site": "pydantic"}
{"title": "Performance tips", "anchor": "performance-tips", "heading_level": 1, "md_text": "In most cases Pydantic won't be your bottle neck, only follow this if you're sure it's necessary.", "url": "https://docs.pydantic.dev/latest/docs/concepts/performance/#performance-tips", "page": "docs/concepts/performance", "source_site": "pydantic"}
{"title": "In general, use `model_validate_json()` not `model_validate(json.loads(...))`", "anchor": "in-general-use-model_validate_json-not-model_validatejsonloads", "heading_level": 2, "md_text": "On `model_validate(json.loads(...))`, the JSON is parsed in Python, then converted to a dict, then it's validated internally.\nOn the other hand, `model_validate_json()` already performs the validation internally.\n\nThere are a few cases where `model_validate(json.loads(...))` may be faster. Specifically, when using a `'before'` or `'wrap'` validator\non a model, validation may be faster with the two step method. You can read more about these special cases in\n[this discussion](https://github.com/pydantic/pydantic/discussions/6388#discussioncomment-8193105).\n\nMany performance improvements are currently in the works for `pydantic-core`, see\n[this discussion](https://github.com/pydantic/pydantic/discussions/6388#discussioncomment-8194048).\nOnce these changes are merged, we should be at the point where `model_validate_json()` is always faster than `model_validate(json.loads(...))`.", "url": "https://docs.pydantic.dev/latest/docs/concepts/performance/#in-general-use-model_validate_json-not-model_validatejsonloads", "page": "docs/concepts/performance", "source_site": "pydantic"}
{"title": "`TypeAdapter` instantiated once", "anchor": "typeadapter-instantiated-once", "heading_level": 2, "md_text": "The idea here is to avoid constructing validators and serializers more than necessary. Each time a `TypeAdapter` is instantiated,\nit will construct a new validator and serializer. If you're using a `TypeAdapter` in a function, it will be instantiated each time\nthe function is called. Instead, instantiate it once, and reuse it.\n\n=== \":x: Bad\"\n\n    ```python {lint=\"skip\"}\n    from pydantic import TypeAdapter\n\n\n    def my_func():\n        adapter = TypeAdapter(list[int])\n        # do something with adapter\n    ```\n\n=== \":white_check_mark: Good\"\n\n    ```python {lint=\"skip\"}\n    from pydantic import TypeAdapter\n\n    adapter = TypeAdapter(list[int])\n\n    def my_func():\n        ...\n        # do something with adapter\n    ```", "url": "https://docs.pydantic.dev/latest/docs/concepts/performance/#typeadapter-instantiated-once", "page": "docs/concepts/performance", "source_site": "pydantic"}
{"title": "`Sequence` vs `list` or `tuple` with `Mapping` vs `dict`", "anchor": "sequence-vs-list-or-tuple-with-mapping-vs-dict", "heading_level": 2, "md_text": "When using `Sequence`, Pydantic calls `isinstance(value, Sequence)` to check if the value is a sequence.\nAlso, Pydantic will try to validate against different types of sequences, like `list` and `tuple`.\nIf you know the value is a `list` or `tuple`, use `list` or `tuple` instead of `Sequence`.\n\nThe same applies to `Mapping` and `dict`.\nIf you know the value is a `dict`, use `dict` instead of `Mapping`.", "url": "https://docs.pydantic.dev/latest/docs/concepts/performance/#sequence-vs-list-or-tuple-with-mapping-vs-dict", "page": "docs/concepts/performance", "source_site": "pydantic"}
{"title": "Don't do validation when you don't have to, use `Any` to keep the value unchanged", "anchor": "dont-do-validation-when-you-dont-have-to-use-any-to-keep-the-value-unchanged", "heading_level": 2, "md_text": "If you don't need to validate a value, use `Any` to keep the value unchanged.\n\n```python\nfrom typing import Any\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    a: Any\n\n\nmodel = Model(a=1)\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/performance/#dont-do-validation-when-you-dont-have-to-use-any-to-keep-the-value-unchanged", "page": "docs/concepts/performance", "source_site": "pydantic"}
{"title": "Avoid extra information via subclasses of primitives", "anchor": "avoid-extra-information-via-subclasses-of-primitives", "heading_level": 2, "md_text": "=== \"Don't do this\"\n\n    ```python\n    class CompletedStr(str):\n        def __init__(self, s: str):\n            self.s = s\n            self.done = False\n    ```\n\n=== \"Do this\"\n\n    ```python\n    from pydantic import BaseModel\n\n\n    class CompletedModel(BaseModel):\n        s: str\n        done: bool = False\n    ```", "url": "https://docs.pydantic.dev/latest/docs/concepts/performance/#avoid-extra-information-via-subclasses-of-primitives", "page": "docs/concepts/performance", "source_site": "pydantic"}
{"title": "Use tagged union, not union", "anchor": "use-tagged-union-not-union", "heading_level": 2, "md_text": "Tagged union (or discriminated union) is a union with a field that indicates which type it is.\n\n```python {test=\"skip\"}\nfrom typing import Any, Literal\n\nfrom pydantic import BaseModel, Field\n\n\nclass DivModel(BaseModel):\n    el_type: Literal['div'] = 'div'\n    class_name: str | None = None\n    children: list[Any] | None = None\n\n\nclass SpanModel(BaseModel):\n    el_type: Literal['span'] = 'span'\n    class_name: str | None = None\n    contents: str | None = None\n\n\nclass ButtonModel(BaseModel):\n    el_type: Literal['button'] = 'button'\n    class_name: str | None = None\n    contents: str | None = None\n\n\nclass InputModel(BaseModel):\n    el_type: Literal['input'] = 'input'\n    class_name: str | None = None\n    value: str | None = None\n\n\nclass Html(BaseModel):\n    contents: DivModel | SpanModel | ButtonModel | InputModel = Field(\n        discriminator='el_type'\n    )\n```\n\nSee [Discriminated Unions] for more details.", "url": "https://docs.pydantic.dev/latest/docs/concepts/performance/#use-tagged-union-not-union", "page": "docs/concepts/performance", "source_site": "pydantic"}
{"title": "Use `TypedDict` over nested models", "anchor": "use-typeddict-over-nested-models", "heading_level": 2, "md_text": "Instead of using nested models, use `TypedDict` to define the structure of the data.\n\n??? info \"Performance comparison\"\n    With a simple benchmark, `TypedDict` is about ~2.5x faster than nested models:\n\n    ```python {test=\"skip\"}\n    from timeit import timeit\n\n    from typing_extensions import TypedDict\n\n    from pydantic import BaseModel, TypeAdapter\n\n\n    class A(TypedDict):\n        a: str\n        b: int\n\n\n    class TypedModel(TypedDict):\n        a: A\n\n\n    class B(BaseModel):\n        a: str\n        b: int\n\n\n    class Model(BaseModel):\n        b: B\n\n\n    ta = TypeAdapter(TypedModel)\n    result1 = timeit(\n        lambda: ta.validate_python({'a': {'a': 'a', 'b': 2}}), number=10000\n    )\n    result2 = timeit(\n        lambda: Model.model_validate({'b': {'a': 'a', 'b': 2}}), number=10000\n    )\n    print(result2 / result1)\n    ```", "url": "https://docs.pydantic.dev/latest/docs/concepts/performance/#use-typeddict-over-nested-models", "page": "docs/concepts/performance", "source_site": "pydantic"}
{"title": "Avoid wrap validators if you really care about performance", "anchor": "avoid-wrap-validators-if-you-really-care-about-performance", "heading_level": 2, "md_text": "Wrap validators are generally slower than other validators. This is because they require\nthat data is materialized in Python during validation. Wrap validators can be incredibly useful\nfor complex validation logic, but if you're looking for the best performance, you should avoid them.", "url": "https://docs.pydantic.dev/latest/docs/concepts/performance/#avoid-wrap-validators-if-you-really-care-about-performance", "page": "docs/concepts/performance", "source_site": "pydantic"}
{"title": "Failing early with `FailFast`", "anchor": "failing-early-with-failfast", "heading_level": 2, "md_text": "Starting in v2.8+, you can apply the `FailFast` annotation to sequence types to fail early if any item in the sequence fails validation.\nIf you use this annotation, you won't get validation errors for the rest of the items in the sequence if one fails, so you're effectively\ntrading off visibility for performance.\n\n```python\nfrom typing import Annotated\n\nfrom pydantic import FailFast, TypeAdapter, ValidationError\n\nta = TypeAdapter(Annotated[list[bool], FailFast()])\ntry:\n    ta.validate_python([True, 'invalid', False, 'also invalid'])\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for list[bool]\n    1\n      Input should be a valid boolean, unable to interpret input [type=bool_parsing, input_value='invalid', input_type=str]\n    \"\"\"\n```\n\nRead more about `FailFast` [here][pydantic.types.FailFast].\n\n[Discriminated Unions]: ../concepts/unions.md#discriminated-unions", "url": "https://docs.pydantic.dev/latest/docs/concepts/performance/#failing-early-with-failfast", "page": "docs/concepts/performance", "source_site": "pydantic"}
{"title": "dataclasses", "anchor": null, "heading_level": 0, "md_text": "??? api \"API Documentation\"\n    [`@pydantic.dataclasses.dataclass`][pydantic.dataclasses.dataclass]<br>\n\nIf you don't want to use Pydantic's [`BaseModel`][pydantic.BaseModel] you can instead get the same data validation\non standard [dataclasses][dataclasses].\n\n```python\nfrom datetime import datetime\nfrom typing import Optional\n\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass User:\n    id: int\n    name: str = 'John Doe'\n    signup_ts: Optional[datetime] = None\n\n\nuser = User(id='42', signup_ts='2032-06-21T12:00')\nprint(user)\n\"\"\"\nUser(id=42, name='John Doe', signup_ts=datetime.datetime(2032, 6, 21, 12, 0))\n\"\"\"\n```\n\n!!! note\n    Keep in mind that Pydantic dataclasses are **not** a replacement for [Pydantic models](../concepts/models.md).\n    They provide a similar functionality to stdlib dataclasses with the addition of Pydantic validation.\n\n    There are cases where subclassing using Pydantic models is the better choice.\n\n    For more information and discussion see\n    [pydantic/pydantic#710](https://github.com/pydantic/pydantic/issues/710).\n\nSimilarities between Pydantic dataclasses and models include support for:\n\n* [Configuration](#dataclass-config) support\n* [Nested](./models.md#nested-models) classes\n* [Generics](./models.md#generic-models)\n\nSome differences between Pydantic dataclasses and models include:\n\n* [validators](#validators-and-initialization-hooks)\n* The behavior with the [`extra`][pydantic.ConfigDict.extra] configuration value\n\nSimilarly to Pydantic models, arguments used to instantiate the dataclass are [copied](./models.md#attribute-copies).\n\nTo make use of the [various methods](./models.md#model-methods-and-properties) to validate, dump and generate a JSON Schema,\nyou can wrap the dataclass with a [`TypeAdapter`][pydantic.type_adapter.TypeAdapter] and make use of its methods.\n\nYou can use both the Pydantic's [`Field()`][pydantic.Field] and the stdlib's [`field()`][dataclasses.field] functions:\n\n```python\nimport dataclasses\nfrom typing import Optional\n\nfrom pydantic import Field\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass User:\n    id: int\n    name: str = 'John Doe'\n    friends: list[int] = dataclasses.field(default_factory=lambda: [0])\n    age: Optional[int] = dataclasses.field(\n        default=None,\n        metadata={'title': 'The age of the user', 'description': 'do not lie!'},\n    )\n    height: Optional[int] = Field(\n        default=None, title='The height in cm', ge=50, le=300\n    )\n\n\nuser = User(id='42', height='250')\nprint(user)\n#> User(id=42, name='John Doe', friends=[0], age=None, height=250)\n```\n\nThe Pydantic [`@dataclass`][pydantic.dataclasses.dataclass] decorator accepts the same arguments as the standard decorator,\nwith the addition of a `config` parameter.", "url": "https://docs.pydantic.dev/latest/docs/concepts/dataclasses/", "page": "docs/concepts/dataclasses", "source_site": "pydantic"}
{"title": "Dataclass config", "anchor": "dataclass-config", "heading_level": 2, "md_text": "If you want to modify the configuration like you would with a [`BaseModel`][pydantic.BaseModel], you have two options:\n\n* Use the `config` argument of the decorator.\n* Define the configuration with the `__pydantic_config__` attribute.\n\n```python\nfrom pydantic import ConfigDict\nfrom pydantic.dataclasses import dataclass", "url": "https://docs.pydantic.dev/latest/docs/concepts/dataclasses/#dataclass-config", "page": "docs/concepts/dataclasses", "source_site": "pydantic"}
{"title": "Option 1 -- using the decorator argument:", "anchor": "option-1-using-the-decorator-argument", "heading_level": 1, "md_text": "@dataclass(config=ConfigDict(validate_assignment=True))  # (1)!\nclass MyDataclass1:\n    a: int", "url": "https://docs.pydantic.dev/latest/docs/concepts/dataclasses/#option-1-using-the-decorator-argument", "page": "docs/concepts/dataclasses", "source_site": "pydantic"}
{"title": "Option 2 -- using an attribute:", "anchor": "option-2-using-an-attribute", "heading_level": 1, "md_text": "@dataclass\nclass MyDataclass2:\n    a: int\n\n    __pydantic_config__ = ConfigDict(validate_assignment=True)\n```\n\n1. You can read more about `validate_assignment` in the [API reference][pydantic.config.ConfigDict.validate_assignment].\n\n!!! note\n    While Pydantic dataclasses support the [`extra`][pydantic.config.ConfigDict.extra] configuration value, some default\n    behavior of stdlib dataclasses may prevail. For example, any extra fields present on a Pydantic dataclass with\n    [`extra`][pydantic.config.ConfigDict.extra] set to `'allow'` are omitted in the dataclass' string representation.\n    There is also no way to provide validation [using the `__pydantic_extra__` attribute](./models.md#extra-data).", "url": "https://docs.pydantic.dev/latest/docs/concepts/dataclasses/#option-2-using-an-attribute", "page": "docs/concepts/dataclasses", "source_site": "pydantic"}
{"title": "Rebuilding dataclass schema", "anchor": "rebuilding-dataclass-schema", "heading_level": 2, "md_text": "The [`rebuild_dataclass()`][pydantic.dataclasses.rebuild_dataclass] function can be used to rebuild the core schema of the dataclass.\nSee the [rebuilding model schema](./models.md#rebuilding-model-schema) section for more details.", "url": "https://docs.pydantic.dev/latest/docs/concepts/dataclasses/#rebuilding-dataclass-schema", "page": "docs/concepts/dataclasses", "source_site": "pydantic"}
{"title": "Inherit from stdlib dataclasses", "anchor": "inherit-from-stdlib-dataclasses", "heading_level": 3, "md_text": "Stdlib dataclasses (nested or not) can also be inherited and Pydantic will automatically validate\nall the inherited fields.\n\n```python\nimport dataclasses\n\nimport pydantic\n\n\n@dataclasses.dataclass\nclass Z:\n    z: int\n\n\n@dataclasses.dataclass\nclass Y(Z):\n    y: int = 0\n\n\n@pydantic.dataclasses.dataclass\nclass X(Y):\n    x: int = 0\n\n\nfoo = X(x=b'1', y='2', z='3')\nprint(foo)\n#> X(z=3, y=2, x=1)\n\ntry:\n    X(z='pika')\nexcept pydantic.ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for X\n    z\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='pika', input_type=str]\n    \"\"\"\n```\n\nThe decorator can also be applied directly on a stdlib dataclass, in which case a new subclass will be created:\n\n```python\nimport dataclasses\n\nimport pydantic\n\n\n@dataclasses.dataclass\nclass A:\n    a: int\n\n\nPydanticA = pydantic.dataclasses.dataclass(A)\nprint(PydanticA(a='1'))\n#> A(a=1)\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/dataclasses/#inherit-from-stdlib-dataclasses", "page": "docs/concepts/dataclasses", "source_site": "pydantic"}
{"title": "Usage of stdlib dataclasses with `BaseModel`", "anchor": "usage-of-stdlib-dataclasses-with-basemodel", "heading_level": 3, "md_text": "When a standard library dataclass is used within a Pydantic model, a Pydantic dataclass or a [`TypeAdapter`][pydantic.TypeAdapter],\nvalidation will be applied (and the [configuration](#dataclass-config) stays the same). This means that using a stdlib or a Pydantic\ndataclass as a field annotation is functionally equivalent.\n\n```python\nimport dataclasses\nfrom typing import Optional\n\nfrom pydantic import BaseModel, ConfigDict, ValidationError\n\n\n@dataclasses.dataclass(frozen=True)\nclass User:\n    name: str\n\n\nclass Foo(BaseModel):\n    # Required so that pydantic revalidates the model attributes:\n    model_config = ConfigDict(revalidate_instances='always')\n\n    user: Optional[User] = None", "url": "https://docs.pydantic.dev/latest/docs/concepts/dataclasses/#usage-of-stdlib-dataclasses-with-basemodel", "page": "docs/concepts/dataclasses", "source_site": "pydantic"}
{"title": "nothing is validated as expected:", "anchor": "nothing-is-validated-as-expected", "heading_level": 1, "md_text": "user = User(name=['not', 'a', 'string'])\nprint(user)\n#> User(name=['not', 'a', 'string'])\n\n\ntry:\n    Foo(user=user)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Foo\n    user.name\n      Input should be a valid string [type=string_type, input_value=['not', 'a', 'string'], input_type=list]\n    \"\"\"\n\nfoo = Foo(user=User(name='pika'))\ntry:\n    foo.user.name = 'bulbi'\nexcept dataclasses.FrozenInstanceError as e:\n    print(e)\n    #> cannot assign to field 'name'\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/dataclasses/#nothing-is-validated-as-expected", "page": "docs/concepts/dataclasses", "source_site": "pydantic"}
{"title": "Using custom types", "anchor": "using-custom-types", "heading_level": 3, "md_text": "As said above, validation is applied on standard library dataclasses. If you make use\nof custom types, you will get an error when trying to refer to the dataclass. To circumvent\nthe issue, you can set the [`arbitrary_types_allowed`][pydantic.ConfigDict.arbitrary_types_allowed]\nconfiguration value on the dataclass:\n\n```python\nimport dataclasses\n\nfrom pydantic import BaseModel, ConfigDict\nfrom pydantic.errors import PydanticSchemaGenerationError\n\n\nclass ArbitraryType:\n    def __init__(self, value):\n        self.value = value\n\n    def __repr__(self):\n        return f'ArbitraryType(value={self.value!r})'\n\n\n@dataclasses.dataclass\nclass DC:\n    a: ArbitraryType\n    b: str", "url": "https://docs.pydantic.dev/latest/docs/concepts/dataclasses/#using-custom-types", "page": "docs/concepts/dataclasses", "source_site": "pydantic"}
{"title": "valid as it is a stdlib dataclass without validation:", "anchor": "valid-as-it-is-a-stdlib-dataclass-without-validation", "heading_level": 1, "md_text": "my_dc = DC(a=ArbitraryType(value=3), b='qwe')\n\ntry:\n\n    class Model(BaseModel):\n        dc: DC\n        other: str\n\n    # invalid as dc is now validated with pydantic, and ArbitraryType is not a known type\n    Model(dc=my_dc, other='other')\n\nexcept PydanticSchemaGenerationError as e:\n    print(e.message)\n    \"\"\"\n    Unable to generate pydantic-core schema for <class '__main__.ArbitraryType'>. Set `arbitrary_types_allowed=True` in the model_config to ignore this error or implement `__get_pydantic_core_schema__` on your type to fully support it.\n\n    If you got this error by calling handler(<some type>) within `__get_pydantic_core_schema__` then you likely need to call `handler.generate_schema(<some type>)` since we do not call `__get_pydantic_core_schema__` on `<some type>` otherwise to avoid infinite recursion.\n    \"\"\"", "url": "https://docs.pydantic.dev/latest/docs/concepts/dataclasses/#valid-as-it-is-a-stdlib-dataclass-without-validation", "page": "docs/concepts/dataclasses", "source_site": "pydantic"}
{"title": "valid as we set arbitrary_types_allowed=True, and that config pushes down to the nested vanilla dataclass", "anchor": "valid-as-we-set-arbitrary_types_allowedtrue-and-that-config-pushes-down-to-the-nested-vanilla-dataclass", "heading_level": 1, "md_text": "class Model(BaseModel):\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n    dc: DC\n    other: str\n\n\nm = Model(dc=my_dc, other='other')\nprint(repr(m))\n#> Model(dc=DC(a=ArbitraryType(value=3), b='qwe'), other='other')\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/dataclasses/#valid-as-we-set-arbitrary_types_allowedtrue-and-that-config-pushes-down-to-the-nested-vanilla-dataclass", "page": "docs/concepts/dataclasses", "source_site": "pydantic"}
{"title": "Checking if a dataclass is a Pydantic dataclass", "anchor": "checking-if-a-dataclass-is-a-pydantic-dataclass", "heading_level": 3, "md_text": "Pydantic dataclasses are still considered dataclasses, so using [`dataclasses.is_dataclass()`][dataclasses.is_dataclass]\nwill return `True`. To check if a type is specifically a Pydantic dataclass you can use the\n[`is_pydantic_dataclass()`][pydantic.dataclasses.is_pydantic_dataclass] function.\n\n```python\nimport dataclasses\n\nimport pydantic\n\n\n@dataclasses.dataclass\nclass StdLibDataclass:\n    id: int\n\n\nPydanticDataclass = pydantic.dataclasses.dataclass(StdLibDataclass)\n\nprint(dataclasses.is_dataclass(StdLibDataclass))\n#> True\nprint(pydantic.dataclasses.is_pydantic_dataclass(StdLibDataclass))\n#> False\n\nprint(dataclasses.is_dataclass(PydanticDataclass))\n#> True\nprint(pydantic.dataclasses.is_pydantic_dataclass(PydanticDataclass))\n#> True\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/dataclasses/#checking-if-a-dataclass-is-a-pydantic-dataclass", "page": "docs/concepts/dataclasses", "source_site": "pydantic"}
{"title": "Validators and initialization hooks", "anchor": "validators-and-initialization-hooks", "heading_level": 2, "md_text": "Validators also work with Pydantic dataclasses:\n\n```python\nfrom pydantic import field_validator\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass DemoDataclass:\n    product_id: str  # should be a five-digit string, may have leading zeros\n\n    @field_validator('product_id', mode='before')\n    @classmethod\n    def convert_int_serial(cls, v):\n        if isinstance(v, int):\n            v = str(v).zfill(5)\n        return v\n\n\nprint(DemoDataclass(product_id='01234'))\n#> DemoDataclass(product_id='01234')\nprint(DemoDataclass(product_id=2468))\n#> DemoDataclass(product_id='02468')\n```\n\n<!-- markdownlint-disable-next-line strong-style -->\nThe dataclass [`__post_init__()`][dataclasses.__post_init__] method is also supported, and will\nbe called between the calls to *before* and *after* model validators.\n\n??? example\n\n    ```python\n    from pydantic_core import ArgsKwargs\n    from typing_extensions import Self\n\n    from pydantic import model_validator\n    from pydantic.dataclasses import dataclass\n\n\n    @dataclass\n    class Birth:\n        year: int\n        month: int\n        day: int\n\n\n    @dataclass\n    class User:\n        birth: Birth\n\n        @model_validator(mode='before')\n        @classmethod\n        def before(cls, values: ArgsKwargs) -> ArgsKwargs:\n            print(f'First: {values}')  # (1)!\n            \"\"\"\n            First: ArgsKwargs((), {'birth': {'year': 1995, 'month': 3, 'day': 2}})\n            \"\"\"\n            return values\n\n        @model_validator(mode='after')\n        def after(self) -> Self:\n            print(f'Third: {self}')\n            #> Third: User(birth=Birth(year=1995, month=3, day=2))\n            return self\n\n        def __post_init__(self):\n            print(f'Second: {self.birth}')\n            #> Second: Birth(year=1995, month=3, day=2)\n\n\n    user = User(**{'birth': {'year': 1995, 'month': 3, 'day': 2}})\n    ```\n\n    1. Unlike Pydantic models, the `values` parameter is of type [`ArgsKwargs`][pydantic_core.ArgsKwargs]", "url": "https://docs.pydantic.dev/latest/docs/concepts/dataclasses/#validators-and-initialization-hooks", "page": "docs/concepts/dataclasses", "source_site": "pydantic"}
{"title": "Experimental Features", "anchor": "experimental-features", "heading_level": 1, "md_text": "In this section you will find documentation for new, experimental features in Pydantic. These features are subject to change or removal, and we are looking for feedback and suggestions before making them a permanent part of Pydantic.\n\nSee our [Version Policy](../version-policy.md#experimental-features) for more information on experimental features.", "url": "https://docs.pydantic.dev/latest/docs/concepts/experimental/#experimental-features", "page": "docs/concepts/experimental", "source_site": "pydantic"}
{"title": "Feedback", "anchor": "feedback", "heading_level": 2, "md_text": "We welcome feedback on experimental features! Please open an issue on the [Pydantic GitHub repository](https://github.com/pydantic/pydantic/issues/new/choose) to share your thoughts, requests, or suggestions.\n\nWe also encourage you to read through existing feedback and add your thoughts to existing issues.", "url": "https://docs.pydantic.dev/latest/docs/concepts/experimental/#feedback", "page": "docs/concepts/experimental", "source_site": "pydantic"}
{"title": "Pipeline API", "anchor": "pipeline-api", "heading_level": 2, "md_text": "Pydantic v2.8.0 introduced an experimental \"pipeline\" API that allows composing of parsing (validation), constraints and transformations in a more type-safe manner than existing APIs. This API is subject to change or removal, we are looking for feedback and suggestions before making it a permanent part of Pydantic.\n\n??? api \"API Documentation\"\n    [`pydantic.experimental.pipeline`][pydantic.experimental.pipeline]<br>\n\nGenerally, the pipeline API is used to define a sequence of steps to apply to incoming data during validation. The pipeline API is designed to be more type-safe and composable than the existing Pydantic API.\n\nEach step in the pipeline can be:\n\n* A validation step that runs pydantic validation on the provided type\n* A transformation step that modifies the data\n* A constraint step that checks the data against a condition\n* A predicate step that checks the data against a condition and raises an error if it returns `False`\n\n<!-- TODO: add more documentation once we solidify the API during the experimental phase -->\n\nNote that the following example attempts to be exhaustive at the cost of complexity: if you find yourself writing this many transformations in type annotations you may want to consider having a `UserIn` and `UserOut` model (example below) or similar where you make the transformations via idiomatic plain Python code.\nThese APIs are meant for situations where the code savings are significant and the added complexity is relatively small.\n\n```python\nfrom __future__ import annotations\n\nfrom datetime import datetime\nfrom typing import Annotated\n\nfrom pydantic import BaseModel\nfrom pydantic.experimental.pipeline import validate_as\n\n\nclass User(BaseModel):\n    name: Annotated[str, validate_as(str).str_lower()]  # (1)!\n    age: Annotated[int, validate_as(int).gt(0)]  # (2)!\n    username: Annotated[str, validate_as(str).str_pattern(r'[a-z]+')]  # (3)!\n    password: Annotated[\n        str,\n        validate_as(str)\n        .transform(str.lower)\n        .predicate(lambda x: x != 'password'),  # (4)!\n    ]\n    favorite_number: Annotated[  # (5)!\n        int,\n        (validate_as(int) | validate_as(str).str_strip().validate_as(int)).gt(\n            0\n        ),\n    ]\n    friends: Annotated[list[User], validate_as(...).len(0, 100)]  # (6)!\n    bio: Annotated[\n        datetime,\n        validate_as(int)\n        .transform(lambda x: x / 1_000_000)\n        .validate_as(...),  # (8)!\n    ]\n```\n\n1. Lowercase a string.\n2. Constrain an integer to be greater than zero.\n3. Constrain a string to match a regex pattern.\n4. You can also use the lower level transform, constrain and predicate methods.\n5. Use the `|` or `&` operators to combine steps (like a logical OR or AND).\n6. Calling `validate_as(...)` with `Ellipsis`, `...` as the first positional argument implies `validate_as(<field type>)`. Use `validate_as(Any)` to accept any type.\n7. You can call `validate_as()` before or after other steps to do pre or post processing.", "url": "https://docs.pydantic.dev/latest/docs/concepts/experimental/#pipeline-api", "page": "docs/concepts/experimental", "source_site": "pydantic"}
{"title": "Mapping from `BeforeValidator`, `AfterValidator` and `WrapValidator`", "anchor": "mapping-from-beforevalidator-aftervalidator-and-wrapvalidator", "heading_level": 3, "md_text": "The `validate_as` method is a more type-safe way to define `BeforeValidator`, `AfterValidator` and `WrapValidator`:\n\n```python\nfrom typing import Annotated\n\nfrom pydantic.experimental.pipeline import transform, validate_as", "url": "https://docs.pydantic.dev/latest/docs/concepts/experimental/#mapping-from-beforevalidator-aftervalidator-and-wrapvalidator", "page": "docs/concepts/experimental", "source_site": "pydantic"}
{"title": "BeforeValidator", "anchor": "beforevalidator", "heading_level": 1, "md_text": "Annotated[int, validate_as(str).str_strip().validate_as(...)]  # (1)!", "url": "https://docs.pydantic.dev/latest/docs/concepts/experimental/#beforevalidator", "page": "docs/concepts/experimental", "source_site": "pydantic"}
{"title": "AfterValidator", "anchor": "aftervalidator", "heading_level": 1, "md_text": "Annotated[int, transform(lambda x: x * 2)]  # (2)!", "url": "https://docs.pydantic.dev/latest/docs/concepts/experimental/#aftervalidator", "page": "docs/concepts/experimental", "source_site": "pydantic"}
{"title": "WrapValidator", "anchor": "wrapvalidator", "heading_level": 1, "md_text": "Annotated[\n    int,\n    validate_as(str)\n    .str_strip()\n    .validate_as(...)\n    .transform(lambda x: x * 2),  # (3)!\n]\n```\n\n1. Strip whitespace from a string before parsing it as an integer.\n2. Multiply an integer by 2 after parsing it.\n3. Strip whitespace from a string, validate it as an integer, then multiply it by 2.", "url": "https://docs.pydantic.dev/latest/docs/concepts/experimental/#wrapvalidator", "page": "docs/concepts/experimental", "source_site": "pydantic"}
{"title": "Alternative patterns", "anchor": "alternative-patterns", "heading_level": 3, "md_text": "There are many alternative patterns to use depending on the scenario.\nJust as an example, consider the `UserIn` and `UserOut` pattern mentioned above:\n\n```python\nfrom __future__ import annotations\n\nfrom pydantic import BaseModel\n\n\nclass UserIn(BaseModel):\n    favorite_number: int | str\n\n\nclass UserOut(BaseModel):\n    favorite_number: int\n\n\ndef my_api(user: UserIn) -> UserOut:\n    favorite_number = user.favorite_number\n    if isinstance(favorite_number, str):\n        favorite_number = int(user.favorite_number.strip())\n\n    return UserOut(favorite_number=favorite_number)\n\n\nassert my_api(UserIn(favorite_number=' 1 ')).favorite_number == 1\n```\n\nThis example uses plain idiomatic Python code that may be easier to understand, type-check, etc. than the examples above.\nThe approach you choose should really depend on your use case.\nYou will have to compare verbosity, performance, ease of returning meaningful errors to your users, etc. to choose the right pattern.\nJust be mindful of abusing advanced patterns like the pipeline API just because you can.", "url": "https://docs.pydantic.dev/latest/docs/concepts/experimental/#alternative-patterns", "page": "docs/concepts/experimental", "source_site": "pydantic"}
{"title": "Partial Validation", "anchor": "partial-validation", "heading_level": 2, "md_text": "Pydantic v2.10.0 introduces experimental support for \"partial validation\".\n\nThis allows you to validate an incomplete JSON string, or a Python object representing incomplete input data.\n\nPartial validation is particularly helpful when processing the output of an LLM, where the model streams structured responses, and you may wish to begin validating the stream while you're still receiving data (e.g. to show partial data to users).\n\n!!! warning\n    Partial validation is an experimental feature and may change in future versions of Pydantic. The current implementation should be considered a proof of concept at this time and has a number of [limitations](#limitations-of-partial-validation).\n\nPartial validation can be enabled when using the three validation methods on `TypeAdapter`: [`TypeAdapter.validate_json()`][pydantic.TypeAdapter.validate_json], [`TypeAdapter.validate_python()`][pydantic.TypeAdapter.validate_python], and [`TypeAdapter.validate_strings()`][pydantic.TypeAdapter.validate_strings]. This allows you to parse and validation incomplete JSON, but also to validate Python objects created by parsing incomplete data of any format.\n\nThe `experimental_allow_partial` flag can be passed to these methods to enable partial validation.\nIt can take the following values (and is `False`, by default):\n\n* `False` or `'off'` - disable partial validation\n* `True` or `'on'` - enable partial validation, but don't support trailing strings\n* `'trailing-strings'` - enable partial validation and support trailing strings\n\n!!! info \"`'trailing-strings'` mode\"\n    `'trailing-strings'` mode allows for trailing incomplete strings at the end of partial JSON to be included in the output.\n    For example, if you're validating against the following model:\n\n    ```python\n    from typing import TypedDict\n\n\n    class Model(TypedDict):\n        a: str\n        b: str\n    ```\n\n    Then the following JSON input would be considered valid, despite the incomplete string at the end:\n\n    ```json\n    '{\"a\": \"hello\", \"b\": \"wor'\n    ```\n\n    And would be validated as:\n\n    ```python {test=\"skip\" lint=\"skip\"}\n    {'a': 'hello', 'b': 'wor'}\n    ```\n\n`experiment_allow_partial` in action:\n\n```python\nfrom typing import Annotated\n\nfrom annotated_types import MinLen\nfrom typing_extensions import NotRequired, TypedDict\n\nfrom pydantic import TypeAdapter\n\n\nclass Foobar(TypedDict):  # (1)!\n    a: int\n    b: NotRequired[float]\n    c: NotRequired[Annotated[str, MinLen(5)]]\n\n\nta = TypeAdapter(list[Foobar])\n\nv = ta.validate_json('[{\"a\": 1, \"b\"', experimental_allow_partial=True)  # (2)!\nprint(v)\n#> [{'a': 1}]\n\nv = ta.validate_json(\n    '[{\"a\": 1, \"b\": 1.0, \"c\": \"abcd', experimental_allow_partial=True  # (3)!\n)\nprint(v)\n#> [{'a': 1, 'b': 1.0}]\n\nv = ta.validate_json(\n    '[{\"b\": 1.0, \"c\": \"abcde\"', experimental_allow_partial=True  # (4)!\n)\nprint(v)\n#> []\n\nv = ta.validate_json(\n    '[{\"a\": 1, \"b\": 1.0, \"c\": \"abcde\"},{\"a\": ', experimental_allow_partial=True\n)\nprint(v)\n#> [{'a': 1, 'b': 1.0, 'c': 'abcde'}]\n\nv = ta.validate_python([{'a': 1}], experimental_allow_partial=True)  # (5)!\nprint(v)\n#> [{'a': 1}]\n\nv = ta.validate_python(\n    [{'a': 1, 'b': 1.0, 'c': 'abcd'}], experimental_allow_partial=True  # (6)!\n)\nprint(v)\n#> [{'a': 1, 'b': 1.0}]\n\nv = ta.validate_json(\n    '[{\"a\": 1, \"b\": 1.0, \"c\": \"abcdefg',\n    experimental_allow_partial='trailing-strings',  # (7)!\n)\nprint(v)\n#> [{'a': 1, 'b': 1.0, 'c': 'abcdefg'}]\n```\n\n1. The TypedDict `Foobar` has three field, but only `a` is required, that means that a valid instance of `Foobar` can be created even if the `b` and `c` fields are missing.\n2. Parsing JSON, the input is valid JSON up to the point where the string is truncated.\n3. In this case truncation of the input means the value of `c` (`abcd`) is invalid as input to `c` field, hence it's omitted.\n4. The `a` field is required, so validation on the only item in the list fails and is dropped.\n5. Partial validation also works with Python objects, it should have the same semantics as with JSON except of course you can't have a genuinely \"incomplete\" Python object.\n6. The same as above but with a Python object, `c` is dropped as it's not required and failed validation.\n7. The `trailing-strings` mode allows for incomplete strings at the end of partial JSON to be included in the output, in this case the input is valid JSON up to the point where the string is truncated, so the last string is included.", "url": "https://docs.pydantic.dev/latest/docs/concepts/experimental/#partial-validation", "page": "docs/concepts/experimental", "source_site": "pydantic"}
{"title": "How Partial Validation Works", "anchor": "how-partial-validation-works", "heading_level": 3, "md_text": "Partial validation follows the zen of Pydantic \u2014 it makes no guarantees about what the input data might have been, but it does guarantee to return a valid instance of the type you required, or raise a validation error.\n\nTo do this, the `experimental_allow_partial` flag enables two pieces of behavior:", "url": "https://docs.pydantic.dev/latest/docs/concepts/experimental/#how-partial-validation-works", "page": "docs/concepts/experimental", "source_site": "pydantic"}
{"title": "1. Partial JSON parsing", "anchor": "1-partial-json-parsing", "heading_level": 4, "md_text": "The [jiter](https://github.com/pydantic/jiter) JSON parser used by Pydantic already supports parsing partial JSON,\n`experimental_allow_partial` is simply passed to jiter via the `allow_partial` argument.\n\n!!! note\n    If you just want pure JSON parsing with support for partial JSON, you can use the [`jiter`](https://pypi.org/project/jiter/) Python library directly, or pass the `allow_partial` argument when calling [`pydantic_core.from_json`][pydantic_core.from_json].", "url": "https://docs.pydantic.dev/latest/docs/concepts/experimental/#1-partial-json-parsing", "page": "docs/concepts/experimental", "source_site": "pydantic"}
{"title": "2. Ignore errors in the last element of the input {#2-ignore-errors-in-last}", "anchor": "2-ignore-errors-in-the-last-element-of-the-input-2-ignore-errors-in-last", "heading_level": 4, "md_text": "Only having access to part of the input data means errors can commonly occur in the last element of the input data.\n\nFor example:\n\n* if a string has a constraint `MinLen(5)`, when you only see part of the input, validation might fail because part of the string is missing (e.g. `{\"name\": \"Sam` instead of `{\"name\": \"Samuel\"}`)\n* if an `int` field has a constraint `Ge(10)`, when you only see part of the input, validation might fail because the number is too small (e.g. `1` instead of `10`)\n* if a `TypedDict` field has 3 required fields, but the partial input only has two of the fields, validation would fail because some field are missing\n* etc. etc. \u2014 there are lost more cases like this\n\nThe point is that if you only see part of some valid input data, validation errors can often occur in the last element of a sequence or last value of mapping.\n\nTo avoid these errors breaking partial validation, Pydantic will ignore ALL errors in the last element of the input data.\n\n```python {title=\"Errors in last element ignored\"}\nfrom typing import Annotated\n\nfrom annotated_types import MinLen\n\nfrom pydantic import BaseModel, TypeAdapter\n\n\nclass MyModel(BaseModel):\n    a: int\n    b: Annotated[str, MinLen(5)]\n\n\nta = TypeAdapter(list[MyModel])\nv = ta.validate_json(\n    '[{\"a\": 1, \"b\": \"12345\"}, {\"a\": 1,',\n    experimental_allow_partial=True,\n)\nprint(v)\n#> [MyModel(a=1, b='12345')]\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/experimental/#2-ignore-errors-in-the-last-element-of-the-input-2-ignore-errors-in-last", "page": "docs/concepts/experimental", "source_site": "pydantic"}
{"title": "TypeAdapter only", "anchor": "typeadapter-only", "heading_level": 4, "md_text": "You can only pass `experiment_allow_partial` to [`TypeAdapter`][pydantic.TypeAdapter] methods, it's not yet supported via other Pydantic entry points like [`BaseModel`][pydantic.BaseModel].", "url": "https://docs.pydantic.dev/latest/docs/concepts/experimental/#typeadapter-only", "page": "docs/concepts/experimental", "source_site": "pydantic"}
{"title": "Types supported", "anchor": "types-supported", "heading_level": 4, "md_text": "Right now only a subset of collection validators know how to handle partial validation:\n\n* `list`\n* `set`\n* `frozenset`\n* `dict` (as in `dict[X, Y]`)\n* `TypedDict` \u2014 only non-required fields may be missing, e.g. via [`NotRequired`][typing.NotRequired] or [`total=False`][typing.TypedDict.__total__])\n\nWhile you can use `experimental_allow_partial` while validating against types that include other collection validators, those types will be validated \"all or nothing\", and partial validation will not work on more nested types.\n\nE.g. in the [above](#2-ignore-errors-in-last) example partial validation works although the second item in the list is dropped completely since `BaseModel` doesn't (yet) support partial validation.\n\nBut partial validation won't work at all in the follow example because `BaseModel` doesn't support partial validation so it doesn't forward the `allow_partial` instruction down to the list validator in `b`:\n\n```python\nfrom typing import Annotated\n\nfrom annotated_types import MinLen\n\nfrom pydantic import BaseModel, TypeAdapter, ValidationError\n\n\nclass MyModel(BaseModel):\n    a: int = 1\n    b: list[Annotated[str, MinLen(5)]] = []  # (1)!\n\n\nta = TypeAdapter(MyModel)\ntry:\n    v = ta.validate_json(\n        '{\"a\": 1, \"b\": [\"12345\", \"12', experimental_allow_partial=True\n    )\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for MyModel\n    b.1\n      String should have at least 5 characters [type=string_too_short, input_value='12', input_type=str]\n    \"\"\"\n```\n\n1. The list validator for `b` doesn't get the `allow_partial` instruction passed down to it by the model validator so it doesn't know to ignore errors in the last element of the input.", "url": "https://docs.pydantic.dev/latest/docs/concepts/experimental/#types-supported", "page": "docs/concepts/experimental", "source_site": "pydantic"}
{"title": "Some invalid but complete JSON will be accepted", "anchor": "some-invalid-but-complete-json-will-be-accepted", "heading_level": 4, "md_text": "The way [jiter](https://github.com/pydantic/jiter) (the JSON parser used by Pydantic) works means it's currently not possible to differentiate between complete JSON like `{\"a\": 1, \"b\": \"12\"}` and incomplete JSON like `{\"a\": 1, \"b\": \"12`.\n\nThis means that some invalid JSON will be accepted by Pydantic when using `experimental_allow_partial`, e.g.:\n\n```python\nfrom typing import Annotated\n\nfrom annotated_types import MinLen\nfrom typing_extensions import TypedDict\n\nfrom pydantic import TypeAdapter\n\n\nclass Foobar(TypedDict, total=False):\n    a: int\n    b: Annotated[str, MinLen(5)]\n\n\nta = TypeAdapter(Foobar)\n\nv = ta.validate_json(\n    '{\"a\": 1, \"b\": \"12', experimental_allow_partial=True  # (1)!\n)\nprint(v)\n#> {'a': 1}\n\nv = ta.validate_json(\n    '{\"a\": 1, \"b\": \"12\"}', experimental_allow_partial=True  # (2)!\n)\nprint(v)\n#> {'a': 1}\n```\n\n1. This will pass validation as expected although the last field will be omitted as it failed validation.\n2. This will also pass validation since the binary representation of the JSON data passed to pydantic-core is indistinguishable from the previous case.", "url": "https://docs.pydantic.dev/latest/docs/concepts/experimental/#some-invalid-but-complete-json-will-be-accepted", "page": "docs/concepts/experimental", "source_site": "pydantic"}
{"title": "Any error in the last field of the input will be ignored", "anchor": "any-error-in-the-last-field-of-the-input-will-be-ignored", "heading_level": 4, "md_text": "As described [above](#2-ignore-errors-in-last), many errors can result from truncating the input. Rather than trying to specifically ignore errors that could result from truncation, Pydantic ignores all errors in the last element of the input in partial validation mode.\n\nThis means clearly invalid data will pass validation if the error is in the last field of the input:\n\n```python\nfrom typing import Annotated\n\nfrom annotated_types import Ge\n\nfrom pydantic import TypeAdapter\n\nta = TypeAdapter(list[Annotated[int, Ge(10)]])\nv = ta.validate_python([20, 30, 4], experimental_allow_partial=True)  # (1)!\nprint(v)\n#> [20, 30]\n\nta = TypeAdapter(list[int])\n\nv = ta.validate_python([1, 2, 'wrong'], experimental_allow_partial=True)  # (2)!\nprint(v)\n#> [1, 2]\n```\n\n1. As you would expect, this will pass validation since Pydantic correctly ignores the error in the (truncated) last item.\n2. This will also pass validation since the error in the last item is ignored.", "url": "https://docs.pydantic.dev/latest/docs/concepts/experimental/#any-error-in-the-last-field-of-the-input-will-be-ignored", "page": "docs/concepts/experimental", "source_site": "pydantic"}
{"title": "Validation of a callable's arguments", "anchor": "validation-of-a-callables-arguments", "heading_level": 2, "md_text": "Pydantic provides the [`@validate_call`][pydantic.validate_call] decorator to perform validation on the provided\narguments (and additionally return type) of a callable. However, it only allows arguments to be provided\nby actually calling the decorated callable. In some situations, you may want to just *validate* the arguments,\nsuch as when loading from other data sources such as JSON data.\n\nFor this reason, the experimental [`generate_arguments_schema()`][pydantic.experimental.arguments_schema.generate_arguments_schema]\nfunction can be used to construct a core schema, which can later be used with a [`SchemaValidator`][pydantic_core.SchemaValidator].\n\n```python\nfrom pydantic_core import SchemaValidator\n\nfrom pydantic.experimental.arguments_schema import generate_arguments_schema\n\n\ndef func(p: bool, *args: str, **kwargs: int) -> None: ...\n\n\narguments_schema = generate_arguments_schema(func=func)\n\nval = SchemaValidator(arguments_schema, config={'coerce_numbers_to_str': True})\n\nargs, kwargs = val.validate_json(\n    '{\"p\": true, \"args\": [\"arg1\", 1], \"kwargs\": {\"extra\": 1}}'\n)\nprint(args, kwargs)  # (1)!\n#> (True, 'arg1', '1') {'extra': 1}\n```\n\n1. If you want the validated arguments as a dictionary, you can use the [`Signature.bind()`][inspect.Signature.bind]\n   method:\n\n     ```python {test=\"skip\" lint=\"skip\"}\n     from inspect import signature\n\n     signature(func).bind(*args, **kwargs).arguments\n     #> {'p': True, 'args': ('arg1', '1'), 'kwargs': {'extra': 1}}\n     ```\n\n!!! note\n    Unlike [`@validate_call`][pydantic.validate_call], this core schema will only validate the provided arguments;\n    the underlying callable will *not* be called.\n\nAdditionally, you can ignore specific parameters by providing a callback, which is called for every parameter:\n\n```python\nfrom typing import Any\n\nfrom pydantic_core import SchemaValidator\n\nfrom pydantic.experimental.arguments_schema import generate_arguments_schema\n\n\ndef func(p: bool, *args: str, **kwargs: int) -> None: ...\n\n\ndef skip_first_parameter(index: int, name: str, annotation: Any) -> Any:\n    if index == 0:\n        return 'skip'\n\n\narguments_schema = generate_arguments_schema(\n    func=func,\n    parameters_callback=skip_first_parameter,\n)\n\nval = SchemaValidator(arguments_schema)\n\nargs, kwargs = val.validate_json('{\"args\": [\"arg1\"], \"kwargs\": {\"extra\": 1}}')\nprint(args, kwargs)\n#> ('arg1',) {'extra': 1}\n```", "url": "https://docs.pydantic.dev/latest/docs/concepts/experimental/#validation-of-a-callables-arguments", "page": "docs/concepts/experimental", "source_site": "pydantic"}
{"title": "`MISSING` sentinel", "anchor": "missing-sentinel", "heading_level": 2, "md_text": "The `MISSING` sentinel is a singleton indicating a field value was not provided during validation.\n\nThis singleton can be used as a default value, as an alternative to `None` when it has an explicit\nmeaning. During serialization, any field with `MISSING` as a value is excluded from the output.\n\n```python\nfrom typing import Union\n\nfrom pydantic import BaseModel\nfrom pydantic.experimental.missing_sentinel import MISSING\n\n\nclass Configuration(BaseModel):\n    timeout: Union[int, None, MISSING] = MISSING", "url": "https://docs.pydantic.dev/latest/docs/concepts/experimental/#missing-sentinel", "page": "docs/concepts/experimental", "source_site": "pydantic"}
{"title": "configuration defaults, stored somewhere else:", "anchor": "configuration-defaults-stored-somewhere-else", "heading_level": 1, "md_text": "defaults = {'timeout': 200}\n\nconf = Configuration()", "url": "https://docs.pydantic.dev/latest/docs/concepts/experimental/#configuration-defaults-stored-somewhere-else", "page": "docs/concepts/experimental", "source_site": "pydantic"}
{"title": "`timeout` is excluded from the serialization output:", "anchor": "timeout-is-excluded-from-the-serialization-output", "heading_level": 1, "md_text": "conf.model_dump()", "url": "https://docs.pydantic.dev/latest/docs/concepts/experimental/#timeout-is-excluded-from-the-serialization-output", "page": "docs/concepts/experimental", "source_site": "pydantic"}
{"title": "The `MISSING` value doesn't appear in the JSON Schema:", "anchor": "the-missing-value-doesnt-appear-in-the-json-schema", "heading_level": 1, "md_text": "Configuration.model_json_schema()['properties']['timeout']\n#> {'anyOf': [{'type': 'integer'}, {'type': 'null'}], 'title': 'Timeout'}}", "url": "https://docs.pydantic.dev/latest/docs/concepts/experimental/#the-missing-value-doesnt-appear-in-the-json-schema", "page": "docs/concepts/experimental", "source_site": "pydantic"}
{"title": "`is` can be used to discriminate between the sentinel and other values:", "anchor": "is-can-be-used-to-discriminate-between-the-sentinel-and-other-values", "heading_level": 1, "md_text": "timeout = conf.timeout if conf.timeout is not MISSING else defaults['timeout']\n```\n\nThis feature is marked as experimental because it relies on the draft [PEP 661](https://peps.python.org/pep-0661/), introducing sentinels in the standard library.\n\nAs such, the following limitations currently apply:\n\n* Static type checking of sentinels is only supported with Pyright\n  [1.1.402](https://github.com/microsoft/pyright/releases/tag/1.1.402)\n  or greater, and the `enableExperimentalFeatures` type evaluation setting\n  should be enabled.\n* Pickling of models containing `MISSING` as a value is not supported.", "url": "https://docs.pydantic.dev/latest/docs/concepts/experimental/#is-can-be-used-to-discriminate-between-the-sentinel-and-other-values", "page": "docs/concepts/experimental", "source_site": "pydantic"}
{"title": "errors", "anchor": null, "heading_level": 0, "md_text": "Pydantic will raise a [`ValidationError`][pydantic_core.ValidationError] whenever it finds an error in the data it's validating.\n\n!!! note\n    Validation code should not raise the [`ValidationError`][pydantic_core.ValidationError] itself,\n    but rather raise a [`ValueError`][] or a [`AssertionError`][] (or subclass thereof) which will\n    be caught and used to populate the final [`ValidationError`][pydantic_core.ValidationError].\n\n    For more details, refer to the [dedicated section](../concepts/validators.md#raising-validation-errors)\n    of the validators documentation.\n\nThat [`ValidationError`][pydantic_core.ValidationError] will contain information about all the errors and how they happened.\n\nYou can access these errors in several ways:\n\n| Method                                                       | Description                                                                                    |\n|--------------------------------------------------------------|------------------------------------------------------------------------------------------------|\n| [`errors()`][pydantic_core.ValidationError.errors]           | Returns a list of [`ErrorDetails`][pydantic_core.ErrorDetails] errors found in the input data. |\n| [`error_count()`][pydantic_core.ValidationError.error_count] | Returns the number of errors.                                                                  |\n| [`json()`][pydantic_core.ValidationError.json]               | Returns a JSON representation of the list errors.                                              |\n| `str(e)`                                                     | Returns a human-readable representation of the errors.                                         |\n\nThe [`ErrorDetails`][pydantic_core.ErrorDetails] object is a dictionary. It contains the following:\n\n| Property                                    | Description                                                                    |\n|---------------------------------------------|--------------------------------------------------------------------------------|\n| [`ctx`][pydantic_core.ErrorDetails.ctx]     | An optional object which contains values required to render the error message. |\n| [`input`][pydantic_core.ErrorDetails.input] | The input provided for validation.                                             |\n| [`loc`][pydantic_core.ErrorDetails.loc]     | The error's location as a list.                                                |\n| [`msg`][pydantic_core.ErrorDetails.msg]     | A human-readable explanation of the error.                                     |\n| [`type`][pydantic_core.ErrorDetails.type]   | A computer-readable identifier of the error type.                              |\n| [`url`][pydantic_core.ErrorDetails.url]     | The documentation URL giving information about the error.                      |\n\nThe first item in the [`loc`][pydantic_core.ErrorDetails.loc] list will be the field where the error occurred, and if the field is a\n[sub-model](../concepts/models.md#nested-models), subsequent items will be present to indicate the nested location of the error.\n\nAs a demonstration:\n\n```python\nfrom pydantic import BaseModel, Field, ValidationError, field_validator\n\n\nclass Location(BaseModel):\n    lat: float = 0.1\n    lng: float = 10.1\n\n\nclass Model(BaseModel):\n    is_required: float\n    gt_int: int = Field(gt=42)\n    list_of_ints: list[int]\n    a_float: float\n    recursive_model: Location\n\n    @field_validator('a_float', mode='after')\n    @classmethod\n    def validate_float(cls, value: float) -> float:\n        if value > 2.0:\n            raise ValueError('Invalid float value')\n        return value\n\n\ndata = {\n    'list_of_ints': ['1', 2, 'bad'],\n    'a_float': 3.0,\n    'recursive_model': {'lat': 4.2, 'lng': 'New York'},\n    'gt_int': 21,\n}\n\ntry:\n    Model(**data)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    5 validation errors for Model\n    is_required\n      Field required [type=missing, input_value={'list_of_ints': ['1', 2,...ew York'}, 'gt_int': 21}, input_type=dict]\n    gt_int\n      Input should be greater than 42 [type=greater_than, input_value=21, input_type=int]\n    list_of_ints.2\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='bad', input_type=str]\n    a_float\n      Value error, Invalid float value [type=value_error, input_value=3.0, input_type=float]\n    recursive_model.lng\n      Input should be a valid number, unable to parse string as a number [type=float_parsing, input_value='New York', input_type=str]\n    \"\"\"", "url": "https://docs.pydantic.dev/latest/docs/errors/errors/", "page": "docs/errors/errors", "source_site": "pydantic"}
{"title": "errors", "anchor": null, "heading_level": 0, "md_text": "try:\n    Model(**data)\nexcept ValidationError as e:\n    print(e.errors())\n    \"\"\"\n    [\n        {\n            'type': 'missing',\n            'loc': ('is_required',),\n            'msg': 'Field required',\n            'input': {\n                'list_of_ints': ['1', 2, 'bad'],\n                'a_float': 3.0,\n                'recursive_model': {'lat': 4.2, 'lng': 'New York'},\n                'gt_int': 21,\n            },\n            'url': 'https://errors.pydantic.dev/2/v/missing',\n        },\n        {\n            'type': 'greater_than',\n            'loc': ('gt_int',),\n            'msg': 'Input should be greater than 42',\n            'input': 21,\n            'ctx': {'gt': 42},\n            'url': 'https://errors.pydantic.dev/2/v/greater_than',\n        },\n        {\n            'type': 'int_parsing',\n            'loc': ('list_of_ints', 2),\n            'msg': 'Input should be a valid integer, unable to parse string as an integer',\n            'input': 'bad',\n            'url': 'https://errors.pydantic.dev/2/v/int_parsing',\n        },\n        {\n            'type': 'value_error',\n            'loc': ('a_float',),\n            'msg': 'Value error, Invalid float value',\n            'input': 3.0,\n            'ctx': {'error': ValueError('Invalid float value')},\n            'url': 'https://errors.pydantic.dev/2/v/value_error',\n        },\n        {\n            'type': 'float_parsing',\n            'loc': ('recursive_model', 'lng'),\n            'msg': 'Input should be a valid number, unable to parse string as a number',\n            'input': 'New York',\n            'url': 'https://errors.pydantic.dev/2/v/float_parsing',\n        },\n    ]\n    \"\"\"\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/errors/", "page": "docs/errors/errors", "source_site": "pydantic"}
{"title": "Error messages", "anchor": "error-messages", "heading_level": 2, "md_text": "Pydantic attempts to provide useful default error messages for validation and usage errors, which can be found here:\n\n* [Validation Errors](validation_errors.md): Errors that happen during data validation.\n* [Usage Errors](usage_errors.md): Errors that happen when using Pydantic.", "url": "https://docs.pydantic.dev/latest/docs/errors/errors/#error-messages", "page": "docs/errors/errors", "source_site": "pydantic"}
{"title": "Customize error messages", "anchor": "customize-error-messages", "heading_level": 3, "md_text": "You can customize error messages by creating a custom error handler.\n\n```python\nfrom pydantic_core import ErrorDetails\n\nfrom pydantic import BaseModel, HttpUrl, ValidationError\n\nCUSTOM_MESSAGES = {\n    'int_parsing': 'This is not an integer! \ud83e\udd26',\n    'url_scheme': 'Hey, use the right URL scheme! I wanted {expected_schemes}.',\n}\n\n\ndef convert_errors(\n    e: ValidationError, custom_messages: dict[str, str]\n) -> list[ErrorDetails]:\n    new_errors: list[ErrorDetails] = []\n    for error in e.errors():\n        custom_message = custom_messages.get(error['type'])\n        if custom_message:\n            ctx = error.get('ctx')\n            error['msg'] = (\n                custom_message.format(**ctx) if ctx else custom_message\n            )\n        new_errors.append(error)\n    return new_errors\n\n\nclass Model(BaseModel):\n    a: int\n    b: HttpUrl\n\n\ntry:\n    Model(a='wrong', b='ftp://example.com')\nexcept ValidationError as e:\n    errors = convert_errors(e, CUSTOM_MESSAGES)\n    print(errors)\n    \"\"\"\n    [\n        {\n            'type': 'int_parsing',\n            'loc': ('a',),\n            'msg': 'This is not an integer! \ud83e\udd26',\n            'input': 'wrong',\n            'url': 'https://errors.pydantic.dev/2/v/int_parsing',\n        },\n        {\n            'type': 'url_scheme',\n            'loc': ('b',),\n            'msg': \"Hey, use the right URL scheme! I wanted 'http' or 'https'.\",\n            'input': 'ftp://example.com',\n            'ctx': {'expected_schemes': \"'http' or 'https'\"},\n            'url': 'https://errors.pydantic.dev/2/v/url_scheme',\n        },\n    ]\n    \"\"\"\n```\n\nA common use case would be to translate error messages. For example, in the above example,\nwe could translate the error messages replacing the `CUSTOM_MESSAGES` dictionary with a\ndictionary of translations.\n\nAnother example is customizing the way that the `'loc'` value of an error is represented.\n\n```python\nfrom typing import Any, Union\n\nfrom pydantic import BaseModel, ValidationError\n\n\ndef loc_to_dot_sep(loc: tuple[Union[str, int], ...]) -> str:\n    path = ''\n    for i, x in enumerate(loc):\n        if isinstance(x, str):\n            if i > 0:\n                path += '.'\n            path += x\n        elif isinstance(x, int):\n            path += f'[{x}]'\n        else:\n            raise TypeError('Unexpected type')\n    return path\n\n\ndef convert_errors(e: ValidationError) -> list[dict[str, Any]]:\n    new_errors: list[dict[str, Any]] = e.errors()\n    for error in new_errors:\n        error['loc'] = loc_to_dot_sep(error['loc'])\n    return new_errors\n\n\nclass TestNestedModel(BaseModel):\n    key: str\n    value: str\n\n\nclass TestModel(BaseModel):\n    items: list[TestNestedModel]\n\n\ndata = {'items': [{'key': 'foo', 'value': 'bar'}, {'key': 'baz'}]}\n\ntry:\n    TestModel.model_validate(data)\nexcept ValidationError as e:\n    print(e.errors())  # (1)!\n    \"\"\"\n    [\n        {\n            'type': 'missing',\n            'loc': ('items', 1, 'value'),\n            'msg': 'Field required',\n            'input': {'key': 'baz'},\n            'url': 'https://errors.pydantic.dev/2/v/missing',\n        }\n    ]\n    \"\"\"\n    pretty_errors = convert_errors(e)\n    print(pretty_errors)  # (2)!\n    \"\"\"\n    [\n        {\n            'type': 'missing',\n            'loc': 'items[1].value',\n            'msg': 'Field required',\n            'input': {'key': 'baz'},\n            'url': 'https://errors.pydantic.dev/2/v/missing',\n        }\n    ]\n    \"\"\"\n```\n\n1. By default, `e.errors()` produces a list of errors with `loc` values that take the form of tuples.\n2. With our custom `loc_to_dot_sep` function, we've modified the form of the `loc` representation.", "url": "https://docs.pydantic.dev/latest/docs/errors/errors/#customize-error-messages", "page": "docs/errors/errors", "source_site": "pydantic"}
{"title": "validation_errors", "anchor": null, "heading_level": 0, "md_text": "Pydantic attempts to provide useful validation errors. Below are details on common validation errors users\nmay encounter when working with pydantic, together with some suggestions on how to fix them.", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`arguments_type`", "anchor": "arguments_type", "heading_level": 2, "md_text": "This error is raised when an object that would be passed as arguments to a function during validation is not\na `tuple`, `list`, or `dict`. Because `NamedTuple` uses function calls in its implementation, that is one way to\nproduce this error:\n\n```python\nfrom typing import NamedTuple\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass MyNamedTuple(NamedTuple):\n    x: int\n\n\nclass MyModel(BaseModel):\n    field: MyNamedTuple\n\n\ntry:\n    MyModel.model_validate({'field': 'invalid'})\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'arguments_type'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#arguments_type", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`assertion_error`", "anchor": "assertion_error", "heading_level": 2, "md_text": "This error is raised when a failing `assert` statement is encountered during validation:\n\n```python\nfrom pydantic import BaseModel, ValidationError, field_validator\n\n\nclass Model(BaseModel):\n    x: int\n\n    @field_validator('x')\n    @classmethod\n    def force_x_positive(cls, v):\n        assert v > 0\n        return v\n\n\ntry:\n    Model(x=-1)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'assertion_error'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#assertion_error", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`bool_parsing`", "anchor": "bool_parsing", "heading_level": 2, "md_text": "This error is raised when the input value is a string that is not valid for coercion to a boolean:\n\n```python\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: bool\n\n\nModel(x='true')  # OK\n\ntry:\n    Model(x='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'bool_parsing'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#bool_parsing", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`bool_type`", "anchor": "bool_type", "heading_level": 2, "md_text": "This error is raised when the input value's type is not valid for a `bool` field:\n\n```python\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: bool\n\n\ntry:\n    Model(x=None)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'bool_type'\n```\n\nThis error is also raised for strict fields when the input value is not an instance of `bool`.", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#bool_type", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`bytes_invalid_encoding`", "anchor": "bytes_invalid_encoding", "heading_level": 2, "md_text": "This error is raised when a `bytes` value is invalid under the configured encoding.\nIn the following example, `'a'` is invalid hex (odd number of digits).\n\n```python\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: bytes\n    model_config = {'val_json_bytes': 'hex'}\n\n\ntry:\n    Model(x='a')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'bytes_invalid_encoding'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#bytes_invalid_encoding", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`bytes_too_long`", "anchor": "bytes_too_long", "heading_level": 2, "md_text": "This error is raised when the length of a `bytes` value is greater than the field's `max_length` constraint:\n\n```python\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: bytes = Field(max_length=3)\n\n\ntry:\n    Model(x=b'test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'bytes_too_long'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#bytes_too_long", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`bytes_too_short`", "anchor": "bytes_too_short", "heading_level": 2, "md_text": "This error is raised when the length of a `bytes` value is less than the field's `min_length` constraint:\n\n```python\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: bytes = Field(min_length=3)\n\n\ntry:\n    Model(x=b't')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'bytes_too_short'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#bytes_too_short", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`bytes_type`", "anchor": "bytes_type", "heading_level": 2, "md_text": "This error is raised when the input value's type is not valid for a `bytes` field:\n\n```python\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: bytes\n\n\ntry:\n    Model(x=123)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'bytes_type'\n```\n\nThis error is also raised for strict fields when the input value is not an instance of `bytes`.", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#bytes_type", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`callable_type`", "anchor": "callable_type", "heading_level": 2, "md_text": "This error is raised when the input value is not valid as a `Callable`:\n\n```python\nfrom typing import Any, Callable\n\nfrom pydantic import BaseModel, ImportString, ValidationError\n\n\nclass Model(BaseModel):\n    x: ImportString[Callable[[Any], Any]]\n\n\nModel(x='math:cos')  # OK\n\ntry:\n    Model(x='os.path')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'callable_type'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#callable_type", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`complex_str_parsing`", "anchor": "complex_str_parsing", "heading_level": 2, "md_text": "This error is raised when the input value is a string but cannot be parsed as a complex number because\nit does not follow the [rule](https://docs.python.org/3/library/functions.html#complex) in Python:\n\n```python\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    num: complex\n\n\ntry:\n    # Complex numbers in json are expected to be valid complex strings.\n    # This value `abc` is not a valid complex string.\n    Model.model_validate_json('{\"num\": \"abc\"}')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'complex_str_parsing'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#complex_str_parsing", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`complex_type`", "anchor": "complex_type", "heading_level": 2, "md_text": "This error is raised when the input value cannot be interpreted as a complex number:\n\n```python\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    num: complex\n\n\ntry:\n    Model(num=False)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'complex_type'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#complex_type", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`dataclass_exact_type`", "anchor": "dataclass_exact_type", "heading_level": 2, "md_text": "This error is raised when validating a dataclass with `strict=True` and the input is not an instance of the dataclass:\n\n```python\nimport pydantic.dataclasses\nfrom pydantic import TypeAdapter, ValidationError\n\n\n@pydantic.dataclasses.dataclass\nclass MyDataclass:\n    x: str\n\n\nadapter = TypeAdapter(MyDataclass)\n\nprint(adapter.validate_python(MyDataclass(x='test'), strict=True))\n#> MyDataclass(x='test')\nprint(adapter.validate_python({'x': 'test'}))\n#> MyDataclass(x='test')\n\ntry:\n    adapter.validate_python({'x': 'test'}, strict=True)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'dataclass_exact_type'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#dataclass_exact_type", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`dataclass_type`", "anchor": "dataclass_type", "heading_level": 2, "md_text": "This error is raised when the input value is not valid for a `dataclass` field:\n\n```python\nfrom pydantic import ValidationError, dataclasses\n\n\n@dataclasses.dataclass\nclass Inner:\n    x: int\n\n\n@dataclasses.dataclass\nclass Outer:\n    y: Inner\n\n\nOuter(y=Inner(x=1))  # OK\n\ntry:\n    Outer(y=1)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'dataclass_type'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#dataclass_type", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`date_from_datetime_inexact`", "anchor": "date_from_datetime_inexact", "heading_level": 2, "md_text": "This error is raised when the input `datetime` value provided for a `date` field has a nonzero time component.\nFor a timestamp to parse into a field of type `date`, the time components must all be zero:\n\n```python\nfrom datetime import date, datetime\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: date\n\n\nModel(x='2023-01-01')  # OK\nModel(x=datetime(2023, 1, 1))  # OK\n\ntry:\n    Model(x=datetime(2023, 1, 1, 12))\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'date_from_datetime_inexact'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#date_from_datetime_inexact", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`date_from_datetime_parsing`", "anchor": "date_from_datetime_parsing", "heading_level": 2, "md_text": "This error is raised when the input value is a string that cannot be parsed for a `date` field:\n\n```python\nfrom datetime import date\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: date\n\n\ntry:\n    Model(x='XX1494012000')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'date_from_datetime_parsing'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#date_from_datetime_parsing", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`date_future`", "anchor": "date_future", "heading_level": 2, "md_text": "This error is raised when the input value provided for a `FutureDate` field is not in the future:\n\n```python\nfrom datetime import date\n\nfrom pydantic import BaseModel, FutureDate, ValidationError\n\n\nclass Model(BaseModel):\n    x: FutureDate\n\n\ntry:\n    Model(x=date(2000, 1, 1))\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'date_future'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#date_future", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`date_parsing`", "anchor": "date_parsing", "heading_level": 2, "md_text": "This error is raised when validating JSON where the input value is string that cannot be parsed for a `date` field:\n\n```python\nimport json\nfrom datetime import date\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: date = Field(strict=True)\n\n\ntry:\n    Model.model_validate_json(json.dumps({'x': '1'}))\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'date_parsing'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#date_parsing", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`date_past`", "anchor": "date_past", "heading_level": 2, "md_text": "This error is raised when the value provided for a `PastDate` field is not in the past:\n\n```python\nfrom datetime import date, timedelta\n\nfrom pydantic import BaseModel, PastDate, ValidationError\n\n\nclass Model(BaseModel):\n    x: PastDate\n\n\ntry:\n    Model(x=date.today() + timedelta(1))\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'date_past'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#date_past", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`date_type`", "anchor": "date_type", "heading_level": 2, "md_text": "This error is raised when the input value's type is not valid for a `date` field:\n\n```python\nfrom datetime import date\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: date\n\n\ntry:\n    Model(x=None)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'date_type'\n```\n\nThis error is also raised for strict fields when the input value is not an instance of `date`.", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#date_type", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`datetime_from_date_parsing`", "anchor": "datetime_from_date_parsing", "heading_level": 2, "md_text": "This error is raised when the input value is a string that cannot be parsed for a `datetime` field:\n\n```python\nfrom datetime import datetime\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: datetime\n\n\ntry:\n    # there is no 13th month\n    Model(x='2023-13-01')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'datetime_from_date_parsing'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#datetime_from_date_parsing", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`datetime_future`", "anchor": "datetime_future", "heading_level": 2, "md_text": "This error is raised when the value provided for a `FutureDatetime` field is not in the future:\n\n```python\nfrom datetime import datetime\n\nfrom pydantic import BaseModel, FutureDatetime, ValidationError\n\n\nclass Model(BaseModel):\n    x: FutureDatetime\n\n\ntry:\n    Model(x=datetime(2000, 1, 1))\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'datetime_future'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#datetime_future", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`datetime_object_invalid`", "anchor": "datetime_object_invalid", "heading_level": 2, "md_text": "This error is raised when something about the `datetime` object is not valid:\n\n```python\nfrom datetime import datetime, tzinfo\n\nfrom pydantic import AwareDatetime, BaseModel, ValidationError\n\n\nclass CustomTz(tzinfo):\n    # utcoffset is not implemented!\n\n    def tzname(self, _dt):\n        return 'CustomTZ'\n\n\nclass Model(BaseModel):\n    x: AwareDatetime\n\n\ntry:\n    Model(x=datetime(2023, 1, 1, tzinfo=CustomTz()))\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'datetime_object_invalid'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#datetime_object_invalid", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`datetime_parsing`", "anchor": "datetime_parsing", "heading_level": 2, "md_text": "This error is raised when the value is a string that cannot be parsed for a `datetime` field:\n\n```python\nimport json\nfrom datetime import datetime\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: datetime = Field(strict=True)\n\n\ntry:\n    Model.model_validate_json(json.dumps({'x': 'not a datetime'}))\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'datetime_parsing'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#datetime_parsing", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`datetime_past`", "anchor": "datetime_past", "heading_level": 2, "md_text": "This error is raised when the value provided for a `PastDatetime` field is not in the past:\n\n```python\nfrom datetime import datetime, timedelta\n\nfrom pydantic import BaseModel, PastDatetime, ValidationError\n\n\nclass Model(BaseModel):\n    x: PastDatetime\n\n\ntry:\n    Model(x=datetime.now() + timedelta(100))\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'datetime_past'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#datetime_past", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`datetime_type`", "anchor": "datetime_type", "heading_level": 2, "md_text": "This error is raised when the input value's type is not valid for a `datetime` field:\n\n```python\nfrom datetime import datetime\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: datetime\n\n\ntry:\n    Model(x=None)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'datetime_type'\n```\n\nThis error is also raised for strict fields when the input value is not an instance of `datetime`.", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#datetime_type", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`decimal_max_digits`", "anchor": "decimal_max_digits", "heading_level": 2, "md_text": "This error is raised when the value provided for a `Decimal` has too many digits:\n\n```python\nfrom decimal import Decimal\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: Decimal = Field(max_digits=3)\n\n\ntry:\n    Model(x='42.1234')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'decimal_max_digits'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#decimal_max_digits", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`decimal_max_places`", "anchor": "decimal_max_places", "heading_level": 2, "md_text": "This error is raised when the value provided for a `Decimal` has too many digits after the decimal point:\n\n```python\nfrom decimal import Decimal\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: Decimal = Field(decimal_places=3)\n\n\ntry:\n    Model(x='42.1234')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'decimal_max_places'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#decimal_max_places", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`decimal_parsing`", "anchor": "decimal_parsing", "heading_level": 2, "md_text": "This error is raised when the value provided for a `Decimal` could not be parsed as a decimal number:\n\n```python\nfrom decimal import Decimal\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: Decimal = Field(decimal_places=3)\n\n\ntry:\n    Model(x='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'decimal_parsing'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#decimal_parsing", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`decimal_type`", "anchor": "decimal_type", "heading_level": 2, "md_text": "This error is raised when the value provided for a `Decimal` is of the wrong type:\n\n```python\nfrom decimal import Decimal\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: Decimal = Field(decimal_places=3)\n\n\ntry:\n    Model(x=[1, 2, 3])\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'decimal_type'\n```\n\nThis error is also raised for strict fields when the input value is not an instance of `Decimal`.", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#decimal_type", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`decimal_whole_digits`", "anchor": "decimal_whole_digits", "heading_level": 2, "md_text": "This error is raised when the value provided for a `Decimal` has more digits before the decimal point than `max_digits` - `decimal_places` (as long as both are specified):\n\n```python\nfrom decimal import Decimal\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: Decimal = Field(max_digits=6, decimal_places=3)\n\n\ntry:\n    Model(x='12345.6')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'decimal_whole_digits'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#decimal_whole_digits", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`default_factory_not_called`", "anchor": "default_factory_not_called", "heading_level": 2, "md_text": "This error is raised when a [default factory taking validated data](../concepts/fields.md#default-factory-validated-data)\ncan't be called, because validation failed on previous fields:\n\n```python\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    a: int = Field(gt=10)\n    b: int = Field(default_factory=lambda data: data['a'])\n\n\ntry:\n    Model(a=1)\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    2 validation errors for Model\n    a\n      Input should be greater than 10 [type=greater_than, input_value=1, input_type=int]\n    b\n      The default factory uses validated data, but at least one validation error occurred [type=default_factory_not_called]\n    \"\"\"\n    print(repr(exc.errors()[1]['type']))\n    #> 'default_factory_not_called'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#default_factory_not_called", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`dict_type`", "anchor": "dict_type", "heading_level": 2, "md_text": "This error is raised when the input value's type is not `dict` for a `dict` field:\n\n```python\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: dict\n\n\ntry:\n    Model(x=['1', '2'])\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'dict_type'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#dict_type", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`enum`", "anchor": "enum", "heading_level": 2, "md_text": "This error is raised when the input value does not exist in an `enum` field members:\n\n```python\nfrom enum import Enum\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass MyEnum(str, Enum):\n    option = 'option'\n\n\nclass Model(BaseModel):\n    x: MyEnum\n\n\ntry:\n    Model(x='other_option')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'enum'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#enum", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`extra_forbidden`", "anchor": "extra_forbidden", "heading_level": 2, "md_text": "This error is raised when the input value contains extra fields, but `model_config['extra'] == 'forbid'`:\n\n```python\nfrom pydantic import BaseModel, ConfigDict, ValidationError\n\n\nclass Model(BaseModel):\n    x: str\n\n    model_config = ConfigDict(extra='forbid')\n\n\ntry:\n    Model(x='test', y='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'extra_forbidden'\n```\n\nYou can read more about the `extra` configuration in the [Extra Attributes][pydantic.config.ConfigDict.extra] section.", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#extra_forbidden", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`finite_number`", "anchor": "finite_number", "heading_level": 2, "md_text": "This error is raised when the value is infinite, or too large to be represented as a 64-bit floating point number\nduring validation:\n\n```python\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: int\n\n\ntry:\n    Model(x=2.2250738585072011e308)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'finite_number'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#finite_number", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`float_parsing`", "anchor": "float_parsing", "heading_level": 2, "md_text": "This error is raised when the value is a string that can't be parsed as a `float`:\n\n```python\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: float\n\n\ntry:\n    Model(x='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'float_parsing'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#float_parsing", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`float_type`", "anchor": "float_type", "heading_level": 2, "md_text": "This error is raised when the input value's type is not valid for a `float` field:\n\n```python\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: float\n\n\ntry:\n    Model(x=None)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'float_type'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#float_type", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`frozen_field`", "anchor": "frozen_field", "heading_level": 2, "md_text": "This error is raised when you attempt to assign a value to a field with `frozen=True`, or to delete such a field:\n\n```python\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: str = Field('test', frozen=True)\n\n\nmodel = Model()\n\ntry:\n    model.x = 'test1'\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'frozen_field'\n\ntry:\n    del model.x\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'frozen_field'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#frozen_field", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`frozen_instance`", "anchor": "frozen_instance", "heading_level": 2, "md_text": "This error is raised when `frozen` is set in the [configuration](../concepts/config.md) and you attempt to delete or assign a new value to\nany of the fields:\n\n```python\nfrom pydantic import BaseModel, ConfigDict, ValidationError\n\n\nclass Model(BaseModel):\n    x: int\n\n    model_config = ConfigDict(frozen=True)\n\n\nm = Model(x=1)\n\ntry:\n    m.x = 2\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'frozen_instance'\n\ntry:\n    del m.x\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'frozen_instance'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#frozen_instance", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`frozen_set_type`", "anchor": "frozen_set_type", "heading_level": 2, "md_text": "This error is raised when the input value's type is not valid for a `frozenset` field:\n\n```python\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: frozenset\n\n\ntry:\n    model = Model(x='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'frozen_set_type'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#frozen_set_type", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`get_attribute_error`", "anchor": "get_attribute_error", "heading_level": 2, "md_text": "This error is raised when `model_config['from_attributes'] == True` and an error is raised while reading the attributes:\n\n```python\nfrom pydantic import BaseModel, ConfigDict, ValidationError\n\n\nclass Foobar:\n    def __init__(self):\n        self.x = 1\n\n    @property\n    def y(self):\n        raise RuntimeError('intentional error')\n\n\nclass Model(BaseModel):\n    x: int\n    y: str\n\n    model_config = ConfigDict(from_attributes=True)\n\n\ntry:\n    Model.model_validate(Foobar())\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'get_attribute_error'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#get_attribute_error", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`greater_than`", "anchor": "greater_than", "heading_level": 2, "md_text": "This error is raised when the value is not greater than the field's `gt` constraint:\n\n```python\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: int = Field(gt=10)\n\n\ntry:\n    Model(x=10)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'greater_than'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#greater_than", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`greater_than_equal`", "anchor": "greater_than_equal", "heading_level": 2, "md_text": "This error is raised when the value is not greater than or equal to the field's `ge` constraint:\n\n```python\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: int = Field(ge=10)\n\n\ntry:\n    Model(x=9)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'greater_than_equal'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#greater_than_equal", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`int_from_float`", "anchor": "int_from_float", "heading_level": 2, "md_text": "This error is raised when you provide a `float` value for an `int` field:\n\n```python\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: int\n\n\ntry:\n    Model(x=0.5)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'int_from_float'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#int_from_float", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`int_parsing`", "anchor": "int_parsing", "heading_level": 2, "md_text": "This error is raised when the value can't be parsed as `int`:\n\n```python\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: int\n\n\ntry:\n    Model(x='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'int_parsing'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#int_parsing", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`int_parsing_size`", "anchor": "int_parsing_size", "heading_level": 2, "md_text": "This error is raised when attempting to parse a python or JSON value from a string outside the maximum range that Python\n`str` to `int` parsing permits:\n\n```python\nimport json\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: int", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#int_parsing_size", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "from Python", "anchor": "from-python", "heading_level": 1, "md_text": "assert Model(x='1' * 4_300).x == int('1' * 4_300)  # OK\n\ntoo_long = '1' * 4_301\ntry:\n    Model(x=too_long)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'int_parsing_size'", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#from-python", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "from JSON", "anchor": "from-json", "heading_level": 1, "md_text": "try:\n    Model.model_validate_json(json.dumps({'x': too_long}))\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'int_parsing_size'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#from-json", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`int_type`", "anchor": "int_type", "heading_level": 2, "md_text": "This error is raised when the input value's type is not valid for an `int` field:\n\n```python\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: int\n\n\ntry:\n    Model(x=None)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'int_type'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#int_type", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`invalid_key`", "anchor": "invalid_key", "heading_level": 2, "md_text": "This error is raised when attempting to validate a `dict` that has a key that is not an instance of `str`:\n\n```python\nfrom pydantic import BaseModel, ConfigDict, ValidationError\n\n\nclass Model(BaseModel):\n    x: int\n\n    model_config = ConfigDict(extra='allow')\n\n\ntry:\n    Model.model_validate({'x': 1, b'y': 2})\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'invalid_key'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#invalid_key", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`is_instance_of`", "anchor": "is_instance_of", "heading_level": 2, "md_text": "This error is raised when the input value is not an instance of the expected type:\n\n```python\nfrom pydantic import BaseModel, ConfigDict, ValidationError\n\n\nclass Nested:\n    x: str\n\n\nclass Model(BaseModel):\n    y: Nested\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n\ntry:\n    Model(y='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'is_instance_of'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#is_instance_of", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`is_subclass_of`", "anchor": "is_subclass_of", "heading_level": 2, "md_text": "This error is raised when the input value is not a subclass of the expected type:\n\n```python\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Nested:\n    x: str\n\n\nclass Model(BaseModel):\n    y: type[Nested]\n\n\ntry:\n    Model(y='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'is_subclass_of'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#is_subclass_of", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`iterable_type`", "anchor": "iterable_type", "heading_level": 2, "md_text": "This error is raised when the input value is not valid as an `Iterable`:\n\n```python\nfrom collections.abc import Iterable\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    y: Iterable[str]\n\n\ntry:\n    Model(y=123)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'iterable_type'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#iterable_type", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`iteration_error`", "anchor": "iteration_error", "heading_level": 2, "md_text": "This error is raised when an error occurs during iteration:\n\n```python\nfrom pydantic import BaseModel, ValidationError\n\n\ndef gen():\n    yield 1\n    raise RuntimeError('error')\n\n\nclass Model(BaseModel):\n    x: list[int]\n\n\ntry:\n    Model(x=gen())\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'iteration_error'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#iteration_error", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`json_invalid`", "anchor": "json_invalid", "heading_level": 2, "md_text": "This error is raised when the input value is not a valid JSON string:\n\n```python\nfrom pydantic import BaseModel, Json, ValidationError\n\n\nclass Model(BaseModel):\n    x: Json\n\n\ntry:\n    Model(x='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'json_invalid'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#json_invalid", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`json_type`", "anchor": "json_type", "heading_level": 2, "md_text": "This error is raised when the input value is of a type that cannot be parsed as JSON:\n\n```python\nfrom pydantic import BaseModel, Json, ValidationError\n\n\nclass Model(BaseModel):\n    x: Json\n\n\ntry:\n    Model(x=None)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'json_type'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#json_type", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`less_than`", "anchor": "less_than", "heading_level": 2, "md_text": "This error is raised when the input value is not less than the field's `lt` constraint:\n\n```python\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: int = Field(lt=10)\n\n\ntry:\n    Model(x=10)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'less_than'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#less_than", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`less_than_equal`", "anchor": "less_than_equal", "heading_level": 2, "md_text": "This error is raised when the input value is not less than or equal to the field's `le` constraint:\n\n```python\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: int = Field(le=10)\n\n\ntry:\n    Model(x=11)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'less_than_equal'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#less_than_equal", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`list_type`", "anchor": "list_type", "heading_level": 2, "md_text": "This error is raised when the input value's type is not valid for a `list` field:\n\n```python\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: list[int]\n\n\ntry:\n    Model(x=1)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'list_type'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#list_type", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`literal_error`", "anchor": "literal_error", "heading_level": 2, "md_text": "This error is raised when the input value is not one of the expected literal values:\n\n```python\nfrom typing import Literal\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: Literal['a', 'b']\n\n\nModel(x='a')  # OK\n\ntry:\n    Model(x='c')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'literal_error'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#literal_error", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`mapping_type`", "anchor": "mapping_type", "heading_level": 2, "md_text": "This error is raised when a problem occurs during validation due to a failure in a call to the methods from the\n`Mapping` protocol, such as `.items()`:\n\n```python\nfrom collections.abc import Mapping\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass BadMapping(Mapping):\n    def items(self):\n        raise ValueError()\n\n    def __iter__(self):\n        raise ValueError()\n\n    def __getitem__(self, key):\n        raise ValueError()\n\n    def __len__(self):\n        return 1\n\n\nclass Model(BaseModel):\n    x: dict[str, str]\n\n\ntry:\n    Model(x=BadMapping())\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'mapping_type'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#mapping_type", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`missing`", "anchor": "missing", "heading_level": 2, "md_text": "This error is raised when there are required fields missing from the input value:\n\n```python\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: str\n\n\ntry:\n    Model()\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'missing'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#missing", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`missing_argument`", "anchor": "missing_argument", "heading_level": 2, "md_text": "This error is raised when a required positional-or-keyword argument is not passed to a function decorated with\n`validate_call`:\n\n```python\nfrom pydantic import ValidationError, validate_call\n\n\n@validate_call\ndef foo(a: int):\n    return a\n\n\ntry:\n    foo()\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'missing_argument'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#missing_argument", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`missing_keyword_only_argument`", "anchor": "missing_keyword_only_argument", "heading_level": 2, "md_text": "This error is raised when a required keyword-only argument is not passed to a function decorated with `validate_call`:\n\n```python\nfrom pydantic import ValidationError, validate_call\n\n\n@validate_call\ndef foo(*, a: int):\n    return a\n\n\ntry:\n    foo()\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'missing_keyword_only_argument'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#missing_keyword_only_argument", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`missing_positional_only_argument`", "anchor": "missing_positional_only_argument", "heading_level": 2, "md_text": "This error is raised when a required positional-only argument is not passed to a function decorated with\n`validate_call`:\n\n```python\nfrom pydantic import ValidationError, validate_call\n\n\n@validate_call\ndef foo(a: int, /):\n    return a\n\n\ntry:\n    foo()\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'missing_positional_only_argument'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#missing_positional_only_argument", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`missing_sentinel_error`", "anchor": "missing_sentinel_error", "heading_level": 2, "md_text": "This error is raised when the experimental `MISSING` sentinel is the only value allowed, and wasn't\nprovided during validation:\n\n```python\nfrom pydantic import BaseModel, ValidationError\nfrom pydantic.experimental.missing_sentinel import MISSING\n\n\nclass Model(BaseModel):\n    f: MISSING\n\n\ntry:\n    Model(f=1)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'missing_sentinel_error'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#missing_sentinel_error", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`model_attributes_type`", "anchor": "model_attributes_type", "heading_level": 2, "md_text": "This error is raised when the input value is not a valid dictionary, model instance, or instance that fields can be extracted from:\n\n```python\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    a: int\n    b: int", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#model_attributes_type", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "simply validating a dict", "anchor": "simply-validating-a-dict", "heading_level": 1, "md_text": "print(Model.model_validate({'a': 1, 'b': 2}))\n#> a=1 b=2\n\n\nclass CustomObj:\n    def __init__(self, a, b):\n        self.a = a\n        self.b = b", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#simply-validating-a-dict", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "using from attributes to extract fields from an objects", "anchor": "using-from-attributes-to-extract-fields-from-an-objects", "heading_level": 1, "md_text": "print(Model.model_validate(CustomObj(3, 4), from_attributes=True))\n#> a=3 b=4\n\ntry:\n    Model.model_validate('not an object', from_attributes=True)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'model_attributes_type'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#using-from-attributes-to-extract-fields-from-an-objects", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`model_type`", "anchor": "model_type", "heading_level": 2, "md_text": "This error is raised when the input to a model is not an instance of the model or dict:\n\n```python\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    a: int\n    b: int", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#model_type", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "simply validating a dict", "anchor": "simply-validating-a-dict", "heading_level": 1, "md_text": "m = Model.model_validate({'a': 1, 'b': 2})\nprint(m)\n#> a=1 b=2", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#simply-validating-a-dict", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "validating an existing model instance", "anchor": "validating-an-existing-model-instance", "heading_level": 1, "md_text": "print(Model.model_validate(m))\n#> a=1 b=2\n\ntry:\n    Model.model_validate('not an object')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'model_type'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#validating-an-existing-model-instance", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`multiple_argument_values`", "anchor": "multiple_argument_values", "heading_level": 2, "md_text": "This error is raised when you provide multiple values for a single argument while calling a function decorated with\n`validate_call`:\n\n```python\nfrom pydantic import ValidationError, validate_call\n\n\n@validate_call\ndef foo(a: int):\n    return a\n\n\ntry:\n    foo(1, a=2)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'multiple_argument_values'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#multiple_argument_values", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`multiple_of`", "anchor": "multiple_of", "heading_level": 2, "md_text": "This error is raised when the input is not a multiple of a field's `multiple_of` constraint:\n\n```python\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: int = Field(multiple_of=5)\n\n\ntry:\n    Model(x=1)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'multiple_of'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#multiple_of", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`needs_python_object`", "anchor": "needs_python_object", "heading_level": 2, "md_text": "This type of error is raised when validation is attempted from a format that cannot be converted to a Python object.\nFor example, we cannot check `isinstance` or `issubclass` from JSON:\n\n```python\nimport json\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    bm: type[BaseModel]\n\n\ntry:\n    Model.model_validate_json(json.dumps({'bm': 'not a basemodel class'}))\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'needs_python_object'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#needs_python_object", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`no_such_attribute`", "anchor": "no_such_attribute", "heading_level": 2, "md_text": "This error is raised when `validate_assignment=True` in the config, and you attempt to assign a value to an attribute\nthat is not an existing field:\n\n```python\nfrom pydantic import ConfigDict, ValidationError, dataclasses\n\n\n@dataclasses.dataclass(config=ConfigDict(validate_assignment=True))\nclass MyDataclass:\n    x: int\n\n\nm = MyDataclass(x=1)\ntry:\n    m.y = 10\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'no_such_attribute'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#no_such_attribute", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`none_required`", "anchor": "none_required", "heading_level": 2, "md_text": "This error is raised when the input value is not `None` for a field that requires `None`:\n\n```python\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: None\n\n\ntry:\n    Model(x=1)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'none_required'\n```\n\n!!! note\n    You may encounter this error when there is a naming collision in your model between a field name and its type. More specifically, this error is likely to be thrown when the default value of that field is `None`.\n\n    For example, the following would yield the `none_required` validation error since the field `int` is set to a default value of `None` and has the exact same name as its type, which causes problems with validation.\n\n    ```python {test=\"skip\"}\n    from typing import Optional\n\n    from pydantic import BaseModel\n\n\n    class M1(BaseModel):\n        int: Optional[int] = None\n\n\n    m = M1(int=123)  # errors\n    ```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#none_required", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`recursion_loop`", "anchor": "recursion_loop", "heading_level": 2, "md_text": "This error is raised when a cyclic reference is detected:\n\n```python\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: list['Model']\n\n\nd = {'x': []}\nd['x'].append(d)\ntry:\n    Model(**d)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'recursion_loop'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#recursion_loop", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`set_item_not_hashable`", "anchor": "set_item_not_hashable", "heading_level": 2, "md_text": "This error is raised when an unhashable value is validated against a [`set`][] or a [`frozenset`][]:\n\n```python\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: set[object]\n\n\nclass Unhashable:\n    __hash__ = None\n\n\ntry:\n    Model(x=[{'a': 'b'}, Unhashable()])\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'set_item_not_hashable'\n    print(repr(exc.errors()[1]['type']))\n    #> 'set_item_not_hashable'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#set_item_not_hashable", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`set_type`", "anchor": "set_type", "heading_level": 2, "md_text": "This error is raised when the value type is not valid for a `set` field:\n\n```python\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: set[int]\n\n\ntry:\n    Model(x='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'set_type'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#set_type", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`string_pattern_mismatch`", "anchor": "string_pattern_mismatch", "heading_level": 2, "md_text": "This error is raised when the input value doesn't match the field's `pattern` constraint:\n\n```python\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: str = Field(pattern='test')\n\n\ntry:\n    Model(x='1')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'string_pattern_mismatch'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#string_pattern_mismatch", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`string_sub_type`", "anchor": "string_sub_type", "heading_level": 2, "md_text": "This error is raised when the value is an instance of a strict subtype of `str` when the field is strict:\n\n```python\nfrom enum import Enum\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass MyEnum(str, Enum):\n    foo = 'foo'\n\n\nclass Model(BaseModel):\n    x: str = Field(strict=True)\n\n\ntry:\n    Model(x=MyEnum.foo)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'string_sub_type'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#string_sub_type", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`string_too_long`", "anchor": "string_too_long", "heading_level": 2, "md_text": "This error is raised when the input value is a string whose length is greater than the field's `max_length` constraint:\n\n```python\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: str = Field(max_length=3)\n\n\ntry:\n    Model(x='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'string_too_long'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#string_too_long", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`string_too_short`", "anchor": "string_too_short", "heading_level": 2, "md_text": "This error is raised when the input value is a string whose length is less than the field's `min_length` constraint:\n\n```python\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: str = Field(min_length=3)\n\n\ntry:\n    Model(x='t')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'string_too_short'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#string_too_short", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`string_type`", "anchor": "string_type", "heading_level": 2, "md_text": "This error is raised when the input value's type is not valid for a `str` field:\n\n```python\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: str\n\n\ntry:\n    Model(x=1)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'string_type'\n```\n\nThis error is also raised for strict fields when the input value is not an instance of `str`.", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#string_type", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`string_unicode`", "anchor": "string_unicode", "heading_level": 2, "md_text": "This error is raised when the value cannot be parsed as a Unicode string:\n\n```python\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: str\n\n\ntry:\n    Model(x=b'\\x81')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'string_unicode'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#string_unicode", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`time_delta_parsing`", "anchor": "time_delta_parsing", "heading_level": 2, "md_text": "This error is raised when the input value is a string that cannot be parsed for a `timedelta` field:\n\n```python\nfrom datetime import timedelta\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: timedelta\n\n\ntry:\n    Model(x='t')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'time_delta_parsing'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#time_delta_parsing", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`time_delta_type`", "anchor": "time_delta_type", "heading_level": 2, "md_text": "This error is raised when the input value's type is not valid for a `timedelta` field:\n\n```python\nfrom datetime import timedelta\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: timedelta\n\n\ntry:\n    Model(x=None)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'time_delta_type'\n```\n\nThis error is also raised for strict fields when the input value is not an instance of `timedelta`.", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#time_delta_type", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`time_parsing`", "anchor": "time_parsing", "heading_level": 2, "md_text": "This error is raised when the input value is a string that cannot be parsed for a `time` field:\n\n```python\nfrom datetime import time\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: time\n\n\ntry:\n    Model(x='25:20:30.400')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'time_parsing'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#time_parsing", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`time_type`", "anchor": "time_type", "heading_level": 2, "md_text": "This error is raised when the value type is not valid for a `time` field:\n\n```python\nfrom datetime import time\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: time\n\n\ntry:\n    Model(x=None)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'time_type'\n```\n\nThis error is also raised for strict fields when the input value is not an instance of `time`.", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#time_type", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`timezone_aware`", "anchor": "timezone_aware", "heading_level": 2, "md_text": "This error is raised when the `datetime` value provided for a timezone-aware `datetime` field\ndoesn't have timezone information:\n\n```python\nfrom datetime import datetime\n\nfrom pydantic import AwareDatetime, BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: AwareDatetime\n\n\ntry:\n    Model(x=datetime.now())\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'timezone_aware'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#timezone_aware", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`timezone_naive`", "anchor": "timezone_naive", "heading_level": 2, "md_text": "This error is raised when the `datetime` value provided for a timezone-naive `datetime` field\nhas timezone info:\n\n```python\nfrom datetime import datetime, timezone\n\nfrom pydantic import BaseModel, NaiveDatetime, ValidationError\n\n\nclass Model(BaseModel):\n    x: NaiveDatetime\n\n\ntry:\n    Model(x=datetime.now(tz=timezone.utc))\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'timezone_naive'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#timezone_naive", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`too_long`", "anchor": "too_long", "heading_level": 2, "md_text": "This error is raised when the input value's length is greater than the field's `max_length` constraint:\n\n```python\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: list[int] = Field(max_length=3)\n\n\ntry:\n    Model(x=[1, 2, 3, 4])\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'too_long'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#too_long", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`too_short`", "anchor": "too_short", "heading_level": 2, "md_text": "This error is raised when the value length is less than the field's `min_length` constraint:\n\n```python\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: list[int] = Field(min_length=3)\n\n\ntry:\n    Model(x=[1, 2])\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'too_short'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#too_short", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`tuple_type`", "anchor": "tuple_type", "heading_level": 2, "md_text": "This error is raised when the input value's type is not valid for a `tuple` field:\n\n```python\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: tuple[int]\n\n\ntry:\n    Model(x=None)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'tuple_type'\n```\n\nThis error is also raised for strict fields when the input value is not an instance of `tuple`.", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#tuple_type", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`unexpected_keyword_argument`", "anchor": "unexpected_keyword_argument", "heading_level": 2, "md_text": "This error is raised when you provide a value by keyword for a positional-only\nargument while calling a function decorated with `validate_call`:\n\n```python\nfrom pydantic import ValidationError, validate_call\n\n\n@validate_call\ndef foo(a: int, /):\n    return a\n\n\ntry:\n    foo(a=2)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[1]['type']))\n    #> 'unexpected_keyword_argument'\n```\n\nIt is also raised when using pydantic.dataclasses and `extra=forbid`:\n\n```python\nfrom pydantic import TypeAdapter, ValidationError\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass(config={'extra': 'forbid'})\nclass Foo:\n    bar: int\n\n\ntry:\n    TypeAdapter(Foo).validate_python({'bar': 1, 'foobar': 2})\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'unexpected_keyword_argument'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#unexpected_keyword_argument", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`unexpected_positional_argument`", "anchor": "unexpected_positional_argument", "heading_level": 2, "md_text": "This error is raised when you provide a positional value for a keyword-only\nargument while calling a function decorated with `validate_call`:\n\n```python\nfrom pydantic import ValidationError, validate_call\n\n\n@validate_call\ndef foo(*, a: int):\n    return a\n\n\ntry:\n    foo(2)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[1]['type']))\n    #> 'unexpected_positional_argument'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#unexpected_positional_argument", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`union_tag_invalid`", "anchor": "union_tag_invalid", "heading_level": 2, "md_text": "This error is raised when the input's discriminator is not one of the expected values:\n\n```python\nfrom typing import Literal, Union\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass BlackCat(BaseModel):\n    pet_type: Literal['blackcat']\n\n\nclass WhiteCat(BaseModel):\n    pet_type: Literal['whitecat']\n\n\nclass Model(BaseModel):\n    cat: Union[BlackCat, WhiteCat] = Field(discriminator='pet_type')\n\n\ntry:\n    Model(cat={'pet_type': 'dog'})\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'union_tag_invalid'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#union_tag_invalid", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`union_tag_not_found`", "anchor": "union_tag_not_found", "heading_level": 2, "md_text": "This error is raised when it is not possible to extract a discriminator value from the input:\n\n```python\nfrom typing import Literal, Union\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass BlackCat(BaseModel):\n    pet_type: Literal['blackcat']\n\n\nclass WhiteCat(BaseModel):\n    pet_type: Literal['whitecat']\n\n\nclass Model(BaseModel):\n    cat: Union[BlackCat, WhiteCat] = Field(discriminator='pet_type')\n\n\ntry:\n    Model(cat={'name': 'blackcat'})\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'union_tag_not_found'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#union_tag_not_found", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`url_parsing`", "anchor": "url_parsing", "heading_level": 2, "md_text": "This error is raised when the input value cannot be parsed as a URL:\n\n```python\nfrom pydantic import AnyUrl, BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: AnyUrl\n\n\ntry:\n    Model(x='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'url_parsing'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#url_parsing", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`url_scheme`", "anchor": "url_scheme", "heading_level": 2, "md_text": "This error is raised when the URL scheme is not valid for the URL type of the field:\n\n```python\nfrom pydantic import BaseModel, HttpUrl, ValidationError\n\n\nclass Model(BaseModel):\n    x: HttpUrl\n\n\ntry:\n    Model(x='ftp://example.com')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'url_scheme'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#url_scheme", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`url_syntax_violation`", "anchor": "url_syntax_violation", "heading_level": 2, "md_text": "This error is raised when the URL syntax is not valid:\n\n```python\nfrom pydantic import BaseModel, Field, HttpUrl, ValidationError\n\n\nclass Model(BaseModel):\n    x: HttpUrl = Field(strict=True)\n\n\ntry:\n    Model(x='http:////example.com')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'url_syntax_violation'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#url_syntax_violation", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`url_too_long`", "anchor": "url_too_long", "heading_level": 2, "md_text": "This error is raised when the URL length is greater than 2083:\n\n```python\nfrom pydantic import BaseModel, HttpUrl, ValidationError\n\n\nclass Model(BaseModel):\n    x: HttpUrl\n\n\ntry:\n    Model(x='x' * 2084)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'url_too_long'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#url_too_long", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`url_type`", "anchor": "url_type", "heading_level": 2, "md_text": "This error is raised when the input value's type is not valid for a URL field:\n\n```python\nfrom pydantic import BaseModel, HttpUrl, ValidationError\n\n\nclass Model(BaseModel):\n    x: HttpUrl\n\n\ntry:\n    Model(x=None)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'url_type'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#url_type", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`uuid_parsing`", "anchor": "uuid_parsing", "heading_level": 2, "md_text": "This error is raised when the input value's type is not valid for a UUID field:\n\n```python\nfrom uuid import UUID\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    u: UUID\n\n\ntry:\n    Model(u='12345678-124-1234-1234-567812345678')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'uuid_parsing'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#uuid_parsing", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`uuid_type`", "anchor": "uuid_type", "heading_level": 2, "md_text": "This error is raised when the input value's type is not valid instance for a UUID field (str, bytes or UUID):\n\n```python\nfrom uuid import UUID\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    u: UUID\n\n\ntry:\n    Model(u=1234567812412341234567812345678)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'uuid_type'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#uuid_type", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`uuid_version`", "anchor": "uuid_version", "heading_level": 2, "md_text": "This error is raised when the input value's type is not match UUID version:\n\n```python\nfrom pydantic import UUID5, BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    u: UUID5\n\n\ntry:\n    Model(u='a6cc5730-2261-11ee-9c43-2eb5a363657c')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'uuid_version'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#uuid_version", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "`value_error`", "anchor": "value_error", "heading_level": 2, "md_text": "This error is raised when a `ValueError` is raised during validation:\n\n```python\nfrom pydantic import BaseModel, ValidationError, field_validator\n\n\nclass Model(BaseModel):\n    x: str\n\n    @field_validator('x')\n    @classmethod\n    def repeat_b(cls, v):\n        raise ValueError()\n\n\ntry:\n    Model(x='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'value_error'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/validation_errors/#value_error", "page": "docs/errors/validation_errors", "source_site": "pydantic"}
{"title": "usage_errors", "anchor": null, "heading_level": 0, "md_text": "Pydantic attempts to provide useful errors. The following sections provide details on common errors developers may\nencounter when working with Pydantic, along with suggestions for addressing the error condition.", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "Class not fully defined {#class-not-fully-defined}", "anchor": "class-not-fully-defined-class-not-fully-defined", "heading_level": 2, "md_text": "This error is raised when a type referenced in an annotation of a pydantic-validated type\n(such as a subclass of `BaseModel`, or a pydantic `dataclass`) is not defined:\n\n```python\nfrom typing import ForwardRef\n\nfrom pydantic import BaseModel, PydanticUserError\n\nUndefinedType = ForwardRef('UndefinedType')\n\n\nclass Foobar(BaseModel):\n    a: UndefinedType\n\n\ntry:\n    Foobar(a=1)\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'class-not-fully-defined'\n```\n\nOr when the type has been defined after usage:\n\n```python\nfrom typing import Optional\n\nfrom pydantic import BaseModel, PydanticUserError\n\n\nclass Foo(BaseModel):\n    a: Optional['Bar'] = None\n\n\ntry:\n    # this doesn't work, see raised error\n    foo = Foo(a={'b': {'a': None}})\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'class-not-fully-defined'\n\n\nclass Bar(BaseModel):\n    b: 'Foo'", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#class-not-fully-defined-class-not-fully-defined", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "this works, though", "anchor": "this-works-though", "heading_level": 1, "md_text": "foo = Foo(a={'b': {'a': None}})\n```\n\nFor BaseModel subclasses, it can be fixed by defining the type and then calling `.model_rebuild()`:\n\n```python\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    a: Optional['Bar'] = None\n\n\nclass Bar(BaseModel):\n    b: 'Foo'\n\n\nFoo.model_rebuild()\n\nfoo = Foo(a={'b': {'a': None}})\n```\n\nIn other cases, the error message should indicate how to rebuild the class with the appropriate type defined.", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#this-works-though", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "Custom JSON Schema {#custom-json-schema}", "anchor": "custom-json-schema-custom-json-schema", "heading_level": 2, "md_text": "The `__modify_schema__` method is no longer supported in V2. You should use the `__get_pydantic_json_schema__` method instead.\n\nThe `__modify_schema__` used to receive a single argument representing the JSON schema. See the example below:\n\n```python {title=\"Old way\"}\nfrom pydantic import BaseModel, PydanticUserError\n\ntry:\n\n    class Model(BaseModel):\n        @classmethod\n        def __modify_schema__(cls, field_schema):\n            field_schema.update(examples=['example'])\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'custom-json-schema'\n```\n\nThe new method `__get_pydantic_json_schema__` receives two arguments: the first is a dictionary denoted as `CoreSchema`,\nand the second a callable `handler` that receives a `CoreSchema` as parameter, and returns a JSON schema. See the example\nbelow:\n\n```python {title=\"New way\"}\nfrom typing import Any\n\nfrom pydantic_core import CoreSchema\n\nfrom pydantic import BaseModel, GetJsonSchemaHandler\n\n\nclass Model(BaseModel):\n    @classmethod\n    def __get_pydantic_json_schema__(\n        cls, core_schema: CoreSchema, handler: GetJsonSchemaHandler\n    ) -> dict[str, Any]:\n        json_schema = super().__get_pydantic_json_schema__(core_schema, handler)\n        json_schema = handler.resolve_ref_schema(json_schema)\n        json_schema.update(examples=['example'])\n        return json_schema\n\n\nprint(Model.model_json_schema())\n\"\"\"\n{'examples': ['example'], 'properties': {}, 'title': 'Model', 'type': 'object'}\n\"\"\"\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#custom-json-schema-custom-json-schema", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "Decorator on missing field {#decorator-missing-field}", "anchor": "decorator-on-missing-field-decorator-missing-field", "heading_level": 2, "md_text": "This error is raised when you define a decorator with a field that is not valid.\n\n```python\nfrom typing import Any\n\nfrom pydantic import BaseModel, PydanticUserError, field_validator\n\ntry:\n\n    class Model(BaseModel):\n        a: str\n\n        @field_validator('b')\n        def check_b(cls, v: Any):\n            return v\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'decorator-missing-field'\n```\n\nYou can use `check_fields=False` if you're inheriting from the model and intended this.\n\n```python\nfrom typing import Any\n\nfrom pydantic import BaseModel, create_model, field_validator\n\n\nclass Model(BaseModel):\n    @field_validator('a', check_fields=False)\n    def check_a(cls, v: Any):\n        return v\n\n\nmodel = create_model('FooModel', a=(str, 'cake'), __base__=Model)\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#decorator-on-missing-field-decorator-missing-field", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "Discriminator no field {#discriminator-no-field}", "anchor": "discriminator-no-field-discriminator-no-field", "heading_level": 2, "md_text": "This error is raised when a model in discriminated unions doesn't define a discriminator field.\n\n```python\nfrom typing import Literal, Union\n\nfrom pydantic import BaseModel, Field, PydanticUserError\n\n\nclass Cat(BaseModel):\n    c: str\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n    d: str\n\n\ntry:\n\n    class Model(BaseModel):\n        pet: Union[Cat, Dog] = Field(discriminator='pet_type')\n        number: int\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'discriminator-no-field'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#discriminator-no-field-discriminator-no-field", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "Discriminator alias type {#discriminator-alias-type}", "anchor": "discriminator-alias-type-discriminator-alias-type", "heading_level": 2, "md_text": "This error is raised when you define a non-string alias on a discriminator field.\n\n```python\nfrom typing import Literal, Union\n\nfrom pydantic import AliasChoices, BaseModel, Field, PydanticUserError\n\n\nclass Cat(BaseModel):\n    pet_type: Literal['cat'] = Field(\n        validation_alias=AliasChoices('Pet', 'PET')\n    )\n    c: str\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n    d: str\n\n\ntry:\n\n    class Model(BaseModel):\n        pet: Union[Cat, Dog] = Field(discriminator='pet_type')\n        number: int\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'discriminator-alias-type'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#discriminator-alias-type-discriminator-alias-type", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "Discriminator needs literal {#discriminator-needs-literal}", "anchor": "discriminator-needs-literal-discriminator-needs-literal", "heading_level": 2, "md_text": "This error is raised when you define a non-`Literal` type on a discriminator field.\n\n```python\nfrom typing import Literal, Union\n\nfrom pydantic import BaseModel, Field, PydanticUserError\n\n\nclass Cat(BaseModel):\n    pet_type: int\n    c: str\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n    d: str\n\n\ntry:\n\n    class Model(BaseModel):\n        pet: Union[Cat, Dog] = Field(discriminator='pet_type')\n        number: int\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'discriminator-needs-literal'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#discriminator-needs-literal-discriminator-needs-literal", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "Discriminator alias {#discriminator-alias}", "anchor": "discriminator-alias-discriminator-alias", "heading_level": 2, "md_text": "This error is raised when you define different aliases on discriminator fields.\n\n```python\nfrom typing import Literal, Union\n\nfrom pydantic import BaseModel, Field, PydanticUserError\n\n\nclass Cat(BaseModel):\n    pet_type: Literal['cat'] = Field(validation_alias='PET')\n    c: str\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog'] = Field(validation_alias='Pet')\n    d: str\n\n\ntry:\n\n    class Model(BaseModel):\n        pet: Union[Cat, Dog] = Field(discriminator='pet_type')\n        number: int\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'discriminator-alias'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#discriminator-alias-discriminator-alias", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "Invalid discriminator validator {#discriminator-validator}", "anchor": "invalid-discriminator-validator-discriminator-validator", "heading_level": 2, "md_text": "This error is raised when you use a before, wrap, or plain validator on a discriminator field.\n\nThis is disallowed because the discriminator field is used to determine the type of the model to use for validation,\nso you can't use a validator that might change its value.\n\n```python\nfrom typing import Literal, Union\n\nfrom pydantic import BaseModel, Field, PydanticUserError, field_validator\n\n\nclass Cat(BaseModel):\n    pet_type: Literal['cat']\n\n    @field_validator('pet_type', mode='before')\n    @classmethod\n    def validate_pet_type(cls, v):\n        if v == 'kitten':\n            return 'cat'\n        return v\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n\n\ntry:\n\n    class Model(BaseModel):\n        pet: Union[Cat, Dog] = Field(discriminator='pet_type')\n        number: int\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'discriminator-validator'\n```\n\nThis can be worked around by using a standard `Union`, dropping the discriminator:\n\n```python\nfrom typing import Literal, Union\n\nfrom pydantic import BaseModel, field_validator\n\n\nclass Cat(BaseModel):\n    pet_type: Literal['cat']\n\n    @field_validator('pet_type', mode='before')\n    @classmethod\n    def validate_pet_type(cls, v):\n        if v == 'kitten':\n            return 'cat'\n        return v\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n\n\nclass Model(BaseModel):\n    pet: Union[Cat, Dog]\n\n\nassert Model(pet={'pet_type': 'kitten'}).pet.pet_type == 'cat'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#invalid-discriminator-validator-discriminator-validator", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "Callable discriminator case with no tag {#callable-discriminator-no-tag}", "anchor": "callable-discriminator-case-with-no-tag-callable-discriminator-no-tag", "heading_level": 2, "md_text": "This error is raised when a `Union` that uses a callable `Discriminator` doesn't have `Tag` annotations for all cases.\n\n```python\nfrom typing import Annotated, Union\n\nfrom pydantic import BaseModel, Discriminator, PydanticUserError, Tag\n\n\ndef model_x_discriminator(v):\n    if isinstance(v, str):\n        return 'str'\n    if isinstance(v, (dict, BaseModel)):\n        return 'model'", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#callable-discriminator-case-with-no-tag-callable-discriminator-no-tag", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "tag missing for both union choices", "anchor": "tag-missing-for-both-union-choices", "heading_level": 1, "md_text": "try:\n\n    class DiscriminatedModel(BaseModel):\n        x: Annotated[\n            Union[str, 'DiscriminatedModel'],\n            Discriminator(model_x_discriminator),\n        ]\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'callable-discriminator-no-tag'", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#tag-missing-for-both-union-choices", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "tag missing for `'DiscriminatedModel'` union choice", "anchor": "tag-missing-for-discriminatedmodel-union-choice", "heading_level": 1, "md_text": "try:\n\n    class DiscriminatedModel(BaseModel):\n        x: Annotated[\n            Union[Annotated[str, Tag('str')], 'DiscriminatedModel'],\n            Discriminator(model_x_discriminator),\n        ]\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'callable-discriminator-no-tag'", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#tag-missing-for-discriminatedmodel-union-choice", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "tag missing for `str` union choice", "anchor": "tag-missing-for-str-union-choice", "heading_level": 1, "md_text": "try:\n\n    class DiscriminatedModel(BaseModel):\n        x: Annotated[\n            Union[str, Annotated['DiscriminatedModel', Tag('model')]],\n            Discriminator(model_x_discriminator),\n        ]\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'callable-discriminator-no-tag'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#tag-missing-for-str-union-choice", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "`TypedDict` version {#typed-dict-version}", "anchor": "typeddict-version-typed-dict-version", "heading_level": 2, "md_text": "This error is raised when you use [typing.TypedDict][]\ninstead of `typing_extensions.TypedDict` on Python < 3.12.", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#typeddict-version-typed-dict-version", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "Model parent field overridden {#model-field-overridden}", "anchor": "model-parent-field-overridden-model-field-overridden", "heading_level": 2, "md_text": "This error is raised when a field defined on a base class was overridden by a non-annotated attribute.\n\n```python\nfrom pydantic import BaseModel, PydanticUserError\n\n\nclass Foo(BaseModel):\n    a: float\n\n\ntry:\n\n    class Bar(Foo):\n        x: float = 12.3\n        a = 123.0\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'model-field-overridden'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#model-parent-field-overridden-model-field-overridden", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "Model field missing annotation {#model-field-missing-annotation}", "anchor": "model-field-missing-annotation-model-field-missing-annotation", "heading_level": 2, "md_text": "This error is raised when a field doesn't have an annotation.\n\n```python\nfrom pydantic import BaseModel, Field, PydanticUserError\n\ntry:\n\n    class Model(BaseModel):\n        a = Field('foobar')\n        b = None\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'model-field-missing-annotation'\n```\n\nIf the field is not meant to be a field, you may be able to resolve the error\nby annotating it as a `ClassVar`:\n\n```python\nfrom typing import ClassVar\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    a: ClassVar[str]\n```\n\nOr updating `model_config['ignored_types']`:\n\n```python\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass IgnoredType:\n    pass\n\n\nclass MyModel(BaseModel):\n    model_config = ConfigDict(ignored_types=(IgnoredType,))\n\n    _a = IgnoredType()\n    _b: int = IgnoredType()\n    _c: IgnoredType\n    _d: IgnoredType = IgnoredType()\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#model-field-missing-annotation-model-field-missing-annotation", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "`Config` and `model_config` both defined {#config-both}", "anchor": "config-and-model_config-both-defined-config-both", "heading_level": 2, "md_text": "This error is raised when `class Config` and `model_config` are used together.\n\n```python\nfrom pydantic import BaseModel, ConfigDict, PydanticUserError\n\ntry:\n\n    class Model(BaseModel):\n        model_config = ConfigDict(from_attributes=True)\n\n        a: str\n\n        class Config:\n            from_attributes = True\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'config-both'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#config-and-model_config-both-defined-config-both", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "Keyword arguments removed {#removed-kwargs}", "anchor": "keyword-arguments-removed-removed-kwargs", "heading_level": 2, "md_text": "This error is raised when the keyword arguments are not available in Pydantic V2.\n\nFor example, `regex` is removed from Pydantic V2:\n\n```python\nfrom pydantic import BaseModel, Field, PydanticUserError\n\ntry:\n\n    class Model(BaseModel):\n        x: str = Field(regex='test')\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'removed-kwargs'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#keyword-arguments-removed-removed-kwargs", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "Circular reference schema {#circular-reference-schema}", "anchor": "circular-reference-schema-circular-reference-schema", "heading_level": 2, "md_text": "This error is raised when a circular reference is found that would otherwise result in an infinite recursion.\n\nFor example, this is a valid type alias:\n\n```python {test=\"skip\" lint=\"skip\" upgrade=\"skip\"}\ntype A = list[A] | None\n```\n\nwhile these are not:\n\n```python {test=\"skip\" lint=\"skip\" upgrade=\"skip\"}\ntype A = A\n\ntype B = C\ntype C = B\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#circular-reference-schema-circular-reference-schema", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "JSON schema invalid type {#invalid-for-json-schema}", "anchor": "json-schema-invalid-type-invalid-for-json-schema", "heading_level": 2, "md_text": "This error is raised when Pydantic fails to generate a JSON schema for some `CoreSchema`.\n\n```python\nfrom pydantic import BaseModel, ImportString, PydanticUserError\n\n\nclass Model(BaseModel):\n    a: ImportString\n\n\ntry:\n    Model.model_json_schema()\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'invalid-for-json-schema'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#json-schema-invalid-type-invalid-for-json-schema", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "JSON schema already used {#json-schema-already-used}", "anchor": "json-schema-already-used-json-schema-already-used", "heading_level": 2, "md_text": "This error is raised when the JSON schema generator has already been used to generate a JSON schema.\nYou must create a new instance to generate a new JSON schema.", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#json-schema-already-used-json-schema-already-used", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "BaseModel instantiated {#base-model-instantiated}", "anchor": "basemodel-instantiated-base-model-instantiated", "heading_level": 2, "md_text": "This error is raised when you instantiate `BaseModel` directly. Pydantic models should inherit from `BaseModel`.\n\n```python\nfrom pydantic import BaseModel, PydanticUserError\n\ntry:\n    BaseModel()\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'base-model-instantiated'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#basemodel-instantiated-base-model-instantiated", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "Undefined annotation {#undefined-annotation}", "anchor": "undefined-annotation-undefined-annotation", "heading_level": 2, "md_text": "This error is raised when handling undefined annotations during `CoreSchema` generation.\n\n```python\nfrom pydantic import BaseModel, PydanticUndefinedAnnotation\n\n\nclass Model(BaseModel):\n    a: 'B'  # noqa F821\n\n\ntry:\n    Model.model_rebuild()\nexcept PydanticUndefinedAnnotation as exc_info:\n    assert exc_info.code == 'undefined-annotation'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#undefined-annotation-undefined-annotation", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "Schema for unknown type {#schema-for-unknown-type}", "anchor": "schema-for-unknown-type-schema-for-unknown-type", "heading_level": 2, "md_text": "This error is raised when Pydantic fails to generate a `CoreSchema` for some type.\n\n```python\nfrom pydantic import BaseModel, PydanticUserError\n\ntry:\n\n    class Model(BaseModel):\n        x: 43 = 123\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'schema-for-unknown-type'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#schema-for-unknown-type-schema-for-unknown-type", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "Import error {#import-error}", "anchor": "import-error-import-error", "heading_level": 2, "md_text": "This error is raised when you try to import an object that was available in Pydantic V1, but has been removed in\nPydantic V2.\n\nSee the [Migration Guide](../migration.md) for more information.", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#import-error-import-error", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "`create_model` field definitions {#create-model-field-definitions}", "anchor": "create_model-field-definitions-create-model-field-definitions", "heading_level": 2, "md_text": "This error is raised when you provide invalid field definitions in [`create_model()`][pydantic.create_model].\n\n```python\nfrom pydantic import PydanticUserError, create_model\n\ntry:\n    create_model('FooModel', foo=(str, 'default value', 'more'))\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'create-model-field-definitions'\n```\n\nThe fields definition syntax can be found in the [dynamic model creation](../concepts/models.md#dynamic-model-creation) documentation.", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#create_model-field-definitions-create-model-field-definitions", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "Validator with no fields {#validator-no-fields}", "anchor": "validator-with-no-fields-validator-no-fields", "heading_level": 2, "md_text": "This error is raised when you use validator bare (with no fields).\n\n```python\nfrom pydantic import BaseModel, PydanticUserError, field_validator\n\ntry:\n\n    class Model(BaseModel):\n        a: str\n\n        @field_validator\n        def checker(cls, v):\n            return v\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'validator-no-fields'\n```\n\nValidators should be used with fields and keyword arguments.\n\n```python\nfrom pydantic import BaseModel, field_validator\n\n\nclass Model(BaseModel):\n    a: str\n\n    @field_validator('a')\n    def checker(cls, v):\n        return v\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#validator-with-no-fields-validator-no-fields", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "Invalid validator fields {#validator-invalid-fields}", "anchor": "invalid-validator-fields-validator-invalid-fields", "heading_level": 2, "md_text": "This error is raised when you use a validator with non-string fields.\n\n```python\nfrom pydantic import BaseModel, PydanticUserError, field_validator\n\ntry:\n\n    class Model(BaseModel):\n        a: str\n        b: str\n\n        @field_validator(['a', 'b'])\n        def check_fields(cls, v):\n            return v\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'validator-invalid-fields'\n```\n\nFields should be passed as separate string arguments:\n\n```python\nfrom pydantic import BaseModel, field_validator\n\n\nclass Model(BaseModel):\n    a: str\n    b: str\n\n    @field_validator('a', 'b')\n    def check_fields(cls, v):\n        return v\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#invalid-validator-fields-validator-invalid-fields", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "Validator on instance method {#validator-instance-method}", "anchor": "validator-on-instance-method-validator-instance-method", "heading_level": 2, "md_text": "This error is raised when you apply a validator on an instance method.\n\n```python\nfrom pydantic import BaseModel, PydanticUserError, field_validator\n\ntry:\n\n    class Model(BaseModel):\n        a: int = 1\n\n        @field_validator('a')\n        def check_a(self, value):\n            return value\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'validator-instance-method'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#validator-on-instance-method-validator-instance-method", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "`json_schema_input_type` used with the wrong mode {#validator-input-type}", "anchor": "json_schema_input_type-used-with-the-wrong-mode-validator-input-type", "heading_level": 2, "md_text": "This error is raised when you explicitly specify a value for the `json_schema_input_type`\nargument and `mode` isn't set to either `'before'`, `'plain'` or `'wrap'`.\n\n```python\nfrom pydantic import BaseModel, PydanticUserError, field_validator\n\ntry:\n\n    class Model(BaseModel):\n        a: int = 1\n\n        @field_validator('a', mode='after', json_schema_input_type=int)\n        @classmethod\n        def check_a(self, value):\n            return value\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'validator-input-type'\n```\n\nDocumenting the JSON Schema input type is only possible for validators where the given\nvalue can be anything. That is why it isn't available for `after` validators, where\nthe value is first validated against the type annotation.", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#json_schema_input_type-used-with-the-wrong-mode-validator-input-type", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "Root validator, `pre`, `skip_on_failure` {#root-validator-pre-skip}", "anchor": "root-validator-pre-skip_on_failure-root-validator-pre-skip", "heading_level": 2, "md_text": "If you use `@root_validator` with `pre=False` (the default) you MUST specify `skip_on_failure=True`.\nThe `skip_on_failure=False` option is no longer available.\n\nIf you were not trying to set `skip_on_failure=False`, you can safely set `skip_on_failure=True`.\nIf you do, this root validator will no longer be called if validation fails for any of the fields.\n\nPlease see the [Migration Guide](../migration.md) for more details.", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#root-validator-pre-skip_on_failure-root-validator-pre-skip", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "`model_serializer` instance methods {#model-serializer-instance-method}", "anchor": "model_serializer-instance-methods-model-serializer-instance-method", "heading_level": 2, "md_text": "`@model_serializer` must be applied to instance methods.\n\nThis error is raised when you apply `model_serializer` on an instance method without `self`:\n\n```python\nfrom pydantic import BaseModel, PydanticUserError, model_serializer\n\ntry:\n\n    class MyModel(BaseModel):\n        a: int\n\n        @model_serializer\n        def _serialize(slf, x, y, z):\n            return slf\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'model-serializer-instance-method'\n```\n\nOr on a class method:\n\n```python\nfrom pydantic import BaseModel, PydanticUserError, model_serializer\n\ntry:\n\n    class MyModel(BaseModel):\n        a: int\n\n        @model_serializer\n        @classmethod\n        def _serialize(self, x, y, z):\n            return self\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'model-serializer-instance-method'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#model_serializer-instance-methods-model-serializer-instance-method", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "`validator`, `field`, `config`, and `info` {#validator-field-config-info}", "anchor": "validator-field-config-and-info-validator-field-config-info", "heading_level": 2, "md_text": "The `field` and `config` parameters are not available in Pydantic V2.\nPlease use the `info` parameter instead.\n\nYou can access the configuration via `info.config`,\nbut it is a dictionary instead of an object like it was in Pydantic V1.\n\nThe `field` argument is no longer available.", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#validator-field-config-and-info-validator-field-config-info", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "Pydantic V1 validator signature {#validator-v1-signature}", "anchor": "pydantic-v1-validator-signature-validator-v1-signature", "heading_level": 2, "md_text": "This error is raised when you use an unsupported signature for Pydantic V1-style validator.\n\n```python\nimport warnings\n\nfrom pydantic import BaseModel, PydanticUserError, validator\n\nwarnings.filterwarnings('ignore', category=DeprecationWarning)\n\ntry:\n\n    class Model(BaseModel):\n        a: int\n\n        @validator('a')\n        def check_a(cls, value, foo):\n            return value\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'validator-v1-signature'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#pydantic-v1-validator-signature-validator-v1-signature", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "Unrecognized `field_validator` signature {#validator-signature}", "anchor": "unrecognized-field_validator-signature-validator-signature", "heading_level": 2, "md_text": "This error is raised when a `field_validator` or `model_validator` function has the wrong signature.\n\n```python\nfrom pydantic import BaseModel, PydanticUserError, field_validator\n\ntry:\n\n    class Model(BaseModel):\n        a: str\n\n        @field_validator('a')\n        @classmethod\n        def check_a(cls):\n            return 'a'\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'validator-signature'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#unrecognized-field_validator-signature-validator-signature", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "Unrecognized `field_serializer` signature {#field-serializer-signature}", "anchor": "unrecognized-field_serializer-signature-field-serializer-signature", "heading_level": 2, "md_text": "This error is raised when the `field_serializer` function has the wrong signature.\n\n```python\nfrom pydantic import BaseModel, PydanticUserError, field_serializer\n\ntry:\n\n    class Model(BaseModel):\n        x: int\n\n        @field_serializer('x')\n        def no_args():\n            return 'x'\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'field-serializer-signature'\n```\n\nValid field serializer signatures are:\n\n```python {test=\"skip\" lint=\"skip\" upgrade=\"skip\"}\nfrom pydantic import FieldSerializationInfo, SerializerFunctionWrapHandler, field_serializer", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#unrecognized-field_serializer-signature-field-serializer-signature", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "an instance method with the default mode or `mode='plain'`", "anchor": "an-instance-method-with-the-default-mode-or-modeplain", "heading_level": 1, "md_text": "@field_serializer('x')  # or @field_serializer('x', mode='plain')\ndef ser_x(self, value: Any, info: FieldSerializationInfo): ...", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#an-instance-method-with-the-default-mode-or-modeplain", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "a static method or function with the default mode or `mode='plain'`", "anchor": "a-static-method-or-function-with-the-default-mode-or-modeplain", "heading_level": 1, "md_text": "@field_serializer('x')  # or @field_serializer('x', mode='plain')\n@staticmethod\ndef ser_x(value: Any, info: FieldSerializationInfo): ...", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#a-static-method-or-function-with-the-default-mode-or-modeplain", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "equivalent to", "anchor": "equivalent-to", "heading_level": 1, "md_text": "def ser_x(value: Any, info: FieldSerializationInfo): ...\nserializer('x')(ser_x)", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#equivalent-to", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "an instance method with `mode='wrap'`", "anchor": "an-instance-method-with-modewrap", "heading_level": 1, "md_text": "@field_serializer('x', mode='wrap')\ndef ser_x(self, value: Any, nxt: SerializerFunctionWrapHandler, info: FieldSerializationInfo): ...", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#an-instance-method-with-modewrap", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "a static method or function with `mode='wrap'`", "anchor": "a-static-method-or-function-with-modewrap", "heading_level": 1, "md_text": "@field_serializer('x', mode='wrap')\n@staticmethod\ndef ser_x(value: Any, nxt: SerializerFunctionWrapHandler, info: FieldSerializationInfo): ...", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#a-static-method-or-function-with-modewrap", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "equivalent to", "anchor": "equivalent-to", "heading_level": 1, "md_text": "def ser_x(value: Any, nxt: SerializerFunctionWrapHandler, info: FieldSerializationInfo): ...\nserializer('x')(ser_x)", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#equivalent-to", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "For all of these, you can also choose to omit the `info` argument, for example:", "anchor": "for-all-of-these-you-can-also-choose-to-omit-the-info-argument-for-example", "heading_level": 1, "md_text": "@field_serializer('x')\ndef ser_x(self, value: Any): ...\n\n@field_serializer('x', mode='wrap')\ndef ser_x(self, value: Any, handler: SerializerFunctionWrapHandler): ...\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#for-all-of-these-you-can-also-choose-to-omit-the-info-argument-for-example", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "Unrecognized `model_serializer` signature {#model-serializer-signature}", "anchor": "unrecognized-model_serializer-signature-model-serializer-signature", "heading_level": 2, "md_text": "This error is raised when the `model_serializer` function has the wrong signature.\n\n```python\nfrom pydantic import BaseModel, PydanticUserError, model_serializer\n\ntry:\n\n    class MyModel(BaseModel):\n        a: int\n\n        @model_serializer\n        def _serialize(self, x, y, z):\n            return self\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'model-serializer-signature'\n```\n\nValid model serializer signatures are:\n\n```python {test=\"skip\" lint=\"skip\" upgrade=\"skip\"}\nfrom pydantic import SerializerFunctionWrapHandler, SerializationInfo, model_serializer", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#unrecognized-model_serializer-signature-model-serializer-signature", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "an instance method with the default mode or `mode='plain'`", "anchor": "an-instance-method-with-the-default-mode-or-modeplain", "heading_level": 1, "md_text": "@model_serializer  # or model_serializer(mode='plain')\ndef mod_ser(self, info: SerializationInfo): ...", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#an-instance-method-with-the-default-mode-or-modeplain", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "an instance method with `mode='wrap'`", "anchor": "an-instance-method-with-modewrap", "heading_level": 1, "md_text": "@model_serializer(mode='wrap')\ndef mod_ser(self, handler: SerializerFunctionWrapHandler, info: SerializationInfo):", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#an-instance-method-with-modewrap", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "For all of these, you can also choose to omit the `info` argument, for example:", "anchor": "for-all-of-these-you-can-also-choose-to-omit-the-info-argument-for-example", "heading_level": 1, "md_text": "@model_serializer(mode='plain')\ndef mod_ser(self): ...\n\n@model_serializer(mode='wrap')\ndef mod_ser(self, handler: SerializerFunctionWrapHandler): ...\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#for-all-of-these-you-can-also-choose-to-omit-the-info-argument-for-example", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "Multiple field serializers {#multiple-field-serializers}", "anchor": "multiple-field-serializers-multiple-field-serializers", "heading_level": 2, "md_text": "This error is raised when multiple `model_serializer` functions are defined for a field.\n\n```python\nfrom pydantic import BaseModel, PydanticUserError, field_serializer\n\ntry:\n\n    class MyModel(BaseModel):\n        x: int\n        y: int\n\n        @field_serializer('x', 'y')\n        def serializer1(v):\n            return f'{v:,}'\n\n        @field_serializer('x')\n        def serializer2(v):\n            return v\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'multiple-field-serializers'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#multiple-field-serializers-multiple-field-serializers", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "Invalid annotated type {#invalid-annotated-type}", "anchor": "invalid-annotated-type-invalid-annotated-type", "heading_level": 2, "md_text": "This error is raised when an annotation cannot annotate a type.\n\n```python\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, FutureDate, PydanticUserError\n\ntry:\n\n    class Model(BaseModel):\n        foo: Annotated[str, FutureDate()]\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'invalid-annotated-type'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#invalid-annotated-type-invalid-annotated-type", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "`config` is unused with `TypeAdapter` {#type-adapter-config-unused}", "anchor": "config-is-unused-with-typeadapter-type-adapter-config-unused", "heading_level": 2, "md_text": "You will get this error if you try to pass `config` to `TypeAdapter` when the type is a type that\nhas its own config that cannot be overridden (currently this is only `BaseModel`, `TypedDict` and `dataclass`):\n\n```python\nfrom typing_extensions import TypedDict\n\nfrom pydantic import ConfigDict, PydanticUserError, TypeAdapter\n\n\nclass MyTypedDict(TypedDict):\n    x: int\n\n\ntry:\n    TypeAdapter(MyTypedDict, config=ConfigDict(strict=True))\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'type-adapter-config-unused'\n```\n\nInstead you'll need to subclass the type and override or set the config on it:\n\n```python\nfrom typing_extensions import TypedDict\n\nfrom pydantic import ConfigDict, TypeAdapter\n\n\nclass MyTypedDict(TypedDict):\n    x: int\n\n    # or `model_config = ...` for BaseModel\n    __pydantic_config__ = ConfigDict(strict=True)\n\n\nTypeAdapter(MyTypedDict)  # ok\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#config-is-unused-with-typeadapter-type-adapter-config-unused", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "Cannot specify `model_config['extra']` with `RootModel` {#root-model-extra}", "anchor": "cannot-specify-model_configextra-with-rootmodel-root-model-extra", "heading_level": 2, "md_text": "Because `RootModel` is not capable of storing or even accepting extra fields during initialization, we raise an error\nif you try to specify a value for the config setting `'extra'` when creating a subclass of `RootModel`:\n\n```python\nfrom pydantic import PydanticUserError, RootModel\n\ntry:\n\n    class MyRootModel(RootModel):\n        model_config = {'extra': 'allow'}\n        root: int\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'root-model-extra'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#cannot-specify-model_configextra-with-rootmodel-root-model-extra", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "Cannot evaluate type annotation {#unevaluable-type-annotation}", "anchor": "cannot-evaluate-type-annotation-unevaluable-type-annotation", "heading_level": 2, "md_text": "Because type annotations are evaluated *after* assignments, you might get unexpected results when using a type annotation name\nthat clashes with one of your fields. We raise an error in the following case:\n\n```python {test=\"skip\"}\nfrom datetime import date\n\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    date: date = Field(description='A date')\n```\n\nAs a workaround, you can either use an alias or change your import:\n\n```python {lint=\"skip\"}\nimport datetime", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#cannot-evaluate-type-annotation-unevaluable-type-annotation", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "Or `from datetime import date as _date`", "anchor": "or-from-datetime-import-date-as-_date", "heading_level": 1, "md_text": "from pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    date: datetime.date = Field(description='A date')\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#or-from-datetime-import-date-as-_date", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "Incompatible `dataclass` `init` and `extra` settings {#dataclass-init-false-extra-allow}", "anchor": "incompatible-dataclass-init-and-extra-settings-dataclass-init-false-extra-allow", "heading_level": 2, "md_text": "Pydantic does not allow the specification of the `extra='allow'` setting on a dataclass\nwhile any of the fields have `init=False` set.\n\nThus, you may not do something like the following:\n\n```python {test=\"skip\"}\nfrom pydantic import ConfigDict, Field\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass(config=ConfigDict(extra='allow'))\nclass A:\n    a: int = Field(init=False, default=1)\n```\n\nThe above snippet results in the following error during schema building for the `A` dataclass:\n\n```output\npydantic.errors.PydanticUserError: Field a has `init=False` and dataclass has config setting `extra=\"allow\"`.\nThis combination is not allowed.\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#incompatible-dataclass-init-and-extra-settings-dataclass-init-false-extra-allow", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "Incompatible `init` and `init_var` settings on `dataclass` field {#clashing-init-and-init-var}", "anchor": "incompatible-init-and-init_var-settings-on-dataclass-field-clashing-init-and-init-var", "heading_level": 2, "md_text": "The `init=False` and `init_var=True` settings are mutually exclusive. Doing so results in the `PydanticUserError` shown in the example below.\n\n```python {test=\"skip\"}\nfrom pydantic import Field\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass Foo:\n    bar: str = Field(init=False, init_var=True)\n\n\n\"\"\"\npydantic.errors.PydanticUserError: Dataclass field bar has init=False and init_var=True, but these are mutually exclusive.\n\"\"\"\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#incompatible-init-and-init_var-settings-on-dataclass-field-clashing-init-and-init-var", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "`model_config` is used as a model field {#model-config-invalid-field-name}", "anchor": "model_config-is-used-as-a-model-field-model-config-invalid-field-name", "heading_level": 2, "md_text": "This error is raised when `model_config` is used as the name of a field.\n\n```python\nfrom pydantic import BaseModel, PydanticUserError\n\ntry:\n\n    class Model(BaseModel):\n        model_config: str\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'model-config-invalid-field-name'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#model_config-is-used-as-a-model-field-model-config-invalid-field-name", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "[`with_config`][pydantic.config.with_config] is used on a `BaseModel` subclass {#with-config-on-model}", "anchor": "with_configpydanticconfigwith_config-is-used-on-a-basemodel-subclass-with-config-on-model", "heading_level": 2, "md_text": "This error is raised when the [`with_config`][pydantic.config.with_config] decorator is used on a class which is already a Pydantic model (use the `model_config` attribute instead).\n\n```python\nfrom pydantic import BaseModel, PydanticUserError, with_config\n\ntry:\n\n    @with_config({'allow_inf_nan': True})\n    class Model(BaseModel):\n        bar: str\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'with-config-on-model'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#with_configpydanticconfigwith_config-is-used-on-a-basemodel-subclass-with-config-on-model", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "`dataclass` is used on a `BaseModel` subclass {#dataclass-on-model}", "anchor": "dataclass-is-used-on-a-basemodel-subclass-dataclass-on-model", "heading_level": 2, "md_text": "This error is raised when the Pydantic `dataclass` decorator is used on a class which is already\na Pydantic model.\n\n```python\nfrom pydantic import BaseModel, PydanticUserError\nfrom pydantic.dataclasses import dataclass\n\ntry:\n\n    @dataclass\n    class Model(BaseModel):\n        bar: str\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'dataclass-on-model'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#dataclass-is-used-on-a-basemodel-subclass-dataclass-on-model", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "Unsupported type for `validate_call` {#validate-call-type}", "anchor": "unsupported-type-for-validate_call-validate-call-type", "heading_level": 2, "md_text": "`validate_call` has some limitations on the callables it can validate. This error is raised when you try to use it with an unsupported callable.\nCurrently the supported callables are functions (including lambdas, but not built-ins) and methods and instances of [`partial`][functools.partial].\nIn the case of [`partial`][functools.partial], the function being partially applied must be one of the supported callables.", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#unsupported-type-for-validate_call-validate-call-type", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "`@classmethod`, `@staticmethod`, and `@property`", "anchor": "classmethod-staticmethod-and-property", "heading_level": 3, "md_text": "These decorators must be put before `validate_call`.\n\n```python\nfrom pydantic import PydanticUserError, validate_call", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#classmethod-staticmethod-and-property", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "error", "anchor": "error", "heading_level": 1, "md_text": "try:\n\n    class A:\n        @validate_call\n        @classmethod\n        def f1(cls): ...\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'validate-call-type'", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#error", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "correct", "anchor": "correct", "heading_level": 1, "md_text": "@classmethod\n@validate_call\ndef f2(cls): ...\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#correct", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "Classes", "anchor": "classes", "heading_level": 3, "md_text": "While classes are callables themselves, `validate_call` can't be applied on them, as it needs to know about which method to use (`__init__` or `__new__`) to fetch type annotations. If you want to validate the constructor of a class, you should put `validate_call` on top of the appropriate method instead.\n\n```python\nfrom pydantic import PydanticUserError, validate_call", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#classes", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "error", "anchor": "error", "heading_level": 1, "md_text": "try:\n\n    @validate_call\n    class A1: ...\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'validate-call-type'", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#error", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "correct", "anchor": "correct", "heading_level": 1, "md_text": "class A2:\n    @validate_call\n    def __init__(self): ...\n\n    @validate_call\n    def __new__(cls): ...\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#correct", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "Callable instances", "anchor": "callable-instances", "heading_level": 3, "md_text": "Although instances can be callable by implementing a `__call__` method, currently the instances of these types cannot be validated with `validate_call`.\nThis may change in the future, but for now, you should use `validate_call` explicitly on `__call__` instead.\n\n```python\nfrom pydantic import PydanticUserError, validate_call", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#callable-instances", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "error", "anchor": "error", "heading_level": 1, "md_text": "try:\n\n    class A1:\n        def __call__(self): ...\n\n    validate_call(A1())\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'validate-call-type'", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#error", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "correct", "anchor": "correct", "heading_level": 1, "md_text": "class A2:\n    @validate_call\n    def __call__(self): ...\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#correct", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "Invalid signature", "anchor": "invalid-signature", "heading_level": 3, "md_text": "This is generally less common, but a possible reason is that you are trying to validate a method that doesn't have at least one argument (usually `self`).\n\n```python\nfrom pydantic import PydanticUserError, validate_call\n\ntry:\n\n    class A:\n        def f(): ...\n\n    validate_call(A().f)\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'validate-call-type'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#invalid-signature", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "[`Unpack`][typing.Unpack] used without a [`TypedDict`][typing.TypedDict] {#unpack-typed-dict}", "anchor": "unpacktypingunpack-used-without-a-typeddicttypingtypeddict-unpack-typed-dict", "heading_level": 2, "md_text": "This error is raised when [`Unpack`][typing.Unpack] is used with something other than\na [`TypedDict`][typing.TypedDict] class object to type hint variadic keyword parameters.\n\nFor reference, see the [related specification section] and [PEP 692].\n\n```python\nfrom typing_extensions import Unpack\n\nfrom pydantic import PydanticUserError, validate_call\n\ntry:\n\n    @validate_call\n    def func(**kwargs: Unpack[int]):\n        pass\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'unpack-typed-dict'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#unpacktypingunpack-used-without-a-typeddicttypingtypeddict-unpack-typed-dict", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "Overlapping unpacked [`TypedDict`][typing.TypedDict] fields and arguments {#overlapping-unpack-typed-dict}", "anchor": "overlapping-unpacked-typeddicttypingtypeddict-fields-and-arguments-overlapping-unpack-typed-dict", "heading_level": 2, "md_text": "This error is raised when the typed dictionary used to type hint variadic keywords parameters has field names\noverlapping with other parameters (unless [positional only][positional-only_parameter]).\n\nFor reference, see the [related specification section] and [PEP 692].\n\n```python\nfrom typing_extensions import TypedDict, Unpack\n\nfrom pydantic import PydanticUserError, validate_call\n\n\nclass TD(TypedDict):\n    a: int\n\n\ntry:\n\n    @validate_call\n    def func(a: int, **kwargs: Unpack[TD]):\n        pass\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'overlapping-unpack-typed-dict'\n```\n\n[related specification section]: https://typing.readthedocs.io/en/latest/spec/callables.html#unpack-for-keyword-arguments\n[PEP 692]: https://peps.python.org/pep-0692/", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#overlapping-unpacked-typeddicttypingtypeddict-fields-and-arguments-overlapping-unpack-typed-dict", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "Invalid `Self` type {#invalid-self-type}", "anchor": "invalid-self-type-invalid-self-type", "heading_level": 2, "md_text": "Currently, [`Self`][typing.Self] can only be used to annotate a field of a class (specifically, subclasses of [`BaseModel`][pydantic.BaseModel], [`NamedTuple`][typing.NamedTuple], [`TypedDict`][typing.TypedDict], or dataclasses). Attempting to use [`Self`][typing.Self] in any other ways will raise this error.\n\n```python\nfrom typing_extensions import Self\n\nfrom pydantic import PydanticUserError, validate_call\n\ntry:\n\n    @validate_call\n    def func(self: Self):\n        pass\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'invalid-self-type'\n```\n\nThe following example of [`validate_call()`][pydantic.validate_call] will also raise this error, even though it is correct from a type-checking perspective. This may be supported in the future.\n\n```python\nfrom typing_extensions import Self\n\nfrom pydantic import BaseModel, PydanticUserError, validate_call\n\ntry:\n\n    class A(BaseModel):\n        @validate_call\n        def func(self, arg: Self):\n            pass\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'invalid-self-type'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#invalid-self-type-invalid-self-type", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "`validate_by_alias` and `validate_by_name` both set to `False` {#validate-by-alias-and-name-false}", "anchor": "validate_by_alias-and-validate_by_name-both-set-to-false-validate-by-alias-and-name-false", "heading_level": 2, "md_text": "This error is raised when you set `validate_by_alias` and `validate_by_name` to `False` in the configuration.\n\nThis is not allowed because it would make it impossible to populate attributes.\n\n```python\nfrom pydantic import BaseModel, ConfigDict, Field, PydanticUserError\n\ntry:\n\n    class Model(BaseModel):\n        a: int = Field(alias='A')\n\n        model_config = ConfigDict(\n            validate_by_alias=False, validate_by_name=False\n        )\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'validate-by-alias-and-name-false'\n```", "url": "https://docs.pydantic.dev/latest/docs/errors/usage_errors/#validate_by_alias-and-validate_by_name-both-set-to-false-validate-by-alias-and-name-false", "page": "docs/errors/usage_errors", "source_site": "pydantic"}
{"title": "decorator", "anchor": "decorator", "heading_level": 0, "md_text": "The `decorator` module is a backport module from V1.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/decorator", "source_site": "pydantic"}
{"title": "dataclasses", "anchor": "dataclasses", "heading_level": 0, "md_text": "Provide an enhanced dataclass that performs validation.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/dataclasses", "source_site": "pydantic"}
{"title": "dataclass", "anchor": "dataclass", "heading_level": 0, "md_text": "A decorator used to create a Pydantic-enhanced dataclass, similar to the standard Python `dataclass`,\nbut with added validation.\n\nThis function should be used similarly to `dataclasses.dataclass`.\n\nArgs:\n    _cls: The target `dataclass`.\n    init: Included for signature compatibility with `dataclasses.dataclass`, and is passed through to\n        `dataclasses.dataclass` when appropriate. If specified, must be set to `False`, as pydantic inserts its\n        own  `__init__` function.\n    repr: A boolean indicating whether to include the field in the `__repr__` output.\n    eq: Determines if a `__eq__` method should be generated for the class.\n    order: Determines if comparison magic methods should be generated, such as `__lt__`, but not `__eq__`.\n    unsafe_hash: Determines if a `__hash__` method should be included in the class, as in `dataclasses.dataclass`.\n    frozen: Determines if the generated class should be a 'frozen' `dataclass`, which does not allow its\n        attributes to be modified after it has been initialized. If not set, the value from the provided `config` argument will be used (and will default to `False` otherwise).\n    config: The Pydantic config to use for the `dataclass`.\n    validate_on_init: A deprecated parameter included for backwards compatibility; in V2, all Pydantic dataclasses\n        are validated on init.\n    kw_only: Determines if `__init__` method parameters must be specified by keyword only. Defaults to `False`.\n    slots: Determines if the generated class should be a 'slots' `dataclass`, which does not allow the addition of\n        new attributes after instantiation.\n\nReturns:\n    A decorator that accepts a class as its argument and returns a Pydantic `dataclass`.\n\nRaises:\n    AssertionError: Raised if `init` is not `False` or `validate_on_init` is `False`.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/dataclasses", "source_site": "pydantic"}
{"title": "_pydantic_fields_complete", "anchor": "_pydantic_fields_complete", "heading_level": 0, "md_text": "Return whether the fields where successfully collected (i.e. type hints were successfully resolves).\n\nThis is a private property, not meant to be used outside Pydantic.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/dataclasses", "source_site": "pydantic"}
{"title": "rebuild_dataclass", "anchor": "rebuild_dataclass", "heading_level": 0, "md_text": "Try to rebuild the pydantic-core schema for the dataclass.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nThis is analogous to `BaseModel.model_rebuild`.\n\nArgs:\n    cls: The class to rebuild the pydantic-core schema for.\n    force: Whether to force the rebuilding of the schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/dataclasses", "source_site": "pydantic"}
{"title": "is_pydantic_dataclass", "anchor": "is_pydantic_dataclass", "heading_level": 0, "md_text": "Whether a class is a pydantic dataclass.\n\nArgs:\n    class_: The class.\n\nReturns:\n    `True` if the class is a pydantic dataclass, `False` otherwise.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/dataclasses", "source_site": "pydantic"}
{"title": "create_dataclass", "anchor": "create_dataclass", "heading_level": 0, "md_text": "Create a Pydantic dataclass from a regular dataclass.\n\nArgs:\n    cls: The class to create the Pydantic dataclass from.\n\nReturns:\n    A Pydantic dataclass.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/dataclasses", "source_site": "pydantic"}
{"title": "_call_initvar", "anchor": "_call_initvar", "heading_level": 0, "md_text": "This function does nothing but raise an error that is as similar as possible to what you'd get\nif you were to try calling `InitVar[int]()` without this monkeypatch. The whole purpose is just\nto ensure typing._type_check does not error if the type hint evaluates to `InitVar[<parameter>]`.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/dataclasses", "source_site": "pydantic"}
{"title": "env_settings", "anchor": "env_settings", "heading_level": 0, "md_text": "The `env_settings` module is a backport module from V1.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/env_settings", "source_site": "pydantic"}
{"title": "mypy", "anchor": "mypy", "heading_level": 0, "md_text": "This module includes classes and functions designed specifically for use with the mypy plugin.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "plugin", "anchor": "plugin", "heading_level": 0, "md_text": "`version` is the mypy version string.\n\nWe might want to use this to print a warning if the mypy version being used is\nnewer, or especially older, than we expect (or need).\n\nArgs:\n    version: The mypy version string.\n\nReturn:\n    The Pydantic mypy plugin type.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "PydanticPlugin", "anchor": "pydanticplugin", "heading_level": 0, "md_text": "The Pydantic mypy plugin.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "PydanticPluginConfig", "anchor": "pydanticpluginconfig", "heading_level": 0, "md_text": "A Pydantic mypy plugin config holder.\n\nAttributes:\n    init_forbid_extra: Whether to add a `**kwargs` at the end of the generated `__init__` signature.\n    init_typed: Whether to annotate fields in the generated `__init__`.\n    warn_required_dynamic_aliases: Whether to raise required dynamic aliases error.\n    debug_dataclass_transform: Whether to not reset `dataclass_transform_spec` attribute\n        of `ModelMetaclass` for testing purposes.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "from_attributes_callback", "anchor": "from_attributes_callback", "heading_level": 0, "md_text": "Raise an error if from_attributes is not enabled.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "PydanticModelField", "anchor": "pydanticmodelfield", "heading_level": 0, "md_text": "Based on mypy.plugins.dataclasses.DataclassAttribute.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "PydanticModelClassVar", "anchor": "pydanticmodelclassvar", "heading_level": 0, "md_text": "Based on mypy.plugins.dataclasses.DataclassAttribute.\n\nClassVars are ignored by subclasses.\n\nAttributes:\n    name: the ClassVar name", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "PydanticModelTransformer", "anchor": "pydanticmodeltransformer", "heading_level": 0, "md_text": "Transform the BaseModel subclass according to the plugin settings.\n\nAttributes:\n    tracked_config_fields: A set of field configs that the plugin has to track their value.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "ChangeExplicitTypeOfAny", "anchor": "changeexplicittypeofany", "heading_level": 0, "md_text": "A type translator used to change type of Any's, if explicit.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "ModelConfigData", "anchor": "modelconfigdata", "heading_level": 0, "md_text": "Pydantic mypy plugin model config class.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "is_root_model", "anchor": "is_root_model", "heading_level": 0, "md_text": "Return whether the type info is a root model subclass (or the `RootModel` class itself).", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "error_from_attributes", "anchor": "error_from_attributes", "heading_level": 0, "md_text": "Emits an error when the model does not have `from_attributes=True`.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "error_invalid_config_value", "anchor": "error_invalid_config_value", "heading_level": 0, "md_text": "Emits an error when the config value is invalid.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "error_required_dynamic_aliases", "anchor": "error_required_dynamic_aliases", "heading_level": 0, "md_text": "Emits required dynamic aliases error.\n\nThis will be called when `warn_required_dynamic_aliases=True`.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "error_unexpected_behavior", "anchor": "error_unexpected_behavior", "heading_level": 0, "md_text": "Emits unexpected behavior error.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "error_untyped_fields", "anchor": "error_untyped_fields", "heading_level": 0, "md_text": "Emits an error when there is an untyped field in the model.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "error_extra_fields_on_root_model", "anchor": "error_extra_fields_on_root_model", "heading_level": 0, "md_text": "Emits an error when there is more than just a root field defined for a subclass of RootModel.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "add_method", "anchor": "add_method", "heading_level": 0, "md_text": "Very closely related to `mypy.plugins.common.add_method_to_class`, with a few pydantic-specific changes.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "parse_toml", "anchor": "parse_toml", "heading_level": 0, "md_text": "Returns a dict of config keys to values.\n\nIt reads configs from toml file and returns `None` if the file is not a toml file.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "PydanticPlugin.get_base_class_hook", "anchor": "pydanticplugin-get_base_class_hook", "heading_level": 0, "md_text": "Update Pydantic model class.", "url": "https://docs.pydantic.dev/latest/api/get-base-class-hook/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "PydanticPlugin.get_metaclass_hook", "anchor": "pydanticplugin-get_metaclass_hook", "heading_level": 0, "md_text": "Update Pydantic `ModelMetaclass` definition.", "url": "https://docs.pydantic.dev/latest/api/get-metaclass-hook/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "PydanticPlugin.get_method_hook", "anchor": "pydanticplugin-get_method_hook", "heading_level": 0, "md_text": "Adjust return type of `from_orm` method call.", "url": "https://docs.pydantic.dev/latest/api/get-method-hook/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "PydanticPlugin.report_config_data", "anchor": "pydanticplugin-report_config_data", "heading_level": 0, "md_text": "Return all plugin config data.\n\nUsed by mypy to determine if cache needs to be discarded.", "url": "https://docs.pydantic.dev/latest/api/report-config-data/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "PydanticPlugin._pydantic_model_metaclass_marker_callback", "anchor": "pydanticplugin-_pydantic_model_metaclass_marker_callback", "heading_level": 0, "md_text": "Reset dataclass_transform_spec attribute of ModelMetaclass.\n\nLet the plugin handle it. This behavior can be disabled\nif 'debug_dataclass_transform' is set to True', for testing purposes.", "url": "https://docs.pydantic.dev/latest/api/-pydantic-model-metaclass-marker-callback/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "PydanticPluginConfig.to_data", "anchor": "pydanticpluginconfig-to_data", "heading_level": 0, "md_text": "Returns a dict of config names to their values.", "url": "https://docs.pydantic.dev/latest/api/to-data/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "PydanticModelField.to_argument", "anchor": "pydanticmodelfield-to_argument", "heading_level": 0, "md_text": "Based on mypy.plugins.dataclasses.DataclassAttribute.to_argument.", "url": "https://docs.pydantic.dev/latest/api/to-argument/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "PydanticModelField.expand_type", "anchor": "pydanticmodelfield-expand_type", "heading_level": 0, "md_text": "Based on mypy.plugins.dataclasses.DataclassAttribute.expand_type.", "url": "https://docs.pydantic.dev/latest/api/expand-type/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "PydanticModelField.to_var", "anchor": "pydanticmodelfield-to_var", "heading_level": 0, "md_text": "Based on mypy.plugins.dataclasses.DataclassAttribute.to_var.", "url": "https://docs.pydantic.dev/latest/api/to-var/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "PydanticModelField.serialize", "anchor": "pydanticmodelfield-serialize", "heading_level": 0, "md_text": "Based on mypy.plugins.dataclasses.DataclassAttribute.serialize.", "url": "https://docs.pydantic.dev/latest/api/serialize/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "PydanticModelField.deserialize", "anchor": "pydanticmodelfield-deserialize", "heading_level": 0, "md_text": "Based on mypy.plugins.dataclasses.DataclassAttribute.deserialize.", "url": "https://docs.pydantic.dev/latest/api/deserialize/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "PydanticModelField.expand_typevar_from_subtype", "anchor": "pydanticmodelfield-expand_typevar_from_subtype", "heading_level": 0, "md_text": "Expands type vars in the context of a subtype when an attribute is inherited\nfrom a generic super type.", "url": "https://docs.pydantic.dev/latest/api/expand-typevar-from-subtype/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "PydanticModelClassVar.deserialize", "anchor": "pydanticmodelclassvar-deserialize", "heading_level": 0, "md_text": "Based on mypy.plugins.dataclasses.DataclassAttribute.deserialize.", "url": "https://docs.pydantic.dev/latest/api/deserialize/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "PydanticModelClassVar.serialize", "anchor": "pydanticmodelclassvar-serialize", "heading_level": 0, "md_text": "Based on mypy.plugins.dataclasses.DataclassAttribute.serialize.", "url": "https://docs.pydantic.dev/latest/api/serialize/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "PydanticModelTransformer.transform", "anchor": "pydanticmodeltransformer-transform", "heading_level": 0, "md_text": "Configures the BaseModel subclass according to the plugin settings.\n\nIn particular:\n\n* determines the model config and fields,\n* adds a fields-aware signature for the initializer and construct methods\n* freezes the class if frozen = True\n* stores the fields, config, and if the class is settings in the mypy metadata for access by subclasses", "url": "https://docs.pydantic.dev/latest/api/transform/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "PydanticModelTransformer.adjust_decorator_signatures", "anchor": "pydanticmodeltransformer-adjust_decorator_signatures", "heading_level": 0, "md_text": "When we decorate a function `f` with `pydantic.validator(...)`, `pydantic.field_validator`\nor `pydantic.serializer(...)`, mypy sees `f` as a regular method taking a `self` instance,\neven though pydantic internally wraps `f` with `classmethod` if necessary.\n\nTeach mypy this by marking any function whose outermost decorator is a `validator()`,\n`field_validator()` or `serializer()` call as a `classmethod`.", "url": "https://docs.pydantic.dev/latest/api/adjust-decorator-signatures/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "PydanticModelTransformer.collect_config", "anchor": "pydanticmodeltransformer-collect_config", "heading_level": 0, "md_text": "Collects the values of the config attributes that are used by the plugin, accounting for parent classes.", "url": "https://docs.pydantic.dev/latest/api/collect-config/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "PydanticModelTransformer.collect_fields_and_class_vars", "anchor": "pydanticmodeltransformer-collect_fields_and_class_vars", "heading_level": 0, "md_text": "Collects the fields for the model, accounting for parent classes.", "url": "https://docs.pydantic.dev/latest/api/collect-fields-and-class-vars/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "PydanticModelTransformer.collect_field_or_class_var_from_stmt", "anchor": "pydanticmodeltransformer-collect_field_or_class_var_from_stmt", "heading_level": 0, "md_text": "Get pydantic model field from statement.\n\nArgs:\n    stmt: The statement.\n    model_config: Configuration settings for the model.\n    class_vars: ClassVars already known to be defined on the model.\n\nReturns:\n    A pydantic model field if it could find the field in statement. Otherwise, `None`.", "url": "https://docs.pydantic.dev/latest/api/collect-field-or-class-var-from-stmt/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "PydanticModelTransformer._infer_dataclass_attr_init_type", "anchor": "pydanticmodeltransformer-_infer_dataclass_attr_init_type", "heading_level": 0, "md_text": "Infer __init__ argument type for an attribute.\n\nIn particular, possibly use the signature of __set__.", "url": "https://docs.pydantic.dev/latest/api/-infer-dataclass-attr-init-type/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "PydanticModelTransformer.add_initializer", "anchor": "pydanticmodeltransformer-add_initializer", "heading_level": 0, "md_text": "Adds a fields-aware `__init__` method to the class.\n\nThe added `__init__` will be annotated with types vs. all `Any` depending on the plugin settings.", "url": "https://docs.pydantic.dev/latest/api/add-initializer/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "PydanticModelTransformer.add_model_construct_method", "anchor": "pydanticmodeltransformer-add_model_construct_method", "heading_level": 0, "md_text": "Adds a fully typed `model_construct` classmethod to the class.\n\nSimilar to the fields-aware __init__ method, but always uses the field names (not aliases),\nand does not treat settings fields as optional.", "url": "https://docs.pydantic.dev/latest/api/add-model-construct-method/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "PydanticModelTransformer.set_frozen", "anchor": "pydanticmodeltransformer-set_frozen", "heading_level": 0, "md_text": "Marks all fields as properties so that attempts to set them trigger mypy errors.\n\nThis is the same approach used by the attrs and dataclasses plugins.", "url": "https://docs.pydantic.dev/latest/api/set-frozen/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "PydanticModelTransformer.get_config_update", "anchor": "pydanticmodeltransformer-get_config_update", "heading_level": 0, "md_text": "Determines the config update due to a single kwarg in the ConfigDict definition.\n\nWarns if a tracked config attribute is set to a value the plugin doesn't know how to interpret (e.g., an int)", "url": "https://docs.pydantic.dev/latest/api/get-config-update/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "PydanticModelTransformer.get_has_default", "anchor": "pydanticmodeltransformer-get_has_default", "heading_level": 0, "md_text": "Returns a boolean indicating whether the field defined in `stmt` is a required field.", "url": "https://docs.pydantic.dev/latest/api/get-has-default/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "PydanticModelTransformer.get_strict", "anchor": "pydanticmodeltransformer-get_strict", "heading_level": 0, "md_text": "Returns a the `strict` value of a field if defined, otherwise `None`.", "url": "https://docs.pydantic.dev/latest/api/get-strict/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "PydanticModelTransformer.get_alias_info", "anchor": "pydanticmodeltransformer-get_alias_info", "heading_level": 0, "md_text": "Returns a pair (alias, has_dynamic_alias), extracted from the declaration of the field defined in `stmt`.\n\n`has_dynamic_alias` is True if and only if an alias is provided, but not as a string literal.\nIf `has_dynamic_alias` is True, `alias` will be None.", "url": "https://docs.pydantic.dev/latest/api/get-alias-info/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "PydanticModelTransformer.is_field_frozen", "anchor": "pydanticmodeltransformer-is_field_frozen", "heading_level": 0, "md_text": "Returns whether the field is frozen, extracted from the declaration of the field defined in `stmt`.\n\nNote that this is only whether the field was declared to be frozen in a `<field_name> = Field(frozen=True)`\nsense; this does not determine whether the field is frozen because the entire model is frozen; that is\nhandled separately.", "url": "https://docs.pydantic.dev/latest/api/is-field-frozen/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "PydanticModelTransformer.get_field_arguments", "anchor": "pydanticmodeltransformer-get_field_arguments", "heading_level": 0, "md_text": "Helper function used during the construction of the `__init__` and `model_construct` method signatures.\n\nReturns a list of mypy Argument instances for use in the generated signatures.", "url": "https://docs.pydantic.dev/latest/api/get-field-arguments/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "PydanticModelTransformer.should_init_forbid_extra", "anchor": "pydanticmodeltransformer-should_init_forbid_extra", "heading_level": 0, "md_text": "Indicates whether the generated `__init__` should get a `**kwargs` at the end of its signature.\n\nWe disallow arbitrary kwargs if the extra config setting is \"forbid\", or if the plugin config says to,\n*unless* a required dynamic alias is present (since then we can't determine a valid signature).", "url": "https://docs.pydantic.dev/latest/api/should-init-forbid-extra/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "PydanticModelTransformer.is_dynamic_alias_present", "anchor": "pydanticmodeltransformer-is_dynamic_alias_present", "heading_level": 0, "md_text": "Returns whether any fields on the model have a \"dynamic alias\", i.e., an alias that cannot be\ndetermined during static analysis.", "url": "https://docs.pydantic.dev/latest/api/is-dynamic-alias-present/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "ModelConfigData.get_values_dict", "anchor": "modelconfigdata-get_values_dict", "heading_level": 0, "md_text": "Returns a dict of Pydantic model config names to their values.\n\nIt includes the config if config value is not `None`.", "url": "https://docs.pydantic.dev/latest/api/get-values-dict/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "ModelConfigData.update", "anchor": "modelconfigdata-update", "heading_level": 0, "md_text": "Update Pydantic model config values.", "url": "https://docs.pydantic.dev/latest/api/update/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "ModelConfigData.setdefault", "anchor": "modelconfigdata-setdefault", "heading_level": 0, "md_text": "Set default value for Pydantic model config if config value is `None`.", "url": "https://docs.pydantic.dev/latest/api/setdefault/", "page": "pydantic/mypy", "source_site": "pydantic"}
{"title": "fields", "anchor": "fields", "heading_level": 0, "md_text": "Defining fields on models.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/fields", "source_site": "pydantic"}
{"title": "_FromFieldInfoInputs", "anchor": "_fromfieldinfoinputs", "heading_level": 0, "md_text": "This class exists solely to add type checking for the `**kwargs` in `FieldInfo.from_field`.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/fields", "source_site": "pydantic"}
{"title": "_FieldInfoInputs", "anchor": "_fieldinfoinputs", "heading_level": 0, "md_text": "This class exists solely to add type checking for the `**kwargs` in `FieldInfo.__init__`.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/fields", "source_site": "pydantic"}
{"title": "FieldInfo", "anchor": "fieldinfo", "heading_level": 0, "md_text": "This class holds information about a field.\n\n`FieldInfo` is used for any field definition regardless of whether the [`Field()`][pydantic.fields.Field]\nfunction is explicitly used.\n\nAttributes:\n    annotation: The type annotation of the field.\n    default: The default value of the field.\n    default_factory: A callable to generate the default value. The callable can either take 0 arguments\n        (in which case it is called as is) or a single argument containing the already validated data.\n    alias: The alias name of the field.\n    alias_priority: The priority of the field's alias.\n    validation_alias: The validation alias of the field.\n    serialization_alias: The serialization alias of the field.\n    title: The title of the field.\n    field_title_generator: A callable that takes a field name and returns title for it.\n    description: The description of the field.\n    examples: List of examples of the field.\n    exclude: Whether to exclude the field from the model serialization.\n    exclude_if: A callable that determines whether to exclude a field during serialization based on its value.\n    discriminator: Field name or Discriminator for discriminating the type in a tagged union.\n    deprecated: A deprecation message, an instance of `warnings.deprecated` or the `typing_extensions.deprecated` backport,\n        or a boolean. If `True`, a default deprecation message will be emitted when accessing the field.\n    json_schema_extra: A dict or callable to provide extra JSON schema properties.\n    frozen: Whether the field is frozen.\n    validate_default: Whether to validate the default value of the field.\n    repr: Whether to include the field in representation of the model.\n    init: Whether the field should be included in the constructor of the dataclass.\n    init_var: Whether the field should _only_ be included in the constructor of the dataclass, and not stored.\n    kw_only: Whether the field should be a keyword-only argument in the constructor of the dataclass.\n    metadata: The metadata list. Contains all the data that isn't expressed as direct `FieldInfo` attributes, including:\n\n        * Type-specific constraints, such as `gt` or `min_length` (these are converted to metadata classes such as `annotated_types.Gt`).\n        * Any other arbitrary object used within [`Annotated`][typing.Annotated] metadata\n          (e.g. [custom types handlers](../concepts/types.md#as-an-annotation) or any object not recognized by Pydantic).", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/fields", "source_site": "pydantic"}
{"title": "_EmptyKwargs", "anchor": "_emptykwargs", "heading_level": 0, "md_text": "This class exists solely to ensure that type checking warns about passing `**extra` in `Field`.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/fields", "source_site": "pydantic"}
{"title": "Field", "anchor": "field", "heading_level": 0, "md_text": "Create a field for objects that can be configured.\n\nUsed to provide extra information about a field, either for the model schema or complex validation. Some arguments\napply only to number fields (`int`, `float`, `Decimal`) and some apply only to `str`.\n\nNote:\n    - Any `_Unset` objects will be replaced by the corresponding value defined in the `_DefaultValues` dictionary. If a key for the `_Unset` object is not found in the `_DefaultValues` dictionary, it will default to `None`\n\nArgs:\n    default: Default value if the field is not set.\n    default_factory: A callable to generate the default value. The callable can either take 0 arguments\n        (in which case it is called as is) or a single argument containing the already validated data.\n    alias: The name to use for the attribute when validating or serializing by alias.\n        This is often used for things like converting between snake and camel case.\n    alias_priority: Priority of the alias. This affects whether an alias generator is used.\n    validation_alias: Like `alias`, but only affects validation, not serialization.\n    serialization_alias: Like `alias`, but only affects serialization, not validation.\n    title: Human-readable title.\n    field_title_generator: A callable that takes a field name and returns title for it.\n    description: Human-readable description.\n    examples: Example values for this field.\n    exclude: Whether to exclude the field from the model serialization.\n    exclude_if: A callable that determines whether to exclude a field during serialization based on its value.\n    discriminator: Field name or Discriminator for discriminating the type in a tagged union.\n    deprecated: A deprecation message, an instance of `warnings.deprecated` or the `typing_extensions.deprecated` backport,\n        or a boolean. If `True`, a default deprecation message will be emitted when accessing the field.\n    json_schema_extra: A dict or callable to provide extra JSON schema properties.\n    frozen: Whether the field is frozen. If true, attempts to change the value on an instance will raise an error.\n    validate_default: If `True`, apply validation to the default value every time you create an instance.\n        Otherwise, for performance reasons, the default value of the field is trusted and not validated.\n    repr: A boolean indicating whether to include the field in the `__repr__` output.\n    init: Whether the field should be included in the constructor of the dataclass.\n        (Only applies to dataclasses.)\n    init_var: Whether the field should _only_ be included in the constructor of the dataclass.\n        (Only applies to dataclasses.)\n    kw_only: Whether the field should be a keyword-only argument in the constructor of the dataclass.\n        (Only applies to dataclasses.)\n    coerce_numbers_to_str: Whether to enable coercion of any `Number` type to `str` (not applicable in `strict` mode).\n    strict: If `True`, strict validation is applied to the field.\n        See [Strict Mode](../concepts/strict_mode.md) for details.\n    gt: Greater than. If set, value must be greater than this. Only applicable to numbers.\n    ge: Greater than or equal. If set, value must be greater than or equal to this. Only applicable to numbers.\n    lt: Less than. If set, value must be less than this. Only applicable to numbers.\n    le: Less than or equal. If set, value must be less than or equal to this. Only applicable to numbers.\n    multiple_of: Value must be a multiple of this. Only applicable to numbers.\n    min_length: Minimum length for iterables.\n    max_length: Maximum length for iterables.\n    pattern: Pattern for strings (a regular expression).\n    allow_inf_nan: Allow `inf`, `-inf`, `nan`. Only applicable to float and [`Decimal`][decimal.Decimal] numbers.\n    max_digits: Maximum number of allow digits for strings.\n    decimal_places: Maximum number of decimal places allowed for numbers.\n    union_mode: The strategy to apply when validating a union. Can be `smart` (the default), or `left_to_right`.\n        See [Union Mode](../concepts/unions.md#union-modes) for details.\n    fail_fast: If `True`, validation will stop on the first error. If `False`, all validation errors will be collected.\n        This option can be applied only to iterable types (list, tuple, set, and frozenset).\n    extra: (Deprecated) Extra fields that will be included in the JSON schema.\n\nReturns:\n    A new [`FieldInfo`][pydantic.fields.FieldInfo]. The return annotation is `Any` so `Field` can be used on\n        type-annotated fields without causing a type error.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/fields", "source_site": "pydantic"}
{"title": "ModelPrivateAttr", "anchor": "modelprivateattr", "heading_level": 0, "md_text": "A descriptor for private attributes in class models.\n\nAttributes:\n    default: The default value of the attribute if not provided.\n    default_factory: A callable function that generates the default value of the\n        attribute if not provided.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/fields", "source_site": "pydantic"}
{"title": "PrivateAttr", "anchor": "privateattr", "heading_level": 0, "md_text": "Indicates that an attribute is intended for private use and not handled during normal validation/serialization.\n\nPrivate attributes are not validated by Pydantic, so it's up to you to ensure they are used in a type-safe manner.\n\nPrivate attributes are stored in `__private_attributes__` on the model.\n\nArgs:\n    default: The attribute's default value. Defaults to Undefined.\n    default_factory: Callable that will be\n        called when a default value is needed for this attribute.\n        If both `default` and `default_factory` are set, an error will be raised.\n    init: Whether the attribute should be included in the constructor of the dataclass. Always `False`.\n\nReturns:\n    An instance of [`ModelPrivateAttr`][pydantic.fields.ModelPrivateAttr] class.\n\nRaises:\n    ValueError: If both `default` and `default_factory` are set.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/fields", "source_site": "pydantic"}
{"title": "ComputedFieldInfo", "anchor": "computedfieldinfo", "heading_level": 0, "md_text": "A container for data from `@computed_field` so that we can access it while building the pydantic-core schema.\n\nAttributes:\n    decorator_repr: A class variable representing the decorator string, '@computed_field'.\n    wrapped_property: The wrapped computed field property.\n    return_type: The type of the computed field property's return value.\n    alias: The alias of the property to be used during serialization.\n    alias_priority: The priority of the alias. This affects whether an alias generator is used.\n    title: Title of the computed field to include in the serialization JSON schema.\n    field_title_generator: A callable that takes a field name and returns title for it.\n    description: Description of the computed field to include in the serialization JSON schema.\n    deprecated: A deprecation message, an instance of `warnings.deprecated` or the `typing_extensions.deprecated` backport,\n        or a boolean. If `True`, a default deprecation message will be emitted when accessing the field.\n    examples: Example values of the computed field to include in the serialization JSON schema.\n    json_schema_extra: A dict or callable to provide extra JSON schema properties.\n    repr: A boolean indicating whether to include the field in the __repr__ output.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/fields", "source_site": "pydantic"}
{"title": "_wrapped_property_is_private", "anchor": "_wrapped_property_is_private", "heading_level": 0, "md_text": "Returns true if provided property is private, False otherwise.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/fields", "source_site": "pydantic"}
{"title": "computed_field", "anchor": "computed_field", "heading_level": 0, "md_text": "Decorator to include `property` and `cached_property` when serializing models or dataclasses.\n\nThis is useful for fields that are computed from other fields, or for fields that are expensive to compute and should be cached.\n\n```python\nfrom pydantic import BaseModel, computed_field\n\nclass Rectangle(BaseModel):\n    width: int\n    length: int\n\n    @computed_field\n    @property\n    def area(self) -> int:\n        return self.width * self.length\n\nprint(Rectangle(width=3, length=2).model_dump())\n#> {'width': 3, 'length': 2, 'area': 6}\n```\n\nIf applied to functions not yet decorated with `@property` or `@cached_property`, the function is\nautomatically wrapped with `property`. Although this is more concise, you will lose IntelliSense in your IDE,\nand confuse static type checkers, thus explicit use of `@property` is recommended.\n\n```python\nimport random\n\nfrom pydantic import BaseModel, computed_field\n\nclass Square(BaseModel):\n    width: float\n\n    @computed_field\n    def area(self) -> float:  # converted to a `property` by `computed_field`\n        return round(self.width**2, 2)\n\n    @area.setter\n    def area(self, new_area: float) -> None:\n        self.width = new_area**0.5\n\n    @computed_field(alias='the magic number', repr=False)\n    def random_number(self) -> int:\n        return random.randint(0, 1_000)\n\nsquare = Square(width=1.3)\n\n# `random_number` does not appear in representation\nprint(repr(square))\n#> Square(width=1.3, area=1.69)\n\nprint(square.random_number)\n#> 3\n\nsquare.area = 4\n\nprint(square.model_dump_json(by_alias=True))\n#> {\"width\":2.0,\"area\":4.0,\"the magic number\":3}\n```\n\n```python\nfrom pydantic import BaseModel, computed_field\n\nclass Parent(BaseModel):\n    a: str\n\ntry:\n\n    class Child(Parent):\n        @computed_field\n        @property\n        def a(self) -> str:\n            return 'new a'\n\nexcept TypeError as e:\n    print(e)\n    '''\n    Field 'a' of class 'Child' overrides symbol of same name in a parent class. This override with a computed_field is incompatible.\n    '''\n```\n\nPrivate properties decorated with `@computed_field` have `repr=False` by default.\n\n```python\nfrom functools import cached_property\n\nfrom pydantic import BaseModel, computed_field\n\nclass Model(BaseModel):\n    foo: int\n\n    @computed_field\n    @cached_property\n    def _private_cached_property(self) -> int:\n        return -self.foo\n\n    @computed_field\n    @property\n    def _private_property(self) -> int:\n        return -self.foo\n\nm = Model(foo=1)\nprint(repr(m))\n#> Model(foo=1)\n```\n\nArgs:\n    func: the function to wrap.\n    alias: alias to use when serializing this computed field, only used when `by_alias=True`\n    alias_priority: priority of the alias. This affects whether an alias generator is used\n    title: Title to use when including this computed field in JSON Schema\n    field_title_generator: A callable that takes a field name and returns title for it.\n    description: Description to use when including this computed field in JSON Schema, defaults to the function's\n        docstring\n    deprecated: A deprecation message (or an instance of `warnings.deprecated` or the `typing_extensions.deprecated` backport).\n        to be emitted when accessing the field. Or a boolean. This will automatically be set if the property is decorated with the\n        `deprecated` decorator.\n    examples: Example values to use when including this computed field in JSON Schema\n    json_schema_extra: A dict or callable to provide extra JSON schema properties.\n    repr: whether to include this computed field in model repr.\n        Default is `False` for private properties and `True` for public properties.\n    return_type: optional return for serialization logic to expect when serializing to JSON, if included\n        this must be correct, otherwise a `TypeError` is raised.\n        If you don't include a return type Any is used, which does runtime introspection to handle arbitrary\n        objects.\n\nReturns:\n    A proxy wrapper for the property.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/fields", "source_site": "pydantic"}
{"title": "FieldInfo.__init__", "anchor": "fieldinfo-__init__", "heading_level": 0, "md_text": "This class should generally not be initialized directly; instead, use the `pydantic.fields.Field` function\nor one of the constructor classmethods.\n\nSee the signature of `pydantic.fields.Field` for more details about the expected arguments.", "url": "https://docs.pydantic.dev/latest/api/--init--/", "page": "pydantic/fields", "source_site": "pydantic"}
{"title": "FieldInfo.from_field", "anchor": "fieldinfo-from_field", "heading_level": 0, "md_text": "Create a new `FieldInfo` object with the `Field` function.\n\nArgs:\n    default: The default value for the field. Defaults to Undefined.\n    **kwargs: Additional arguments dictionary.\n\nRaises:\n    TypeError: If 'annotation' is passed as a keyword argument.\n\nReturns:\n    A new FieldInfo object with the given parameters.\n\nExample:\n    This is how you can create a field with default value like this:\n\n    ```python\n    import pydantic\n\n    class MyModel(pydantic.BaseModel):\n        foo: int = pydantic.Field(4)\n    ```", "url": "https://docs.pydantic.dev/latest/api/from-field/", "page": "pydantic/fields", "source_site": "pydantic"}
{"title": "FieldInfo.from_annotation", "anchor": "fieldinfo-from_annotation", "heading_level": 0, "md_text": "Creates a `FieldInfo` instance from a bare annotation.\n\nThis function is used internally to create a `FieldInfo` from a bare annotation like this:\n\n```python\nimport pydantic\n\nclass MyModel(pydantic.BaseModel):\n    foo: int  # <-- like this\n```\n\nWe also account for the case where the annotation can be an instance of `Annotated` and where\none of the (not first) arguments in `Annotated` is an instance of `FieldInfo`, e.g.:\n\n```python\nfrom typing import Annotated\n\nimport annotated_types\n\nimport pydantic\n\nclass MyModel(pydantic.BaseModel):\n    foo: Annotated[int, annotated_types.Gt(42)]\n    bar: Annotated[int, pydantic.Field(gt=42)]\n```\n\nArgs:\n    annotation: An annotation object.\n\nReturns:\n    An instance of the field metadata.", "url": "https://docs.pydantic.dev/latest/api/from-annotation/", "page": "pydantic/fields", "source_site": "pydantic"}
{"title": "FieldInfo.from_annotated_attribute", "anchor": "fieldinfo-from_annotated_attribute", "heading_level": 0, "md_text": "Create `FieldInfo` from an annotation with a default value.\n\nThis is used in cases like the following:\n\n```python\nfrom typing import Annotated\n\nimport annotated_types\n\nimport pydantic\n\nclass MyModel(pydantic.BaseModel):\n    foo: int = 4  # <-- like this\n    bar: Annotated[int, annotated_types.Gt(4)] = 4  # <-- or this\n    spam: Annotated[int, pydantic.Field(gt=4)] = 4  # <-- or this\n```\n\nArgs:\n    annotation: The type annotation of the field.\n    default: The default value of the field.\n\nReturns:\n    A field object with the passed values.", "url": "https://docs.pydantic.dev/latest/api/from-annotated-attribute/", "page": "pydantic/fields", "source_site": "pydantic"}
{"title": "FieldInfo._construct", "anchor": "fieldinfo-_construct", "heading_level": 0, "md_text": "Construct the final `FieldInfo` instance, by merging the possibly existing `FieldInfo` instances from the metadata.\n\nWith the following example:\n\n```python {test=\"skip\" lint=\"skip\"}\nclass Model(BaseModel):\n    f: Annotated[int, Gt(1), Field(description='desc', lt=2)]\n```\n\n`metadata` refers to the metadata elements of the `Annotated` form. This metadata is iterated over from left to right:\n\n- If the element is a `Field()` function (which is itself a `FieldInfo` instance), the field attributes (such as\n  `description`) are saved to be set on the final `FieldInfo` instance.\n  On the other hand, some kwargs (such as `lt`) are stored as `metadata` (see `FieldInfo.__init__()`, calling\n  `FieldInfo._collect_metadata()`). In this case, the final metadata list is extended with the one from this instance.\n- Else, the element is considered as a single metadata object, and is appended to the final metadata list.\n\nArgs:\n    metadata: The list of metadata elements to merge together. If the `FieldInfo` instance to be constructed is for\n        a field with an assigned `Field()`, this `Field()` assignment should be added as the last element of the\n        provided metadata.\n    **attr_overrides: Extra attributes that should be set on the final merged `FieldInfo` instance.\n\nReturns:\n    The final merged `FieldInfo` instance.", "url": "https://docs.pydantic.dev/latest/api/-construct/", "page": "pydantic/fields", "source_site": "pydantic"}
{"title": "FieldInfo.merge_field_infos", "anchor": "fieldinfo-merge_field_infos", "heading_level": 0, "md_text": "Merge `FieldInfo` instances keeping only explicitly set attributes.\n\nLater `FieldInfo` instances override earlier ones.\n\nReturns:\n    FieldInfo: A merged FieldInfo instance.", "url": "https://docs.pydantic.dev/latest/api/merge-field-infos/", "page": "pydantic/fields", "source_site": "pydantic"}
{"title": "FieldInfo._from_dataclass_field", "anchor": "fieldinfo-_from_dataclass_field", "heading_level": 0, "md_text": "Return a new `FieldInfo` instance from a `dataclasses.Field` instance.\n\nArgs:\n    dc_field: The `dataclasses.Field` instance to convert.\n\nReturns:\n    The corresponding `FieldInfo` instance.\n\nRaises:\n    TypeError: If any of the `FieldInfo` kwargs does not match the `dataclass.Field` kwargs.", "url": "https://docs.pydantic.dev/latest/api/-from-dataclass-field/", "page": "pydantic/fields", "source_site": "pydantic"}
{"title": "FieldInfo._collect_metadata", "anchor": "fieldinfo-_collect_metadata", "heading_level": 0, "md_text": "Collect annotations from kwargs.\n\nArgs:\n    kwargs: Keyword arguments passed to the function.\n\nReturns:\n    A list of metadata objects - a combination of `annotated_types.BaseMetadata` and\n        `PydanticMetadata`.", "url": "https://docs.pydantic.dev/latest/api/-collect-metadata/", "page": "pydantic/fields", "source_site": "pydantic"}
{"title": "FieldInfo.deprecation_message", "anchor": "fieldinfo-deprecation_message", "heading_level": 0, "md_text": "The deprecation message to be emitted, or `None` if not set.", "url": "https://docs.pydantic.dev/latest/api/deprecation-message/", "page": "pydantic/fields", "source_site": "pydantic"}
{"title": "FieldInfo.default_factory_takes_validated_data", "anchor": "fieldinfo-default_factory_takes_validated_data", "heading_level": 0, "md_text": "Whether the provided default factory callable has a validated data parameter.\n\nReturns `None` if no default factory is set.", "url": "https://docs.pydantic.dev/latest/api/default-factory-takes-validated-data/", "page": "pydantic/fields", "source_site": "pydantic"}
{"title": "FieldInfo.get_default", "anchor": "fieldinfo-get_default", "heading_level": 0, "md_text": "Get the default value.\n\nWe expose an option for whether to call the default_factory (if present), as calling it may\nresult in side effects that we want to avoid. However, there are times when it really should\nbe called (namely, when instantiating a model via `model_construct`).\n\nArgs:\n    call_default_factory: Whether to call the default factory or not.\n    validated_data: The already validated data to be passed to the default factory.\n\nReturns:\n    The default value, calling the default factory if requested or `None` if not set.", "url": "https://docs.pydantic.dev/latest/api/get-default/", "page": "pydantic/fields", "source_site": "pydantic"}
{"title": "FieldInfo.is_required", "anchor": "fieldinfo-is_required", "heading_level": 0, "md_text": "Check if the field is required (i.e., does not have a default value or factory).\n\nReturns:\n    `True` if the field is required, `False` otherwise.", "url": "https://docs.pydantic.dev/latest/api/is-required/", "page": "pydantic/fields", "source_site": "pydantic"}
{"title": "FieldInfo.rebuild_annotation", "anchor": "fieldinfo-rebuild_annotation", "heading_level": 0, "md_text": "Attempts to rebuild the original annotation for use in function signatures.\n\nIf metadata is present, it adds it to the original annotation using\n`Annotated`. Otherwise, it returns the original annotation as-is.\n\nNote that because the metadata has been flattened, the original annotation\nmay not be reconstructed exactly as originally provided, e.g. if the original\ntype had unrecognized annotations, or was annotated with a call to `pydantic.Field`.\n\nReturns:\n    The rebuilt annotation.", "url": "https://docs.pydantic.dev/latest/api/rebuild-annotation/", "page": "pydantic/fields", "source_site": "pydantic"}
{"title": "FieldInfo.apply_typevars_map", "anchor": "fieldinfo-apply_typevars_map", "heading_level": 0, "md_text": "Apply a `typevars_map` to the annotation.\n\nThis method is used when analyzing parametrized generic types to replace typevars with their concrete types.\n\nThis method applies the `typevars_map` to the annotation in place.\n\nArgs:\n    typevars_map: A dictionary mapping type variables to their concrete types.\n    globalns: The globals namespace to use during type annotation evaluation.\n    localns: The locals namespace to use during type annotation evaluation.\n\nSee Also:\n    pydantic._internal._generics.replace_types is used for replacing the typevars with\n        their concrete types.", "url": "https://docs.pydantic.dev/latest/api/apply-typevars-map/", "page": "pydantic/fields", "source_site": "pydantic"}
{"title": "FieldInfo.asdict", "anchor": "fieldinfo-asdict", "heading_level": 0, "md_text": "Return a dictionary representation of the `FieldInfo` instance.\n\nThe returned value is a dictionary with three items:\n\n* `annotation`: The type annotation of the field.\n* `metadata`: The metadata list.\n* `attributes`: A mapping of the remaining `FieldInfo` attributes to their values (e.g. `alias`, `title`).", "url": "https://docs.pydantic.dev/latest/api/asdict/", "page": "pydantic/fields", "source_site": "pydantic"}
{"title": "FieldInfo._copy", "anchor": "fieldinfo-_copy", "heading_level": 0, "md_text": "Return a copy of the `FieldInfo` instance.", "url": "https://docs.pydantic.dev/latest/api/-copy/", "page": "pydantic/fields", "source_site": "pydantic"}
{"title": "ModelPrivateAttr.__set_name__", "anchor": "modelprivateattr-__set_name__", "heading_level": 0, "md_text": "Preserve `__set_name__` protocol defined in https://peps.python.org/pep-0487.", "url": "https://docs.pydantic.dev/latest/api/--set-name--/", "page": "pydantic/fields", "source_site": "pydantic"}
{"title": "ModelPrivateAttr.get_default", "anchor": "modelprivateattr-get_default", "heading_level": 0, "md_text": "Retrieve the default value of the object.\n\nIf `self.default_factory` is `None`, the method will return a deep copy of the `self.default` object.\n\nIf `self.default_factory` is not `None`, it will call `self.default_factory` and return the value returned.\n\nReturns:\n    The default value of the object.", "url": "https://docs.pydantic.dev/latest/api/get-default/", "page": "pydantic/fields", "source_site": "pydantic"}
{"title": "ComputedFieldInfo.deprecation_message", "anchor": "computedfieldinfo-deprecation_message", "heading_level": 0, "md_text": "The deprecation message to be emitted, or `None` if not set.", "url": "https://docs.pydantic.dev/latest/api/deprecation-message/", "page": "pydantic/fields", "source_site": "pydantic"}
{"title": "ComputedFieldInfo._update_from_config", "anchor": "computedfieldinfo-_update_from_config", "heading_level": 0, "md_text": "Update the instance from the configuration set on the class this computed field belongs to.", "url": "https://docs.pydantic.dev/latest/api/-update-from-config/", "page": "pydantic/fields", "source_site": "pydantic"}
{"title": "ComputedFieldInfo._apply_alias_generator", "anchor": "computedfieldinfo-_apply_alias_generator", "heading_level": 0, "md_text": "Apply an alias generator to aliases if appropriate.\n\nArgs:\n    alias_generator: A callable that takes a string and returns a string, or an `AliasGenerator` instance.\n    name: The name of the computed field from which to generate the alias.", "url": "https://docs.pydantic.dev/latest/api/-apply-alias-generator/", "page": "pydantic/fields", "source_site": "pydantic"}
{"title": "__getattr__", "anchor": "__getattr__", "heading_level": 0, "md_text": "This function improves compatibility with custom descriptors by ensuring delegation happens\nas expected when the default value of a private attribute is a descriptor.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/fields", "source_site": "pydantic"}
{"title": "json_schema", "anchor": "json_schema", "heading_level": 0, "md_text": "The `json_schema` module contains classes and functions to allow the way [JSON Schema](https://json-schema.org/)\nis generated to be customized.\n\nIn general you shouldn't need to use this module directly; instead, you can use\n[`BaseModel.model_json_schema`][pydantic.BaseModel.model_json_schema] and\n[`TypeAdapter.json_schema`][pydantic.TypeAdapter.json_schema].", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "PydanticJsonSchemaWarning", "anchor": "pydanticjsonschemawarning", "heading_level": 0, "md_text": "This class is used to emit warnings produced during JSON schema generation.\nSee the [`GenerateJsonSchema.emit_warning`][pydantic.json_schema.GenerateJsonSchema.emit_warning] and\n[`GenerateJsonSchema.render_warning_message`][pydantic.json_schema.GenerateJsonSchema.render_warning_message]\nmethods for more details; these can be overridden to control warning behavior.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema", "anchor": "generatejsonschema", "heading_level": 0, "md_text": "A class for generating JSON schemas.\n\nThis class generates JSON schemas based on configured parameters. The default schema dialect\nis [https://json-schema.org/draft/2020-12/schema](https://json-schema.org/draft/2020-12/schema).\nThe class uses `by_alias` to configure how fields with\nmultiple names are handled and `ref_template` to format reference names.\n\nAttributes:\n    schema_dialect: The JSON schema dialect used to generate the schema. See\n        [Declaring a Dialect](https://json-schema.org/understanding-json-schema/reference/schema.html#id4)\n        in the JSON Schema documentation for more information about dialects.\n    ignored_warning_kinds: Warnings to ignore when generating the schema. `self.render_warning_message` will\n        do nothing if its argument `kind` is in `ignored_warning_kinds`;\n        this value can be modified on subclasses to easily control which warnings are emitted.\n    by_alias: Whether to use field aliases when generating the schema.\n    ref_template: The format string used when generating reference names.\n    core_to_json_refs: A mapping of core refs to JSON refs.\n    core_to_defs_refs: A mapping of core refs to definition refs.\n    defs_to_core_refs: A mapping of definition refs to core refs.\n    json_to_defs_refs: A mapping of JSON refs to definition refs.\n    definitions: Definitions in the schema.\n\nArgs:\n    by_alias: Whether to use field aliases in the generated schemas.\n    ref_template: The format string to use when generating reference names.\n    union_format: The format to use when combining schemas from unions together. Can be one of:\n\n        - `'any_of'`: Use the [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\n          keyword to combine schemas (the default).\n        - `'primitive_type_array'`: Use the [`type`](https://json-schema.org/understanding-json-schema/reference/type)\n          keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\n          type (`string`, `boolean`, `null`, `integer` or `number`) or contains constraints/metadata, falls back to\n          `any_of`.\n\nRaises:\n    JsonSchemaError: If the instance of the class is inadvertently reused after generating a schema.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "model_json_schema", "anchor": "model_json_schema", "heading_level": 0, "md_text": "Utility function to generate a JSON Schema for a model.\n\nArgs:\n    cls: The model class to generate a JSON Schema for.\n    by_alias: If `True` (the default), fields will be serialized according to their alias.\n        If `False`, fields will be serialized according to their attribute name.\n    ref_template: The template to use for generating JSON Schema references.\n    union_format: The format to use when combining schemas from unions together. Can be one of:\n\n        - `'any_of'`: Use the [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\n          keyword to combine schemas (the default).\n        - `'primitive_type_array'`: Use the [`type`](https://json-schema.org/understanding-json-schema/reference/type)\n          keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\n          type (`string`, `boolean`, `null`, `integer` or `number`) or contains constraints/metadata, falls back to\n          `any_of`.\n    schema_generator: The class to use for generating the JSON Schema.\n    mode: The mode to use for generating the JSON Schema. It can be one of the following:\n\n        - 'validation': Generate a JSON Schema for validating data.\n        - 'serialization': Generate a JSON Schema for serializing data.\n\nReturns:\n    The generated JSON Schema.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "models_json_schema", "anchor": "models_json_schema", "heading_level": 0, "md_text": "Utility function to generate a JSON Schema for multiple models.\n\nArgs:\n    models: A sequence of tuples of the form (model, mode).\n    by_alias: Whether field aliases should be used as keys in the generated JSON Schema.\n    title: The title of the generated JSON Schema.\n    description: The description of the generated JSON Schema.\n    ref_template: The reference template to use for generating JSON Schema references.\n    union_format: The format to use when combining schemas from unions together. Can be one of:\n\n        - `'any_of'`: Use the [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\n          keyword to combine schemas (the default).\n        - `'primitive_type_array'`: Use the [`type`](https://json-schema.org/understanding-json-schema/reference/type)\n          keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\n          type (`string`, `boolean`, `null`, `integer` or `number`) or contains constraints/metadata, falls back to\n          `any_of`.\n    schema_generator: The schema generator to use for generating the JSON Schema.\n\nReturns:\n    A tuple where:\n        - The first element is a dictionary whose keys are tuples of JSON schema key type and JSON mode, and\n            whose values are the JSON schema corresponding to that pair of inputs. (These schemas may have\n            JsonRef references to definitions that are defined in the second returned element.)\n        - The second element is a JSON schema containing all definitions referenced in the first returned\n                element, along with the optional title and description keys.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "WithJsonSchema", "anchor": "withjsonschema", "heading_level": 0, "md_text": "Add this as an annotation on a field to override the (base) JSON schema that would be generated for that field.\nThis provides a way to set a JSON schema for types that would otherwise raise errors when producing a JSON schema,\nsuch as Callable, or types that have an is-instance core schema, without needing to go so far as creating a\ncustom subclass of pydantic.json_schema.GenerateJsonSchema.\nNote that any _modifications_ to the schema that would normally be made (such as setting the title for model fields)\nwill still be performed.\n\nIf `mode` is set this will only apply to that schema generation mode, allowing you\nto set different json schemas for validation and serialization.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "Examples", "anchor": "examples", "heading_level": 0, "md_text": "Add examples to a JSON schema.\n\nIf the JSON Schema already contains examples, the provided examples\nwill be appended.\n\nIf `mode` is set this will only apply to that schema generation mode,\nallowing you to add different examples for validation and serialization.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "_get_all_json_refs", "anchor": "_get_all_json_refs", "heading_level": 0, "md_text": "Get all the definitions references from a JSON schema.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "_get_ser_schema_for_default_value", "anchor": "_get_ser_schema_for_default_value", "heading_level": 0, "md_text": "Get a `'function-plain'` serialization schema that can be used to serialize a default value.\n\nThis takes into account having the serialization schema nested under validation schema(s).", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "_DefinitionsRemapping.from_prioritized_choices", "anchor": "_definitionsremapping-from_prioritized_choices", "heading_level": 0, "md_text": "This function should produce a remapping that replaces complex DefsRef with the simpler ones from the\nprioritized_choices such that applying the name remapping would result in an equivalent JSON schema.", "url": "https://docs.pydantic.dev/latest/api/from-prioritized-choices/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "_DefinitionsRemapping.remap_json_schema", "anchor": "_definitionsremapping-remap_json_schema", "heading_level": 0, "md_text": "Recursively update the JSON schema replacing all $refs", "url": "https://docs.pydantic.dev/latest/api/remap-json-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.build_schema_type_to_method", "anchor": "generatejsonschema-build_schema_type_to_method", "heading_level": 0, "md_text": "Builds a dictionary mapping fields to methods for generating JSON schemas.\n\nReturns:\n    A dictionary containing the mapping of `CoreSchemaOrFieldType` to a handler method.\n\nRaises:\n    TypeError: If no method has been defined for generating a JSON schema for a given pydantic core schema type.", "url": "https://docs.pydantic.dev/latest/api/build-schema-type-to-method/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.generate_definitions", "anchor": "generatejsonschema-generate_definitions", "heading_level": 0, "md_text": "Generates JSON schema definitions from a list of core schemas, pairing the generated definitions with a\nmapping that links the input keys to the definition references.\n\nArgs:\n    inputs: A sequence of tuples, where:\n\n        - The first element is a JSON schema key type.\n        - The second element is the JSON mode: either 'validation' or 'serialization'.\n        - The third element is a core schema.\n\nReturns:\n    A tuple where:\n\n        - The first element is a dictionary whose keys are tuples of JSON schema key type and JSON mode, and\n            whose values are the JSON schema corresponding to that pair of inputs. (These schemas may have\n            JsonRef references to definitions that are defined in the second returned element.)\n        - The second element is a dictionary whose keys are definition references for the JSON schemas\n            from the first returned element, and whose values are the actual JSON schema definitions.\n\nRaises:\n    PydanticUserError: Raised if the JSON schema generator has already been used to generate a JSON schema.", "url": "https://docs.pydantic.dev/latest/api/generate-definitions/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.generate", "anchor": "generatejsonschema-generate", "heading_level": 0, "md_text": "Generates a JSON schema for a specified schema in a specified mode.\n\nArgs:\n    schema: A Pydantic model.\n    mode: The mode in which to generate the schema. Defaults to 'validation'.\n\nReturns:\n    A JSON schema representing the specified schema.\n\nRaises:\n    PydanticUserError: If the JSON schema generator has already been used to generate a JSON schema.", "url": "https://docs.pydantic.dev/latest/api/generate/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.generate_inner", "anchor": "generatejsonschema-generate_inner", "heading_level": 0, "md_text": "Generates a JSON schema for a given core schema.\n\nArgs:\n    schema: The given core schema.\n\nReturns:\n    The generated JSON schema.\n\nTODO: the nested function definitions here seem like bad practice, I'd like to unpack these\nin a future PR. It'd be great if we could shorten the call stack a bit for JSON schema generation,\nand I think there's potential for that here.", "url": "https://docs.pydantic.dev/latest/api/generate-inner/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.sort", "anchor": "generatejsonschema-sort", "heading_level": 0, "md_text": "Override this method to customize the sorting of the JSON schema (e.g., don't sort at all, sort all keys unconditionally, etc.)\n\nBy default, alphabetically sort the keys in the JSON schema, skipping the 'properties' and 'default' keys to preserve field definition order.\nThis sort is recursive, so it will sort all nested dictionaries as well.", "url": "https://docs.pydantic.dev/latest/api/sort/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema._sort_recursive", "anchor": "generatejsonschema-_sort_recursive", "heading_level": 0, "md_text": "Recursively sort a JSON schema value.", "url": "https://docs.pydantic.dev/latest/api/-sort-recursive/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.invalid_schema", "anchor": "generatejsonschema-invalid_schema", "heading_level": 0, "md_text": "Placeholder - should never be called.", "url": "https://docs.pydantic.dev/latest/api/invalid-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.any_schema", "anchor": "generatejsonschema-any_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches any value.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/any-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.none_schema", "anchor": "generatejsonschema-none_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches `None`.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/none-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.bool_schema", "anchor": "generatejsonschema-bool_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a bool value.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/bool-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.int_schema", "anchor": "generatejsonschema-int_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches an int value.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/int-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.float_schema", "anchor": "generatejsonschema-float_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a float value.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/float-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.decimal_schema", "anchor": "generatejsonschema-decimal_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a decimal value.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/decimal-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.str_schema", "anchor": "generatejsonschema-str_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a string value.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/str-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.bytes_schema", "anchor": "generatejsonschema-bytes_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a bytes value.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/bytes-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.date_schema", "anchor": "generatejsonschema-date_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a date value.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/date-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.time_schema", "anchor": "generatejsonschema-time_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a time value.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/time-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.datetime_schema", "anchor": "generatejsonschema-datetime_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a datetime value.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/datetime-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.timedelta_schema", "anchor": "generatejsonschema-timedelta_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a timedelta value.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/timedelta-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.literal_schema", "anchor": "generatejsonschema-literal_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a literal value.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/literal-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.missing_sentinel_schema", "anchor": "generatejsonschema-missing_sentinel_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches the `MISSING` sentinel value.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/missing-sentinel-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.enum_schema", "anchor": "generatejsonschema-enum_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches an Enum value.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/enum-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.is_instance_schema", "anchor": "generatejsonschema-is_instance_schema", "heading_level": 0, "md_text": "Handles JSON schema generation for a core schema that checks if a value is an instance of a class.\n\nUnless overridden in a subclass, this raises an error.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/is-instance-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.is_subclass_schema", "anchor": "generatejsonschema-is_subclass_schema", "heading_level": 0, "md_text": "Handles JSON schema generation for a core schema that checks if a value is a subclass of a class.\n\nFor backwards compatibility with v1, this does not raise an error, but can be overridden to change this.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/is-subclass-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.callable_schema", "anchor": "generatejsonschema-callable_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a callable value.\n\nUnless overridden in a subclass, this raises an error.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/callable-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.list_schema", "anchor": "generatejsonschema-list_schema", "heading_level": 0, "md_text": "Returns a schema that matches a list schema.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/list-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.tuple_positional_schema", "anchor": "generatejsonschema-tuple_positional_schema", "heading_level": 0, "md_text": "Replaced by `tuple_schema`.", "url": "https://docs.pydantic.dev/latest/api/tuple-positional-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.tuple_variable_schema", "anchor": "generatejsonschema-tuple_variable_schema", "heading_level": 0, "md_text": "Replaced by `tuple_schema`.", "url": "https://docs.pydantic.dev/latest/api/tuple-variable-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.tuple_schema", "anchor": "generatejsonschema-tuple_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a tuple schema e.g. `tuple[int,\nstr, bool]` or `tuple[int, ...]`.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/tuple-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.set_schema", "anchor": "generatejsonschema-set_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a set schema.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/set-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.frozenset_schema", "anchor": "generatejsonschema-frozenset_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a frozenset schema.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/frozenset-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.generator_schema", "anchor": "generatejsonschema-generator_schema", "heading_level": 0, "md_text": "Returns a JSON schema that represents the provided GeneratorSchema.\n\nArgs:\n    schema: The schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/generator-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.dict_schema", "anchor": "generatejsonschema-dict_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a dict schema.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/dict-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.function_before_schema", "anchor": "generatejsonschema-function_before_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a function-before schema.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/function-before-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.function_after_schema", "anchor": "generatejsonschema-function_after_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a function-after schema.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/function-after-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.function_plain_schema", "anchor": "generatejsonschema-function_plain_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a function-plain schema.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/function-plain-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.function_wrap_schema", "anchor": "generatejsonschema-function_wrap_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a function-wrap schema.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/function-wrap-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.default_schema", "anchor": "generatejsonschema-default_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a schema with a default value.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/default-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.get_default_value", "anchor": "generatejsonschema-get_default_value", "heading_level": 0, "md_text": "Get the default value to be used when generating a JSON Schema for a core schema with a default.\n\nThe default implementation is to use the statically defined default value. This method can be overridden\nif you want to make use of the default factory.\n\nArgs:\n    schema: The `'with-default'` core schema.\n\nReturns:\n    The default value to use, or [`NoDefault`][pydantic.json_schema.NoDefault] if no default\n        value is available.", "url": "https://docs.pydantic.dev/latest/api/get-default-value/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.nullable_schema", "anchor": "generatejsonschema-nullable_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a schema that allows null values.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/nullable-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.union_schema", "anchor": "generatejsonschema-union_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a schema that allows values matching any of the given schemas.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/union-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.get_union_of_schemas", "anchor": "generatejsonschema-get_union_of_schemas", "heading_level": 0, "md_text": "Returns the JSON Schema representation for the union of the provided JSON Schemas.\n\nThe result depends on the configured `'union_format'`.\n\nArgs:\n    schemas: The list of JSON Schemas to be included in the union.\n\nReturns:\n    The JSON Schema representing the union of schemas.", "url": "https://docs.pydantic.dev/latest/api/get-union-of-schemas/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.tagged_union_schema", "anchor": "generatejsonschema-tagged_union_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a schema that allows values matching any of the given schemas, where\nthe schemas are tagged with a discriminator field that indicates which schema should be used to validate\nthe value.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/tagged-union-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema._extract_discriminator", "anchor": "generatejsonschema-_extract_discriminator", "heading_level": 0, "md_text": "Extract a compatible OpenAPI discriminator from the schema and one_of choices that end up in the final\nschema.", "url": "https://docs.pydantic.dev/latest/api/-extract-discriminator/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.chain_schema", "anchor": "generatejsonschema-chain_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a core_schema.ChainSchema.\n\nWhen generating a schema for validation, we return the validation JSON schema for the first step in the chain.\nFor serialization, we return the serialization JSON schema for the last step in the chain.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/chain-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.lax_or_strict_schema", "anchor": "generatejsonschema-lax_or_strict_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a schema that allows values matching either the lax schema or the\nstrict schema.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/lax-or-strict-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.json_or_python_schema", "anchor": "generatejsonschema-json_or_python_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a schema that allows values matching either the JSON schema or the\nPython schema.\n\nThe JSON schema is used instead of the Python schema. If you want to use the Python schema, you should override\nthis method.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/json-or-python-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.typed_dict_schema", "anchor": "generatejsonschema-typed_dict_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a schema that defines a typed dict.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/typed-dict-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.typed_dict_field_schema", "anchor": "generatejsonschema-typed_dict_field_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a schema that defines a typed dict field.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/typed-dict-field-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.dataclass_field_schema", "anchor": "generatejsonschema-dataclass_field_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a schema that defines a dataclass field.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/dataclass-field-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.model_field_schema", "anchor": "generatejsonschema-model_field_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a schema that defines a model field.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/model-field-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.computed_field_schema", "anchor": "generatejsonschema-computed_field_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a schema that defines a computed field.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/computed-field-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.model_schema", "anchor": "generatejsonschema-model_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a schema that defines a model.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/model-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema._update_class_schema", "anchor": "generatejsonschema-_update_class_schema", "heading_level": 0, "md_text": "Update json_schema with the following, extracted from `config` and `cls`:\n\n* title\n* description\n* additional properties\n* json_schema_extra\n* deprecated\n\nDone in place, hence there's no return value as the original json_schema is mutated.\nNo ref resolving is involved here, as that's not appropriate for simple updates.", "url": "https://docs.pydantic.dev/latest/api/-update-class-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.resolve_ref_schema", "anchor": "generatejsonschema-resolve_ref_schema", "heading_level": 0, "md_text": "Resolve a JsonSchemaValue to the non-ref schema if it is a $ref schema.\n\nArgs:\n    json_schema: The schema to resolve.\n\nReturns:\n    The resolved schema.\n\nRaises:\n    RuntimeError: If the schema reference can't be found in definitions.", "url": "https://docs.pydantic.dev/latest/api/resolve-ref-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.model_fields_schema", "anchor": "generatejsonschema-model_fields_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a schema that defines a model's fields.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/model-fields-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.field_is_present", "anchor": "generatejsonschema-field_is_present", "heading_level": 0, "md_text": "Whether the field should be included in the generated JSON schema.\n\nArgs:\n    field: The schema for the field itself.\n\nReturns:\n    `True` if the field should be included in the generated JSON schema, `False` otherwise.", "url": "https://docs.pydantic.dev/latest/api/field-is-present/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.field_is_required", "anchor": "generatejsonschema-field_is_required", "heading_level": 0, "md_text": "Whether the field should be marked as required in the generated JSON schema.\n(Note that this is irrelevant if the field is not present in the JSON schema.).\n\nArgs:\n    field: The schema for the field itself.\n    total: Only applies to `TypedDictField`s.\n        Indicates if the `TypedDict` this field belongs to is total, in which case any fields that don't\n        explicitly specify `required=False` are required.\n\nReturns:\n    `True` if the field should be marked as required in the generated JSON schema, `False` otherwise.", "url": "https://docs.pydantic.dev/latest/api/field-is-required/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.dataclass_args_schema", "anchor": "generatejsonschema-dataclass_args_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a schema that defines a dataclass's constructor arguments.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/dataclass-args-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.dataclass_schema", "anchor": "generatejsonschema-dataclass_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a schema that defines a dataclass.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/dataclass-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.arguments_schema", "anchor": "generatejsonschema-arguments_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a schema that defines a function's arguments.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/arguments-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.kw_arguments_schema", "anchor": "generatejsonschema-kw_arguments_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a schema that defines a function's keyword arguments.\n\nArgs:\n    arguments: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/kw-arguments-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.p_arguments_schema", "anchor": "generatejsonschema-p_arguments_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a schema that defines a function's positional arguments.\n\nArgs:\n    arguments: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/p-arguments-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.get_argument_name", "anchor": "generatejsonschema-get_argument_name", "heading_level": 0, "md_text": "Retrieves the name of an argument.\n\nArgs:\n    argument: The core schema.\n\nReturns:\n    The name of the argument.", "url": "https://docs.pydantic.dev/latest/api/get-argument-name/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.arguments_v3_schema", "anchor": "generatejsonschema-arguments_v3_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a schema that defines a function's arguments.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/arguments-v3-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.call_schema", "anchor": "generatejsonschema-call_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a schema that defines a function call.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/call-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.custom_error_schema", "anchor": "generatejsonschema-custom_error_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a schema that defines a custom error.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/custom-error-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.json_schema", "anchor": "generatejsonschema-json_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a schema that defines a JSON object.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/json-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.url_schema", "anchor": "generatejsonschema-url_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a schema that defines a URL.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/url-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.multi_host_url_schema", "anchor": "generatejsonschema-multi_host_url_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a schema that defines a URL that can be used with multiple hosts.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/multi-host-url-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.uuid_schema", "anchor": "generatejsonschema-uuid_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a UUID.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/uuid-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.definitions_schema", "anchor": "generatejsonschema-definitions_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a schema that defines a JSON object with definitions.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/definitions-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.definition_ref_schema", "anchor": "generatejsonschema-definition_ref_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a schema that references a definition.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/definition-ref-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.ser_schema", "anchor": "generatejsonschema-ser_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a schema that defines a serialized object.\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/ser-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.complex_schema", "anchor": "generatejsonschema-complex_schema", "heading_level": 0, "md_text": "Generates a JSON schema that matches a complex number.\n\nJSON has no standard way to represent complex numbers. Complex number is not a numeric\ntype. Here we represent complex number as strings following the rule defined by Python.\nFor instance, '1+2j' is an accepted complex string. Details can be found in\n[Python's `complex` documentation][complex].\n\nArgs:\n    schema: The core schema.\n\nReturns:\n    The generated JSON schema.", "url": "https://docs.pydantic.dev/latest/api/complex-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.get_title_from_name", "anchor": "generatejsonschema-get_title_from_name", "heading_level": 0, "md_text": "Retrieves a title from a name.\n\nArgs:\n    name: The name to retrieve a title from.\n\nReturns:\n    The title.", "url": "https://docs.pydantic.dev/latest/api/get-title-from-name/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.field_title_should_be_set", "anchor": "generatejsonschema-field_title_should_be_set", "heading_level": 0, "md_text": "Returns true if a field with the given schema should have a title set based on the field name.\n\nIntuitively, we want this to return true for schemas that wouldn't otherwise provide their own title\n(e.g., int, float, str), and false for those that would (e.g., BaseModel subclasses).\n\nArgs:\n    schema: The schema to check.\n\nReturns:\n    `True` if the field should have a title set, `False` otherwise.", "url": "https://docs.pydantic.dev/latest/api/field-title-should-be-set/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.normalize_name", "anchor": "generatejsonschema-normalize_name", "heading_level": 0, "md_text": "Normalizes a name to be used as a key in a dictionary.\n\nArgs:\n    name: The name to normalize.\n\nReturns:\n    The normalized name.", "url": "https://docs.pydantic.dev/latest/api/normalize-name/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.get_defs_ref", "anchor": "generatejsonschema-get_defs_ref", "heading_level": 0, "md_text": "Override this method to change the way that definitions keys are generated from a core reference.\n\nArgs:\n    core_mode_ref: The core reference.\n\nReturns:\n    The definitions key.", "url": "https://docs.pydantic.dev/latest/api/get-defs-ref/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.get_cache_defs_ref_schema", "anchor": "generatejsonschema-get_cache_defs_ref_schema", "heading_level": 0, "md_text": "This method wraps the get_defs_ref method with some cache-lookup/population logic,\nand returns both the produced defs_ref and the JSON schema that will refer to the right definition.\n\nArgs:\n    core_ref: The core reference to get the definitions reference for.\n\nReturns:\n    A tuple of the definitions reference and the JSON schema that will refer to it.", "url": "https://docs.pydantic.dev/latest/api/get-cache-defs-ref-schema/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.handle_ref_overrides", "anchor": "generatejsonschema-handle_ref_overrides", "heading_level": 0, "md_text": "Remove any sibling keys that are redundant with the referenced schema.\n\nArgs:\n    json_schema: The schema to remove redundant sibling keys from.\n\nReturns:\n    The schema with redundant sibling keys removed.", "url": "https://docs.pydantic.dev/latest/api/handle-ref-overrides/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.encode_default", "anchor": "generatejsonschema-encode_default", "heading_level": 0, "md_text": "Encode a default value to a JSON-serializable value.\n\nThis is used to encode default values for fields in the generated JSON schema.\n\nArgs:\n    dft: The default value to encode.\n\nReturns:\n    The encoded default value.", "url": "https://docs.pydantic.dev/latest/api/encode-default/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.update_with_validations", "anchor": "generatejsonschema-update_with_validations", "heading_level": 0, "md_text": "Update the json_schema with the corresponding validations specified in the core_schema,\nusing the provided mapping to translate keys in core_schema to the appropriate keys for a JSON schema.\n\nArgs:\n    json_schema: The JSON schema to update.\n    core_schema: The core schema to get the validations from.\n    mapping: A mapping from core_schema attribute names to the corresponding JSON schema attribute names.", "url": "https://docs.pydantic.dev/latest/api/update-with-validations/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "ValidationsMapping", "anchor": "validationsmapping", "heading_level": 0, "md_text": "This class just contains mappings from core_schema attribute names to the corresponding\nJSON schema attribute names. While I suspect it is unlikely to be necessary, you can in\nprinciple override this class in a subclass of GenerateJsonSchema (by inheriting from\nGenerateJsonSchema.ValidationsMapping) to change these mappings.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.get_json_ref_counts", "anchor": "generatejsonschema-get_json_ref_counts", "heading_level": 0, "md_text": "Get all values corresponding to the key '$ref' anywhere in the json_schema.", "url": "https://docs.pydantic.dev/latest/api/get-json-ref-counts/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.emit_warning", "anchor": "generatejsonschema-emit_warning", "heading_level": 0, "md_text": "This method simply emits PydanticJsonSchemaWarnings based on handling in the `warning_message` method.", "url": "https://docs.pydantic.dev/latest/api/emit-warning/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "GenerateJsonSchema.render_warning_message", "anchor": "generatejsonschema-render_warning_message", "heading_level": 0, "md_text": "This method is responsible for ignoring warnings as desired, and for formatting the warning messages.\n\nYou can override the value of `ignored_warning_kinds` in a subclass of GenerateJsonSchema\nto modify what warnings are generated. If you want more control, you can override this method;\njust return None in situations where you don't want warnings to be emitted.\n\nArgs:\n    kind: The kind of warning to render. It can be one of the following:\n\n        - 'skipped-choice': A choice field was skipped because it had no valid choices.\n        - 'non-serializable-default': A default value was skipped because it was not JSON-serializable.\n    detail: A string with additional details about the warning.\n\nReturns:\n    The formatted warning message, or `None` if no warning should be emitted.", "url": "https://docs.pydantic.dev/latest/api/render-warning-message/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "SkipJsonSchema", "anchor": "skipjsonschema", "heading_level": 0, "md_text": "Add this as an annotation on a field to skip generating a JSON schema for that field.\n\nExample:\n    ```python\n    from pprint import pprint\n    from typing import Union\n\n    from pydantic import BaseModel\n    from pydantic.json_schema import SkipJsonSchema\n\n    class Model(BaseModel):\n        a: Union[int, None] = None  # (1)!\n        b: Union[int, SkipJsonSchema[None]] = None  # (2)!\n        c: SkipJsonSchema[Union[int, None]] = None  # (3)!\n\n    pprint(Model.model_json_schema())\n    '''\n    {\n        'properties': {\n            'a': {\n                'anyOf': [\n                    {'type': 'integer'},\n                    {'type': 'null'}\n                ],\n                'default': None,\n                'title': 'A'\n            },\n            'b': {\n                'default': None,\n                'title': 'B',\n                'type': 'integer'\n            }\n        },\n        'title': 'Model',\n        'type': 'object'\n    }\n    '''\n    ```\n\n    1. The integer and null types are both included in the schema for `a`.\n    2. The integer type is the only type included in the schema for `b`.\n    3. The entirety of the `c` field is omitted from the schema.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "handler_func", "anchor": "handler_func", "heading_level": 0, "md_text": "Generate a JSON schema based on the input schema.\n\nArgs:\n    schema_or_field: The core schema to generate a JSON schema from.\n\nReturns:\n    The generated JSON schema.\n\nRaises:\n    TypeError: If an unexpected schema type is encountered.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/json_schema", "source_site": "pydantic"}
{"title": "datetime_parse", "anchor": "datetime_parse", "heading_level": 0, "md_text": "The `datetime_parse` module is a backport module from V1.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/datetime_parse", "source_site": "pydantic"}
{"title": "errors", "anchor": "errors", "heading_level": 0, "md_text": "Pydantic-specific errors.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/errors", "source_site": "pydantic"}
{"title": "PydanticErrorMixin", "anchor": "pydanticerrormixin", "heading_level": 0, "md_text": "A mixin class for common functionality shared by all Pydantic-specific errors.\n\nAttributes:\n    message: A message describing the error.\n    code: An optional error code from PydanticErrorCodes enum.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/errors", "source_site": "pydantic"}
{"title": "PydanticUserError", "anchor": "pydanticusererror", "heading_level": 0, "md_text": "An error raised due to incorrect use of Pydantic.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/errors", "source_site": "pydantic"}
{"title": "PydanticUndefinedAnnotation", "anchor": "pydanticundefinedannotation", "heading_level": 0, "md_text": "A subclass of `NameError` raised when handling undefined annotations during `CoreSchema` generation.\n\nAttributes:\n    name: Name of the error.\n    message: Description of the error.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/errors", "source_site": "pydantic"}
{"title": "PydanticImportError", "anchor": "pydanticimporterror", "heading_level": 0, "md_text": "An error raised when an import fails due to module changes between V1 and V2.\n\nAttributes:\n    message: Description of the error.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/errors", "source_site": "pydantic"}
{"title": "PydanticSchemaGenerationError", "anchor": "pydanticschemagenerationerror", "heading_level": 0, "md_text": "An error raised during failures to generate a `CoreSchema` for some type.\n\nAttributes:\n    message: Description of the error.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/errors", "source_site": "pydantic"}
{"title": "PydanticInvalidForJsonSchema", "anchor": "pydanticinvalidforjsonschema", "heading_level": 0, "md_text": "An error raised during failures to generate a JSON schema for some `CoreSchema`.\n\nAttributes:\n    message: Description of the error.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/errors", "source_site": "pydantic"}
{"title": "PydanticForbiddenQualifier", "anchor": "pydanticforbiddenqualifier", "heading_level": 0, "md_text": "An error raised if a forbidden type qualifier is found in a type annotation.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/errors", "source_site": "pydantic"}
{"title": "PydanticUndefinedAnnotation.from_name_error", "anchor": "pydanticundefinedannotation-from_name_error", "heading_level": 0, "md_text": "Convert a `NameError` to a `PydanticUndefinedAnnotation` error.\n\nArgs:\n    name_error: `NameError` to be converted.\n\nReturns:\n    Converted `PydanticUndefinedAnnotation` error.", "url": "https://docs.pydantic.dev/latest/api/from-name-error/", "page": "pydantic/errors", "source_site": "pydantic"}
{"title": "aliases", "anchor": "aliases", "heading_level": 0, "md_text": "Support for alias configurations.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/aliases", "source_site": "pydantic"}
{"title": "AliasPath", "anchor": "aliaspath", "heading_level": 0, "md_text": "A data class used by `validation_alias` as a convenience to create aliases.\n\nAttributes:\n    path: A list of string or integer aliases.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/aliases", "source_site": "pydantic"}
{"title": "AliasChoices", "anchor": "aliaschoices", "heading_level": 0, "md_text": "A data class used by `validation_alias` as a convenience to create aliases.\n\nAttributes:\n    choices: A list containing a string or `AliasPath`.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/aliases", "source_site": "pydantic"}
{"title": "AliasGenerator", "anchor": "aliasgenerator", "heading_level": 0, "md_text": "A data class used by `alias_generator` as a convenience to create various aliases.\n\nAttributes:\n    alias: A callable that takes a field name and returns an alias for it.\n    validation_alias: A callable that takes a field name and returns a validation alias for it.\n    serialization_alias: A callable that takes a field name and returns a serialization alias for it.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/aliases", "source_site": "pydantic"}
{"title": "AliasPath.convert_to_aliases", "anchor": "aliaspath-convert_to_aliases", "heading_level": 0, "md_text": "Converts arguments to a list of string or integer aliases.\n\nReturns:\n    The list of aliases.", "url": "https://docs.pydantic.dev/latest/api/convert-to-aliases/", "page": "pydantic/aliases", "source_site": "pydantic"}
{"title": "AliasPath.search_dict_for_path", "anchor": "aliaspath-search_dict_for_path", "heading_level": 0, "md_text": "Searches a dictionary for the path specified by the alias.\n\nReturns:\n    The value at the specified path, or `PydanticUndefined` if the path is not found.", "url": "https://docs.pydantic.dev/latest/api/search-dict-for-path/", "page": "pydantic/aliases", "source_site": "pydantic"}
{"title": "AliasChoices.convert_to_aliases", "anchor": "aliaschoices-convert_to_aliases", "heading_level": 0, "md_text": "Converts arguments to a list of lists containing string or integer aliases.\n\nReturns:\n    The list of aliases.", "url": "https://docs.pydantic.dev/latest/api/convert-to-aliases/", "page": "pydantic/aliases", "source_site": "pydantic"}
{"title": "AliasGenerator._generate_alias", "anchor": "aliasgenerator-_generate_alias", "heading_level": 0, "md_text": "Generate an alias of the specified kind. Returns None if the alias generator is None.\n\nRaises:\n    TypeError: If the alias generator produces an invalid type.", "url": "https://docs.pydantic.dev/latest/api/-generate-alias/", "page": "pydantic/aliases", "source_site": "pydantic"}
{"title": "AliasGenerator.generate_aliases", "anchor": "aliasgenerator-generate_aliases", "heading_level": 0, "md_text": "Generate `alias`, `validation_alias`, and `serialization_alias` for a field.\n\nReturns:\n    A tuple of three aliases - validation, alias, and serialization.", "url": "https://docs.pydantic.dev/latest/api/generate-aliases/", "page": "pydantic/aliases", "source_site": "pydantic"}
{"title": "utils", "anchor": "utils", "heading_level": 0, "md_text": "The `utils` module is a backport module from V1.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/utils", "source_site": "pydantic"}
{"title": "warnings", "anchor": "warnings", "heading_level": 0, "md_text": "Pydantic-specific warnings.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/warnings", "source_site": "pydantic"}
{"title": "PydanticDeprecationWarning", "anchor": "pydanticdeprecationwarning", "heading_level": 0, "md_text": "A Pydantic specific deprecation warning.\n\nThis warning is raised when using deprecated functionality in Pydantic. It provides information on when the\ndeprecation was introduced and the expected version in which the corresponding functionality will be removed.\n\nAttributes:\n    message: Description of the warning.\n    since: Pydantic version in what the deprecation was introduced.\n    expected_removal: Pydantic version in what the corresponding functionality expected to be removed.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/warnings", "source_site": "pydantic"}
{"title": "PydanticDeprecatedSince20", "anchor": "pydanticdeprecatedsince20", "heading_level": 0, "md_text": "A specific `PydanticDeprecationWarning` subclass defining functionality deprecated since Pydantic 2.0.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/warnings", "source_site": "pydantic"}
{"title": "PydanticDeprecatedSince26", "anchor": "pydanticdeprecatedsince26", "heading_level": 0, "md_text": "A specific `PydanticDeprecationWarning` subclass defining functionality deprecated since Pydantic 2.6.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/warnings", "source_site": "pydantic"}
{"title": "PydanticDeprecatedSince29", "anchor": "pydanticdeprecatedsince29", "heading_level": 0, "md_text": "A specific `PydanticDeprecationWarning` subclass defining functionality deprecated since Pydantic 2.9.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/warnings", "source_site": "pydantic"}
{"title": "PydanticDeprecatedSince210", "anchor": "pydanticdeprecatedsince210", "heading_level": 0, "md_text": "A specific `PydanticDeprecationWarning` subclass defining functionality deprecated since Pydantic 2.10.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/warnings", "source_site": "pydantic"}
{"title": "PydanticDeprecatedSince211", "anchor": "pydanticdeprecatedsince211", "heading_level": 0, "md_text": "A specific `PydanticDeprecationWarning` subclass defining functionality deprecated since Pydantic 2.11.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/warnings", "source_site": "pydantic"}
{"title": "PydanticDeprecatedSince212", "anchor": "pydanticdeprecatedsince212", "heading_level": 0, "md_text": "A specific `PydanticDeprecationWarning` subclass defining functionality deprecated since Pydantic 2.12.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/warnings", "source_site": "pydantic"}
{"title": "PydanticExperimentalWarning", "anchor": "pydanticexperimentalwarning", "heading_level": 0, "md_text": "A Pydantic specific experimental functionality warning.\n\nIt is raised to warn users that the functionality may change or be removed in future versions of Pydantic.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/warnings", "source_site": "pydantic"}
{"title": "CoreSchemaGenerationWarning", "anchor": "coreschemagenerationwarning", "heading_level": 0, "md_text": "A warning raised during core schema generation.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/warnings", "source_site": "pydantic"}
{"title": "ArbitraryTypeWarning", "anchor": "arbitrarytypewarning", "heading_level": 0, "md_text": "A warning raised when Pydantic fails to generate a core schema for an arbitrary type.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/warnings", "source_site": "pydantic"}
{"title": "UnsupportedFieldAttributeWarning", "anchor": "unsupportedfieldattributewarning", "heading_level": 0, "md_text": "A warning raised when a `Field()` attribute isn't supported in the context it is used.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/warnings", "source_site": "pydantic"}
{"title": "TypedDictExtraConfigWarning", "anchor": "typeddictextraconfigwarning", "heading_level": 0, "md_text": "A warning raised when the [`extra`][pydantic.ConfigDict.extra] configuration is incompatible with the `closed` or `extra_items` specification.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/warnings", "source_site": "pydantic"}
{"title": "error_wrappers", "anchor": "error_wrappers", "heading_level": 0, "md_text": "The `error_wrappers` module is a backport module from V1.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/error_wrappers", "source_site": "pydantic"}
{"title": "alias_generators", "anchor": "alias_generators", "heading_level": 0, "md_text": "Alias generators for converting between different capitalization conventions.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/alias_generators", "source_site": "pydantic"}
{"title": "to_pascal", "anchor": "to_pascal", "heading_level": 0, "md_text": "Convert a snake_case string to PascalCase.\n\nArgs:\n    snake: The string to convert.\n\nReturns:\n    The PascalCase string.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/alias_generators", "source_site": "pydantic"}
{"title": "to_camel", "anchor": "to_camel", "heading_level": 0, "md_text": "Convert a snake_case string to camelCase.\n\nArgs:\n    snake: The string to convert.\n\nReturns:\n    The converted camelCase string.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/alias_generators", "source_site": "pydantic"}
{"title": "to_snake", "anchor": "to_snake", "heading_level": 0, "md_text": "Convert a PascalCase, camelCase, or kebab-case string to snake_case.\n\nArgs:\n    camel: The string to convert.\n\nReturns:\n    The converted string in snake_case.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/alias_generators", "source_site": "pydantic"}
{"title": "tools", "anchor": "tools", "heading_level": 0, "md_text": "The `tools` module is a backport module from V1.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/tools", "source_site": "pydantic"}
{"title": "class_validators", "anchor": "class_validators", "heading_level": 0, "md_text": "`class_validators` module is a backport module from V1.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/class_validators", "source_site": "pydantic"}
{"title": "networks", "anchor": "networks", "heading_level": 0, "md_text": "The networks module contains types for common network-related fields.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "UrlConstraints", "anchor": "urlconstraints", "heading_level": 0, "md_text": "Url constraints.\n\nAttributes:\n    max_length: The maximum length of the url. Defaults to `None`.\n    allowed_schemes: The allowed schemes. Defaults to `None`.\n    host_required: Whether the host is required. Defaults to `None`.\n    default_host: The default host. Defaults to `None`.\n    default_port: The default port. Defaults to `None`.\n    default_path: The default path. Defaults to `None`.\n    preserve_empty_path: Whether to preserve empty URL paths. Defaults to `None`.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "AnyUrl", "anchor": "anyurl", "heading_level": 0, "md_text": "Base type for all URLs.\n\n* Any scheme allowed\n* Top-level domain (TLD) not required\n* Host not required\n\nAssuming an input URL of `http://samuel:pass@example.com:8000/the/path/?query=here#fragment=is;this=bit`,\nthe types export the following properties:\n\n- `scheme`: the URL scheme (`http`), always set.\n- `host`: the URL host (`example.com`).\n- `username`: optional username if included (`samuel`).\n- `password`: optional password if included (`pass`).\n- `port`: optional port (`8000`).\n- `path`: optional path (`/the/path/`).\n- `query`: optional URL query (for example, `GET` arguments or \"search string\", such as `query=here`).\n- `fragment`: optional fragment (`fragment=is;this=bit`).", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "AnyHttpUrl", "anchor": "anyhttpurl", "heading_level": 0, "md_text": "A type that will accept any http or https URL.\n\n* TLD not required\n* Host not required", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "HttpUrl", "anchor": "httpurl", "heading_level": 0, "md_text": "A type that will accept any http or https URL.\n\n* TLD not required\n* Host not required\n* Max length 2083\n\n```python\nfrom pydantic import BaseModel, HttpUrl, ValidationError\n\nclass MyModel(BaseModel):\n    url: HttpUrl\n\nm = MyModel(url='http://www.example.com')  # (1)!\nprint(m.url)\n#> http://www.example.com/\n\ntry:\n    MyModel(url='ftp://invalid.url')\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for MyModel\n    url\n      URL scheme should be 'http' or 'https' [type=url_scheme, input_value='ftp://invalid.url', input_type=str]\n    '''\n\ntry:\n    MyModel(url='not a url')\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for MyModel\n    url\n      Input should be a valid URL, relative URL without a base [type=url_parsing, input_value='not a url', input_type=str]\n    '''\n```\n\n1. Note: mypy would prefer `m = MyModel(url=HttpUrl('http://www.example.com'))`, but Pydantic will convert the string to an HttpUrl instance anyway.\n\n\"International domains\" (e.g. a URL where the host or TLD includes non-ascii characters) will be encoded via\n[punycode](https://en.wikipedia.org/wiki/Punycode) (see\n[this article](https://www.xudongz.com/blog/2017/idn-phishing/) for a good description of why this is important):\n\n```python\nfrom pydantic import BaseModel, HttpUrl\n\nclass MyModel(BaseModel):\n    url: HttpUrl\n\nm1 = MyModel(url='http://puny\u00a3code.com')\nprint(m1.url)\n#> http://xn--punycode-eja.com/\nm2 = MyModel(url='https://www.\u0430\u0440\u0440\u04cf\u0435.com/')\nprint(m2.url)\n#> https://www.xn--80ak6aa92e.com/\nm3 = MyModel(url='https://www.example.\u73e0\u5b9d/')\nprint(m3.url)\n#> https://www.example.xn--pbt977c/\n```", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "AnyWebsocketUrl", "anchor": "anywebsocketurl", "heading_level": 0, "md_text": "A type that will accept any ws or wss URL.\n\n* TLD not required\n* Host not required", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "WebsocketUrl", "anchor": "websocketurl", "heading_level": 0, "md_text": "A type that will accept any ws or wss URL.\n\n* TLD not required\n* Host not required\n* Max length 2083", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "FileUrl", "anchor": "fileurl", "heading_level": 0, "md_text": "A type that will accept any file URL.\n\n* Host not required", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "FtpUrl", "anchor": "ftpurl", "heading_level": 0, "md_text": "A type that will accept ftp URL.\n\n* TLD not required\n* Host not required", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "PostgresDsn", "anchor": "postgresdsn", "heading_level": 0, "md_text": "A type that will accept any Postgres DSN.\n\n* User info required\n* TLD not required\n* Host required\n* Supports multiple hosts\n\nIf further validation is required, these properties can be used by validators to enforce specific behaviour:\n\n```python\nfrom pydantic import (\n    BaseModel,\n    HttpUrl,\n    PostgresDsn,\n    ValidationError,\n    field_validator,\n)\n\nclass MyModel(BaseModel):\n    url: HttpUrl\n\nm = MyModel(url='http://www.example.com')\n\n# the repr() method for a url will display all properties of the url\nprint(repr(m.url))\n#> HttpUrl('http://www.example.com/')\nprint(m.url.scheme)\n#> http\nprint(m.url.host)\n#> www.example.com\nprint(m.url.port)\n#> 80\n\nclass MyDatabaseModel(BaseModel):\n    db: PostgresDsn\n\n    @field_validator('db')\n    def check_db_name(cls, v):\n        assert v.path and len(v.path) > 1, 'database must be provided'\n        return v\n\nm = MyDatabaseModel(db='postgres://user:pass@localhost:5432/foobar')\nprint(m.db)\n#> postgres://user:pass@localhost:5432/foobar\n\ntry:\n    MyDatabaseModel(db='postgres://user:pass@localhost:5432')\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for MyDatabaseModel\n    db\n      Assertion failed, database must be provided\n    assert (None)\n     +  where None = PostgresDsn('postgres://user:pass@localhost:5432').path [type=assertion_error, input_value='postgres://user:pass@localhost:5432', input_type=str]\n    '''\n```", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "CockroachDsn", "anchor": "cockroachdsn", "heading_level": 0, "md_text": "A type that will accept any Cockroach DSN.\n\n* User info required\n* TLD not required\n* Host required", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "AmqpDsn", "anchor": "amqpdsn", "heading_level": 0, "md_text": "A type that will accept any AMQP DSN.\n\n* User info required\n* TLD not required\n* Host not required", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "RedisDsn", "anchor": "redisdsn", "heading_level": 0, "md_text": "A type that will accept any Redis DSN.\n\n* User info required\n* TLD not required\n* Host required (e.g., `rediss://:pass@localhost`)", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "MongoDsn", "anchor": "mongodsn", "heading_level": 0, "md_text": "A type that will accept any MongoDB DSN.\n\n* User info not required\n* Database name not required\n* Port not required\n* User info may be passed without user part (e.g., `mongodb://mongodb0.example.com:27017`).", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "KafkaDsn", "anchor": "kafkadsn", "heading_level": 0, "md_text": "A type that will accept any Kafka DSN.\n\n* User info required\n* TLD not required\n* Host not required", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "NatsDsn", "anchor": "natsdsn", "heading_level": 0, "md_text": "A type that will accept any NATS DSN.\n\nNATS is a connective technology built for the ever increasingly hyper-connected world.\nIt is a single technology that enables applications to securely communicate across\nany combination of cloud vendors, on-premise, edge, web and mobile, and devices.\nMore: https://nats.io", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "MySQLDsn", "anchor": "mysqldsn", "heading_level": 0, "md_text": "A type that will accept any MySQL DSN.\n\n* User info required\n* TLD not required\n* Host not required", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "MariaDBDsn", "anchor": "mariadbdsn", "heading_level": 0, "md_text": "A type that will accept any MariaDB DSN.\n\n* User info required\n* TLD not required\n* Host not required", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "ClickHouseDsn", "anchor": "clickhousedsn", "heading_level": 0, "md_text": "A type that will accept any ClickHouse DSN.\n\n* User info required\n* TLD not required\n* Host not required", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "SnowflakeDsn", "anchor": "snowflakedsn", "heading_level": 0, "md_text": "A type that will accept any Snowflake DSN.\n\n* User info required\n* TLD not required\n* Host required", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "NameEmail", "anchor": "nameemail", "heading_level": 0, "md_text": "Info:\n    To use this type, you need to install the optional\n    [`email-validator`](https://github.com/JoshData/python-email-validator) package:\n\n    ```bash\n    pip install email-validator\n    ```\n\nValidate a name and email address combination, as specified by\n[RFC 5322](https://datatracker.ietf.org/doc/html/rfc5322#section-3.4).\n\nThe `NameEmail` has two properties: `name` and `email`.\nIn case the `name` is not provided, it's inferred from the email address.\n\n```python\nfrom pydantic import BaseModel, NameEmail\n\nclass User(BaseModel):\n    email: NameEmail\n\nuser = User(email='Fred Bloggs <fred.bloggs@example.com>')\nprint(user.email)\n#> Fred Bloggs <fred.bloggs@example.com>\nprint(user.email.name)\n#> Fred Bloggs\n\nuser = User(email='fred.bloggs@example.com')\nprint(user.email)\n#> fred.bloggs <fred.bloggs@example.com>\nprint(user.email.name)\n#> fred.bloggs\n```", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "validate_email", "anchor": "validate_email", "heading_level": 0, "md_text": "Email address validation using [email-validator](https://pypi.org/project/email-validator/).\n\nReturns:\n    A tuple containing the local part of the email (or the name for \"pretty\" email addresses)\n        and the normalized email.\n\nRaises:\n    PydanticCustomError: If the email is invalid.\n\nNote:\n    Note that:\n\n    * Raw IP address (literal) domain parts are not allowed.\n    * `\"John Doe <local_part@domain.com>\"` style \"pretty\" email addresses are processed.\n    * Spaces are striped from the beginning and end of addresses, but no error is raised.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "UrlConstraints.defined_constraints", "anchor": "urlconstraints-defined_constraints", "heading_level": 0, "md_text": "Fetch a key / value mapping of constraints to values that are not None. Used for core schema updates.", "url": "https://docs.pydantic.dev/latest/api/defined-constraints/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "_BaseUrl.scheme", "anchor": "_baseurl-scheme", "heading_level": 0, "md_text": "The scheme part of the URL.\n\ne.g. `https` in `https://user:pass@host:port/path?query#fragment`", "url": "https://docs.pydantic.dev/latest/api/scheme/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "_BaseUrl.username", "anchor": "_baseurl-username", "heading_level": 0, "md_text": "The username part of the URL, or `None`.\n\ne.g. `user` in `https://user:pass@host:port/path?query#fragment`", "url": "https://docs.pydantic.dev/latest/api/username/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "_BaseUrl.password", "anchor": "_baseurl-password", "heading_level": 0, "md_text": "The password part of the URL, or `None`.\n\ne.g. `pass` in `https://user:pass@host:port/path?query#fragment`", "url": "https://docs.pydantic.dev/latest/api/password/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "_BaseUrl.host", "anchor": "_baseurl-host", "heading_level": 0, "md_text": "The host part of the URL, or `None`.\n\nIf the URL must be punycode encoded, this is the encoded host, e.g if the input URL is `https://\u00a3\u00a3\u00a3.com`,\n`host` will be `xn--9aaa.com`", "url": "https://docs.pydantic.dev/latest/api/host/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "_BaseUrl.unicode_host", "anchor": "_baseurl-unicode_host", "heading_level": 0, "md_text": "The host part of the URL as a unicode string, or `None`.\n\ne.g. `host` in `https://user:pass@host:port/path?query#fragment`\n\nIf the URL must be punycode encoded, this is the decoded host, e.g if the input URL is `https://\u00a3\u00a3\u00a3.com`,\n`unicode_host()` will be `\u00a3\u00a3\u00a3.com`", "url": "https://docs.pydantic.dev/latest/api/unicode-host/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "_BaseUrl.port", "anchor": "_baseurl-port", "heading_level": 0, "md_text": "The port part of the URL, or `None`.\n\ne.g. `port` in `https://user:pass@host:port/path?query#fragment`", "url": "https://docs.pydantic.dev/latest/api/port/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "_BaseUrl.path", "anchor": "_baseurl-path", "heading_level": 0, "md_text": "The path part of the URL, or `None`.\n\ne.g. `/path` in `https://user:pass@host:port/path?query#fragment`", "url": "https://docs.pydantic.dev/latest/api/path/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "_BaseUrl.query", "anchor": "_baseurl-query", "heading_level": 0, "md_text": "The query part of the URL, or `None`.\n\ne.g. `query` in `https://user:pass@host:port/path?query#fragment`", "url": "https://docs.pydantic.dev/latest/api/query/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "_BaseUrl.query_params", "anchor": "_baseurl-query_params", "heading_level": 0, "md_text": "The query part of the URL as a list of key-value pairs.\n\ne.g. `[('foo', 'bar')]` in `https://user:pass@host:port/path?foo=bar#fragment`", "url": "https://docs.pydantic.dev/latest/api/query-params/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "_BaseUrl.fragment", "anchor": "_baseurl-fragment", "heading_level": 0, "md_text": "The fragment part of the URL, or `None`.\n\ne.g. `fragment` in `https://user:pass@host:port/path?query#fragment`", "url": "https://docs.pydantic.dev/latest/api/fragment/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "_BaseUrl.unicode_string", "anchor": "_baseurl-unicode_string", "heading_level": 0, "md_text": "The URL as a unicode string, unlike `__str__()` this will not punycode encode the host.\n\nIf the URL must be punycode encoded, this is the decoded string, e.g if the input URL is `https://\u00a3\u00a3\u00a3.com`,\n`unicode_string()` will be `https://\u00a3\u00a3\u00a3.com`", "url": "https://docs.pydantic.dev/latest/api/unicode-string/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "_BaseUrl.encoded_string", "anchor": "_baseurl-encoded_string", "heading_level": 0, "md_text": "The URL's encoded string representation via __str__().\n\nThis returns the punycode-encoded host version of the URL as a string.", "url": "https://docs.pydantic.dev/latest/api/encoded-string/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "_BaseUrl.__str__", "anchor": "_baseurl-__str__", "heading_level": 0, "md_text": "The URL as a string, this will punycode encode the host if required.", "url": "https://docs.pydantic.dev/latest/api/--str--/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "_BaseUrl.build", "anchor": "_baseurl-build", "heading_level": 0, "md_text": "Build a new `Url` instance from its component parts.\n\nArgs:\n    scheme: The scheme part of the URL.\n    username: The username part of the URL, or omit for no username.\n    password: The password part of the URL, or omit for no password.\n    host: The host part of the URL.\n    port: The port part of the URL, or omit for no port.\n    path: The path part of the URL, or omit for no path.\n    query: The query part of the URL, or omit for no query.\n    fragment: The fragment part of the URL, or omit for no fragment.\n\nReturns:\n    An instance of URL", "url": "https://docs.pydantic.dev/latest/api/build/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "_BaseMultiHostUrl.scheme", "anchor": "_basemultihosturl-scheme", "heading_level": 0, "md_text": "The scheme part of the URL.\n\ne.g. `https` in `https://foo.com,bar.com/path?query#fragment`", "url": "https://docs.pydantic.dev/latest/api/scheme/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "_BaseMultiHostUrl.path", "anchor": "_basemultihosturl-path", "heading_level": 0, "md_text": "The path part of the URL, or `None`.\n\ne.g. `/path` in `https://foo.com,bar.com/path?query#fragment`", "url": "https://docs.pydantic.dev/latest/api/path/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "_BaseMultiHostUrl.query", "anchor": "_basemultihosturl-query", "heading_level": 0, "md_text": "The query part of the URL, or `None`.\n\ne.g. `query` in `https://foo.com,bar.com/path?query#fragment`", "url": "https://docs.pydantic.dev/latest/api/query/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "_BaseMultiHostUrl.query_params", "anchor": "_basemultihosturl-query_params", "heading_level": 0, "md_text": "The query part of the URL as a list of key-value pairs.\n\ne.g. `[('foo', 'bar')]` in `https://foo.com,bar.com/path?foo=bar#fragment`", "url": "https://docs.pydantic.dev/latest/api/query-params/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "_BaseMultiHostUrl.fragment", "anchor": "_basemultihosturl-fragment", "heading_level": 0, "md_text": "The fragment part of the URL, or `None`.\n\ne.g. `fragment` in `https://foo.com,bar.com/path?query#fragment`", "url": "https://docs.pydantic.dev/latest/api/fragment/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "_BaseMultiHostUrl.hosts", "anchor": "_basemultihosturl-hosts", "heading_level": 0, "md_text": "The hosts of the `MultiHostUrl` as [`MultiHostHost`][pydantic_core.MultiHostHost] typed dicts.\n\n```python\nfrom pydantic_core import MultiHostUrl\n\nmhu = MultiHostUrl('https://foo.com:123,foo:bar@bar.com/path')\nprint(mhu.hosts())\n\"\"\"\n[\n    {'username': None, 'password': None, 'host': 'foo.com', 'port': 123},\n    {'username': 'foo', 'password': 'bar', 'host': 'bar.com', 'port': 443}\n]\n```\nReturns:\n    A list of dicts, each representing a host.", "url": "https://docs.pydantic.dev/latest/api/hosts/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "_BaseMultiHostUrl.encoded_string", "anchor": "_basemultihosturl-encoded_string", "heading_level": 0, "md_text": "The URL's encoded string representation via __str__().\n\nThis returns the punycode-encoded host version of the URL as a string.", "url": "https://docs.pydantic.dev/latest/api/encoded-string/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "_BaseMultiHostUrl.unicode_string", "anchor": "_basemultihosturl-unicode_string", "heading_level": 0, "md_text": "The URL as a unicode string, unlike `__str__()` this will not punycode encode the hosts.", "url": "https://docs.pydantic.dev/latest/api/unicode-string/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "_BaseMultiHostUrl.__str__", "anchor": "_basemultihosturl-__str__", "heading_level": 0, "md_text": "The URL as a string, this will punycode encode the host if required.", "url": "https://docs.pydantic.dev/latest/api/--str--/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "_BaseMultiHostUrl.build", "anchor": "_basemultihosturl-build", "heading_level": 0, "md_text": "Build a new `MultiHostUrl` instance from its component parts.\n\nThis method takes either `hosts` - a list of `MultiHostHost` typed dicts, or the individual components\n`username`, `password`, `host` and `port`.\n\nArgs:\n    scheme: The scheme part of the URL.\n    hosts: Multiple hosts to build the URL from.\n    username: The username part of the URL.\n    password: The password part of the URL.\n    host: The host part of the URL.\n    port: The port part of the URL.\n    path: The path part of the URL.\n    query: The query part of the URL, or omit for no query.\n    fragment: The fragment part of the URL, or omit for no fragment.\n\nReturns:\n    An instance of `MultiHostUrl`", "url": "https://docs.pydantic.dev/latest/api/build/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "PostgresDsn.host", "anchor": "postgresdsn-host", "heading_level": 0, "md_text": "The required URL host.", "url": "https://docs.pydantic.dev/latest/api/host/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "CockroachDsn.host", "anchor": "cockroachdsn-host", "heading_level": 0, "md_text": "The required URL host.", "url": "https://docs.pydantic.dev/latest/api/host/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "RedisDsn.host", "anchor": "redisdsn-host", "heading_level": 0, "md_text": "The required URL host.", "url": "https://docs.pydantic.dev/latest/api/host/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "SnowflakeDsn.host", "anchor": "snowflakedsn-host", "heading_level": 0, "md_text": "The required URL host.", "url": "https://docs.pydantic.dev/latest/api/host/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "EmailStr", "anchor": "emailstr", "heading_level": 0, "md_text": "Info:\n    To use this type, you need to install the optional\n    [`email-validator`](https://github.com/JoshData/python-email-validator) package:\n\n    ```bash\n    pip install email-validator\n    ```\n\nValidate email addresses.\n\n```python\nfrom pydantic import BaseModel, EmailStr\n\nclass Model(BaseModel):\n    email: EmailStr\n\nprint(Model(email='contact@mail.com'))\n#> email='contact@mail.com'\n```", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "IPvAnyAddress", "anchor": "ipvanyaddress", "heading_level": 0, "md_text": "Validate an IPv4 or IPv6 address.\n\n```python\nfrom pydantic import BaseModel\nfrom pydantic.networks import IPvAnyAddress\n\nclass IpModel(BaseModel):\n    ip: IPvAnyAddress\n\nprint(IpModel(ip='127.0.0.1'))\n#> ip=IPv4Address('127.0.0.1')\n\ntry:\n    IpModel(ip='http://www.example.com')\nexcept ValueError as e:\n    print(e.errors())\n    '''\n    [\n        {\n            'type': 'ip_any_address',\n            'loc': ('ip',),\n            'msg': 'value is not a valid IPv4 or IPv6 address',\n            'input': 'http://www.example.com',\n        }\n    ]\n    '''\n```", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "IPvAnyInterface", "anchor": "ipvanyinterface", "heading_level": 0, "md_text": "Validate an IPv4 or IPv6 interface.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "IPvAnyNetwork", "anchor": "ipvanynetwork", "heading_level": 0, "md_text": "Validate an IPv4 or IPv6 network.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "IPvAnyAddress.__new__", "anchor": "ipvanyaddress-__new__", "heading_level": 0, "md_text": "Validate an IPv4 or IPv6 address.", "url": "https://docs.pydantic.dev/latest/api/--new--/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "IPvAnyInterface.__new__", "anchor": "ipvanyinterface-__new__", "heading_level": 0, "md_text": "Validate an IPv4 or IPv6 interface.", "url": "https://docs.pydantic.dev/latest/api/--new--/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "IPvAnyNetwork.__new__", "anchor": "ipvanynetwork-__new__", "heading_level": 0, "md_text": "Validate an IPv4 or IPv6 network.", "url": "https://docs.pydantic.dev/latest/api/--new--/", "page": "pydantic/networks", "source_site": "pydantic"}
{"title": "main", "anchor": "main", "heading_level": 0, "md_text": "Logic for creating models.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/main", "source_site": "pydantic"}
{"title": "BaseModel", "anchor": "basemodel", "heading_level": 0, "md_text": "A base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/main", "source_site": "pydantic"}
{"title": "create_model", "anchor": "create_model", "heading_level": 0, "md_text": "Dynamically creates and returns a new Pydantic model, in other words, `create_model` dynamically creates a\nsubclass of [`BaseModel`][pydantic.BaseModel].\n\nArgs:\n    model_name: The name of the newly created model.\n    __config__: The configuration of the new model.\n    __doc__: The docstring of the new model.\n    __base__: The base class or classes for the new model.\n    __module__: The name of the module that the model belongs to;\n        if `None`, the value is taken from `sys._getframe(1)`\n    __validators__: A dictionary of methods that validate fields. The keys are the names of the validation methods to\n        be added to the model, and the values are the validation methods themselves. You can read more about functional\n        validators [here](https://docs.pydantic.dev/2.9/concepts/validators/#field-validators).\n    __cls_kwargs__: A dictionary of keyword arguments for class creation, such as `metaclass`.\n    __qualname__: The qualified name of the newly created model.\n    **field_definitions: Field definitions of the new model. Either:\n\n        - a single element, representing the type annotation of the field.\n        - a two-tuple, the first element being the type and the second element the assigned value\n          (either a default or the [`Field()`][pydantic.Field] function).\n\nReturns:\n    The new [model][pydantic.BaseModel].\n\nRaises:\n    PydanticUserError: If `__base__` and `__config__` are both passed.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/main", "source_site": "pydantic"}
{"title": "BaseModel.__init__", "anchor": "basemodel-__init__", "heading_level": 0, "md_text": "Create a new model by parsing and validating input data from keyword arguments.\n\nRaises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model.\n\n`self` is explicitly positional-only to allow `self` as a field name.", "url": "https://docs.pydantic.dev/latest/api/--init--/", "page": "pydantic/main", "source_site": "pydantic"}
{"title": "BaseModel.model_fields", "anchor": "basemodel-model_fields", "heading_level": 0, "md_text": "A mapping of field names to their respective [`FieldInfo`][pydantic.fields.FieldInfo] instances.", "url": "https://docs.pydantic.dev/latest/api/model-fields/", "page": "pydantic/main", "source_site": "pydantic"}
{"title": "BaseModel.model_computed_fields", "anchor": "basemodel-model_computed_fields", "heading_level": 0, "md_text": "A mapping of computed field names to their respective [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] instances.", "url": "https://docs.pydantic.dev/latest/api/model-computed-fields/", "page": "pydantic/main", "source_site": "pydantic"}
{"title": "BaseModel.model_extra", "anchor": "basemodel-model_extra", "heading_level": 0, "md_text": "Get extra fields set during validation.\n\nReturns:\n    A dictionary of extra fields, or `None` if `config.extra` is not set to `\"allow\"`.", "url": "https://docs.pydantic.dev/latest/api/model-extra/", "page": "pydantic/main", "source_site": "pydantic"}
{"title": "BaseModel.model_fields_set", "anchor": "basemodel-model_fields_set", "heading_level": 0, "md_text": "Returns the set of fields that have been explicitly set on this model instance.\n\nReturns:\n    A set of strings representing the fields that have been set,\n        i.e. that were not filled from defaults.", "url": "https://docs.pydantic.dev/latest/api/model-fields-set/", "page": "pydantic/main", "source_site": "pydantic"}
{"title": "BaseModel.model_construct", "anchor": "basemodel-model_construct", "heading_level": 0, "md_text": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.", "url": "https://docs.pydantic.dev/latest/api/model-construct/", "page": "pydantic/main", "source_site": "pydantic"}
{"title": "BaseModel.model_copy", "anchor": "basemodel-model_copy", "heading_level": 0, "md_text": "Returns a copy of the model.\n\nArgs:\n    update: Values to change/add in the new model. Note: the data is not validated\n        before creating the new model. You should trust this data.\n    deep: Set to `True` to make a deep copy of the model.\n\nReturns:\n    New model instance.", "url": "https://docs.pydantic.dev/latest/api/model-copy/", "page": "pydantic/main", "source_site": "pydantic"}
{"title": "BaseModel.model_dump", "anchor": "basemodel-model_dump", "heading_level": 0, "md_text": "Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nArgs:\n    mode: The mode in which `to_python` should run.\n        If mode is 'json', the output will only contain JSON serializable types.\n        If mode is 'python', the output may contain non-JSON-serializable Python objects.\n    include: A set of fields to include in the output.\n    exclude: A set of fields to exclude from the output.\n    context: Additional context to pass to the serializer.\n    by_alias: Whether to use the field's alias in the dictionary key if defined.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that are set to their default value.\n    exclude_none: Whether to exclude fields that have a value of `None`.\n    exclude_computed_fields: Whether to exclude computed fields.\n        While this can be useful for round-tripping, it is usually recommended to use the dedicated\n        `round_trip` parameter instead.\n    round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n    warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n        \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n    fallback: A function to call when an unknown value is encountered. If not provided,\n        a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n    serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n    A dictionary representation of the model.", "url": "https://docs.pydantic.dev/latest/api/model-dump/", "page": "pydantic/main", "source_site": "pydantic"}
{"title": "BaseModel.model_dump_json", "anchor": "basemodel-model_dump_json", "heading_level": 0, "md_text": "Generates a JSON representation of the model using Pydantic's `to_json` method.\n\nArgs:\n    indent: Indentation to use in the JSON output. If None is passed, the output will be compact.\n    ensure_ascii: If `True`, the output is guaranteed to have all incoming non-ASCII characters escaped.\n        If `False` (the default), these characters will be output as-is.\n    include: Field(s) to include in the JSON output.\n    exclude: Field(s) to exclude from the JSON output.\n    context: Additional context to pass to the serializer.\n    by_alias: Whether to serialize using field aliases.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that are set to their default value.\n    exclude_none: Whether to exclude fields that have a value of `None`.\n    exclude_computed_fields: Whether to exclude computed fields.\n        While this can be useful for round-tripping, it is usually recommended to use the dedicated\n        `round_trip` parameter instead.\n    round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n    warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n        \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n    fallback: A function to call when an unknown value is encountered. If not provided,\n        a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n    serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n    A JSON string representation of the model.", "url": "https://docs.pydantic.dev/latest/api/model-dump-json/", "page": "pydantic/main", "source_site": "pydantic"}
{"title": "BaseModel.model_json_schema", "anchor": "basemodel-model_json_schema", "heading_level": 0, "md_text": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    union_format: The format to use when combining schemas from unions together. Can be one of:\n\n        - `'any_of'`: Use the [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\n        keyword to combine schemas (the default).\n        - `'primitive_type_array'`: Use the [`type`](https://json-schema.org/understanding-json-schema/reference/type)\n        keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\n        type (`string`, `boolean`, `null`, `integer` or `number`) or contains constraints/metadata, falls back to\n        `any_of`.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.", "url": "https://docs.pydantic.dev/latest/api/model-json-schema/", "page": "pydantic/main", "source_site": "pydantic"}
{"title": "BaseModel.model_parametrized_name", "anchor": "basemodel-model_parametrized_name", "heading_level": 0, "md_text": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.", "url": "https://docs.pydantic.dev/latest/api/model-parametrized-name/", "page": "pydantic/main", "source_site": "pydantic"}
{"title": "BaseModel.model_post_init", "anchor": "basemodel-model_post_init", "heading_level": 0, "md_text": "Override this method to perform additional initialization after `__init__` and `model_construct`.\nThis is useful if you want to do some validation that requires the entire model to be initialized.", "url": "https://docs.pydantic.dev/latest/api/model-post-init/", "page": "pydantic/main", "source_site": "pydantic"}
{"title": "BaseModel.model_rebuild", "anchor": "basemodel-model_rebuild", "heading_level": 0, "md_text": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.", "url": "https://docs.pydantic.dev/latest/api/model-rebuild/", "page": "pydantic/main", "source_site": "pydantic"}
{"title": "BaseModel.model_validate", "anchor": "basemodel-model_validate", "heading_level": 0, "md_text": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    extra: Whether to ignore, allow, or forbid extra data during model validation.\n        See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.", "url": "https://docs.pydantic.dev/latest/api/model-validate/", "page": "pydantic/main", "source_site": "pydantic"}
{"title": "BaseModel.model_validate_json", "anchor": "basemodel-model_validate_json", "heading_level": 0, "md_text": "Validate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    extra: Whether to ignore, allow, or forbid extra data during model validation.\n        See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.", "url": "https://docs.pydantic.dev/latest/api/model-validate-json/", "page": "pydantic/main", "source_site": "pydantic"}
{"title": "BaseModel.model_validate_strings", "anchor": "basemodel-model_validate_strings", "heading_level": 0, "md_text": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    extra: Whether to ignore, allow, or forbid extra data during model validation.\n        See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.", "url": "https://docs.pydantic.dev/latest/api/model-validate-strings/", "page": "pydantic/main", "source_site": "pydantic"}
{"title": "BaseModel.__get_pydantic_json_schema__", "anchor": "basemodel-__get_pydantic_json_schema__", "heading_level": 0, "md_text": "Hook into generating the model's JSON schema.\n\nArgs:\n    core_schema: A `pydantic-core` CoreSchema.\n        You can ignore this argument and call the handler with a new CoreSchema,\n        wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),\n        or just call the handler with the original schema.\n    handler: Call into Pydantic's internal JSON schema generation.\n        This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema\n        generation fails.\n        Since this gets called by `BaseModel.model_json_schema` you can override the\n        `schema_generator` argument to that function to change JSON schema generation globally\n        for a type.\n\nReturns:\n    A JSON schema, as a Python object.", "url": "https://docs.pydantic.dev/latest/api/--get-pydantic-json-schema--/", "page": "pydantic/main", "source_site": "pydantic"}
{"title": "BaseModel.__pydantic_init_subclass__", "anchor": "basemodel-__pydantic_init_subclass__", "heading_level": 0, "md_text": "This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`\nonly after basic class initialization is complete. In particular, attributes like `model_fields` will\nbe present when this is called, but forward annotations are not guaranteed to be resolved yet,\nmeaning that creating an instance of the class may fail.\n\nThis is necessary because `__init_subclass__` will always be called by `type.__new__`,\nand it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that\n`type.__new__` was called in such a manner that the class would already be sufficiently initialized.\n\nThis will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,\nany kwargs passed to the class definition that aren't used internally by Pydantic.\n\nArgs:\n    **kwargs: Any keyword arguments passed to the class definition that aren't used internally\n        by Pydantic.\n\nNote:\n    You may want to override [`__pydantic_on_complete__()`][pydantic.main.BaseModel.__pydantic_on_complete__]\n    instead, which is called once the class and its fields are fully initialized and ready for validation.", "url": "https://docs.pydantic.dev/latest/api/--pydantic-init-subclass--/", "page": "pydantic/main", "source_site": "pydantic"}
{"title": "BaseModel.__pydantic_on_complete__", "anchor": "basemodel-__pydantic_on_complete__", "heading_level": 0, "md_text": "This is called once the class and its fields are fully initialized and ready to be used.\n\nThis typically happens when the class is created (just before\n[`__pydantic_init_subclass__()`][pydantic.main.BaseModel.__pydantic_init_subclass__] is called on the superclass),\nexcept when forward annotations are used that could not immediately be resolved.\nIn that case, it will be called later, when the model is rebuilt automatically or explicitly using\n[`model_rebuild()`][pydantic.main.BaseModel.model_rebuild].", "url": "https://docs.pydantic.dev/latest/api/--pydantic-on-complete--/", "page": "pydantic/main", "source_site": "pydantic"}
{"title": "BaseModel.__copy__", "anchor": "basemodel-__copy__", "heading_level": 0, "md_text": "Returns a shallow copy of the model.", "url": "https://docs.pydantic.dev/latest/api/--copy--/", "page": "pydantic/main", "source_site": "pydantic"}
{"title": "BaseModel.__deepcopy__", "anchor": "basemodel-__deepcopy__", "heading_level": 0, "md_text": "Returns a deep copy of the model.", "url": "https://docs.pydantic.dev/latest/api/--deepcopy--/", "page": "pydantic/main", "source_site": "pydantic"}
{"title": "BaseModel.__iter__", "anchor": "basemodel-__iter__", "heading_level": 0, "md_text": "So `dict(model)` works.", "url": "https://docs.pydantic.dev/latest/api/--iter--/", "page": "pydantic/main", "source_site": "pydantic"}
{"title": "BaseModel.copy", "anchor": "basemodel-copy", "heading_level": 0, "md_text": "Returns a copy of the model.\n\nIf you need `include` or `exclude`, use:\n\n```python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n```\n\nArgs:\n    include: Optional set or mapping specifying which fields to include in the copied model.\n    exclude: Optional set or mapping specifying which fields to exclude in the copied model.\n    update: Optional dictionary of field-value pairs to override field values in the copied model.\n    deep: If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns:\n    A copy of the model with included, excluded and updated fields as specified.", "url": "https://docs.pydantic.dev/latest/api/copy/", "page": "pydantic/main", "source_site": "pydantic"}
{"title": "_setattr_handler", "anchor": "_setattr_handler", "heading_level": 0, "md_text": "Get a handler for setting an attribute on the model instance.\n\nReturns:\n    A handler for setting an attribute on the model instance. Used for memoization of the handler.\n    Memoizing the handlers leads to a dramatic performance improvement in `__setattr__`\n    Returns `None` when memoization is not safe, then the attribute is set directly.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/main", "source_site": "pydantic"}
{"title": "__init_subclass__", "anchor": "__init_subclass__", "heading_level": 0, "md_text": "This signature is included purely to help type-checkers check arguments to class declaration, which\nprovides a way to conveniently set model_config key/value pairs.\n\n```python\nfrom pydantic import BaseModel\n\nclass MyModel(BaseModel, extra='allow'): ...\n```\n\nHowever, this may be deceiving, since the _actual_ calls to `__init_subclass__` will not receive any\nof the config arguments, and will only receive any keyword arguments passed during class initialization\nthat are _not_ expected keys in ConfigDict. (This is due to the way `ModelMetaclass.__new__` works.)\n\nArgs:\n    **kwargs: Keyword arguments passed to the class definition, which set model_config\n\nNote:\n    You may want to override `__pydantic_init_subclass__` instead, which behaves similarly but is called\n    *after* the class is fully initialized.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/main", "source_site": "pydantic"}
{"title": "parse", "anchor": "parse", "heading_level": 0, "md_text": "The `parse` module is a backport module from V1.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/parse", "source_site": "pydantic"}
{"title": "validators", "anchor": "validators", "heading_level": 0, "md_text": "The `validators` module is a backport module from V1.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/validators", "source_site": "pydantic"}
{"title": "getattr_migration", "anchor": "getattr_migration", "heading_level": 0, "md_text": "Implement PEP 562 for objects that were either moved or removed on the migration\nto V2.\n\nArgs:\n    module: The module name.\n\nReturns:\n    A callable that will raise an error if the object is not found.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_migration", "source_site": "pydantic"}
{"title": "wrapper", "anchor": "wrapper", "heading_level": 0, "md_text": "Raise an error if the object is not found, or warn if it was moved.\n\nIn case it was moved, it still returns the object.\n\nArgs:\n    name: The object name.\n\nReturns:\n    The object.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_migration", "source_site": "pydantic"}
{"title": "types", "anchor": "types", "heading_level": 0, "md_text": "The types module contains custom types used by pydantic.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "Strict", "anchor": "strict", "heading_level": 0, "md_text": "A field metadata class to indicate that a field should be validated in strict mode.\nUse this class as an annotation via [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated), as seen below.\n\nAttributes:\n    strict: Whether to validate the field in strict mode.\n\nExample:\n    ```python\n    from typing import Annotated\n\n    from pydantic.types import Strict\n\n    StrictBool = Annotated[bool, Strict()]\n    ```", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "conint", "anchor": "conint", "heading_level": 0, "md_text": "A wrapper around `int` that allows for additional constraints.\n\nArgs:\n    strict: Whether to validate the integer in strict mode. Defaults to `None`.\n    gt: The value must be greater than this.\n    ge: The value must be greater than or equal to this.\n    lt: The value must be less than this.\n    le: The value must be less than or equal to this.\n    multiple_of: The value must be a multiple of this.\n\nReturns:\n    The wrapped integer type.\n\n```python\nfrom pydantic import BaseModel, ValidationError, conint\n\nclass ConstrainedExample(BaseModel):\n    constrained_int: conint(gt=1)\n\nm = ConstrainedExample(constrained_int=2)\nprint(repr(m))\n#> ConstrainedExample(constrained_int=2)\n\ntry:\n    ConstrainedExample(constrained_int=0)\nexcept ValidationError as e:\n    print(e.errors())\n    '''\n    [\n        {\n            'type': 'greater_than',\n            'loc': ('constrained_int',),\n            'msg': 'Input should be greater than 1',\n            'input': 0,\n            'ctx': {'gt': 1},\n            'url': 'https://errors.pydantic.dev/2/v/greater_than',\n        }\n    ]\n    '''\n```", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "AllowInfNan", "anchor": "allowinfnan", "heading_level": 0, "md_text": "A field metadata class to indicate that a field should allow `-inf`, `inf`, and `nan`.\n\nUse this class as an annotation via [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated), as seen below.\n\nAttributes:\n    allow_inf_nan: Whether to allow `-inf`, `inf`, and `nan`. Defaults to `True`.\n\nExample:\n    ```python\n    from typing import Annotated\n\n    from pydantic.types import AllowInfNan\n\n    LaxFloat = Annotated[float, AllowInfNan()]\n    ```", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "confloat", "anchor": "confloat", "heading_level": 0, "md_text": "A wrapper around `float` that allows for additional constraints.\n\nArgs:\n    strict: Whether to validate the float in strict mode.\n    gt: The value must be greater than this.\n    ge: The value must be greater than or equal to this.\n    lt: The value must be less than this.\n    le: The value must be less than or equal to this.\n    multiple_of: The value must be a multiple of this.\n    allow_inf_nan: Whether to allow `-inf`, `inf`, and `nan`.\n\nReturns:\n    The wrapped float type.\n\n```python\nfrom pydantic import BaseModel, ValidationError, confloat\n\nclass ConstrainedExample(BaseModel):\n    constrained_float: confloat(gt=1.0)\n\nm = ConstrainedExample(constrained_float=1.1)\nprint(repr(m))\n#> ConstrainedExample(constrained_float=1.1)\n\ntry:\n    ConstrainedExample(constrained_float=0.9)\nexcept ValidationError as e:\n    print(e.errors())\n    '''\n    [\n        {\n            'type': 'greater_than',\n            'loc': ('constrained_float',),\n            'msg': 'Input should be greater than 1',\n            'input': 0.9,\n            'ctx': {'gt': 1.0},\n            'url': 'https://errors.pydantic.dev/2/v/greater_than',\n        }\n    ]\n    '''\n```", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "conbytes", "anchor": "conbytes", "heading_level": 0, "md_text": "A wrapper around `bytes` that allows for additional constraints.\n\nArgs:\n    min_length: The minimum length of the bytes.\n    max_length: The maximum length of the bytes.\n    strict: Whether to validate the bytes in strict mode.\n\nReturns:\n    The wrapped bytes type.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "StringConstraints", "anchor": "stringconstraints", "heading_level": 0, "md_text": "A field metadata class to apply constraints to `str` types.\nUse this class as an annotation via [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated), as seen below.\n\nAttributes:\n    strip_whitespace: Whether to remove leading and trailing whitespace.\n    to_upper: Whether to convert the string to uppercase.\n    to_lower: Whether to convert the string to lowercase.\n    strict: Whether to validate the string in strict mode.\n    min_length: The minimum length of the string.\n    max_length: The maximum length of the string.\n    pattern: A regex pattern that the string must match.\n\nExample:\n    ```python\n    from typing import Annotated\n\n    from pydantic.types import StringConstraints\n\n    ConstrainedStr = Annotated[str, StringConstraints(min_length=1, max_length=10)]\n    ```", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "constr", "anchor": "constr", "heading_level": 0, "md_text": "A wrapper around `str` that allows for additional constraints.\n\n```python\nfrom pydantic import BaseModel, constr\n\nclass Foo(BaseModel):\n    bar: constr(strip_whitespace=True, to_upper=True)\n\nfoo = Foo(bar='  hello  ')\nprint(foo)\n#> bar='HELLO'\n```\n\nArgs:\n    strip_whitespace: Whether to remove leading and trailing whitespace.\n    to_upper: Whether to turn all characters to uppercase.\n    to_lower: Whether to turn all characters to lowercase.\n    strict: Whether to validate the string in strict mode.\n    min_length: The minimum length of the string.\n    max_length: The maximum length of the string.\n    pattern: A regex pattern to validate the string against.\n\nReturns:\n    The wrapped string type.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "conset", "anchor": "conset", "heading_level": 0, "md_text": "A wrapper around `typing.Set` that allows for additional constraints.\n\nArgs:\n    item_type: The type of the items in the set.\n    min_length: The minimum length of the set.\n    max_length: The maximum length of the set.\n\nReturns:\n    The wrapped set type.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "confrozenset", "anchor": "confrozenset", "heading_level": 0, "md_text": "A wrapper around `typing.FrozenSet` that allows for additional constraints.\n\nArgs:\n    item_type: The type of the items in the frozenset.\n    min_length: The minimum length of the frozenset.\n    max_length: The maximum length of the frozenset.\n\nReturns:\n    The wrapped frozenset type.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "conlist", "anchor": "conlist", "heading_level": 0, "md_text": "A wrapper around [`list`][] that adds validation.\n\nArgs:\n    item_type: The type of the items in the list.\n    min_length: The minimum length of the list. Defaults to None.\n    max_length: The maximum length of the list. Defaults to None.\n    unique_items: Whether the items in the list must be unique. Defaults to None.\nReturns:\n    The wrapped list type.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "condecimal", "anchor": "condecimal", "heading_level": 0, "md_text": "A wrapper around Decimal that adds validation.\n\nArgs:\n    strict: Whether to validate the value in strict mode. Defaults to `None`.\n    gt: The value must be greater than this. Defaults to `None`.\n    ge: The value must be greater than or equal to this. Defaults to `None`.\n    lt: The value must be less than this. Defaults to `None`.\n    le: The value must be less than or equal to this. Defaults to `None`.\n    multiple_of: The value must be a multiple of this. Defaults to `None`.\n    max_digits: The maximum number of digits. Defaults to `None`.\n    decimal_places: The number of decimal places. Defaults to `None`.\n    allow_inf_nan: Whether to allow infinity and NaN. Defaults to `None`.\n\n```python\nfrom decimal import Decimal\n\nfrom pydantic import BaseModel, ValidationError, condecimal\n\nclass ConstrainedExample(BaseModel):\n    constrained_decimal: condecimal(gt=Decimal('1.0'))\n\nm = ConstrainedExample(constrained_decimal=Decimal('1.1'))\nprint(repr(m))\n#> ConstrainedExample(constrained_decimal=Decimal('1.1'))\n\ntry:\n    ConstrainedExample(constrained_decimal=Decimal('0.9'))\nexcept ValidationError as e:\n    print(e.errors())\n    '''\n    [\n        {\n            'type': 'greater_than',\n            'loc': ('constrained_decimal',),\n            'msg': 'Input should be greater than 1.0',\n            'input': Decimal('0.9'),\n            'ctx': {'gt': Decimal('1.0')},\n            'url': 'https://errors.pydantic.dev/2/v/greater_than',\n        }\n    ]\n    '''\n```", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "UuidVersion", "anchor": "uuidversion", "heading_level": 0, "md_text": "A field metadata class to indicate a [UUID](https://docs.python.org/3/library/uuid.html) version.\n\nUse this class as an annotation via [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated), as seen below.\n\nAttributes:\n    uuid_version: The version of the UUID. Must be one of 1, 3, 4, 5, 6, 7 or 8.\n\nExample:\n    ```python\n    from typing import Annotated\n    from uuid import UUID\n\n    from pydantic.types import UuidVersion\n\n    UUID1 = Annotated[UUID, UuidVersion(1)]\n    ```", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "Secret", "anchor": "secret", "heading_level": 0, "md_text": "A generic base class used for defining a field with sensitive information that you do not want to be visible in logging or tracebacks.\n\nYou may either directly parametrize `Secret` with a type, or subclass from `Secret` with a parametrized type. The benefit of subclassing\nis that you can define a custom `_display` method, which will be used for `repr()` and `str()` methods. The examples below demonstrate both\nways of using `Secret` to create a new secret type.\n\n1. Directly parametrizing `Secret` with a type:\n\n```python\nfrom pydantic import BaseModel, Secret\n\nSecretBool = Secret[bool]\n\nclass Model(BaseModel):\n    secret_bool: SecretBool\n\nm = Model(secret_bool=True)\nprint(m.model_dump())\n#> {'secret_bool': Secret('**********')}\n\nprint(m.model_dump_json())\n#> {\"secret_bool\":\"**********\"}\n\nprint(m.secret_bool.get_secret_value())\n#> True\n```\n\n2. Subclassing from parametrized `Secret`:\n\n```python\nfrom datetime import date\n\nfrom pydantic import BaseModel, Secret\n\nclass SecretDate(Secret[date]):\n    def _display(self) -> str:\n        return '****/**/**'\n\nclass Model(BaseModel):\n    secret_date: SecretDate\n\nm = Model(secret_date=date(2022, 1, 1))\nprint(m.model_dump())\n#> {'secret_date': SecretDate('****/**/**')}\n\nprint(m.model_dump_json())\n#> {\"secret_date\":\"****/**/**\"}\n\nprint(m.secret_date.get_secret_value())\n#> 2022-01-01\n```\n\nThe value returned by the `_display` method will be used for `repr()` and `str()`.\n\nYou can enforce constraints on the underlying type through annotations:\nFor example:\n\n```python\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Field, Secret, ValidationError\n\nSecretPosInt = Secret[Annotated[int, Field(gt=0, strict=True)]]\n\nclass Model(BaseModel):\n    sensitive_int: SecretPosInt\n\nm = Model(sensitive_int=42)\nprint(m.model_dump())\n#> {'sensitive_int': Secret('**********')}\n\ntry:\n    m = Model(sensitive_int=-42)  # (1)!\nexcept ValidationError as exc_info:\n    print(exc_info.errors(include_url=False, include_input=False))\n    '''\n    [\n        {\n            'type': 'greater_than',\n            'loc': ('sensitive_int',),\n            'msg': 'Input should be greater than 0',\n            'ctx': {'gt': 0},\n        }\n    ]\n    '''\n\ntry:\n    m = Model(sensitive_int='42')  # (2)!\nexcept ValidationError as exc_info:\n    print(exc_info.errors(include_url=False, include_input=False))\n    '''\n    [\n        {\n            'type': 'int_type',\n            'loc': ('sensitive_int',),\n            'msg': 'Input should be a valid integer',\n        }\n    ]\n    '''\n```\n\n1. The input value is not greater than 0, so it raises a validation error.\n2. The input value is not an integer, so it raises a validation error because the `SecretPosInt` type has strict mode enabled.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "SecretStr", "anchor": "secretstr", "heading_level": 0, "md_text": "A string used for storing sensitive information that you do not want to be visible in logging or tracebacks.\n\nWhen the secret value is nonempty, it is displayed as `'**********'` instead of the underlying value in\ncalls to `repr()` and `str()`. If the value _is_ empty, it is displayed as `''`.\n\n```python\nfrom pydantic import BaseModel, SecretStr\n\nclass User(BaseModel):\n    username: str\n    password: SecretStr\n\nuser = User(username='scolvin', password='password1')\n\nprint(user)\n#> username='scolvin' password=SecretStr('**********')\nprint(user.password.get_secret_value())\n#> password1\nprint((SecretStr('password'), SecretStr('')))\n#> (SecretStr('**********'), SecretStr(''))\n```\n\nAs seen above, by default, [`SecretStr`][pydantic.types.SecretStr] (and [`SecretBytes`][pydantic.types.SecretBytes])\nwill be serialized as `**********` when serializing to json.\n\nYou can use the [`field_serializer`][pydantic.functional_serializers.field_serializer] to dump the\nsecret as plain-text when serializing to json.\n\n```python\nfrom pydantic import BaseModel, SecretBytes, SecretStr, field_serializer\n\nclass Model(BaseModel):\n    password: SecretStr\n    password_bytes: SecretBytes\n\n    @field_serializer('password', 'password_bytes', when_used='json')\n    def dump_secret(self, v):\n        return v.get_secret_value()\n\nmodel = Model(password='IAmSensitive', password_bytes=b'IAmSensitiveBytes')\nprint(model)\n#> password=SecretStr('**********') password_bytes=SecretBytes(b'**********')\nprint(model.password)\n#> **********\nprint(model.model_dump())\n'''\n{\n    'password': SecretStr('**********'),\n    'password_bytes': SecretBytes(b'**********'),\n}\n'''\nprint(model.model_dump_json())\n#> {\"password\":\"IAmSensitive\",\"password_bytes\":\"IAmSensitiveBytes\"}\n```", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "SecretBytes", "anchor": "secretbytes", "heading_level": 0, "md_text": "A bytes used for storing sensitive information that you do not want to be visible in logging or tracebacks.\n\nIt displays `b'**********'` instead of the string value on `repr()` and `str()` calls.\nWhen the secret value is nonempty, it is displayed as `b'**********'` instead of the underlying value in\ncalls to `repr()` and `str()`. If the value _is_ empty, it is displayed as `b''`.\n\n```python\nfrom pydantic import BaseModel, SecretBytes\n\nclass User(BaseModel):\n    username: str\n    password: SecretBytes\n\nuser = User(username='scolvin', password=b'password1')\n#> username='scolvin' password=SecretBytes(b'**********')\nprint(user.password.get_secret_value())\n#> b'password1'\nprint((SecretBytes(b'password'), SecretBytes(b'')))\n#> (SecretBytes(b'**********'), SecretBytes(b''))\n```", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "PaymentCardNumber", "anchor": "paymentcardnumber", "heading_level": 0, "md_text": "Based on: https://en.wikipedia.org/wiki/Payment_card_number.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "ByteSize", "anchor": "bytesize", "heading_level": 0, "md_text": "Converts a string representing a number of bytes with units (such as `'1KB'` or `'11.5MiB'`) into an integer.\n\nYou can use the `ByteSize` data type to (case-insensitively) convert a string representation of a number of bytes into\nan integer, and also to print out human-readable strings representing a number of bytes.\n\nIn conformance with [IEC 80000-13 Standard](https://en.wikipedia.org/wiki/ISO/IEC_80000) we interpret `'1KB'` to mean 1000 bytes,\nand `'1KiB'` to mean 1024 bytes. In general, including a middle `'i'` will cause the unit to be interpreted as a power of 2,\nrather than a power of 10 (so, for example, `'1 MB'` is treated as `1_000_000` bytes, whereas `'1 MiB'` is treated as `1_048_576` bytes).\n\n```python\nfrom pydantic import BaseModel, ByteSize\n\nclass MyModel(BaseModel):\n    size: ByteSize\n\nprint(MyModel(size=52000).size)\n#> 52000\nprint(MyModel(size='3000 KiB').size)\n#> 3072000\n\nm = MyModel(size='50 PB')\nprint(m.size.human_readable())\n#> 44.4PiB\nprint(m.size.human_readable(decimal=True))\n#> 50.0PB\nprint(m.size.human_readable(separator=' '))\n#> 44.4 PiB\n\nprint(m.size.to('TiB'))\n#> 45474.73508864641\n```", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "condate", "anchor": "condate", "heading_level": 0, "md_text": "A wrapper for date that adds constraints.\n\nArgs:\n    strict: Whether to validate the date value in strict mode. Defaults to `None`.\n    gt: The value must be greater than this. Defaults to `None`.\n    ge: The value must be greater than or equal to this. Defaults to `None`.\n    lt: The value must be less than this. Defaults to `None`.\n    le: The value must be less than or equal to this. Defaults to `None`.\n\nReturns:\n    A date type with the specified constraints.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "EncoderProtocol", "anchor": "encoderprotocol", "heading_level": 0, "md_text": "Protocol for encoding and decoding data to and from bytes.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "Base64Encoder", "anchor": "base64encoder", "heading_level": 0, "md_text": "Standard (non-URL-safe) Base64 encoder.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "Base64UrlEncoder", "anchor": "base64urlencoder", "heading_level": 0, "md_text": "URL-safe Base64 encoder.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "EncodedBytes", "anchor": "encodedbytes", "heading_level": 0, "md_text": "A bytes type that is encoded and decoded using the specified encoder.\n\n`EncodedBytes` needs an encoder that implements `EncoderProtocol` to operate.\n\n```python\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, EncodedBytes, EncoderProtocol, ValidationError\n\nclass MyEncoder(EncoderProtocol):\n    @classmethod\n    def decode(cls, data: bytes) -> bytes:\n        if data == b'**undecodable**':\n            raise ValueError('Cannot decode data')\n        return data[13:]\n\n    @classmethod\n    def encode(cls, value: bytes) -> bytes:\n        return b'**encoded**: ' + value\n\n    @classmethod\n    def get_json_format(cls) -> str:\n        return 'my-encoder'\n\nMyEncodedBytes = Annotated[bytes, EncodedBytes(encoder=MyEncoder)]\n\nclass Model(BaseModel):\n    my_encoded_bytes: MyEncodedBytes\n\n# Initialize the model with encoded data\nm = Model(my_encoded_bytes=b'**encoded**: some bytes')\n\n# Access decoded value\nprint(m.my_encoded_bytes)\n#> b'some bytes'\n\n# Serialize into the encoded form\nprint(m.model_dump())\n#> {'my_encoded_bytes': b'**encoded**: some bytes'}\n\n# Validate encoded data\ntry:\n    Model(my_encoded_bytes=b'**undecodable**')\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for Model\n    my_encoded_bytes\n      Value error, Cannot decode data [type=value_error, input_value=b'**undecodable**', input_type=bytes]\n    '''\n```", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "EncodedStr", "anchor": "encodedstr", "heading_level": 0, "md_text": "A str type that is encoded and decoded using the specified encoder.\n\n`EncodedStr` needs an encoder that implements `EncoderProtocol` to operate.\n\n```python\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, EncodedStr, EncoderProtocol, ValidationError\n\nclass MyEncoder(EncoderProtocol):\n    @classmethod\n    def decode(cls, data: bytes) -> bytes:\n        if data == b'**undecodable**':\n            raise ValueError('Cannot decode data')\n        return data[13:]\n\n    @classmethod\n    def encode(cls, value: bytes) -> bytes:\n        return b'**encoded**: ' + value\n\n    @classmethod\n    def get_json_format(cls) -> str:\n        return 'my-encoder'\n\nMyEncodedStr = Annotated[str, EncodedStr(encoder=MyEncoder)]\n\nclass Model(BaseModel):\n    my_encoded_str: MyEncodedStr\n\n# Initialize the model with encoded data\nm = Model(my_encoded_str='**encoded**: some str')\n\n# Access decoded value\nprint(m.my_encoded_str)\n#> some str\n\n# Serialize into the encoded form\nprint(m.model_dump())\n#> {'my_encoded_str': '**encoded**: some str'}\n\n# Validate encoded data\ntry:\n    Model(my_encoded_str='**undecodable**')\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for Model\n    my_encoded_str\n      Value error, Cannot decode data [type=value_error, input_value='**undecodable**', input_type=str]\n    '''\n```", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "GetPydanticSchema", "anchor": "getpydanticschema", "heading_level": 0, "md_text": "A convenience class for creating an annotation that provides pydantic custom type hooks.\n\nThis class is intended to eliminate the need to create a custom \"marker\" which defines the\n `__get_pydantic_core_schema__` and `__get_pydantic_json_schema__` custom hook methods.\n\nFor example, to have a field treated by type checkers as `int`, but by pydantic as `Any`, you can do:\n```python\nfrom typing import Annotated, Any\n\nfrom pydantic import BaseModel, GetPydanticSchema\n\nHandleAsAny = GetPydanticSchema(lambda _s, h: h(Any))\n\nclass Model(BaseModel):\n    x: Annotated[int, HandleAsAny]  # pydantic sees `x: Any`\n\nprint(repr(Model(x='abc').x))\n#> 'abc'\n```", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "Tag", "anchor": "tag", "heading_level": 0, "md_text": "Provides a way to specify the expected tag to use for a case of a (callable) discriminated union.\n\nAlso provides a way to label a union case in error messages.\n\nWhen using a callable `Discriminator`, attach a `Tag` to each case in the `Union` to specify the tag that\nshould be used to identify that case. For example, in the below example, the `Tag` is used to specify that\nif `get_discriminator_value` returns `'apple'`, the input should be validated as an `ApplePie`, and if it\nreturns `'pumpkin'`, the input should be validated as a `PumpkinPie`.\n\nThe primary role of the `Tag` here is to map the return value from the callable `Discriminator` function to\nthe appropriate member of the `Union` in question.\n\n```python\nfrom typing import Annotated, Any, Literal, Union\n\nfrom pydantic import BaseModel, Discriminator, Tag\n\nclass Pie(BaseModel):\n    time_to_cook: int\n    num_ingredients: int\n\nclass ApplePie(Pie):\n    fruit: Literal['apple'] = 'apple'\n\nclass PumpkinPie(Pie):\n    filling: Literal['pumpkin'] = 'pumpkin'\n\ndef get_discriminator_value(v: Any) -> str:\n    if isinstance(v, dict):\n        return v.get('fruit', v.get('filling'))\n    return getattr(v, 'fruit', getattr(v, 'filling', None))\n\nclass ThanksgivingDinner(BaseModel):\n    dessert: Annotated[\n        Union[\n            Annotated[ApplePie, Tag('apple')],\n            Annotated[PumpkinPie, Tag('pumpkin')],\n        ],\n        Discriminator(get_discriminator_value),\n    ]\n\napple_variation = ThanksgivingDinner.model_validate(\n    {'dessert': {'fruit': 'apple', 'time_to_cook': 60, 'num_ingredients': 8}}\n)\nprint(repr(apple_variation))\n'''\nThanksgivingDinner(dessert=ApplePie(time_to_cook=60, num_ingredients=8, fruit='apple'))\n'''\n\npumpkin_variation = ThanksgivingDinner.model_validate(\n    {\n        'dessert': {\n            'filling': 'pumpkin',\n            'time_to_cook': 40,\n            'num_ingredients': 6,\n        }\n    }\n)\nprint(repr(pumpkin_variation))\n'''\nThanksgivingDinner(dessert=PumpkinPie(time_to_cook=40, num_ingredients=6, filling='pumpkin'))\n'''\n```\n\nSee the [Discriminated Unions] concepts docs for more details on how to use `Tag`s.\n\n[Discriminated Unions]: ../concepts/unions.md#discriminated-unions", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "Discriminator", "anchor": "discriminator", "heading_level": 0, "md_text": "Provides a way to use a custom callable as the way to extract the value of a union discriminator.\n\nThis allows you to get validation behavior like you'd get from `Field(discriminator=<field_name>)`,\nbut without needing to have a single shared field across all the union choices. This also makes it\npossible to handle unions of models and primitive types with discriminated-union-style validation errors.\nFinally, this allows you to use a custom callable as the way to identify which member of a union a value\nbelongs to, while still seeing all the performance benefits of a discriminated union.\n\nConsider this example, which is much more performant with the use of `Discriminator` and thus a `TaggedUnion`\nthan it would be as a normal `Union`.\n\n```python\nfrom typing import Annotated, Any, Literal, Union\n\nfrom pydantic import BaseModel, Discriminator, Tag\n\nclass Pie(BaseModel):\n    time_to_cook: int\n    num_ingredients: int\n\nclass ApplePie(Pie):\n    fruit: Literal['apple'] = 'apple'\n\nclass PumpkinPie(Pie):\n    filling: Literal['pumpkin'] = 'pumpkin'\n\ndef get_discriminator_value(v: Any) -> str:\n    if isinstance(v, dict):\n        return v.get('fruit', v.get('filling'))\n    return getattr(v, 'fruit', getattr(v, 'filling', None))\n\nclass ThanksgivingDinner(BaseModel):\n    dessert: Annotated[\n        Union[\n            Annotated[ApplePie, Tag('apple')],\n            Annotated[PumpkinPie, Tag('pumpkin')],\n        ],\n        Discriminator(get_discriminator_value),\n    ]\n\napple_variation = ThanksgivingDinner.model_validate(\n    {'dessert': {'fruit': 'apple', 'time_to_cook': 60, 'num_ingredients': 8}}\n)\nprint(repr(apple_variation))\n'''\nThanksgivingDinner(dessert=ApplePie(time_to_cook=60, num_ingredients=8, fruit='apple'))\n'''\n\npumpkin_variation = ThanksgivingDinner.model_validate(\n    {\n        'dessert': {\n            'filling': 'pumpkin',\n            'time_to_cook': 40,\n            'num_ingredients': 6,\n        }\n    }\n)\nprint(repr(pumpkin_variation))\n'''\nThanksgivingDinner(dessert=PumpkinPie(time_to_cook=40, num_ingredients=6, filling='pumpkin'))\n'''\n```\n\nSee the [Discriminated Unions] concepts docs for more details on how to use `Discriminator`s.\n\n[Discriminated Unions]: ../concepts/unions.md#discriminated-unions", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "FailFast", "anchor": "failfast", "heading_level": 0, "md_text": "A `FailFast` annotation can be used to specify that validation should stop at the first error.\n\nThis can be useful when you want to validate a large amount of data and you only need to know if it's valid or not.\n\nYou might want to enable this setting if you want to validate your data faster (basically, if you use this,\nvalidation will be more performant with the caveat that you get less information).\n\n```python\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, FailFast, ValidationError\n\nclass Model(BaseModel):\n    x: Annotated[list[int], FailFast()]\n\n# This will raise a single error for the first invalid value and stop validation\ntry:\n    obj = Model(x=[1, 2, 'a', 4, 5, 'b', 7, 8, 9, 'c'])\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for Model\n    x.2\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='a', input_type=str]\n    '''\n```", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "ImportString", "anchor": "importstring", "heading_level": 0, "md_text": "A type that can be used to import a Python object from a string.\n\n`ImportString` expects a string and loads the Python object importable at that dotted path.\nAttributes of modules may be separated from the module by `:` or `.`, e.g. if `'math:cos'` is provided,\nthe resulting field value would be the function `cos`. If a `.` is used and both an attribute and submodule\nare present at the same path, the module will be preferred.\n\nOn model instantiation, pointers will be evaluated and imported. There is\nsome nuance to this behavior, demonstrated in the examples below.\n\n```python\nimport math\n\nfrom pydantic import BaseModel, Field, ImportString, ValidationError\n\nclass ImportThings(BaseModel):\n    obj: ImportString\n\n# A string value will cause an automatic import\nmy_cos = ImportThings(obj='math.cos')\n\n# You can use the imported function as you would expect\ncos_of_0 = my_cos.obj(0)\nassert cos_of_0 == 1\n\n# A string whose value cannot be imported will raise an error\ntry:\n    ImportThings(obj='foo.bar')\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for ImportThings\n    obj\n      Invalid python path: No module named 'foo.bar' [type=import_error, input_value='foo.bar', input_type=str]\n    '''\n\n# Actual python objects can be assigned as well\nmy_cos = ImportThings(obj=math.cos)\nmy_cos_2 = ImportThings(obj='math.cos')\nmy_cos_3 = ImportThings(obj='math:cos')\nassert my_cos == my_cos_2 == my_cos_3\n\n# You can set default field value either as Python object:\nclass ImportThingsDefaultPyObj(BaseModel):\n    obj: ImportString = math.cos\n\n# or as a string value (but only if used with `validate_default=True`)\nclass ImportThingsDefaultString(BaseModel):\n    obj: ImportString = Field(default='math.cos', validate_default=True)\n\nmy_cos_default1 = ImportThingsDefaultPyObj()\nmy_cos_default2 = ImportThingsDefaultString()\nassert my_cos_default1.obj == my_cos_default2.obj == math.cos\n\n# note: this will not work!\nclass ImportThingsMissingValidateDefault(BaseModel):\n    obj: ImportString = 'math.cos'\n\nmy_cos_default3 = ImportThingsMissingValidateDefault()\nassert my_cos_default3.obj == 'math.cos'  # just string, not evaluated\n```\n\nSerializing an `ImportString` type to json is also possible.\n\n```python\nfrom pydantic import BaseModel, ImportString\n\nclass ImportThings(BaseModel):\n    obj: ImportString\n\n# Create an instance\nm = ImportThings(obj='math.cos')\nprint(m)\n#> obj=<built-in function cos>\nprint(m.model_dump_json())\n#> {\"obj\":\"math.cos\"}\n```", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "Json", "anchor": "json", "heading_level": 0, "md_text": "A special type wrapper which loads JSON before parsing.\n\nYou can use the `Json` data type to make Pydantic first load a raw JSON string before\nvalidating the loaded data into the parametrized type:\n\n```python\nfrom typing import Any\n\nfrom pydantic import BaseModel, Json, ValidationError\n\nclass AnyJsonModel(BaseModel):\n    json_obj: Json[Any]\n\nclass ConstrainedJsonModel(BaseModel):\n    json_obj: Json[list[int]]\n\nprint(AnyJsonModel(json_obj='{\"b\": 1}'))\n#> json_obj={'b': 1}\nprint(ConstrainedJsonModel(json_obj='[1, 2, 3]'))\n#> json_obj=[1, 2, 3]\n\ntry:\n    ConstrainedJsonModel(json_obj=12)\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for ConstrainedJsonModel\n    json_obj\n      JSON input should be string, bytes or bytearray [type=json_type, input_value=12, input_type=int]\n    '''\n\ntry:\n    ConstrainedJsonModel(json_obj='[a, b]')\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for ConstrainedJsonModel\n    json_obj\n      Invalid JSON: expected value at line 1 column 2 [type=json_invalid, input_value='[a, b]', input_type=str]\n    '''\n\ntry:\n    ConstrainedJsonModel(json_obj='[\"a\", \"b\"]')\nexcept ValidationError as e:\n    print(e)\n    '''\n    2 validation errors for ConstrainedJsonModel\n    json_obj.0\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='a', input_type=str]\n    json_obj.1\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='b', input_type=str]\n    '''\n```\n\nWhen you dump the model using `model_dump` or `model_dump_json`, the dumped value will be the result of validation,\nnot the original JSON string. However, you can use the argument `round_trip=True` to get the original JSON string back:\n\n```python\nfrom pydantic import BaseModel, Json\n\nclass ConstrainedJsonModel(BaseModel):\n    json_obj: Json[list[int]]\n\nprint(ConstrainedJsonModel(json_obj='[1, 2, 3]').model_dump_json())\n#> {\"json_obj\":[1,2,3]}\nprint(\n    ConstrainedJsonModel(json_obj='[1, 2, 3]').model_dump_json(round_trip=True)\n)\n#> {\"json_obj\":\"[1,2,3]\"}\n```", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "_SecretBase.get_secret_value", "anchor": "_secretbase-get_secret_value", "heading_level": 0, "md_text": "Get the secret value.\n\nReturns:\n    The secret value.", "url": "https://docs.pydantic.dev/latest/api/get-secret-value/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "PaymentCardNumber.validate", "anchor": "paymentcardnumber-validate", "heading_level": 0, "md_text": "Validate the card number and return a `PaymentCardNumber` instance.", "url": "https://docs.pydantic.dev/latest/api/validate/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "PaymentCardNumber.masked", "anchor": "paymentcardnumber-masked", "heading_level": 0, "md_text": "Mask all but the last 4 digits of the card number.\n\nReturns:\n    A masked card number string.", "url": "https://docs.pydantic.dev/latest/api/masked/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "PaymentCardNumber.validate_digits", "anchor": "paymentcardnumber-validate_digits", "heading_level": 0, "md_text": "Validate that the card number is all digits.", "url": "https://docs.pydantic.dev/latest/api/validate-digits/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "PaymentCardNumber.validate_luhn_check_digit", "anchor": "paymentcardnumber-validate_luhn_check_digit", "heading_level": 0, "md_text": "Based on: https://en.wikipedia.org/wiki/Luhn_algorithm.", "url": "https://docs.pydantic.dev/latest/api/validate-luhn-check-digit/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "PaymentCardNumber.validate_brand", "anchor": "paymentcardnumber-validate_brand", "heading_level": 0, "md_text": "Validate length based on BIN for major brands:\nhttps://en.wikipedia.org/wiki/Payment_card_number#Issuer_identification_number_(IIN).", "url": "https://docs.pydantic.dev/latest/api/validate-brand/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "ByteSize.human_readable", "anchor": "bytesize-human_readable", "heading_level": 0, "md_text": "Converts a byte size to a human readable string.\n\nArgs:\n    decimal: If True, use decimal units (e.g. 1000 bytes per KB). If False, use binary units\n        (e.g. 1024 bytes per KiB).\n    separator: A string used to split the value and unit. Defaults to an empty string ('').\n\nReturns:\n    A human readable string representation of the byte size.", "url": "https://docs.pydantic.dev/latest/api/human-readable/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "ByteSize.to", "anchor": "bytesize-to", "heading_level": 0, "md_text": "Converts a byte size to another unit, including both byte and bit units.\n\nArgs:\n    unit: The unit to convert to. Must be one of the following: B, KB, MB, GB, TB, PB, EB,\n        KiB, MiB, GiB, TiB, PiB, EiB (byte units) and\n        bit, kbit, mbit, gbit, tbit, pbit, ebit,\n        kibit, mibit, gibit, tibit, pibit, eibit (bit units).\n\nReturns:\n    The byte size in the new unit.", "url": "https://docs.pydantic.dev/latest/api/to/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "PastDate", "anchor": "pastdate", "heading_level": 0, "md_text": "A date in the past.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "FutureDate", "anchor": "futuredate", "heading_level": 0, "md_text": "A date in the future.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "AwareDatetime", "anchor": "awaredatetime", "heading_level": 0, "md_text": "A datetime that requires timezone info.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "NaiveDatetime", "anchor": "naivedatetime", "heading_level": 0, "md_text": "A datetime that doesn't require timezone info.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "PastDatetime", "anchor": "pastdatetime", "heading_level": 0, "md_text": "A datetime that must be in the past.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "FutureDatetime", "anchor": "futuredatetime", "heading_level": 0, "md_text": "A datetime that must be in the future.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "EncoderProtocol.decode", "anchor": "encoderprotocol-decode", "heading_level": 0, "md_text": "Decode the data using the encoder.\n\nArgs:\n    data: The data to decode.\n\nReturns:\n    The decoded data.", "url": "https://docs.pydantic.dev/latest/api/decode/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "EncoderProtocol.encode", "anchor": "encoderprotocol-encode", "heading_level": 0, "md_text": "Encode the data using the encoder.\n\nArgs:\n    value: The data to encode.\n\nReturns:\n    The encoded data.", "url": "https://docs.pydantic.dev/latest/api/encode/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "EncoderProtocol.get_json_format", "anchor": "encoderprotocol-get_json_format", "heading_level": 0, "md_text": "Get the JSON format for the encoded data.\n\nReturns:\n    The JSON format for the encoded data.", "url": "https://docs.pydantic.dev/latest/api/get-json-format/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "Base64Encoder.decode", "anchor": "base64encoder-decode", "heading_level": 0, "md_text": "Decode the data from base64 encoded bytes to original bytes data.\n\nArgs:\n    data: The data to decode.\n\nReturns:\n    The decoded data.", "url": "https://docs.pydantic.dev/latest/api/decode/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "Base64Encoder.encode", "anchor": "base64encoder-encode", "heading_level": 0, "md_text": "Encode the data from bytes to a base64 encoded bytes.\n\nArgs:\n    value: The data to encode.\n\nReturns:\n    The encoded data.", "url": "https://docs.pydantic.dev/latest/api/encode/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "Base64Encoder.get_json_format", "anchor": "base64encoder-get_json_format", "heading_level": 0, "md_text": "Get the JSON format for the encoded data.\n\nReturns:\n    The JSON format for the encoded data.", "url": "https://docs.pydantic.dev/latest/api/get-json-format/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "Base64UrlEncoder.decode", "anchor": "base64urlencoder-decode", "heading_level": 0, "md_text": "Decode the data from base64 encoded bytes to original bytes data.\n\nArgs:\n    data: The data to decode.\n\nReturns:\n    The decoded data.", "url": "https://docs.pydantic.dev/latest/api/decode/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "Base64UrlEncoder.encode", "anchor": "base64urlencoder-encode", "heading_level": 0, "md_text": "Encode the data from bytes to a base64 encoded bytes.\n\nArgs:\n    value: The data to encode.\n\nReturns:\n    The encoded data.", "url": "https://docs.pydantic.dev/latest/api/encode/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "Base64UrlEncoder.get_json_format", "anchor": "base64urlencoder-get_json_format", "heading_level": 0, "md_text": "Get the JSON format for the encoded data.\n\nReturns:\n    The JSON format for the encoded data.", "url": "https://docs.pydantic.dev/latest/api/get-json-format/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "EncodedBytes.decode", "anchor": "encodedbytes-decode", "heading_level": 0, "md_text": "Decode the data using the specified encoder.\n\nArgs:\n    data: The data to decode.\n\nReturns:\n    The decoded data.", "url": "https://docs.pydantic.dev/latest/api/decode/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "EncodedBytes.encode", "anchor": "encodedbytes-encode", "heading_level": 0, "md_text": "Encode the data using the specified encoder.\n\nArgs:\n    value: The data to encode.\n\nReturns:\n    The encoded data.", "url": "https://docs.pydantic.dev/latest/api/encode/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "EncodedStr.decode_str", "anchor": "encodedstr-decode_str", "heading_level": 0, "md_text": "Decode the data using the specified encoder.\n\nArgs:\n    data: The data to decode.\n\nReturns:\n    The decoded data.", "url": "https://docs.pydantic.dev/latest/api/decode-str/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "EncodedStr.encode_str", "anchor": "encodedstr-encode_str", "heading_level": 0, "md_text": "Encode the data using the specified encoder.\n\nArgs:\n    value: The data to encode.\n\nReturns:\n    The encoded data.", "url": "https://docs.pydantic.dev/latest/api/encode-str/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "__getattr__", "anchor": "__getattr__", "heading_level": 0, "md_text": "Use this rather than defining `__get_pydantic_core_schema__` etc. to reduce the number of nested calls.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/types", "source_site": "pydantic"}
{"title": "version", "anchor": "version", "heading_level": 0, "md_text": "The `version` module holds the version information for Pydantic.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/version", "source_site": "pydantic"}
{"title": "version_short", "anchor": "version_short", "heading_level": 0, "md_text": "Return the `major.minor` part of Pydantic version.\n\nIt returns '2.1' if Pydantic version is '2.1.1'.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/version", "source_site": "pydantic"}
{"title": "version_info", "anchor": "version_info", "heading_level": 0, "md_text": "Return complete version information for Pydantic and its dependencies.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/version", "source_site": "pydantic"}
{"title": "check_pydantic_core_version", "anchor": "check_pydantic_core_version", "heading_level": 0, "md_text": "Check that the installed `pydantic-core` dependency is compatible.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/version", "source_site": "pydantic"}
{"title": "parse_mypy_version", "anchor": "parse_mypy_version", "heading_level": 0, "md_text": "Parse `mypy` string version to a 3-tuple of ints.\n\nIt parses normal version like `1.11.0` and extra info followed by a `+` sign\nlike `1.11.0+dev.d6d9d8cd4f27c52edac1f537e236ec48a01e54cb.dirty`.\n\nArgs:\n    version: The mypy version string.\n\nReturns:\n    A triple of ints, e.g. `(1, 11, 0)`.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/version", "source_site": "pydantic"}
{"title": "functional_serializers", "anchor": "functional_serializers", "heading_level": 0, "md_text": "This module contains related classes and functions for serialization.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/functional_serializers", "source_site": "pydantic"}
{"title": "PlainSerializer", "anchor": "plainserializer", "heading_level": 0, "md_text": "Plain serializers use a function to modify the output of serialization.\n\nThis is particularly helpful when you want to customize the serialization for annotated types.\nConsider an input of `list`, which will be serialized into a space-delimited string.\n\n```python\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, PlainSerializer\n\nCustomStr = Annotated[\n    list, PlainSerializer(lambda x: ' '.join(x), return_type=str)\n]\n\nclass StudentModel(BaseModel):\n    courses: CustomStr\n\nstudent = StudentModel(courses=['Math', 'Chemistry', 'English'])\nprint(student.model_dump())\n#> {'courses': 'Math Chemistry English'}\n```\n\nAttributes:\n    func: The serializer function.\n    return_type: The return type for the function. If omitted it will be inferred from the type annotation.\n    when_used: Determines when this serializer should be used. Accepts a string with values `'always'`,\n        `'unless-none'`, `'json'`, and `'json-unless-none'`. Defaults to 'always'.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/functional_serializers", "source_site": "pydantic"}
{"title": "WrapSerializer", "anchor": "wrapserializer", "heading_level": 0, "md_text": "Wrap serializers receive the raw inputs along with a handler function that applies the standard serialization\nlogic, and can modify the resulting value before returning it as the final output of serialization.\n\nFor example, here's a scenario in which a wrap serializer transforms timezones to UTC **and** utilizes the existing `datetime` serialization logic.\n\n```python\nfrom datetime import datetime, timezone\nfrom typing import Annotated, Any\n\nfrom pydantic import BaseModel, WrapSerializer\n\nclass EventDatetime(BaseModel):\n    start: datetime\n    end: datetime\n\ndef convert_to_utc(value: Any, handler, info) -> dict[str, datetime]:\n    # Note that `handler` can actually help serialize the `value` for\n    # further custom serialization in case it's a subclass.\n    partial_result = handler(value, info)\n    if info.mode == 'json':\n        return {\n            k: datetime.fromisoformat(v).astimezone(timezone.utc)\n            for k, v in partial_result.items()\n        }\n    return {k: v.astimezone(timezone.utc) for k, v in partial_result.items()}\n\nUTCEventDatetime = Annotated[EventDatetime, WrapSerializer(convert_to_utc)]\n\nclass EventModel(BaseModel):\n    event_datetime: UTCEventDatetime\n\ndt = EventDatetime(\n    start='2024-01-01T07:00:00-08:00', end='2024-01-03T20:00:00+06:00'\n)\nevent = EventModel(event_datetime=dt)\nprint(event.model_dump())\n'''\n{\n    'event_datetime': {\n        'start': datetime.datetime(\n            2024, 1, 1, 15, 0, tzinfo=datetime.timezone.utc\n        ),\n        'end': datetime.datetime(\n            2024, 1, 3, 14, 0, tzinfo=datetime.timezone.utc\n        ),\n    }\n}\n'''\n\nprint(event.model_dump_json())\n'''\n{\"event_datetime\":{\"start\":\"2024-01-01T15:00:00Z\",\"end\":\"2024-01-03T14:00:00Z\"}}\n'''\n```\n\nAttributes:\n    func: The serializer function to be wrapped.\n    return_type: The return type for the function. If omitted it will be inferred from the type annotation.\n    when_used: Determines when this serializer should be used. Accepts a string with values `'always'`,\n        `'unless-none'`, `'json'`, and `'json-unless-none'`. Defaults to 'always'.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/functional_serializers", "source_site": "pydantic"}
{"title": "field_serializer", "anchor": "field_serializer", "heading_level": 0, "md_text": "Decorator that enables custom field serialization.\n\nIn the below example, a field of type `set` is used to mitigate duplication. A `field_serializer` is used to serialize the data as a sorted list.\n\n```python\nfrom pydantic import BaseModel, field_serializer\n\nclass StudentModel(BaseModel):\n    name: str = 'Jane'\n    courses: set[str]\n\n    @field_serializer('courses', when_used='json')\n    def serialize_courses_in_order(self, courses: set[str]):\n        return sorted(courses)\n\nstudent = StudentModel(courses={'Math', 'Chemistry', 'English'})\nprint(student.model_dump_json())\n#> {\"name\":\"Jane\",\"courses\":[\"Chemistry\",\"English\",\"Math\"]}\n```\n\nSee [the usage documentation](../concepts/serialization.md#serializers) for more information.\n\nFour signatures are supported:\n\n- `(self, value: Any, info: FieldSerializationInfo)`\n- `(self, value: Any, nxt: SerializerFunctionWrapHandler, info: FieldSerializationInfo)`\n- `(value: Any, info: SerializationInfo)`\n- `(value: Any, nxt: SerializerFunctionWrapHandler, info: SerializationInfo)`\n\nArgs:\n    fields: Which field(s) the method should be called on.\n    mode: The serialization mode.\n\n        - `plain` means the function will be called instead of the default serialization logic,\n        - `wrap` means the function will be called with an argument to optionally call the\n           default serialization logic.\n    return_type: Optional return type for the function, if omitted it will be inferred from the type annotation.\n    when_used: Determines the serializer will be used for serialization.\n    check_fields: Whether to check that the fields actually exist on the model.\n\nReturns:\n    The decorator function.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/functional_serializers", "source_site": "pydantic"}
{"title": "model_serializer", "anchor": "model_serializer", "heading_level": 0, "md_text": "Decorator that enables custom model serialization.\n\nThis is useful when a model need to be serialized in a customized manner, allowing for flexibility beyond just specific fields.\n\nAn example would be to serialize temperature to the same temperature scale, such as degrees Celsius.\n\n```python\nfrom typing import Literal\n\nfrom pydantic import BaseModel, model_serializer\n\nclass TemperatureModel(BaseModel):\n    unit: Literal['C', 'F']\n    value: int\n\n    @model_serializer()\n    def serialize_model(self):\n        if self.unit == 'F':\n            return {'unit': 'C', 'value': int((self.value - 32) / 1.8)}\n        return {'unit': self.unit, 'value': self.value}\n\ntemperature = TemperatureModel(unit='F', value=212)\nprint(temperature.model_dump())\n#> {'unit': 'C', 'value': 100}\n```\n\nTwo signatures are supported for `mode='plain'`, which is the default:\n\n- `(self)`\n- `(self, info: SerializationInfo)`\n\nAnd two other signatures for `mode='wrap'`:\n\n- `(self, nxt: SerializerFunctionWrapHandler)`\n- `(self, nxt: SerializerFunctionWrapHandler, info: SerializationInfo)`\n\n    See [the usage documentation](../concepts/serialization.md#serializers) for more information.\n\nArgs:\n    f: The function to be decorated.\n    mode: The serialization mode.\n\n        - `'plain'` means the function will be called instead of the default serialization logic\n        - `'wrap'` means the function will be called with an argument to optionally call the default\n            serialization logic.\n    when_used: Determines when this serializer should be used.\n    return_type: The return type for the function. If omitted it will be inferred from the type annotation.\n\nReturns:\n    The decorator function.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/functional_serializers", "source_site": "pydantic"}
{"title": "PlainSerializer.__get_pydantic_core_schema__", "anchor": "plainserializer-__get_pydantic_core_schema__", "heading_level": 0, "md_text": "Gets the Pydantic core schema.\n\nArgs:\n    source_type: The source type.\n    handler: The `GetCoreSchemaHandler` instance.\n\nReturns:\n    The Pydantic core schema.", "url": "https://docs.pydantic.dev/latest/api/--get-pydantic-core-schema--/", "page": "pydantic/functional_serializers", "source_site": "pydantic"}
{"title": "WrapSerializer.__get_pydantic_core_schema__", "anchor": "wrapserializer-__get_pydantic_core_schema__", "heading_level": 0, "md_text": "This method is used to get the Pydantic core schema of the class.\n\nArgs:\n    source_type: Source type.\n    handler: Core schema handler.\n\nReturns:\n    The generated core schema of the class.", "url": "https://docs.pydantic.dev/latest/api/--get-pydantic-core-schema--/", "page": "pydantic/functional_serializers", "source_site": "pydantic"}
{"title": "SerializeAsAny", "anchor": "serializeasany", "heading_level": 0, "md_text": "Annotation used to mark a type as having duck-typing serialization behavior.\n\nSee [usage documentation](../concepts/serialization.md#serializing-with-duck-typing) for more details.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/functional_serializers", "source_site": "pydantic"}
{"title": "typing", "anchor": "typing", "heading_level": 0, "md_text": "`typing` module is a backport module from V1.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/typing", "source_site": "pydantic"}
{"title": "generics", "anchor": "generics", "heading_level": 0, "md_text": "The `generics` module is a backport module from V1.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/generics", "source_site": "pydantic"}
{"title": "validate_call_decorator", "anchor": "validate_call_decorator", "heading_level": 0, "md_text": "Decorator for validating function calls.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/validate_call_decorator", "source_site": "pydantic"}
{"title": "_check_function_type", "anchor": "_check_function_type", "heading_level": 0, "md_text": "Check if the input function is a supported type for `validate_call`.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/validate_call_decorator", "source_site": "pydantic"}
{"title": "validate_call", "anchor": "validate_call", "heading_level": 0, "md_text": "Returns a decorated wrapper around the function that validates the arguments and, optionally, the return value.\n\nUsage may be either as a plain decorator `@validate_call` or with arguments `@validate_call(...)`.\n\nArgs:\n    func: The function to be decorated.\n    config: The configuration dictionary.\n    validate_return: Whether to validate the return value.\n\nReturns:\n    The decorated function.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/validate_call_decorator", "source_site": "pydantic"}
{"title": "type_adapter", "anchor": "type_adapter", "heading_level": 0, "md_text": "Type adapter specification.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/type_adapter", "source_site": "pydantic"}
{"title": "_getattr_no_parents", "anchor": "_getattr_no_parents", "heading_level": 0, "md_text": "Returns the attribute value without attempting to look up attributes from parent types.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/type_adapter", "source_site": "pydantic"}
{"title": "_type_has_config", "anchor": "_type_has_config", "heading_level": 0, "md_text": "Returns whether the type has config.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/type_adapter", "source_site": "pydantic"}
{"title": "TypeAdapter", "anchor": "typeadapter", "heading_level": 0, "md_text": "Type adapters provide a flexible way to perform validation and serialization based on a Python type.\n\nA `TypeAdapter` instance exposes some of the functionality from `BaseModel` instance methods\nfor types that do not have such methods (such as dataclasses, primitive types, and more).\n\n**Note:** `TypeAdapter` instances are not types, and cannot be used as type annotations for fields.\n\nArgs:\n    type: The type associated with the `TypeAdapter`.\n    config: Configuration for the `TypeAdapter`, should be a dictionary conforming to\n        [`ConfigDict`][pydantic.config.ConfigDict].\n\nAttributes:\n    core_schema: The core schema for the type.\n    validator: The schema validator for the type.\n    serializer: The schema serializer for the type.\n    pydantic_complete: Whether the core schema for the type is successfully built.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/type_adapter", "source_site": "pydantic"}
{"title": "TypeAdapter._init_core_attrs", "anchor": "typeadapter-_init_core_attrs", "heading_level": 0, "md_text": "Initialize the core schema, validator, and serializer for the type.\n\nArgs:\n    ns_resolver: The namespace resolver to use when building the core schema for the adapted type.\n    force: Whether to force the construction of the core schema, validator, and serializer.\n        If `force` is set to `False` and `_defer_build` is `True`, the core schema, validator, and serializer will be set to mocks.\n    raise_errors: Whether to raise errors if initializing any of the core attrs fails.\n\nReturns:\n    `True` if the core schema, validator, and serializer were successfully initialized, otherwise `False`.\n\nRaises:\n    PydanticUndefinedAnnotation: If `PydanticUndefinedAnnotation` occurs in`__get_pydantic_core_schema__`\n        and `raise_errors=True`.", "url": "https://docs.pydantic.dev/latest/api/-init-core-attrs/", "page": "pydantic/type_adapter", "source_site": "pydantic"}
{"title": "TypeAdapter.rebuild", "anchor": "typeadapter-rebuild", "heading_level": 0, "md_text": "Try to rebuild the pydantic-core schema for the adapter's type.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the type adapter's schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: Depth at which to search for the [parent frame][frame-objects]. This\n        frame is used when resolving forward annotations during schema rebuilding, by looking for\n        the locals of this frame. Defaults to 2, which will result in the frame where the method\n        was called.\n    _types_namespace: An explicit types namespace to use, instead of using the local namespace\n        from the parent frame. Defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.", "url": "https://docs.pydantic.dev/latest/api/rebuild/", "page": "pydantic/type_adapter", "source_site": "pydantic"}
{"title": "TypeAdapter.validate_python", "anchor": "typeadapter-validate_python", "heading_level": 0, "md_text": "Validate a Python object against the model.\n\nArgs:\n    object: The Python object to validate against the model.\n    strict: Whether to strictly check types.\n    extra: Whether to ignore, allow, or forbid extra data during model validation.\n        See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    experimental_allow_partial: **Experimental** whether to enable\n        [partial validation](../concepts/experimental.md#partial-validation), e.g. to process streams.\n        * False / 'off': Default behavior, no partial validation.\n        * True / 'on': Enable partial validation.\n        * 'trailing-strings': Enable partial validation and allow trailing strings in the input.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated object.", "url": "https://docs.pydantic.dev/latest/api/validate-python/", "page": "pydantic/type_adapter", "source_site": "pydantic"}
{"title": "TypeAdapter.validate_json", "anchor": "typeadapter-validate_json", "heading_level": 0, "md_text": "Validate a JSON string or bytes against the model.\n\nArgs:\n    data: The JSON data to validate against the model.\n    strict: Whether to strictly check types.\n    extra: Whether to ignore, allow, or forbid extra data during model validation.\n        See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n    context: Additional context to use during validation.\n    experimental_allow_partial: **Experimental** whether to enable\n        [partial validation](../concepts/experimental.md#partial-validation), e.g. to process streams.\n        * False / 'off': Default behavior, no partial validation.\n        * True / 'on': Enable partial validation.\n        * 'trailing-strings': Enable partial validation and allow trailing strings in the input.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated object.", "url": "https://docs.pydantic.dev/latest/api/validate-json/", "page": "pydantic/type_adapter", "source_site": "pydantic"}
{"title": "TypeAdapter.validate_strings", "anchor": "typeadapter-validate_strings", "heading_level": 0, "md_text": "Validate object contains string data against the model.\n\nArgs:\n    obj: The object contains string data to validate.\n    strict: Whether to strictly check types.\n    extra: Whether to ignore, allow, or forbid extra data during model validation.\n        See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n    context: Additional context to use during validation.\n    experimental_allow_partial: **Experimental** whether to enable\n        [partial validation](../concepts/experimental.md#partial-validation), e.g. to process streams.\n        * False / 'off': Default behavior, no partial validation.\n        * True / 'on': Enable partial validation.\n        * 'trailing-strings': Enable partial validation and allow trailing strings in the input.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated object.", "url": "https://docs.pydantic.dev/latest/api/validate-strings/", "page": "pydantic/type_adapter", "source_site": "pydantic"}
{"title": "TypeAdapter.get_default_value", "anchor": "typeadapter-get_default_value", "heading_level": 0, "md_text": "Get the default value for the wrapped type.\n\nArgs:\n    strict: Whether to strictly check types.\n    context: Additional context to pass to the validator.\n\nReturns:\n    The default value wrapped in a `Some` if there is one or None if not.", "url": "https://docs.pydantic.dev/latest/api/get-default-value/", "page": "pydantic/type_adapter", "source_site": "pydantic"}
{"title": "TypeAdapter.dump_python", "anchor": "typeadapter-dump_python", "heading_level": 0, "md_text": "Dump an instance of the adapted type to a Python object.\n\nArgs:\n    instance: The Python object to serialize.\n    mode: The output format.\n    include: Fields to include in the output.\n    exclude: Fields to exclude from the output.\n    by_alias: Whether to use alias names for field names.\n    exclude_unset: Whether to exclude unset fields.\n    exclude_defaults: Whether to exclude fields with default values.\n    exclude_none: Whether to exclude fields with None values.\n    exclude_computed_fields: Whether to exclude computed fields.\n        While this can be useful for round-tripping, it is usually recommended to use the dedicated\n        `round_trip` parameter instead.\n    round_trip: Whether to output the serialized data in a way that is compatible with deserialization.\n    warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n        \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n    fallback: A function to call when an unknown value is encountered. If not provided,\n        a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n    serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n    context: Additional context to pass to the serializer.\n\nReturns:\n    The serialized object.", "url": "https://docs.pydantic.dev/latest/api/dump-python/", "page": "pydantic/type_adapter", "source_site": "pydantic"}
{"title": "TypeAdapter.dump_json", "anchor": "typeadapter-dump_json", "heading_level": 0, "md_text": "Serialize an instance of the adapted type to JSON.\n\nArgs:\n    instance: The instance to be serialized.\n    indent: Number of spaces for JSON indentation.\n    ensure_ascii: If `True`, the output is guaranteed to have all incoming non-ASCII characters escaped.\n        If `False` (the default), these characters will be output as-is.\n    include: Fields to include.\n    exclude: Fields to exclude.\n    by_alias: Whether to use alias names for field names.\n    exclude_unset: Whether to exclude unset fields.\n    exclude_defaults: Whether to exclude fields with default values.\n    exclude_none: Whether to exclude fields with a value of `None`.\n    exclude_computed_fields: Whether to exclude computed fields.\n        While this can be useful for round-tripping, it is usually recommended to use the dedicated\n        `round_trip` parameter instead.\n    round_trip: Whether to serialize and deserialize the instance to ensure round-tripping.\n    warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n        \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n    fallback: A function to call when an unknown value is encountered. If not provided,\n        a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n    serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n    context: Additional context to pass to the serializer.\n\nReturns:\n    The JSON representation of the given instance as bytes.", "url": "https://docs.pydantic.dev/latest/api/dump-json/", "page": "pydantic/type_adapter", "source_site": "pydantic"}
{"title": "TypeAdapter.json_schema", "anchor": "typeadapter-json_schema", "heading_level": 0, "md_text": "Generate a JSON schema for the adapted type.\n\nArgs:\n    by_alias: Whether to use alias names for field names.\n    ref_template: The format string used for generating $ref strings.\n    union_format: The format to use when combining schemas from unions together. Can be one of:\n\n        - `'any_of'`: Use the [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\n        keyword to combine schemas (the default).\n        - `'primitive_type_array'`: Use the [`type`](https://json-schema.org/understanding-json-schema/reference/type)\n        keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\n        type (`string`, `boolean`, `null`, `integer` or `number`) or contains constraints/metadata, falls back to\n        `any_of`.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n    schema_generator: The generator class used for creating the schema.\n    mode: The mode to use for schema generation.\n\nReturns:\n    The JSON schema for the model as a dictionary.", "url": "https://docs.pydantic.dev/latest/api/json-schema/", "page": "pydantic/type_adapter", "source_site": "pydantic"}
{"title": "TypeAdapter.json_schemas", "anchor": "typeadapter-json_schemas", "heading_level": 0, "md_text": "Generate a JSON schema including definitions from multiple type adapters.\n\nArgs:\n    inputs: Inputs to schema generation. The first two items will form the keys of the (first)\n        output mapping; the type adapters will provide the core schemas that get converted into\n        definitions in the output JSON schema.\n    by_alias: Whether to use alias names.\n    title: The title for the schema.\n    description: The description for the schema.\n    ref_template: The format string used for generating $ref strings.\n    union_format: The format to use when combining schemas from unions together. Can be one of:\n\n        - `'any_of'`: Use the [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\n        keyword to combine schemas (the default).\n        - `'primitive_type_array'`: Use the [`type`](https://json-schema.org/understanding-json-schema/reference/type)\n        keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\n        type (`string`, `boolean`, `null`, `integer` or `number`) or contains constraints/metadata, falls back to\n        `any_of`.\n    schema_generator: The generator class used for creating the schema.\n\nReturns:\n    A tuple where:\n\n        - The first element is a dictionary whose keys are tuples of JSON schema key type and JSON mode, and\n            whose values are the JSON schema corresponding to that pair of inputs. (These schemas may have\n            JsonRef references to definitions that are defined in the second returned element.)\n        - The second element is a JSON schema containing all definitions referenced in the first returned\n            element, along with the optional title and description keys.", "url": "https://docs.pydantic.dev/latest/api/json-schemas/", "page": "pydantic/type_adapter", "source_site": "pydantic"}
{"title": "schema", "anchor": "schema", "heading_level": 0, "md_text": "The `schema` module is a backport module from V1.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/schema", "source_site": "pydantic"}
{"title": "root_model", "anchor": "root_model", "heading_level": 0, "md_text": "RootModel class and type definitions.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/root_model", "source_site": "pydantic"}
{"title": "RootModel", "anchor": "rootmodel", "heading_level": 0, "md_text": "A Pydantic `BaseModel` for the root object of the model.\n\nAttributes:\n    root: The root object of the model.\n    __pydantic_root_model__: Whether the model is a RootModel.\n    __pydantic_private__: Private fields in the model.\n    __pydantic_extra__: Extra fields in the model.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/root_model", "source_site": "pydantic"}
{"title": "RootModel.model_construct", "anchor": "rootmodel-model_construct", "heading_level": 0, "md_text": "Create a new model using the provided root object and update fields set.\n\nArgs:\n    root: The root object of the model.\n    _fields_set: The set of fields to be updated.\n\nReturns:\n    The new model.\n\nRaises:\n    NotImplemented: If the model is not a subclass of `RootModel`.", "url": "https://docs.pydantic.dev/latest/api/model-construct/", "page": "pydantic/root_model", "source_site": "pydantic"}
{"title": "RootModel.__copy__", "anchor": "rootmodel-__copy__", "heading_level": 0, "md_text": "Returns a shallow copy of the model.", "url": "https://docs.pydantic.dev/latest/api/--copy--/", "page": "pydantic/root_model", "source_site": "pydantic"}
{"title": "RootModel.__deepcopy__", "anchor": "rootmodel-__deepcopy__", "heading_level": 0, "md_text": "Returns a deep copy of the model.", "url": "https://docs.pydantic.dev/latest/api/--deepcopy--/", "page": "pydantic/root_model", "source_site": "pydantic"}
{"title": "model_dump", "anchor": "model_dump", "heading_level": 0, "md_text": "This method is included just to get a more accurate return type for type checkers.\nIt is included in this `if TYPE_CHECKING:` block since no override is actually necessary.\n\nSee the documentation of `BaseModel.model_dump` for more details about the arguments.\n\nGenerally, this method will have a return type of `RootModelRootType`, assuming that `RootModelRootType` is\nnot a `BaseModel` subclass. If `RootModelRootType` is a `BaseModel` subclass, then the return\ntype will likely be `dict[str, Any]`, as `model_dump` calls are recursive. The return type could\neven be something different, in the case of a custom serializer.\nThus, `Any` is used here to catch all of these cases.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/root_model", "source_site": "pydantic"}
{"title": "functional_validators", "anchor": "functional_validators", "heading_level": 0, "md_text": "This module contains related classes and functions for validation.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/functional_validators", "source_site": "pydantic"}
{"title": "AfterValidator", "anchor": "aftervalidator", "heading_level": 0, "md_text": "A metadata class that indicates that a validation should be applied **after** the inner validation logic.\n\nAttributes:\n    func: The validator function.\n\nExample:\n    ```python\n    from typing import Annotated\n\n    from pydantic import AfterValidator, BaseModel, ValidationError\n\n    MyInt = Annotated[int, AfterValidator(lambda v: v + 1)]\n\n    class Model(BaseModel):\n        a: MyInt\n\n    print(Model(a=1).a)\n    #> 2\n\n    try:\n        Model(a='a')\n    except ValidationError as e:\n        print(e.json(indent=2))\n        '''\n        [\n          {\n            \"type\": \"int_parsing\",\n            \"loc\": [\n              \"a\"\n            ],\n            \"msg\": \"Input should be a valid integer, unable to parse string as an integer\",\n            \"input\": \"a\",\n            \"url\": \"https://errors.pydantic.dev/2/v/int_parsing\"\n          }\n        ]\n        '''\n    ```", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/functional_validators", "source_site": "pydantic"}
{"title": "BeforeValidator", "anchor": "beforevalidator", "heading_level": 0, "md_text": "A metadata class that indicates that a validation should be applied **before** the inner validation logic.\n\nAttributes:\n    func: The validator function.\n    json_schema_input_type: The input type used to generate the appropriate\n        JSON Schema (in validation mode). The actual input type is `Any`.\n\nExample:\n    ```python\n    from typing import Annotated\n\n    from pydantic import BaseModel, BeforeValidator\n\n    MyInt = Annotated[int, BeforeValidator(lambda v: v + 1)]\n\n    class Model(BaseModel):\n        a: MyInt\n\n    print(Model(a=1).a)\n    #> 2\n\n    try:\n        Model(a='a')\n    except TypeError as e:\n        print(e)\n        #> can only concatenate str (not \"int\") to str\n    ```", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/functional_validators", "source_site": "pydantic"}
{"title": "PlainValidator", "anchor": "plainvalidator", "heading_level": 0, "md_text": "A metadata class that indicates that a validation should be applied **instead** of the inner validation logic.\n\nAttributes:\n    func: The validator function.\n    json_schema_input_type: The input type used to generate the appropriate\n        JSON Schema (in validation mode). The actual input type is `Any`.\n\nExample:\n    ```python\n    from typing import Annotated, Union\n\n    from pydantic import BaseModel, PlainValidator\n\n    def validate(v: object) -> int:\n        if not isinstance(v, (int, str)):\n            raise ValueError(f'Expected int or str, go {type(v)}')\n\n        return int(v) + 1\n\n    MyInt = Annotated[\n        int,\n        PlainValidator(validate, json_schema_input_type=Union[str, int]),  # (1)!\n    ]\n\n    class Model(BaseModel):\n        a: MyInt\n\n    print(Model(a='1').a)\n    #> 2\n\n    print(Model(a=1).a)\n    #> 2\n    ```\n\n    1. In this example, we've specified the `json_schema_input_type` as `Union[str, int]` which indicates to the JSON schema\n    generator that in validation mode, the input type for the `a` field can be either a [`str`][] or an [`int`][].", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/functional_validators", "source_site": "pydantic"}
{"title": "WrapValidator", "anchor": "wrapvalidator", "heading_level": 0, "md_text": "A metadata class that indicates that a validation should be applied **around** the inner validation logic.\n\nAttributes:\n    func: The validator function.\n    json_schema_input_type: The input type used to generate the appropriate\n        JSON Schema (in validation mode). The actual input type is `Any`.\n\n```python\nfrom datetime import datetime\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, ValidationError, WrapValidator\n\ndef validate_timestamp(v, handler):\n    if v == 'now':\n        # we don't want to bother with further validation, just return the new value\n        return datetime.now()\n    try:\n        return handler(v)\n    except ValidationError:\n        # validation failed, in this case we want to return a default value\n        return datetime(2000, 1, 1)\n\nMyTimestamp = Annotated[datetime, WrapValidator(validate_timestamp)]\n\nclass Model(BaseModel):\n    a: MyTimestamp\n\nprint(Model(a='now').a)\n#> 2032-01-02 03:04:05.000006\nprint(Model(a='invalid').a)\n#> 2000-01-01 00:00:00\n```", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/functional_validators", "source_site": "pydantic"}
{"title": "field_validator", "anchor": "field_validator", "heading_level": 0, "md_text": "Decorate methods on the class indicating that they should be used to validate fields.\n\nExample usage:\n```python\nfrom typing import Any\n\nfrom pydantic import (\n    BaseModel,\n    ValidationError,\n    field_validator,\n)\n\nclass Model(BaseModel):\n    a: str\n\n    @field_validator('a')\n    @classmethod\n    def ensure_foobar(cls, v: Any):\n        if 'foobar' not in v:\n            raise ValueError('\"foobar\" not found in a')\n        return v\n\nprint(repr(Model(a='this is foobar good')))\n#> Model(a='this is foobar good')\n\ntry:\n    Model(a='snap')\nexcept ValidationError as exc_info:\n    print(exc_info)\n    '''\n    1 validation error for Model\n    a\n      Value error, \"foobar\" not found in a [type=value_error, input_value='snap', input_type=str]\n    '''\n```\n\nFor more in depth examples, see [Field Validators](../concepts/validators.md#field-validators).\n\nArgs:\n    field: The first field the `field_validator` should be called on; this is separate\n        from `fields` to ensure an error is raised if you don't pass at least one.\n    *fields: Additional field(s) the `field_validator` should be called on.\n    mode: Specifies whether to validate the fields before or after validation.\n    check_fields: Whether to check that the fields actually exist on the model.\n    json_schema_input_type: The input type of the function. This is only used to generate\n        the appropriate JSON Schema (in validation mode) and can only specified\n        when `mode` is either `'before'`, `'plain'` or `'wrap'`.\n\nReturns:\n    A decorator that can be used to decorate a function to be used as a field_validator.\n\nRaises:\n    PydanticUserError:\n        - If `@field_validator` is used bare (with no fields).\n        - If the args passed to `@field_validator` as fields are not strings.\n        - If `@field_validator` applied to instance methods.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/functional_validators", "source_site": "pydantic"}
{"title": "ModelWrapValidatorHandler", "anchor": "modelwrapvalidatorhandler", "heading_level": 0, "md_text": "`@model_validator` decorated function handler argument type. This is used when `mode='wrap'`.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/functional_validators", "source_site": "pydantic"}
{"title": "ModelWrapValidatorWithoutInfo", "anchor": "modelwrapvalidatorwithoutinfo", "heading_level": 0, "md_text": "A `@model_validator` decorated function signature.\nThis is used when `mode='wrap'` and the function does not have info argument.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/functional_validators", "source_site": "pydantic"}
{"title": "ModelWrapValidator", "anchor": "modelwrapvalidator", "heading_level": 0, "md_text": "A `@model_validator` decorated function signature. This is used when `mode='wrap'`.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/functional_validators", "source_site": "pydantic"}
{"title": "FreeModelBeforeValidatorWithoutInfo", "anchor": "freemodelbeforevalidatorwithoutinfo", "heading_level": 0, "md_text": "A `@model_validator` decorated function signature.\nThis is used when `mode='before'` and the function does not have info argument.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/functional_validators", "source_site": "pydantic"}
{"title": "ModelBeforeValidatorWithoutInfo", "anchor": "modelbeforevalidatorwithoutinfo", "heading_level": 0, "md_text": "A `@model_validator` decorated function signature.\nThis is used when `mode='before'` and the function does not have info argument.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/functional_validators", "source_site": "pydantic"}
{"title": "FreeModelBeforeValidator", "anchor": "freemodelbeforevalidator", "heading_level": 0, "md_text": "A `@model_validator` decorated function signature. This is used when `mode='before'`.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/functional_validators", "source_site": "pydantic"}
{"title": "ModelBeforeValidator", "anchor": "modelbeforevalidator", "heading_level": 0, "md_text": "A `@model_validator` decorated function signature. This is used when `mode='before'`.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/functional_validators", "source_site": "pydantic"}
{"title": "model_validator", "anchor": "model_validator", "heading_level": 0, "md_text": "Decorate model methods for validation purposes.\n\nExample usage:\n```python\nfrom typing_extensions import Self\n\nfrom pydantic import BaseModel, ValidationError, model_validator\n\nclass Square(BaseModel):\n    width: float\n    height: float\n\n    @model_validator(mode='after')\n    def verify_square(self) -> Self:\n        if self.width != self.height:\n            raise ValueError('width and height do not match')\n        return self\n\ns = Square(width=1, height=1)\nprint(repr(s))\n#> Square(width=1.0, height=1.0)\n\ntry:\n    Square(width=1, height=2)\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for Square\n      Value error, width and height do not match [type=value_error, input_value={'width': 1, 'height': 2}, input_type=dict]\n    '''\n```\n\nFor more in depth examples, see [Model Validators](../concepts/validators.md#model-validators).\n\nArgs:\n    mode: A required string literal that specifies the validation mode.\n        It can be one of the following: 'wrap', 'before', or 'after'.\n\nReturns:\n    A decorator that can be used to decorate a function to be used as a model validator.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/functional_validators", "source_site": "pydantic"}
{"title": "ValidateAs", "anchor": "validateas", "heading_level": 0, "md_text": "A helper class to validate a custom type from a type that is natively supported by Pydantic.\n\nArgs:\n    from_type: The type natively supported by Pydantic to use to perform validation.\n    instantiation_hook: A callable taking the validated type as an argument, and returning\n        the populated custom type.\n\nExample:\n    ```python {lint=\"skip\"}\n    from typing import Annotated\n\n    from pydantic import BaseModel, TypeAdapter, ValidateAs\n\n    class MyCls:\n        def __init__(self, a: int) -> None:\n            self.a = a\n\n        def __repr__(self) -> str:\n            return f\"MyCls(a={self.a})\"\n\n    class Model(BaseModel):\n        a: int\n\n\n    ta = TypeAdapter(\n        Annotated[MyCls, ValidateAs(Model, lambda v: MyCls(a=v.a))]\n    )\n\n    print(ta.validate_python({'a': 1}))\n    #> MyCls(a=1)\n    ```", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/functional_validators", "source_site": "pydantic"}
{"title": "InstanceOf", "anchor": "instanceof", "heading_level": 0, "md_text": "Generic type for annotating a type that is an instance of a given class.\n\nExample:\n    ```python\n    from pydantic import BaseModel, InstanceOf\n\n    class Foo:\n        ...\n\n    class Bar(BaseModel):\n        foo: InstanceOf[Foo]\n\n    Bar(foo=Foo())\n    try:\n        Bar(foo=42)\n    except ValidationError as e:\n        print(e)\n        \"\"\"\n        [\n        \u2502   {\n        \u2502   \u2502   'type': 'is_instance_of',\n        \u2502   \u2502   'loc': ('foo',),\n        \u2502   \u2502   'msg': 'Input should be an instance of Foo',\n        \u2502   \u2502   'input': 42,\n        \u2502   \u2502   'ctx': {'class': 'Foo'},\n        \u2502   \u2502   'url': 'https://errors.pydantic.dev/0.38.0/v/is_instance_of'\n        \u2502   }\n        ]\n        \"\"\"\n    ```", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/functional_validators", "source_site": "pydantic"}
{"title": "SkipValidation", "anchor": "skipvalidation", "heading_level": 0, "md_text": "If this is applied as an annotation (e.g., via `x: Annotated[int, SkipValidation]`), validation will be\n    skipped. You can also use `SkipValidation[int]` as a shorthand for `Annotated[int, SkipValidation]`.\n\nThis can be useful if you want to use a type annotation for documentation/IDE/type-checking purposes,\nand know that it is safe to skip validation for one or more of the fields.\n\nBecause this converts the validation schema to `any_schema`, subsequent annotation-applied transformations\nmay not have the expected effects. Therefore, when used, this annotation should generally be the final\nannotation applied to a type.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/functional_validators", "source_site": "pydantic"}
{"title": "config", "anchor": "config", "heading_level": 0, "md_text": "Configuration for Pydantic models.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/config", "source_site": "pydantic"}
{"title": "ConfigDict", "anchor": "configdict", "heading_level": 0, "md_text": "A TypedDict for configuring Pydantic behaviour.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/config", "source_site": "pydantic"}
{"title": "with_config", "anchor": "with_config", "heading_level": 0, "md_text": "A convenience decorator to set a [Pydantic configuration](config.md) on a `TypedDict` or a `dataclass` from the standard library.\n\nAlthough the configuration can be set using the `__pydantic_config__` attribute, it does not play well with type checkers,\nespecially with `TypedDict`.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/config", "source_site": "pydantic"}
{"title": "annotated_handlers", "anchor": "annotated_handlers", "heading_level": 0, "md_text": "Type annotations to use with `__get_pydantic_core_schema__` and `__get_pydantic_json_schema__`.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/annotated_handlers", "source_site": "pydantic"}
{"title": "GetJsonSchemaHandler", "anchor": "getjsonschemahandler", "heading_level": 0, "md_text": "Handler to call into the next JSON schema generation function.\n\nAttributes:\n    mode: Json schema mode, can be `validation` or `serialization`.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/annotated_handlers", "source_site": "pydantic"}
{"title": "GetCoreSchemaHandler", "anchor": "getcoreschemahandler", "heading_level": 0, "md_text": "Handler to call into the next CoreSchema schema generation function.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/annotated_handlers", "source_site": "pydantic"}
{"title": "GetJsonSchemaHandler.__call__", "anchor": "getjsonschemahandler-__call__", "heading_level": 0, "md_text": "Call the inner handler and get the JsonSchemaValue it returns.\nThis will call the next JSON schema modifying function up until it calls\ninto `pydantic.json_schema.GenerateJsonSchema`, which will raise a\n`pydantic.errors.PydanticInvalidForJsonSchema` error if it cannot generate\na JSON schema.\n\nArgs:\n    core_schema: A `pydantic_core.core_schema.CoreSchema`.\n\nReturns:\n    JsonSchemaValue: The JSON schema generated by the inner JSON schema modify\n    functions.", "url": "https://docs.pydantic.dev/latest/api/--call--/", "page": "pydantic/annotated_handlers", "source_site": "pydantic"}
{"title": "GetJsonSchemaHandler.resolve_ref_schema", "anchor": "getjsonschemahandler-resolve_ref_schema", "heading_level": 0, "md_text": "Get the real schema for a `{\"$ref\": ...}` schema.\nIf the schema given is not a `$ref` schema, it will be returned as is.\nThis means you don't have to check before calling this function.\n\nArgs:\n    maybe_ref_json_schema: A JsonSchemaValue which may be a `$ref` schema.\n\nRaises:\n    LookupError: If the ref is not found.\n\nReturns:\n    JsonSchemaValue: A JsonSchemaValue that has no `$ref`.", "url": "https://docs.pydantic.dev/latest/api/resolve-ref-schema/", "page": "pydantic/annotated_handlers", "source_site": "pydantic"}
{"title": "GetCoreSchemaHandler.__call__", "anchor": "getcoreschemahandler-__call__", "heading_level": 0, "md_text": "Call the inner handler and get the CoreSchema it returns.\nThis will call the next CoreSchema modifying function up until it calls\ninto Pydantic's internal schema generation machinery, which will raise a\n`pydantic.errors.PydanticSchemaGenerationError` error if it cannot generate\na CoreSchema for the given source type.\n\nArgs:\n    source_type: The input type.\n\nReturns:\n    CoreSchema: The `pydantic-core` CoreSchema generated.", "url": "https://docs.pydantic.dev/latest/api/--call--/", "page": "pydantic/annotated_handlers", "source_site": "pydantic"}
{"title": "GetCoreSchemaHandler.generate_schema", "anchor": "getcoreschemahandler-generate_schema", "heading_level": 0, "md_text": "Generate a schema unrelated to the current context.\nUse this function if e.g. you are handling schema generation for a sequence\nand want to generate a schema for its items.\nOtherwise, you may end up doing something like applying a `min_length` constraint\nthat was intended for the sequence itself to its items!\n\nArgs:\n    source_type: The input type.\n\nReturns:\n    CoreSchema: The `pydantic-core` CoreSchema generated.", "url": "https://docs.pydantic.dev/latest/api/generate-schema/", "page": "pydantic/annotated_handlers", "source_site": "pydantic"}
{"title": "GetCoreSchemaHandler.resolve_ref_schema", "anchor": "getcoreschemahandler-resolve_ref_schema", "heading_level": 0, "md_text": "Get the real schema for a `definition-ref` schema.\nIf the schema given is not a `definition-ref` schema, it will be returned as is.\nThis means you don't have to check before calling this function.\n\nArgs:\n    maybe_ref_schema: A `CoreSchema`, `ref`-based or not.\n\nRaises:\n    LookupError: If the `ref` is not found.\n\nReturns:\n    A concrete `CoreSchema`.", "url": "https://docs.pydantic.dev/latest/api/resolve-ref-schema/", "page": "pydantic/annotated_handlers", "source_site": "pydantic"}
{"title": "GetCoreSchemaHandler.field_name", "anchor": "getcoreschemahandler-field_name", "heading_level": 0, "md_text": "Get the name of the closest field to this validator.", "url": "https://docs.pydantic.dev/latest/api/field-name/", "page": "pydantic/annotated_handlers", "source_site": "pydantic"}
{"title": "GetCoreSchemaHandler._get_types_namespace", "anchor": "getcoreschemahandler-_get_types_namespace", "heading_level": 0, "md_text": "Internal method used during type resolution for serializer annotations.", "url": "https://docs.pydantic.dev/latest/api/-get-types-namespace/", "page": "pydantic/annotated_handlers", "source_site": "pydantic"}
{"title": "color", "anchor": "color", "heading_level": 0, "md_text": "Color definitions are used as per the CSS3\n[CSS Color Module Level 3](http://www.w3.org/TR/css3-color/#svg-color) specification.\n\nA few colors have multiple names referring to the sames colors, eg. `grey` and `gray` or `aqua` and `cyan`.\n\nIn these cases the _last_ color when sorted alphabetically takes preferences,\neg. `Color((0, 255, 255)).as_named() == 'cyan'` because \"cyan\" comes after \"aqua\".\n\nWarning: Deprecated\n    The `Color` class is deprecated, use `pydantic_extra_types` instead.\n    See [`pydantic-extra-types.Color`](../usage/types/extra_types/color_types.md)\n    for more information.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/color", "source_site": "pydantic"}
{"title": "RGBA", "anchor": "rgba", "heading_level": 0, "md_text": "Internal use only as a representation of a color.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/color", "source_site": "pydantic"}
{"title": "Color", "anchor": "color", "heading_level": 0, "md_text": "Represents a color.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/color", "source_site": "pydantic"}
{"title": "parse_tuple", "anchor": "parse_tuple", "heading_level": 0, "md_text": "Parse a tuple or list to get RGBA values.\n\nArgs:\n    value: A tuple or list.\n\nReturns:\n    An `RGBA` tuple parsed from the input tuple.\n\nRaises:\n    PydanticCustomError: If tuple is not valid.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/color", "source_site": "pydantic"}
{"title": "parse_str", "anchor": "parse_str", "heading_level": 0, "md_text": "Parse a string representing a color to an RGBA tuple.\n\nPossible formats for the input string include:\n\n* named color, see `COLORS_BY_NAME`\n* hex short eg. `<prefix>fff` (prefix can be `#`, `0x` or nothing)\n* hex long eg. `<prefix>ffffff` (prefix can be `#`, `0x` or nothing)\n* `rgb(<r>, <g>, <b>)`\n* `rgba(<r>, <g>, <b>, <a>)`\n\nArgs:\n    value: A string representing a color.\n\nReturns:\n    An `RGBA` tuple parsed from the input string.\n\nRaises:\n    ValueError: If the input string cannot be parsed to an RGBA tuple.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/color", "source_site": "pydantic"}
{"title": "ints_to_rgba", "anchor": "ints_to_rgba", "heading_level": 0, "md_text": "Converts integer or string values for RGB color and an optional alpha value to an `RGBA` object.\n\nArgs:\n    r: An integer or string representing the red color value.\n    g: An integer or string representing the green color value.\n    b: An integer or string representing the blue color value.\n    alpha: A float representing the alpha value. Defaults to None.\n\nReturns:\n    An instance of the `RGBA` class with the corresponding color and alpha values.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/color", "source_site": "pydantic"}
{"title": "parse_color_value", "anchor": "parse_color_value", "heading_level": 0, "md_text": "Parse the color value provided and return a number between 0 and 1.\n\nArgs:\n    value: An integer or string color value.\n    max_val: Maximum range value. Defaults to 255.\n\nRaises:\n    PydanticCustomError: If the value is not a valid color.\n\nReturns:\n    A number between 0 and 1.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/color", "source_site": "pydantic"}
{"title": "parse_float_alpha", "anchor": "parse_float_alpha", "heading_level": 0, "md_text": "Parse an alpha value checking it's a valid float in the range 0 to 1.\n\nArgs:\n    value: The input value to parse.\n\nReturns:\n    The parsed value as a float, or `None` if the value was None or equal 1.\n\nRaises:\n    PydanticCustomError: If the input value cannot be successfully parsed as a float in the expected range.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/color", "source_site": "pydantic"}
{"title": "parse_hsl", "anchor": "parse_hsl", "heading_level": 0, "md_text": "Parse raw hue, saturation, lightness, and alpha values and convert to RGBA.\n\nArgs:\n    h: The hue value.\n    h_units: The unit for hue value.\n    sat: The saturation value.\n    light: The lightness value.\n    alpha: Alpha value.\n\nReturns:\n    An instance of `RGBA`.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/color", "source_site": "pydantic"}
{"title": "float_to_255", "anchor": "float_to_255", "heading_level": 0, "md_text": "Converts a float value between 0 and 1 (inclusive) to an integer between 0 and 255 (inclusive).\n\nArgs:\n    c: The float value to be converted. Must be between 0 and 1 (inclusive).\n\nReturns:\n    The integer equivalent of the given float value rounded to the nearest whole number.\n\nRaises:\n    ValueError: If the given float value is outside the acceptable range of 0 to 1 (inclusive).", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/color", "source_site": "pydantic"}
{"title": "Color.original", "anchor": "color-original", "heading_level": 0, "md_text": "Original value passed to `Color`.", "url": "https://docs.pydantic.dev/latest/api/original/", "page": "pydantic/color", "source_site": "pydantic"}
{"title": "Color.as_named", "anchor": "color-as_named", "heading_level": 0, "md_text": "Returns the name of the color if it can be found in `COLORS_BY_VALUE` dictionary,\notherwise returns the hexadecimal representation of the color or raises `ValueError`.\n\nArgs:\n    fallback: If True, falls back to returning the hexadecimal representation of\n        the color instead of raising a ValueError when no named color is found.\n\nReturns:\n    The name of the color, or the hexadecimal representation of the color.\n\nRaises:\n    ValueError: When no named color is found and fallback is `False`.", "url": "https://docs.pydantic.dev/latest/api/as-named/", "page": "pydantic/color", "source_site": "pydantic"}
{"title": "Color.as_hex", "anchor": "color-as_hex", "heading_level": 0, "md_text": "Returns the hexadecimal representation of the color.\n\nHex string representing the color can be 3, 4, 6, or 8 characters depending on whether the string\na \"short\" representation of the color is possible and whether there's an alpha channel.\n\nReturns:\n    The hexadecimal representation of the color.", "url": "https://docs.pydantic.dev/latest/api/as-hex/", "page": "pydantic/color", "source_site": "pydantic"}
{"title": "Color.as_rgb", "anchor": "color-as_rgb", "heading_level": 0, "md_text": "Color as an `rgb(<r>, <g>, <b>)` or `rgba(<r>, <g>, <b>, <a>)` string.", "url": "https://docs.pydantic.dev/latest/api/as-rgb/", "page": "pydantic/color", "source_site": "pydantic"}
{"title": "Color.as_rgb_tuple", "anchor": "color-as_rgb_tuple", "heading_level": 0, "md_text": "Returns the color as an RGB or RGBA tuple.\n\nArgs:\n    alpha: Whether to include the alpha channel. There are three options for this input:\n\n        - `None` (default): Include alpha only if it's set. (e.g. not `None`)\n        - `True`: Always include alpha.\n        - `False`: Always omit alpha.\n\nReturns:\n    A tuple that contains the values of the red, green, and blue channels in the range 0 to 255.\n        If alpha is included, it is in the range 0 to 1.", "url": "https://docs.pydantic.dev/latest/api/as-rgb-tuple/", "page": "pydantic/color", "source_site": "pydantic"}
{"title": "Color.as_hsl", "anchor": "color-as_hsl", "heading_level": 0, "md_text": "Color as an `hsl(<h>, <s>, <l>)` or `hsl(<h>, <s>, <l>, <a>)` string.", "url": "https://docs.pydantic.dev/latest/api/as-hsl/", "page": "pydantic/color", "source_site": "pydantic"}
{"title": "Color.as_hsl_tuple", "anchor": "color-as_hsl_tuple", "heading_level": 0, "md_text": "Returns the color as an HSL or HSLA tuple.\n\nArgs:\n    alpha: Whether to include the alpha channel.\n\n        - `None` (default): Include the alpha channel only if it's set (e.g. not `None`).\n        - `True`: Always include alpha.\n        - `False`: Always omit alpha.\n\nReturns:\n    The color as a tuple of hue, saturation, lightness, and alpha (if included).\n        All elements are in the range 0 to 1.\n\nNote:\n    This is HSL as used in HTML and most other places, not HLS as used in Python's `colorsys`.", "url": "https://docs.pydantic.dev/latest/api/as-hsl-tuple/", "page": "pydantic/color", "source_site": "pydantic"}
{"title": "json", "anchor": "json", "heading_level": 0, "md_text": "The `json` module is a backport module from V1.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/json", "source_site": "pydantic"}
{"title": "__init__", "anchor": "__init__", "heading_level": 0, "md_text": "Plugin interface for Pydantic plugins, and related types.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/plugin/__init__", "source_site": "pydantic"}
{"title": "SchemaTypePath", "anchor": "schematypepath", "heading_level": 0, "md_text": "Path defining where `schema_type` was defined, or where `TypeAdapter` was called.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/plugin/__init__", "source_site": "pydantic"}
{"title": "PydanticPluginProtocol", "anchor": "pydanticpluginprotocol", "heading_level": 0, "md_text": "Protocol defining the interface for Pydantic plugins.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/plugin/__init__", "source_site": "pydantic"}
{"title": "BaseValidateHandlerProtocol", "anchor": "basevalidatehandlerprotocol", "heading_level": 0, "md_text": "Base class for plugin callbacks protocols.\n\nYou shouldn't implement this protocol directly, instead use one of the subclasses with adds the correctly\ntyped `on_error` method.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/plugin/__init__", "source_site": "pydantic"}
{"title": "ValidatePythonHandlerProtocol", "anchor": "validatepythonhandlerprotocol", "heading_level": 0, "md_text": "Event handler for `SchemaValidator.validate_python`.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/plugin/__init__", "source_site": "pydantic"}
{"title": "ValidateJsonHandlerProtocol", "anchor": "validatejsonhandlerprotocol", "heading_level": 0, "md_text": "Event handler for `SchemaValidator.validate_json`.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/plugin/__init__", "source_site": "pydantic"}
{"title": "ValidateStringsHandlerProtocol", "anchor": "validatestringshandlerprotocol", "heading_level": 0, "md_text": "Event handler for `SchemaValidator.validate_strings`.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/plugin/__init__", "source_site": "pydantic"}
{"title": "PydanticPluginProtocol.new_schema_validator", "anchor": "pydanticpluginprotocol-new_schema_validator", "heading_level": 0, "md_text": "This method is called for each plugin every time a new [`SchemaValidator`][pydantic_core.SchemaValidator]\nis created.\n\nIt should return an event handler for each of the three validation methods, or `None` if the plugin does not\nimplement that method.\n\nArgs:\n    schema: The schema to validate against.\n    schema_type: The original type which the schema was created from, e.g. the model class.\n    schema_type_path: Path defining where `schema_type` was defined, or where `TypeAdapter` was called.\n    schema_kind: The kind of schema to validate against.\n    config: The config to use for validation.\n    plugin_settings: Any plugin settings.\n\nReturns:\n    A tuple of optional event handlers for each of the three validation methods -\n        `validate_python`, `validate_json`, `validate_strings`.", "url": "https://docs.pydantic.dev/latest/api/new-schema-validator/", "page": "pydantic/plugin/__init__", "source_site": "pydantic"}
{"title": "BaseValidateHandlerProtocol.on_success", "anchor": "basevalidatehandlerprotocol-on_success", "heading_level": 0, "md_text": "Callback to be notified of successful validation.\n\nArgs:\n    result: The result of the validation.", "url": "https://docs.pydantic.dev/latest/api/on-success/", "page": "pydantic/plugin/__init__", "source_site": "pydantic"}
{"title": "BaseValidateHandlerProtocol.on_error", "anchor": "basevalidatehandlerprotocol-on_error", "heading_level": 0, "md_text": "Callback to be notified of validation errors.\n\nArgs:\n    error: The validation error.", "url": "https://docs.pydantic.dev/latest/api/on-error/", "page": "pydantic/plugin/__init__", "source_site": "pydantic"}
{"title": "BaseValidateHandlerProtocol.on_exception", "anchor": "basevalidatehandlerprotocol-on_exception", "heading_level": 0, "md_text": "Callback to be notified of validation exceptions.\n\nArgs:\n    exception: The exception raised during validation.", "url": "https://docs.pydantic.dev/latest/api/on-exception/", "page": "pydantic/plugin/__init__", "source_site": "pydantic"}
{"title": "ValidatePythonHandlerProtocol.on_enter", "anchor": "validatepythonhandlerprotocol-on_enter", "heading_level": 0, "md_text": "Callback to be notified of validation start, and create an instance of the event handler.\n\nArgs:\n    input: The input to be validated.\n    strict: Whether to validate the object in strict mode.\n    extra: Whether to ignore, allow, or forbid extra data during model validation.\n    from_attributes: Whether to validate objects as inputs by extracting attributes.\n    context: The context to use for validation, this is passed to functional validators.\n    self_instance: An instance of a model to set attributes on from validation, this is used when running\n        validation from the `__init__` method of a model.\n    by_alias: Whether to use the field's alias to match the input data to an attribute.\n    by_name: Whether to use the field's name to match the input data to an attribute.", "url": "https://docs.pydantic.dev/latest/api/on-enter/", "page": "pydantic/plugin/__init__", "source_site": "pydantic"}
{"title": "ValidateJsonHandlerProtocol.on_enter", "anchor": "validatejsonhandlerprotocol-on_enter", "heading_level": 0, "md_text": "Callback to be notified of validation start, and create an instance of the event handler.\n\nArgs:\n    input: The JSON data to be validated.\n    strict: Whether to validate the object in strict mode.\n    extra: Whether to ignore, allow, or forbid extra data during model validation.\n    context: The context to use for validation, this is passed to functional validators.\n    self_instance: An instance of a model to set attributes on from validation, this is used when running\n        validation from the `__init__` method of a model.\n    by_alias: Whether to use the field's alias to match the input data to an attribute.\n    by_name: Whether to use the field's name to match the input data to an attribute.", "url": "https://docs.pydantic.dev/latest/api/on-enter/", "page": "pydantic/plugin/__init__", "source_site": "pydantic"}
{"title": "ValidateStringsHandlerProtocol.on_enter", "anchor": "validatestringshandlerprotocol-on_enter", "heading_level": 0, "md_text": "Callback to be notified of validation start, and create an instance of the event handler.\n\nArgs:\n    input: The string data to be validated.\n    strict: Whether to validate the object in strict mode.\n    extra: Whether to ignore, allow, or forbid extra data during model validation.\n    context: The context to use for validation, this is passed to functional validators.\n    by_alias: Whether to use the field's alias to match the input data to an attribute.\n    by_name: Whether to use the field's name to match the input data to an attribute.", "url": "https://docs.pydantic.dev/latest/api/on-enter/", "page": "pydantic/plugin/__init__", "source_site": "pydantic"}
{"title": "get_plugins", "anchor": "get_plugins", "heading_level": 0, "md_text": "Load plugins for Pydantic.\n\nInspired by: https://github.com/pytest-dev/pluggy/blob/1.3.0/src/pluggy/_manager.py#L376-L402", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/plugin/_loader", "source_site": "pydantic"}
{"title": "_schema_validator", "anchor": "_schema_validator", "heading_level": 0, "md_text": "Pluggable schema validator for pydantic.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/plugin/_schema_validator", "source_site": "pydantic"}
{"title": "create_schema_validator", "anchor": "create_schema_validator", "heading_level": 0, "md_text": "Create a `SchemaValidator` or `PluggableSchemaValidator` if plugins are installed.\n\nReturns:\n    If plugins are installed then return `PluggableSchemaValidator`, otherwise return `SchemaValidator`.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/plugin/_schema_validator", "source_site": "pydantic"}
{"title": "PluggableSchemaValidator", "anchor": "pluggableschemavalidator", "heading_level": 0, "md_text": "Pluggable schema validator.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/plugin/_schema_validator", "source_site": "pydantic"}
{"title": "filter_handlers", "anchor": "filter_handlers", "heading_level": 0, "md_text": "Filter out handler methods which are not implemented by the plugin directly - e.g. are missing\nor are inherited from the protocol.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/plugin/_schema_validator", "source_site": "pydantic"}
{"title": "__init__", "anchor": "__init__", "heading_level": 0, "md_text": "The \"experimental\" module of pydantic contains potential new features that are subject to change.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/experimental/__init__", "source_site": "pydantic"}
{"title": "missing_sentinel", "anchor": "missing_sentinel", "heading_level": 0, "md_text": "Experimental module exposing a function a `MISSING` sentinel.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/experimental/missing_sentinel", "source_site": "pydantic"}
{"title": "pipeline", "anchor": "pipeline", "heading_level": 0, "md_text": "Experimental pipeline API functionality. Be careful with this API, it's subject to change.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/experimental/pipeline", "source_site": "pydantic"}
{"title": "_Pipeline", "anchor": "_pipeline", "heading_level": 0, "md_text": "Abstract representation of a chain of validation, transformation, and parsing steps.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/experimental/pipeline", "source_site": "pydantic"}
{"title": "_apply_constraint", "anchor": "_apply_constraint", "heading_level": 0, "md_text": "Apply a single constraint to a schema.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/experimental/pipeline", "source_site": "pydantic"}
{"title": "_Pipeline.transform", "anchor": "_pipeline-transform", "heading_level": 0, "md_text": "Transform the output of the previous step.\n\nIf used as the first step in a pipeline, the type of the field is used.\nThat is, the transformation is applied to after the value is parsed to the field's type.", "url": "https://docs.pydantic.dev/latest/api/transform/", "page": "pydantic/experimental/pipeline", "source_site": "pydantic"}
{"title": "_Pipeline.validate_as", "anchor": "_pipeline-validate_as", "heading_level": 0, "md_text": "Validate / parse the input into a new type.\n\nIf no type is provided, the type of the field is used.\n\nTypes are parsed in Pydantic's `lax` mode by default,\nbut you can enable `strict` mode by passing `strict=True`.", "url": "https://docs.pydantic.dev/latest/api/validate-as/", "page": "pydantic/experimental/pipeline", "source_site": "pydantic"}
{"title": "_Pipeline.validate_as_deferred", "anchor": "_pipeline-validate_as_deferred", "heading_level": 0, "md_text": "Parse the input into a new type, deferring resolution of the type until the current class\nis fully defined.\n\nThis is useful when you need to reference the class in it's own type annotations.", "url": "https://docs.pydantic.dev/latest/api/validate-as-deferred/", "page": "pydantic/experimental/pipeline", "source_site": "pydantic"}
{"title": "_Pipeline.constrain", "anchor": "_pipeline-constrain", "heading_level": 0, "md_text": "Constrain a value to meet a certain condition.\n\nWe support most conditions from `annotated_types`, as well as regular expressions.\n\nMost of the time you'll be calling a shortcut method like `gt`, `lt`, `len`, etc\nso you don't need to call this directly.", "url": "https://docs.pydantic.dev/latest/api/constrain/", "page": "pydantic/experimental/pipeline", "source_site": "pydantic"}
{"title": "_Pipeline.predicate", "anchor": "_pipeline-predicate", "heading_level": 0, "md_text": "Constrain a value to meet a certain predicate.", "url": "https://docs.pydantic.dev/latest/api/predicate/", "page": "pydantic/experimental/pipeline", "source_site": "pydantic"}
{"title": "_Pipeline.gt", "anchor": "_pipeline-gt", "heading_level": 0, "md_text": "Constrain a value to be greater than a certain value.", "url": "https://docs.pydantic.dev/latest/api/gt/", "page": "pydantic/experimental/pipeline", "source_site": "pydantic"}
{"title": "_Pipeline.lt", "anchor": "_pipeline-lt", "heading_level": 0, "md_text": "Constrain a value to be less than a certain value.", "url": "https://docs.pydantic.dev/latest/api/lt/", "page": "pydantic/experimental/pipeline", "source_site": "pydantic"}
{"title": "_Pipeline.ge", "anchor": "_pipeline-ge", "heading_level": 0, "md_text": "Constrain a value to be greater than or equal to a certain value.", "url": "https://docs.pydantic.dev/latest/api/ge/", "page": "pydantic/experimental/pipeline", "source_site": "pydantic"}
{"title": "_Pipeline.le", "anchor": "_pipeline-le", "heading_level": 0, "md_text": "Constrain a value to be less than or equal to a certain value.", "url": "https://docs.pydantic.dev/latest/api/le/", "page": "pydantic/experimental/pipeline", "source_site": "pydantic"}
{"title": "_Pipeline.len", "anchor": "_pipeline-len", "heading_level": 0, "md_text": "Constrain a value to have a certain length.", "url": "https://docs.pydantic.dev/latest/api/len/", "page": "pydantic/experimental/pipeline", "source_site": "pydantic"}
{"title": "_Pipeline.multiple_of", "anchor": "_pipeline-multiple_of", "heading_level": 0, "md_text": "Constrain a value to be a multiple of a certain number.", "url": "https://docs.pydantic.dev/latest/api/multiple-of/", "page": "pydantic/experimental/pipeline", "source_site": "pydantic"}
{"title": "_Pipeline.eq", "anchor": "_pipeline-eq", "heading_level": 0, "md_text": "Constrain a value to be equal to a certain value.", "url": "https://docs.pydantic.dev/latest/api/eq/", "page": "pydantic/experimental/pipeline", "source_site": "pydantic"}
{"title": "_Pipeline.not_eq", "anchor": "_pipeline-not_eq", "heading_level": 0, "md_text": "Constrain a value to not be equal to a certain value.", "url": "https://docs.pydantic.dev/latest/api/not-eq/", "page": "pydantic/experimental/pipeline", "source_site": "pydantic"}
{"title": "_Pipeline.in_", "anchor": "_pipeline-in_", "heading_level": 0, "md_text": "Constrain a value to be in a certain set.", "url": "https://docs.pydantic.dev/latest/api/in-/", "page": "pydantic/experimental/pipeline", "source_site": "pydantic"}
{"title": "_Pipeline.not_in", "anchor": "_pipeline-not_in", "heading_level": 0, "md_text": "Constrain a value to not be in a certain set.", "url": "https://docs.pydantic.dev/latest/api/not-in/", "page": "pydantic/experimental/pipeline", "source_site": "pydantic"}
{"title": "_Pipeline.otherwise", "anchor": "_pipeline-otherwise", "heading_level": 0, "md_text": "Combine two validation chains, returning the result of the first chain if it succeeds, and the second chain if it fails.", "url": "https://docs.pydantic.dev/latest/api/otherwise/", "page": "pydantic/experimental/pipeline", "source_site": "pydantic"}
{"title": "_Pipeline.then", "anchor": "_pipeline-then", "heading_level": 0, "md_text": "Pipe the result of one validation chain into another.", "url": "https://docs.pydantic.dev/latest/api/then/", "page": "pydantic/experimental/pipeline", "source_site": "pydantic"}
{"title": "arguments_schema", "anchor": "arguments_schema", "heading_level": 0, "md_text": "Experimental module exposing a function to generate a core schema that validates callable arguments.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/experimental/arguments_schema", "source_site": "pydantic"}
{"title": "generate_arguments_schema", "anchor": "generate_arguments_schema", "heading_level": 0, "md_text": "Generate the schema for the arguments of a function.\n\nArgs:\n    func: The function to generate the schema for.\n    schema_type: The type of schema to generate.\n    parameters_callback: A callable that will be invoked for each parameter. The callback\n        should take three required arguments: the index, the name and the type annotation\n        (or [`Parameter.empty`][inspect.Parameter.empty] if not annotated) of the parameter.\n        The callback can optionally return `'skip'`, so that the parameter gets excluded\n        from the resulting schema.\n    config: The configuration to use.\n\nReturns:\n    The generated schema.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/experimental/arguments_schema", "source_site": "pydantic"}
{"title": "validate_arguments", "anchor": "validate_arguments", "heading_level": 0, "md_text": "Decorator to validate the arguments passed to a function.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/deprecated/decorator", "source_site": "pydantic"}
{"title": "schema_of", "anchor": "schema_of", "heading_level": 0, "md_text": "Generate a JSON schema (as dict) for the passed model or dynamically generated one.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/deprecated/tools", "source_site": "pydantic"}
{"title": "schema_json_of", "anchor": "schema_json_of", "heading_level": 0, "md_text": "Generate a JSON schema (as JSON) for the passed model or dynamically generated one.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/deprecated/tools", "source_site": "pydantic"}
{"title": "class_validators", "anchor": "class_validators", "heading_level": 0, "md_text": "Old `@validator` and `@root_validator` function validators from V1.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/deprecated/class_validators", "source_site": "pydantic"}
{"title": "validator", "anchor": "validator", "heading_level": 0, "md_text": "Decorate methods on the class indicating that they should be used to validate fields.\n\nArgs:\n    __field (str): The first field the validator should be called on; this is separate\n        from `fields` to ensure an error is raised if you don't pass at least one.\n    *fields (str): Additional field(s) the validator should be called on.\n    pre (bool, optional): Whether this validator should be called before the standard\n        validators (else after). Defaults to False.\n    each_item (bool, optional): For complex objects (sets, lists etc.) whether to validate\n        individual elements rather than the whole object. Defaults to False.\n    always (bool, optional): Whether this method and other validators should be called even if\n        the value is missing. Defaults to False.\n    check_fields (bool | None, optional): Whether to check that the fields actually exist on the model.\n        Defaults to None.\n    allow_reuse (bool, optional): Whether to track and raise an error if another validator refers to\n        the decorated function. Defaults to False.\n\nReturns:\n    Callable: A decorator that can be used to decorate a\n        function to be used as a validator.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/deprecated/class_validators", "source_site": "pydantic"}
{"title": "root_validator", "anchor": "root_validator", "heading_level": 0, "md_text": "Decorate methods on a model indicating that they should be used to validate (and perhaps\nmodify) data either before or after standard model parsing/validation is performed.\n\nArgs:\n    pre (bool, optional): Whether this validator should be called before the standard\n        validators (else after). Defaults to False.\n    skip_on_failure (bool, optional): Whether to stop validation and return as soon as a\n        failure is encountered. Defaults to False.\n    allow_reuse (bool, optional): Whether to track and raise an error if another validator\n        refers to the decorated function. Defaults to False.\n\nReturns:\n    Any: A decorator that can be used to decorate a function to be used as a root_validator.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/deprecated/class_validators", "source_site": "pydantic"}
{"title": "BaseConfig", "anchor": "baseconfig", "heading_level": 0, "md_text": "This class is only retained for backwards compatibility.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/deprecated/config", "source_site": "pydantic"}
{"title": "decimal_encoder", "anchor": "decimal_encoder", "heading_level": 0, "md_text": "Encodes a Decimal as int of there's no exponent, otherwise float.\n\nThis is useful when we use ConstrainedDecimal to represent Numeric(x,0)\nwhere a integer (but not int typed) is used. Encoding this as a float\nresults in failed round-tripping between encode and parse.\nOur Id type is a prime example of this.\n\n>>> decimal_encoder(Decimal(\"1.0\"))\n1.0\n\n>>> decimal_encoder(Decimal(\"1\"))\n1", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/deprecated/json", "source_site": "pydantic"}
{"title": "timedelta_isoformat", "anchor": "timedelta_isoformat", "heading_level": 0, "md_text": "ISO 8601 encoding for Python timedelta object.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/deprecated/json", "source_site": "pydantic"}
{"title": "create_generic_submodel", "anchor": "create_generic_submodel", "heading_level": 0, "md_text": "Dynamically create a submodel of a provided (generic) BaseModel.\n\nThis is used when producing concrete parametrizations of generic models. This function\nonly *creates* the new subclass; the schema/validators/serialization must be updated to\nreflect a concrete parametrization elsewhere.\n\nArgs:\n    model_name: The name of the newly created model.\n    origin: The base class for the new model to inherit from.\n    args: A tuple of generic metadata arguments.\n    params: A tuple of generic metadata parameters.\n\nReturns:\n    The created submodel.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_generics", "source_site": "pydantic"}
{"title": "_get_caller_frame_info", "anchor": "_get_caller_frame_info", "heading_level": 0, "md_text": "Used inside a function to check whether it was called globally.\n\nArgs:\n    depth: The depth to get the frame.\n\nReturns:\n    A tuple contains `module_name` and `called_globally`.\n\nRaises:\n    RuntimeError: If the function is not called inside a function.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_generics", "source_site": "pydantic"}
{"title": "iter_contained_typevars", "anchor": "iter_contained_typevars", "heading_level": 0, "md_text": "Recursively iterate through all subtypes and type args of `v` and yield any typevars that are found.\n\nThis is inspired as an alternative to directly accessing the `__parameters__` attribute of a GenericAlias,\nsince __parameters__ of (nested) generic BaseModel subclasses won't show up in that list.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_generics", "source_site": "pydantic"}
{"title": "get_standard_typevars_map", "anchor": "get_standard_typevars_map", "heading_level": 0, "md_text": "Package a generic type's typevars and parametrization (if present) into a dictionary compatible with the\n`replace_types` function. Specifically, this works with standard typing generics and typing._GenericAlias.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_generics", "source_site": "pydantic"}
{"title": "get_model_typevars_map", "anchor": "get_model_typevars_map", "heading_level": 0, "md_text": "Package a generic BaseModel's typevars and concrete parametrization (if present) into a dictionary compatible\nwith the `replace_types` function.\n\nSince BaseModel.__class_getitem__ does not produce a typing._GenericAlias, and the BaseModel generic info is\nstored in the __pydantic_generic_metadata__ attribute, we need special handling here.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_generics", "source_site": "pydantic"}
{"title": "replace_types", "anchor": "replace_types", "heading_level": 0, "md_text": "Return type with all occurrences of `type_map` keys recursively replaced with their values.\n\nArgs:\n    type_: The class or generic alias.\n    type_map: Mapping from `TypeVar` instance to concrete types.\n\nReturns:\n    A new type representing the basic structure of `type_` with all\n    `typevar_map` keys recursively replaced.\n\nExample:\n    ```python\n    from typing import Union\n\n    from pydantic._internal._generics import replace_types\n\n    replace_types(tuple[str, Union[list[str], float]], {str: int})\n    #> tuple[int, Union[list[int], float]]\n    ```", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_generics", "source_site": "pydantic"}
{"title": "map_generic_model_arguments", "anchor": "map_generic_model_arguments", "heading_level": 0, "md_text": "Return a mapping between the parameters of a generic model and the provided arguments during parameterization.\n\nRaises:\n    TypeError: If the number of arguments does not match the parameters (i.e. if providing too few or too many arguments).\n\nExample:\n    ```python {test=\"skip\" lint=\"skip\"}\n    class Model[T, U, V = int](BaseModel): ...\n\n    map_generic_model_arguments(Model, (str, bytes))\n    #> {T: str, U: bytes, V: int}\n\n    map_generic_model_arguments(Model, (str,))\n    #> TypeError: Too few arguments for <class '__main__.Model'>; actual 1, expected at least 2\n\n    map_generic_model_arguments(Model, (str, bytes, int, complex))\n    #> TypeError: Too many arguments for <class '__main__.Model'>; actual 4, expected 3\n    ```\n\nNote:\n    This function is analogous to the private `typing._check_generic_specialization` function.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_generics", "source_site": "pydantic"}
{"title": "generic_recursion_self_type", "anchor": "generic_recursion_self_type", "heading_level": 0, "md_text": "This contextmanager should be placed around the recursive calls used to build a generic type,\nand accept as arguments the generic origin type and the type arguments being passed to it.\n\nIf the same origin and arguments are observed twice, it implies that a self-reference placeholder\ncan be used while building the core schema, and will produce a schema_ref that will be valid in the\nfinal parent schema.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_generics", "source_site": "pydantic"}
{"title": "get_cached_generic_type_early", "anchor": "get_cached_generic_type_early", "heading_level": 0, "md_text": "The use of a two-stage cache lookup approach was necessary to have the highest performance possible for\nrepeated calls to `__class_getitem__` on generic types (which may happen in tighter loops during runtime),\nwhile still ensuring that certain alternative parametrizations ultimately resolve to the same type.\n\nAs a concrete example, this approach was necessary to make Model[List[T]][int] equal to Model[List[int]].\nThe approach could be modified to not use two different cache keys at different points, but the\n_early_cache_key is optimized to be as quick to compute as possible (for repeated-access speed), and the\n_late_cache_key is optimized to be as \"correct\" as possible, so that two types that will ultimately be the\nsame after resolving the type arguments will always produce cache hits.\n\nIf we wanted to move to only using a single cache key per type, we would either need to always use the\nslower/more computationally intensive logic associated with _late_cache_key, or would need to accept\nthat Model[List[T]][int] is a different type than Model[List[T]][int]. Because we rely on subclass relationships\nduring validation, I think it is worthwhile to ensure that types that are functionally equivalent are actually\nequal.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_generics", "source_site": "pydantic"}
{"title": "get_cached_generic_type_late", "anchor": "get_cached_generic_type_late", "heading_level": 0, "md_text": "See the docstring of `get_cached_generic_type_early` for more information about the two-stage cache lookup.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_generics", "source_site": "pydantic"}
{"title": "set_cached_generic_type", "anchor": "set_cached_generic_type", "heading_level": 0, "md_text": "See the docstring of `get_cached_generic_type_early` for more information about why items are cached with\ntwo different keys.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_generics", "source_site": "pydantic"}
{"title": "_union_orderings_key", "anchor": "_union_orderings_key", "heading_level": 0, "md_text": "This is intended to help differentiate between Union types with the same arguments in different order.\n\nThanks to caching internal to the `typing` module, it is not possible to distinguish between\nList[Union[int, float]] and List[Union[float, int]] (and similarly for other \"parent\" origins besides List)\nbecause `typing` considers Union[int, float] to be equal to Union[float, int].\n\nHowever, you _can_ distinguish between (top-level) Union[int, float] vs. Union[float, int].\nBecause we parse items as the first Union type that is successful, we get slightly more consistent behavior\nif we make an effort to distinguish the ordering of items in a union. It would be best if we could _always_\nget the exact-correct order of items in the union, but that would require a change to the `typing` module itself.\n(See https://github.com/python/cpython/issues/86483 for reference.)", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_generics", "source_site": "pydantic"}
{"title": "_early_cache_key", "anchor": "_early_cache_key", "heading_level": 0, "md_text": "This is intended for minimal computational overhead during lookups of cached types.\n\nNote that this is overly simplistic, and it's possible that two different cls/typevar_values\ninputs would ultimately result in the same type being created in BaseModel.__class_getitem__.\nTo handle this, we have a fallback _late_cache_key that is checked later if the _early_cache_key\nlookup fails, and should result in a cache hit _precisely_ when the inputs to __class_getitem__\nwould result in the same type.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_generics", "source_site": "pydantic"}
{"title": "_late_cache_key", "anchor": "_late_cache_key", "heading_level": 0, "md_text": "This is intended for use later in the process of creating a new type, when we have more information\nabout the exact args that will be passed. If it turns out that a different set of inputs to\n__class_getitem__ resulted in the same inputs to the generic type creation process, we can still\nreturn the cached type, and update the cache with the _early_cache_key as well.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_generics", "source_site": "pydantic"}
{"title": "DeepChainMap", "anchor": "deepchainmap", "heading_level": 0, "md_text": "Variant of ChainMap that allows direct updates to inner scopes.\n\nTaken from https://docs.python.org/3/library/collections.html#collections.ChainMap,\nwith some light modifications for this use case.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_generics", "source_site": "pydantic"}
{"title": "_dataclasses", "anchor": "_dataclasses", "heading_level": 0, "md_text": "Private logic for creating pydantic dataclasses.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_dataclasses", "source_site": "pydantic"}
{"title": "set_dataclass_fields", "anchor": "set_dataclass_fields", "heading_level": 0, "md_text": "Collect and set `cls.__pydantic_fields__`.\n\nArgs:\n    cls: The class.\n    config_wrapper: The config wrapper instance.\n    ns_resolver: Namespace resolver to use when getting dataclass annotations.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_dataclasses", "source_site": "pydantic"}
{"title": "complete_dataclass", "anchor": "complete_dataclass", "heading_level": 0, "md_text": "Finish building a pydantic dataclass.\n\nThis logic is called on a class which has already been wrapped in `dataclasses.dataclass()`.\n\nThis is somewhat analogous to `pydantic._internal._model_construction.complete_model_class`.\n\nArgs:\n    cls: The class.\n    config_wrapper: The config wrapper instance.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    ns_resolver: The namespace resolver instance to use when collecting dataclass fields\n        and during schema building.\n    _force_build: Whether to force building the dataclass, no matter if\n        [`defer_build`][pydantic.config.ConfigDict.defer_build] is set.\n\nReturns:\n    `True` if building a pydantic dataclass is successfully completed, `False` otherwise.\n\nRaises:\n    PydanticUndefinedAnnotation: If `raise_error` is `True` and there is an undefined annotations.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_dataclasses", "source_site": "pydantic"}
{"title": "is_stdlib_dataclass", "anchor": "is_stdlib_dataclass", "heading_level": 0, "md_text": "Returns `True` if the class is a stdlib dataclass and *not* a Pydantic dataclass.\n\nUnlike the stdlib `dataclasses.is_dataclass()` function, this does *not* include subclasses\nof a dataclass that are themselves not dataclasses.\n\nArgs:\n    cls: The class.\n\nReturns:\n    `True` if the class is a stdlib dataclass, `False` otherwise.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_dataclasses", "source_site": "pydantic"}
{"title": "patch_base_fields", "anchor": "patch_base_fields", "heading_level": 0, "md_text": "Temporarily patch the stdlib dataclasses bases of `cls` if the Pydantic `Field()` function is used.\n\nWhen creating a Pydantic dataclass, it is possible to inherit from stdlib dataclasses, where\nthe Pydantic `Field()` function is used. To create this Pydantic dataclass, we first apply\nthe stdlib `@dataclass` decorator on it. During the construction of the stdlib dataclass,\nthe `kw_only` and `repr` field arguments need to be understood by the stdlib *during* the\ndataclass construction. To do so, we temporarily patch the fields dictionary of the affected\nbases.\n\nFor instance, with the following example:\n\n```python {test=\"skip\" lint=\"skip\"}\nimport dataclasses as stdlib_dc\n\nimport pydantic\nimport pydantic.dataclasses as pydantic_dc\n\n@stdlib_dc.dataclass\nclass A:\n    a: int = pydantic.Field(repr=False)\n\n# Notice that the `repr` attribute of the dataclass field is `True`:\nA.__dataclass_fields__['a']\n#> dataclass.Field(default=FieldInfo(repr=False), repr=True, ...)\n\n@pydantic_dc.dataclass\nclass B(A):\n    b: int = pydantic.Field(repr=False)\n```\n\nWhen passing `B` to the stdlib `@dataclass` decorator, it will look for fields in the parent classes\nand reuse them directly. When this context manager is active, `A` will be temporarily patched to be\nequivalent to:\n\n```python {test=\"skip\" lint=\"skip\"}\n@stdlib_dc.dataclass\nclass A:\n    a: int = stdlib_dc.field(default=Field(repr=False), repr=False)\n```", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_dataclasses", "source_site": "pydantic"}
{"title": "PydanticDataclass", "anchor": "pydanticdataclass", "heading_level": 0, "md_text": "A protocol containing attributes only available once a class has been decorated as a Pydantic dataclass.\n\nAttributes:\n    __pydantic_config__: Pydantic-specific configuration settings for the dataclass.\n    __pydantic_complete__: Whether dataclass building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The pydantic-core schema used to build the SchemaValidator and SchemaSerializer.\n    __pydantic_decorators__: Metadata containing the decorators defined on the dataclass.\n    __pydantic_fields__: Metadata about the fields defined on the dataclass.\n    __pydantic_serializer__: The pydantic-core SchemaSerializer used to dump instances of the dataclass.\n    __pydantic_validator__: The pydantic-core SchemaValidator used to validate instances of the dataclass.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_dataclasses", "source_site": "pydantic"}
{"title": "_generate_schema", "anchor": "_generate_schema", "heading_level": 0, "md_text": "Convert python types to pydantic-core schema.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_generate_schema", "source_site": "pydantic"}
{"title": "check_validator_fields_against_field_name", "anchor": "check_validator_fields_against_field_name", "heading_level": 0, "md_text": "Check if field name is in validator fields.\n\nArgs:\n    info: The field info.\n    field: The field name to check.\n\nReturns:\n    `True` if field name is in validator fields, `False` otherwise.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_generate_schema", "source_site": "pydantic"}
{"title": "check_decorator_fields_exist", "anchor": "check_decorator_fields_exist", "heading_level": 0, "md_text": "Check if the defined fields in decorators exist in `fields` param.\n\nIt ignores the check for a decorator if the decorator has `*` as field or `check_fields=False`.\n\nArgs:\n    decorators: An iterable of decorators.\n    fields: An iterable of fields name.\n\nRaises:\n    PydanticUserError: If one of the field names does not exist in `fields` param.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_generate_schema", "source_site": "pydantic"}
{"title": "_add_custom_serialization_from_json_encoders", "anchor": "_add_custom_serialization_from_json_encoders", "heading_level": 0, "md_text": "Iterate over the json_encoders and add the first matching encoder to the schema.\n\nArgs:\n    json_encoders: A dictionary of types and their encoder functions.\n    tp: The type to check for a matching encoder.\n    schema: The schema to add the encoder to.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_generate_schema", "source_site": "pydantic"}
{"title": "InvalidSchemaError", "anchor": "invalidschemaerror", "heading_level": 0, "md_text": "The core schema is invalid.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_generate_schema", "source_site": "pydantic"}
{"title": "GenerateSchema", "anchor": "generateschema", "heading_level": 0, "md_text": "Generate core schema for a Pydantic model, dataclass and types like `str`, `datetime`, ... .", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_generate_schema", "source_site": "pydantic"}
{"title": "apply_validators", "anchor": "apply_validators", "heading_level": 0, "md_text": "Apply validators to a schema.\n\nArgs:\n    schema: The schema to apply validators on.\n    validators: An iterable of validators.\n    field_name: The name of the field if validators are being applied to a model field.\n\nReturns:\n    The updated schema.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_generate_schema", "source_site": "pydantic"}
{"title": "_validators_require_validate_default", "anchor": "_validators_require_validate_default", "heading_level": 0, "md_text": "In v1, if any of the validators for a field had `always=True`, the default value would be validated.\n\nThis serves as an auxiliary function for re-implementing that logic, by looping over a provided\ncollection of (v1-style) ValidatorDecoratorInfo's and checking if any of them have `always=True`.\n\nWe should be able to drop this function and the associated logic calling it once we drop support\nfor v1-style validator decorators. (Or we can extend it and keep it if we add something equivalent\nto the v1-validator `always` kwarg to `field_validator`.)", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_generate_schema", "source_site": "pydantic"}
{"title": "apply_model_validators", "anchor": "apply_model_validators", "heading_level": 0, "md_text": "Apply model validators to a schema.\n\nIf mode == 'inner', only \"before\" validators are applied\nIf mode == 'outer', validators other than \"before\" are applied\nIf mode == 'all', all validators are applied\n\nArgs:\n    schema: The schema to apply validators on.\n    validators: An iterable of validators.\n    mode: The validator mode.\n\nReturns:\n    The updated schema.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_generate_schema", "source_site": "pydantic"}
{"title": "wrap_default", "anchor": "wrap_default", "heading_level": 0, "md_text": "Wrap schema with default schema if default value or `default_factory` are available.\n\nArgs:\n    field_info: The field info object.\n    schema: The schema to apply default on.\n\nReturns:\n    Updated schema by default value or `default_factory`.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_generate_schema", "source_site": "pydantic"}
{"title": "_extract_get_pydantic_json_schema", "anchor": "_extract_get_pydantic_json_schema", "heading_level": 0, "md_text": "Extract `__get_pydantic_json_schema__` from a type, handling the deprecated `__modify_schema__`.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_generate_schema", "source_site": "pydantic"}
{"title": "_inlining_behavior", "anchor": "_inlining_behavior", "heading_level": 0, "md_text": "Determine the inlining behavior of the `'definition-ref'` schema.\n\n- If no `'serialization'` schema and no metadata is attached, the schema can safely be inlined.\n- If it has metadata but only related to the deferred discriminator application, it can be inlined\n  provided that such metadata is kept.\n- Otherwise, the schema should not be inlined. Doing so would remove the `'serialization'` schema or metadata.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_generate_schema", "source_site": "pydantic"}
{"title": "_Definitions", "anchor": "_definitions", "heading_level": 0, "md_text": "Keeps track of references and definitions.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_generate_schema", "source_site": "pydantic"}
{"title": "GenerateSchema._fraction_schema", "anchor": "generateschema-_fraction_schema", "heading_level": 0, "md_text": "Support for [`fractions.Fraction`][fractions.Fraction].", "url": "https://docs.pydantic.dev/latest/api/-fraction-schema/", "page": "pydantic/_internal/_generate_schema", "source_site": "pydantic"}
{"title": "GenerateSchema.generate_schema", "anchor": "generateschema-generate_schema", "heading_level": 0, "md_text": "Generate core schema.\n\nArgs:\n    obj: The object to generate core schema for.\n\nReturns:\n    The generated core schema.\n\nRaises:\n    PydanticUndefinedAnnotation:\n        If it is not possible to evaluate forward reference.\n    PydanticSchemaGenerationError:\n        If it is not possible to generate pydantic-core schema.\n    TypeError:\n        - If `alias_generator` returns a disallowed type (must be str, AliasPath or AliasChoices).\n        - If V1 style validator with `each_item=True` applied on a wrong field.\n    PydanticUserError:\n        - If `typing.TypedDict` is used instead of `typing_extensions.TypedDict` on Python < 3.12.\n        - If `__modify_schema__` method is used instead of `__get_pydantic_json_schema__`.", "url": "https://docs.pydantic.dev/latest/api/generate-schema/", "page": "pydantic/_internal/_generate_schema", "source_site": "pydantic"}
{"title": "GenerateSchema._model_schema", "anchor": "generateschema-_model_schema", "heading_level": 0, "md_text": "Generate schema for a Pydantic model.", "url": "https://docs.pydantic.dev/latest/api/-model-schema/", "page": "pydantic/_internal/_generate_schema", "source_site": "pydantic"}
{"title": "GenerateSchema.match_type", "anchor": "generateschema-match_type", "heading_level": 0, "md_text": "Main mapping of types to schemas.\n\nThe general structure is a series of if statements starting with the simple cases\n(non-generic primitive types) and then handling generics and other more complex cases.\n\nEach case either generates a schema directly, calls into a public user-overridable method\n(like `GenerateSchema.tuple_variable_schema`) or calls into a private method that handles some\nboilerplate before calling into the user-facing method (e.g. `GenerateSchema._tuple_schema`).\n\nThe idea is that we'll evolve this into adding more and more user facing methods over time\nas they get requested and we figure out what the right API for them is.", "url": "https://docs.pydantic.dev/latest/api/match-type/", "page": "pydantic/_internal/_generate_schema", "source_site": "pydantic"}
{"title": "GenerateSchema._generate_td_field_schema", "anchor": "generateschema-_generate_td_field_schema", "heading_level": 0, "md_text": "Prepare a TypedDictField to represent a model or typeddict field.", "url": "https://docs.pydantic.dev/latest/api/-generate-td-field-schema/", "page": "pydantic/_internal/_generate_schema", "source_site": "pydantic"}
{"title": "GenerateSchema._generate_md_field_schema", "anchor": "generateschema-_generate_md_field_schema", "heading_level": 0, "md_text": "Prepare a ModelField to represent a model field.", "url": "https://docs.pydantic.dev/latest/api/-generate-md-field-schema/", "page": "pydantic/_internal/_generate_schema", "source_site": "pydantic"}
{"title": "GenerateSchema._generate_dc_field_schema", "anchor": "generateschema-_generate_dc_field_schema", "heading_level": 0, "md_text": "Prepare a DataclassField to represent the parameter/field, of a dataclass.", "url": "https://docs.pydantic.dev/latest/api/-generate-dc-field-schema/", "page": "pydantic/_internal/_generate_schema", "source_site": "pydantic"}
{"title": "GenerateSchema._union_schema", "anchor": "generateschema-_union_schema", "heading_level": 0, "md_text": "Generate schema for a Union.", "url": "https://docs.pydantic.dev/latest/api/-union-schema/", "page": "pydantic/_internal/_generate_schema", "source_site": "pydantic"}
{"title": "GenerateSchema._literal_schema", "anchor": "generateschema-_literal_schema", "heading_level": 0, "md_text": "Generate schema for a Literal.", "url": "https://docs.pydantic.dev/latest/api/-literal-schema/", "page": "pydantic/_internal/_generate_schema", "source_site": "pydantic"}
{"title": "GenerateSchema._typed_dict_schema", "anchor": "generateschema-_typed_dict_schema", "heading_level": 0, "md_text": "Generate a core schema for a `TypedDict` class.\n\nTo be able to build a `DecoratorInfos` instance for the `TypedDict` class (which will include\nvalidators, serializers, etc.), we need to have access to the original bases of the class\n(see https://docs.python.org/3/library/types.html#types.get_original_bases).\nHowever, the `__orig_bases__` attribute was only added in 3.12 (https://github.com/python/cpython/pull/103698).\n\nFor this reason, we require Python 3.12 (or using the `typing_extensions` backport).", "url": "https://docs.pydantic.dev/latest/api/-typed-dict-schema/", "page": "pydantic/_internal/_generate_schema", "source_site": "pydantic"}
{"title": "GenerateSchema._namedtuple_schema", "anchor": "generateschema-_namedtuple_schema", "heading_level": 0, "md_text": "Generate schema for a NamedTuple.", "url": "https://docs.pydantic.dev/latest/api/-namedtuple-schema/", "page": "pydantic/_internal/_generate_schema", "source_site": "pydantic"}
{"title": "GenerateSchema._generate_parameter_schema", "anchor": "generateschema-_generate_parameter_schema", "heading_level": 0, "md_text": "Generate the definition of a field in a namedtuple or a parameter in a function signature.\n\nThis definition is meant to be used for the `'arguments'` core schema, which will be replaced\nin V3 by the `'arguments-v3`'.", "url": "https://docs.pydantic.dev/latest/api/-generate-parameter-schema/", "page": "pydantic/_internal/_generate_schema", "source_site": "pydantic"}
{"title": "GenerateSchema._generate_parameter_v3_schema", "anchor": "generateschema-_generate_parameter_v3_schema", "heading_level": 0, "md_text": "Generate the definition of a parameter in a function signature.\n\nThis definition is meant to be used for the `'arguments-v3'` core schema, which will replace\nthe `'arguments`' schema in V3.", "url": "https://docs.pydantic.dev/latest/api/-generate-parameter-v3-schema/", "page": "pydantic/_internal/_generate_schema", "source_site": "pydantic"}
{"title": "GenerateSchema._tuple_schema", "anchor": "generateschema-_tuple_schema", "heading_level": 0, "md_text": "Generate schema for a Tuple, e.g. `tuple[int, str]` or `tuple[int, ...]`.", "url": "https://docs.pydantic.dev/latest/api/-tuple-schema/", "page": "pydantic/_internal/_generate_schema", "source_site": "pydantic"}
{"title": "GenerateSchema._zoneinfo_schema", "anchor": "generateschema-_zoneinfo_schema", "heading_level": 0, "md_text": "Generate schema for a zone_info.ZoneInfo object", "url": "https://docs.pydantic.dev/latest/api/-zoneinfo-schema/", "page": "pydantic/_internal/_generate_schema", "source_site": "pydantic"}
{"title": "GenerateSchema._union_is_subclass_schema", "anchor": "generateschema-_union_is_subclass_schema", "heading_level": 0, "md_text": "Generate schema for `type[Union[X, ...]]`.", "url": "https://docs.pydantic.dev/latest/api/-union-is-subclass-schema/", "page": "pydantic/_internal/_generate_schema", "source_site": "pydantic"}
{"title": "GenerateSchema._subclass_schema", "anchor": "generateschema-_subclass_schema", "heading_level": 0, "md_text": "Generate schema for a type, e.g. `type[int]`.", "url": "https://docs.pydantic.dev/latest/api/-subclass-schema/", "page": "pydantic/_internal/_generate_schema", "source_site": "pydantic"}
{"title": "GenerateSchema._sequence_schema", "anchor": "generateschema-_sequence_schema", "heading_level": 0, "md_text": "Generate schema for a Sequence, e.g. `Sequence[int]`.", "url": "https://docs.pydantic.dev/latest/api/-sequence-schema/", "page": "pydantic/_internal/_generate_schema", "source_site": "pydantic"}
{"title": "GenerateSchema._iterable_schema", "anchor": "generateschema-_iterable_schema", "heading_level": 0, "md_text": "Generate a schema for an `Iterable`.", "url": "https://docs.pydantic.dev/latest/api/-iterable-schema/", "page": "pydantic/_internal/_generate_schema", "source_site": "pydantic"}
{"title": "GenerateSchema._dataclass_schema", "anchor": "generateschema-_dataclass_schema", "heading_level": 0, "md_text": "Generate schema for a dataclass.", "url": "https://docs.pydantic.dev/latest/api/-dataclass-schema/", "page": "pydantic/_internal/_generate_schema", "source_site": "pydantic"}
{"title": "GenerateSchema._call_schema", "anchor": "generateschema-_call_schema", "heading_level": 0, "md_text": "Generate schema for a Callable.\n\nTODO support functional validators once we support them in Config", "url": "https://docs.pydantic.dev/latest/api/-call-schema/", "page": "pydantic/_internal/_generate_schema", "source_site": "pydantic"}
{"title": "GenerateSchema._arguments_schema", "anchor": "generateschema-_arguments_schema", "heading_level": 0, "md_text": "Generate schema for a Signature.", "url": "https://docs.pydantic.dev/latest/api/-arguments-schema/", "page": "pydantic/_internal/_generate_schema", "source_site": "pydantic"}
{"title": "GenerateSchema._annotated_schema", "anchor": "generateschema-_annotated_schema", "heading_level": 0, "md_text": "Generate schema for an Annotated type, e.g. `Annotated[int, Field(...)]` or `Annotated[int, Gt(0)]`.", "url": "https://docs.pydantic.dev/latest/api/-annotated-schema/", "page": "pydantic/_internal/_generate_schema", "source_site": "pydantic"}
{"title": "GenerateSchema._apply_annotations", "anchor": "generateschema-_apply_annotations", "heading_level": 0, "md_text": "Apply arguments from `Annotated` or from `FieldInfo` to a schema.\n\nThis gets called by `GenerateSchema._annotated_schema` but differs from it in that it does\nnot expect `source_type` to be an `Annotated` object, it expects it to be  the first argument of that\n(in other words, `GenerateSchema._annotated_schema` just unpacks `Annotated`, this process it).", "url": "https://docs.pydantic.dev/latest/api/-apply-annotations/", "page": "pydantic/_internal/_generate_schema", "source_site": "pydantic"}
{"title": "GenerateSchema._get_unsupported_field_info_attributes", "anchor": "generateschema-_get_unsupported_field_info_attributes", "heading_level": 0, "md_text": "Get the list of unsupported `FieldInfo` attributes when not directly used in `Annotated` for field annotations.", "url": "https://docs.pydantic.dev/latest/api/-get-unsupported-field-info-attributes/", "page": "pydantic/_internal/_generate_schema", "source_site": "pydantic"}
{"title": "GenerateSchema._apply_field_serializers", "anchor": "generateschema-_apply_field_serializers", "heading_level": 0, "md_text": "Apply field serializers to a schema.", "url": "https://docs.pydantic.dev/latest/api/-apply-field-serializers/", "page": "pydantic/_internal/_generate_schema", "source_site": "pydantic"}
{"title": "GenerateSchema._apply_model_serializers", "anchor": "generateschema-_apply_model_serializers", "heading_level": 0, "md_text": "Apply model serializers to a schema.", "url": "https://docs.pydantic.dev/latest/api/-apply-model-serializers/", "page": "pydantic/_internal/_generate_schema", "source_site": "pydantic"}
{"title": "_Definitions.get_schema_or_ref", "anchor": "_definitions-get_schema_or_ref", "heading_level": 0, "md_text": "Get a definition for `tp` if one exists.\n\nIf a definition exists, a tuple of `(ref_string, CoreSchema)` is returned.\nIf no definition exists yet, a tuple of `(ref_string, None)` is returned.\n\nNote that the returned `CoreSchema` will always be a `DefinitionReferenceSchema`,\nnot the actual definition itself.\n\nThis should be called for any type that can be identified by reference.\nThis includes any recursive types.\n\nAt present the following types can be named/recursive:\n\n- Pydantic model\n- Pydantic and stdlib dataclasses\n- Typed dictionaries\n- Named tuples\n- `TypeAliasType` instances\n- Enums", "url": "https://docs.pydantic.dev/latest/api/get-schema-or-ref/", "page": "pydantic/_internal/_generate_schema", "source_site": "pydantic"}
{"title": "_Definitions.get_schema_from_ref", "anchor": "_definitions-get_schema_from_ref", "heading_level": 0, "md_text": "Resolve the schema from the given reference.", "url": "https://docs.pydantic.dev/latest/api/get-schema-from-ref/", "page": "pydantic/_internal/_generate_schema", "source_site": "pydantic"}
{"title": "_Definitions.create_definition_reference_schema", "anchor": "_definitions-create_definition_reference_schema", "heading_level": 0, "md_text": "Store the schema as a definition and return a `'definition-reference'` schema pointing to it.\n\nThe schema must have a reference attached to it.", "url": "https://docs.pydantic.dev/latest/api/create-definition-reference-schema/", "page": "pydantic/_internal/_generate_schema", "source_site": "pydantic"}
{"title": "_Definitions.unpack_definitions", "anchor": "_definitions-unpack_definitions", "heading_level": 0, "md_text": "Store the definitions of the `'definitions'` core schema and return the inner core schema.", "url": "https://docs.pydantic.dev/latest/api/unpack-definitions/", "page": "pydantic/_internal/_generate_schema", "source_site": "pydantic"}
{"title": "_Definitions.finalize_schema", "anchor": "_definitions-finalize_schema", "heading_level": 0, "md_text": "Finalize the core schema.\n\nThis traverses the core schema and referenced definitions, replaces `'definition-ref'` schemas\nby the referenced definition if possible, and applies deferred discriminators.", "url": "https://docs.pydantic.dev/latest/api/finalize-schema/", "page": "pydantic/_internal/_generate_schema", "source_site": "pydantic"}
{"title": "extract_function_name", "anchor": "extract_function_name", "heading_level": 0, "md_text": "Extract the name of a `ValidateCallSupportedTypes` object.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_validate_call", "source_site": "pydantic"}
{"title": "extract_function_qualname", "anchor": "extract_function_qualname", "heading_level": 0, "md_text": "Extract the qualname of a `ValidateCallSupportedTypes` object.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_validate_call", "source_site": "pydantic"}
{"title": "update_wrapper_attributes", "anchor": "update_wrapper_attributes", "heading_level": 0, "md_text": "Update the `wrapper` function with the attributes of the `wrapped` function. Return the updated function.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_validate_call", "source_site": "pydantic"}
{"title": "ValidateCallWrapper", "anchor": "validatecallwrapper", "heading_level": 0, "md_text": "This is a wrapper around a function that validates the arguments passed to it, and optionally the return value.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_validate_call", "source_site": "pydantic"}
{"title": "CoreMetadata", "anchor": "coremetadata", "heading_level": 0, "md_text": "A `TypedDict` for holding the metadata dict of the schema.\n\nAttributes:\n    pydantic_js_functions: List of JSON schema functions that resolve refs during application.\n    pydantic_js_annotation_functions: List of JSON schema functions that don't resolve refs during application.\n    pydantic_js_prefer_positional_arguments: Whether JSON schema generator will\n        prefer positional over keyword arguments for an 'arguments' schema.\n        custom validation function. Only applies to before, plain, and wrap validators.\n    pydantic_js_updates: key / value pair updates to apply to the JSON schema for a type.\n    pydantic_js_extra: WIP, either key/value pair updates to apply to the JSON schema, or a custom callable.\n    pydantic_internal_union_tag_key: Used internally by the `Tag` metadata to specify the tag used for a discriminated union.\n    pydantic_internal_union_discriminator: Used internally to specify the discriminator value for a discriminated union\n        when the discriminator was applied to a `'definition-ref'` schema, and that reference was missing at the time\n        of the annotation application.\n\nTODO: Perhaps we should move this structure to pydantic-core. At the moment, though,\nit's easier to iterate on if we leave it in pydantic until we feel there is a semi-stable API.\n\nTODO: It's unfortunate how functionally oriented JSON schema generation is, especially that which occurs during\nthe core schema generation process. It's inevitable that we need to store some json schema related information\non core schemas, given that we generate JSON schemas directly from core schemas. That being said, debugging related\nissues is quite difficult when JSON schema information is disguised via dynamically defined functions.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_core_metadata", "source_site": "pydantic"}
{"title": "PydanticRecursiveRef.__call__", "anchor": "pydanticrecursiveref-__call__", "heading_level": 0, "md_text": "Defining __call__ is necessary for the `typing` module to let you use an instance of\nthis class as the result of resolving a standard ForwardRef.", "url": "https://docs.pydantic.dev/latest/api/--call--/", "page": "pydantic/_internal/_forward_ref", "source_site": "pydantic"}
{"title": "_field_name_for_signature", "anchor": "_field_name_for_signature", "heading_level": 0, "md_text": "Extract the correct name to use for the field when generating a signature.\n\nAssuming the field has a valid alias, this will return the alias. Otherwise, it will return the field name.\nFirst priority is given to the alias, then the validation_alias, then the field name.\n\nArgs:\n    field_name: The name of the field\n    field_info: The corresponding FieldInfo object.\n\nReturns:\n    The correct name to use when generating a signature.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_signature", "source_site": "pydantic"}
{"title": "_process_param_defaults", "anchor": "_process_param_defaults", "heading_level": 0, "md_text": "Modify the signature for a parameter in a dataclass where the default value is a FieldInfo instance.\n\nArgs:\n    param (Parameter): The parameter\n\nReturns:\n    Parameter: The custom processed parameter", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_signature", "source_site": "pydantic"}
{"title": "_generate_signature_parameters", "anchor": "_generate_signature_parameters", "heading_level": 0, "md_text": "Generate a mapping of parameter names to Parameter objects for a pydantic BaseModel or dataclass.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_signature", "source_site": "pydantic"}
{"title": "generate_pydantic_signature", "anchor": "generate_pydantic_signature", "heading_level": 0, "md_text": "Generate signature for a pydantic BaseModel or dataclass.\n\nArgs:\n    init: The class init.\n    fields: The model fields.\n    validate_by_name: The `validate_by_name` value of the config.\n    extra: The `extra` value of the config.\n    is_dataclass: Whether the model is a dataclass.\n\nReturns:\n    The dataclass/BaseModel subclass signature.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_signature", "source_site": "pydantic"}
{"title": "ConfigWrapper", "anchor": "configwrapper", "heading_level": 0, "md_text": "Internal wrapper for Config which exposes ConfigDict items as attributes.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_config", "source_site": "pydantic"}
{"title": "ConfigWrapperStack", "anchor": "configwrapperstack", "heading_level": 0, "md_text": "A stack of `ConfigWrapper` instances.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_config", "source_site": "pydantic"}
{"title": "prepare_config", "anchor": "prepare_config", "heading_level": 0, "md_text": "Create a `ConfigDict` instance from an existing dict, a class (e.g. old class-based config) or None.\n\nArgs:\n    config: The input config.\n\nReturns:\n    A ConfigDict object created from config.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_config", "source_site": "pydantic"}
{"title": "check_deprecated", "anchor": "check_deprecated", "heading_level": 0, "md_text": "Check for deprecated config keys and warn the user.\n\nArgs:\n    config_dict: The input config.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_config", "source_site": "pydantic"}
{"title": "ConfigWrapper.for_model", "anchor": "configwrapper-for_model", "heading_level": 0, "md_text": "Build a new `ConfigWrapper` instance for a `BaseModel`.\n\nThe config wrapper built based on (in descending order of priority):\n- options from `kwargs`\n- options from the `namespace`\n- options from the base classes (`bases`)\n\nArgs:\n    bases: A tuple of base classes.\n    namespace: The namespace of the class being created.\n    raw_annotations: The (non-evaluated) annotations of the model.\n    kwargs: The kwargs passed to the class being created.\n\nReturns:\n    A `ConfigWrapper` instance for `BaseModel`.", "url": "https://docs.pydantic.dev/latest/api/for-model/", "page": "pydantic/_internal/_config", "source_site": "pydantic"}
{"title": "ConfigWrapper.core_config", "anchor": "configwrapper-core_config", "heading_level": 0, "md_text": "Create a pydantic-core config.\n\nWe don't use getattr here since we don't want to populate with defaults.\n\nArgs:\n    title: The title to use if not set in config.\n\nReturns:\n    A `CoreConfig` object created from config.", "url": "https://docs.pydantic.dev/latest/api/core-config/", "page": "pydantic/_internal/_config", "source_site": "pydantic"}
{"title": "expand_grouped_metadata", "anchor": "expand_grouped_metadata", "heading_level": 0, "md_text": "Expand the annotations.\n\nArgs:\n    annotations: An iterable of annotations.\n\nReturns:\n    An iterable of expanded annotations.\n\nExample:\n    ```python\n    from annotated_types import Ge, Len\n\n    from pydantic._internal._known_annotated_metadata import expand_grouped_metadata\n\n    print(list(expand_grouped_metadata([Ge(4), Len(5)])))\n    #> [Ge(ge=4), MinLen(min_length=5)]\n    ```", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_known_annotated_metadata", "source_site": "pydantic"}
{"title": "_get_at_to_constraint_map", "anchor": "_get_at_to_constraint_map", "heading_level": 0, "md_text": "Return a mapping of annotated types to constraints.\n\nNormally, we would define a mapping like this in the module scope, but we can't do that\nbecause we don't permit module level imports of `annotated_types`, in an attempt to speed up\nthe import time of `pydantic`. We still only want to have this dictionary defined in one place,\nso we use this function to cache the result.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_known_annotated_metadata", "source_site": "pydantic"}
{"title": "apply_known_metadata", "anchor": "apply_known_metadata", "heading_level": 0, "md_text": "Apply `annotation` to `schema` if it is an annotation we know about (Gt, Le, etc.).\nOtherwise return `None`.\n\nThis does not handle all known annotations. If / when it does, it can always\nreturn a CoreSchema and return the unmodified schema if the annotation should be ignored.\n\nAssumes that GroupedMetadata has already been expanded via `expand_grouped_metadata`.\n\nArgs:\n    annotation: The annotation.\n    schema: The schema.\n\nReturns:\n    An updated schema with annotation if it is an annotation we know about, `None` otherwise.\n\nRaises:\n    RuntimeError: If a constraint can't be applied to a specific schema type.\n    ValueError: If an unknown constraint is encountered.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_known_annotated_metadata", "source_site": "pydantic"}
{"title": "collect_known_metadata", "anchor": "collect_known_metadata", "heading_level": 0, "md_text": "Split `annotations` into known metadata and unknown annotations.\n\nArgs:\n    annotations: An iterable of annotations.\n\nReturns:\n    A tuple contains a dict of known metadata and a list of unknown annotations.\n\nExample:\n    ```python\n    from annotated_types import Gt, Len\n\n    from pydantic._internal._known_annotated_metadata import collect_known_metadata\n\n    print(collect_known_metadata([Gt(1), Len(42), ...]))\n    #> ({'gt': 1, 'min_length': 42}, [Ellipsis])\n    ```", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_known_annotated_metadata", "source_site": "pydantic"}
{"title": "check_metadata", "anchor": "check_metadata", "heading_level": 0, "md_text": "A small utility function to validate that the given metadata can be applied to the target.\nMore than saving lines of code, this gives us a consistent error message for all of our internal implementations.\n\nArgs:\n    metadata: A dict of metadata.\n    allowed: An iterable of allowed metadata.\n    source_type: The source type.\n\nRaises:\n    TypeError: If there is metadatas that can't be applied on source type.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_known_annotated_metadata", "source_site": "pydantic"}
{"title": "_git", "anchor": "_git", "heading_level": 0, "md_text": "Git utilities, adopted from mypy's git utilities (https://github.com/python/mypy/blob/master/mypy/git.py).", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_git", "source_site": "pydantic"}
{"title": "is_git_repo", "anchor": "is_git_repo", "heading_level": 0, "md_text": "Is the given directory version-controlled with git?", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_git", "source_site": "pydantic"}
{"title": "have_git", "anchor": "have_git", "heading_level": 0, "md_text": "Can we run the git executable?", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_git", "source_site": "pydantic"}
{"title": "git_revision", "anchor": "git_revision", "heading_level": 0, "md_text": "Get the SHA-1 of the HEAD of a git repository.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_git", "source_site": "pydantic"}
{"title": "_schema_generation_shared", "anchor": "_schema_generation_shared", "heading_level": 0, "md_text": "Types and utility functions used by various other internal tools.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_schema_generation_shared", "source_site": "pydantic"}
{"title": "GenerateJsonSchemaHandler", "anchor": "generatejsonschemahandler", "heading_level": 0, "md_text": "JsonSchemaHandler implementation that doesn't do ref unwrapping by default.\n\nThis is used for any Annotated metadata so that we don't end up with conflicting\nmodifications to the definition schema.\n\nUsed internally by Pydantic, please do not rely on this implementation.\nSee `GetJsonSchemaHandler` for the handler API.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_schema_generation_shared", "source_site": "pydantic"}
{"title": "CallbackGetCoreSchemaHandler", "anchor": "callbackgetcoreschemahandler", "heading_level": 0, "md_text": "Wrapper to use an arbitrary function as a `GetCoreSchemaHandler`.\n\nUsed internally by Pydantic, please do not rely on this implementation.\nSee `GetCoreSchemaHandler` for the handler API.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_schema_generation_shared", "source_site": "pydantic"}
{"title": "GenerateJsonSchemaHandler.resolve_ref_schema", "anchor": "generatejsonschemahandler-resolve_ref_schema", "heading_level": 0, "md_text": "Resolves `$ref` in the json schema.\n\nThis returns the input json schema if there is no `$ref` in json schema.\n\nArgs:\n    maybe_ref_json_schema: The input json schema that may contains `$ref`.\n\nReturns:\n    Resolved json schema.\n\nRaises:\n    LookupError: If it can't find the definition for `$ref`.", "url": "https://docs.pydantic.dev/latest/api/resolve-ref-schema/", "page": "pydantic/_internal/_schema_generation_shared", "source_site": "pydantic"}
{"title": "CallbackGetCoreSchemaHandler.resolve_ref_schema", "anchor": "callbackgetcoreschemahandler-resolve_ref_schema", "heading_level": 0, "md_text": "Resolves reference in the core schema.\n\nArgs:\n    maybe_ref_schema: The input core schema that may contains reference.\n\nReturns:\n    Resolved core schema.\n\nRaises:\n    LookupError: If it can't find the definition for reference.", "url": "https://docs.pydantic.dev/latest/api/resolve-ref-schema/", "page": "pydantic/_internal/_schema_generation_shared", "source_site": "pydantic"}
{"title": "_utils", "anchor": "_utils", "heading_level": 0, "md_text": "Bucket of reusable internal utilities.\n\nThis should be reduced as much as possible with functions only used in one place, moved to that place.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_utils", "source_site": "pydantic"}
{"title": "can_be_positional", "anchor": "can_be_positional", "heading_level": 0, "md_text": "Return whether the parameter accepts a positional argument.\n\n```python {test=\"skip\" lint=\"skip\"}\ndef func(a, /, b, *, c):\n    pass\n\nparams = inspect.signature(func).parameters\ncan_be_positional(params['a'])\n#> True\ncan_be_positional(params['b'])\n#> True\ncan_be_positional(params['c'])\n#> False\n```", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_utils", "source_site": "pydantic"}
{"title": "is_model_class", "anchor": "is_model_class", "heading_level": 0, "md_text": "Returns true if cls is a _proper_ subclass of BaseModel, and provides proper type-checking,\nunlike raw calls to lenient_issubclass.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_utils", "source_site": "pydantic"}
{"title": "is_valid_identifier", "anchor": "is_valid_identifier", "heading_level": 0, "md_text": "Checks that a string is a valid identifier and not a Python keyword.\n:param identifier: The identifier to test.\n:return: True if the identifier is valid.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_utils", "source_site": "pydantic"}
{"title": "unique_list", "anchor": "unique_list", "heading_level": 0, "md_text": "Make a list unique while maintaining order.\nWe update the list if another one with the same name is set\n(e.g. model validator overridden in subclass).", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_utils", "source_site": "pydantic"}
{"title": "ValueItems", "anchor": "valueitems", "heading_level": 0, "md_text": "Class for more convenient calculation of excluded or included fields on values.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_utils", "source_site": "pydantic"}
{"title": "smart_deepcopy", "anchor": "smart_deepcopy", "heading_level": 0, "md_text": "Return type as is for immutable built-in types\nUse obj.copy() for built-in empty collections\nUse copy.deepcopy() for non-empty collections and unknown objects.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_utils", "source_site": "pydantic"}
{"title": "all_identical", "anchor": "all_identical", "heading_level": 0, "md_text": "Check that the items of `left` are the same objects as those in `right`.\n\n>>> a, b = object(), object()\n>>> all_identical([a, b, a], [a, b, a])\nTrue\n>>> all_identical([a, b, [a]], [a, b, [a]])  # new list object, while \"equal\" is not \"identical\"\nFalse", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_utils", "source_site": "pydantic"}
{"title": "get_first_not_none", "anchor": "get_first_not_none", "heading_level": 0, "md_text": "Return the first argument if it is not `None`, otherwise return the second argument.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_utils", "source_site": "pydantic"}
{"title": "SafeGetItemProxy", "anchor": "safegetitemproxy", "heading_level": 0, "md_text": "Wrapper redirecting `__getitem__` to `get` with a sentinel value as default\n\nThis makes is safe to use in `operator.itemgetter` when some keys may be missing", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_utils", "source_site": "pydantic"}
{"title": "deprecated_instance_property", "anchor": "deprecated_instance_property", "heading_level": 0, "md_text": "A decorator exposing the decorated class method as a property, with a warning on instance access.\n\nThis decorator takes a class method defined on the `BaseModel` class and transforms it into\nan attribute. The attribute can be accessed on both the class and instances of the class. If accessed\nvia an instance, a deprecation warning is emitted stating that instance access will be removed in V3.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_utils", "source_site": "pydantic"}
{"title": "ValueItems.is_excluded", "anchor": "valueitems-is_excluded", "heading_level": 0, "md_text": "Check if item is fully excluded.\n\n:param item: key or index of a value", "url": "https://docs.pydantic.dev/latest/api/is-excluded/", "page": "pydantic/_internal/_utils", "source_site": "pydantic"}
{"title": "ValueItems.is_included", "anchor": "valueitems-is_included", "heading_level": 0, "md_text": "Check if value is contained in self._items.\n\n:param item: key or index of value", "url": "https://docs.pydantic.dev/latest/api/is-included/", "page": "pydantic/_internal/_utils", "source_site": "pydantic"}
{"title": "ValueItems.for_element", "anchor": "valueitems-for_element", "heading_level": 0, "md_text": ":param e: key or index of element on value\n:return: raw values for element if self._items is dict and contain needed element", "url": "https://docs.pydantic.dev/latest/api/for-element/", "page": "pydantic/_internal/_utils", "source_site": "pydantic"}
{"title": "ValueItems._normalize_indexes", "anchor": "valueitems-_normalize_indexes", "heading_level": 0, "md_text": ":param items: dict or set of indexes which will be normalized\n:param v_length: length of sequence indexes of which will be\n\n>>> self._normalize_indexes({0: True, -2: True, -1: True}, 4)\n{0: True, 2: True, 3: True}\n>>> self._normalize_indexes({'__all__': True}, 4)\n{0: True, 1: True, 2: True, 3: True}", "url": "https://docs.pydantic.dev/latest/api/-normalize-indexes/", "page": "pydantic/_internal/_utils", "source_site": "pydantic"}
{"title": "ValueItems.merge", "anchor": "valueitems-merge", "heading_level": 0, "md_text": "Merge a `base` item with an `override` item.\n\nBoth `base` and `override` are converted to dictionaries if possible.\nSets are converted to dictionaries with the sets entries as keys and\nEllipsis as values.\n\nEach key-value pair existing in `base` is merged with `override`,\nwhile the rest of the key-value pairs are updated recursively with this function.\n\nMerging takes place based on the \"union\" of keys if `intersect` is\nset to `False` (default) and on the intersection of keys if\n`intersect` is set to `True`.", "url": "https://docs.pydantic.dev/latest/api/merge/", "page": "pydantic/_internal/_utils", "source_site": "pydantic"}
{"title": "LazyClassAttribute", "anchor": "lazyclassattribute", "heading_level": 0, "md_text": "A descriptor exposing an attribute only accessible on a class (hidden from instances).\n\nThe attribute is lazily computed and cached during the first access.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_utils", "source_site": "pydantic"}
{"title": "_validators", "anchor": "_validators", "heading_level": 0, "md_text": "Validator functions for standard library types.\n\nImport of this module is deferred since it contains imports of many standard library modules.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_validators", "source_site": "pydantic"}
{"title": "sequence_validator", "anchor": "sequence_validator", "heading_level": 0, "md_text": "Validator for `Sequence` types, isinstance(v, Sequence) has already been called.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_validators", "source_site": "pydantic"}
{"title": "_import_string_logic", "anchor": "_import_string_logic", "heading_level": 0, "md_text": "Inspired by uvicorn \u2014 dotted paths should include a colon before the final item if that item is not a module.\n(This is necessary to distinguish between a submodule and an attribute when there is a conflict.).\n\nIf the dotted path does not include a colon and the final item is not a valid module, importing as an attribute\nrather than a submodule will be attempted automatically.\n\nSo, for example, the following values of `dotted_path` result in the following returned values:\n* 'collections': <module 'collections'>\n* 'collections.abc': <module 'collections.abc'>\n* 'collections.abc:Mapping': <class 'collections.abc.Mapping'>\n* `collections.abc.Mapping`: <class 'collections.abc.Mapping'> (though this is a bit slower than the previous line)\n\nAn error will be raised under any of the following scenarios:\n* `dotted_path` contains more than one colon (e.g., 'collections:abc:Mapping')\n* the substring of `dotted_path` before the colon is not a valid module in the environment (e.g., '123:Mapping')\n* the substring of `dotted_path` after the colon is not an attribute of the module (e.g., 'collections:abc123')", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_validators", "source_site": "pydantic"}
{"title": "ip_v4_network_validator", "anchor": "ip_v4_network_validator", "heading_level": 0, "md_text": "Assume IPv4Network initialised with a default `strict` argument.\n\nSee more:\nhttps://docs.python.org/library/ipaddress.html#ipaddress.IPv4Network", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_validators", "source_site": "pydantic"}
{"title": "ip_v6_network_validator", "anchor": "ip_v6_network_validator", "heading_level": 0, "md_text": "Assume IPv6Network initialised with a default `strict` argument.\n\nSee more:\nhttps://docs.python.org/library/ipaddress.html#ipaddress.IPv6Network", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_validators", "source_site": "pydantic"}
{"title": "_safe_repr", "anchor": "_safe_repr", "heading_level": 0, "md_text": "The context argument for `PydanticKnownError` requires a number or str type, so we do a simple repr() coercion for types like timedelta.\n\nSee tests/test_types.py::test_annotated_metadata_any_order for some context.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_validators", "source_site": "pydantic"}
{"title": "_extract_decimal_digits_info", "anchor": "_extract_decimal_digits_info", "heading_level": 0, "md_text": "Compute the total number of digits and decimal places for a given [`Decimal`][decimal.Decimal] instance.\n\nThis function handles both normalized and non-normalized Decimal instances.\nExample: Decimal('1.230') -> 4 digits, 3 decimal places\n\nArgs:\n    decimal (Decimal): The decimal number to analyze.\n\nReturns:\n    tuple[int, int]: A tuple containing the number of decimal places and total digits.\n\nThough this could be divided into two separate functions, the logic is easier to follow if we couple the computation\nof the number of decimals and digits together.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_validators", "source_site": "pydantic"}
{"title": "MissingDefinitionForUnionRef", "anchor": "missingdefinitionforunionref", "heading_level": 0, "md_text": "Raised when applying a discriminated union discriminator to a schema\nrequires a definition that is not yet defined", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_discriminated_union", "source_site": "pydantic"}
{"title": "apply_discriminator", "anchor": "apply_discriminator", "heading_level": 0, "md_text": "Applies the discriminator and returns a new core schema.\n\nArgs:\n    schema: The input schema.\n    discriminator: The name of the field which will serve as the discriminator.\n    definitions: A mapping of schema ref to schema.\n\nReturns:\n    The new core schema.\n\nRaises:\n    TypeError:\n        - If `discriminator` is used with invalid union variant.\n        - If `discriminator` is used with `Union` type with one variant.\n        - If `discriminator` value mapped to multiple choices.\n    MissingDefinitionForUnionRef:\n        If the definition for ref is missing.\n    PydanticUserError:\n        - If a model in union doesn't have a discriminator field.\n        - If discriminator field has a non-string alias.\n        - If discriminator fields have different aliases.\n        - If discriminator field not of type `Literal`.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_discriminated_union", "source_site": "pydantic"}
{"title": "_ApplyInferredDiscriminator", "anchor": "_applyinferreddiscriminator", "heading_level": 0, "md_text": "This class is used to convert an input schema containing a union schema into one where that union is\nreplaced with a tagged-union, with all the associated debugging and performance benefits.\n\nThis is done by:\n* Validating that the input schema is compatible with the provided discriminator\n* Introspecting the schema to determine which discriminator values should map to which union choices\n* Handling various edge cases such as 'definitions', 'default', 'nullable' schemas, and more\n\nI have chosen to implement the conversion algorithm in this class, rather than a function,\nto make it easier to maintain state while recursively walking the provided CoreSchema.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_discriminated_union", "source_site": "pydantic"}
{"title": "_ApplyInferredDiscriminator.apply", "anchor": "_applyinferreddiscriminator-apply", "heading_level": 0, "md_text": "Return a new CoreSchema based on `schema` that uses a tagged-union with the discriminator provided\nto this class.\n\nArgs:\n    schema: The input schema.\n\nReturns:\n    The new core schema.\n\nRaises:\n    TypeError:\n        - If `discriminator` is used with invalid union variant.\n        - If `discriminator` is used with `Union` type with one variant.\n        - If `discriminator` value mapped to multiple choices.\n    ValueError:\n        If the definition for ref is missing.\n    PydanticUserError:\n        - If a model in union doesn't have a discriminator field.\n        - If discriminator field has a non-string alias.\n        - If discriminator fields have different aliases.\n        - If discriminator field not of type `Literal`.", "url": "https://docs.pydantic.dev/latest/api/apply/", "page": "pydantic/_internal/_discriminated_union", "source_site": "pydantic"}
{"title": "_ApplyInferredDiscriminator._apply_to_root", "anchor": "_applyinferreddiscriminator-_apply_to_root", "heading_level": 0, "md_text": "This method handles the outer-most stage of recursion over the input schema:\nunwrapping nullable or definitions schemas, and calling the `_handle_choice`\nmethod iteratively on the choices extracted (recursively) from the possibly-wrapped union.", "url": "https://docs.pydantic.dev/latest/api/-apply-to-root/", "page": "pydantic/_internal/_discriminated_union", "source_site": "pydantic"}
{"title": "_ApplyInferredDiscriminator._handle_choice", "anchor": "_applyinferreddiscriminator-_handle_choice", "heading_level": 0, "md_text": "This method handles the \"middle\" stage of recursion over the input schema.\nSpecifically, it is responsible for handling each choice of the outermost union\n(and any \"coalesced\" choices obtained from inner unions).\n\nHere, \"handling\" entails:\n* Coalescing nested unions and compatible tagged-unions\n* Tracking the presence of 'none' and 'nullable' schemas occurring as choices\n* Validating that each allowed discriminator value maps to a unique choice\n* Updating the _tagged_union_choices mapping that will ultimately be used to build the TaggedUnionSchema.", "url": "https://docs.pydantic.dev/latest/api/-handle-choice/", "page": "pydantic/_internal/_discriminated_union", "source_site": "pydantic"}
{"title": "_ApplyInferredDiscriminator._is_discriminator_shared", "anchor": "_applyinferreddiscriminator-_is_discriminator_shared", "heading_level": 0, "md_text": "This method returns a boolean indicating whether the discriminator for the `choice`\nis the same as that being used for the outermost tagged union. This is used to\ndetermine whether this TaggedUnionSchema choice should be \"coalesced\" into the top level,\nor whether it should be treated as a separate (nested) choice.", "url": "https://docs.pydantic.dev/latest/api/-is-discriminator-shared/", "page": "pydantic/_internal/_discriminated_union", "source_site": "pydantic"}
{"title": "_ApplyInferredDiscriminator._infer_discriminator_values_for_choice", "anchor": "_applyinferreddiscriminator-_infer_discriminator_values_for_choice", "heading_level": 0, "md_text": "This function recurses over `choice`, extracting all discriminator values that should map to this choice.\n\n`model_name` is accepted for the purpose of producing useful error messages.", "url": "https://docs.pydantic.dev/latest/api/-infer-discriminator-values-for-choice/", "page": "pydantic/_internal/_discriminated_union", "source_site": "pydantic"}
{"title": "_ApplyInferredDiscriminator._infer_discriminator_values_for_typed_dict_choice", "anchor": "_applyinferreddiscriminator-_infer_discriminator_values_for_typed_dict_choice", "heading_level": 0, "md_text": "This method just extracts the _infer_discriminator_values_for_choice logic specific to TypedDictSchema\nfor the sake of readability.", "url": "https://docs.pydantic.dev/latest/api/-infer-discriminator-values-for-typed-dict-choice/", "page": "pydantic/_internal/_discriminated_union", "source_site": "pydantic"}
{"title": "_ApplyInferredDiscriminator._infer_discriminator_values_for_inner_schema", "anchor": "_applyinferreddiscriminator-_infer_discriminator_values_for_inner_schema", "heading_level": 0, "md_text": "When inferring discriminator values for a field, we typically extract the expected values from a literal\nschema. This function does that, but also handles nested unions and defaults.", "url": "https://docs.pydantic.dev/latest/api/-infer-discriminator-values-for-inner-schema/", "page": "pydantic/_internal/_discriminated_union", "source_site": "pydantic"}
{"title": "_ApplyInferredDiscriminator._set_unique_choice_for_values", "anchor": "_applyinferreddiscriminator-_set_unique_choice_for_values", "heading_level": 0, "md_text": "This method updates `self.tagged_union_choices` so that all provided (discriminator) `values` map to the\nprovided `choice`, validating that none of these values already map to another (different) choice.", "url": "https://docs.pydantic.dev/latest/api/-set-unique-choice-for-values/", "page": "pydantic/_internal/_discriminated_union", "source_site": "pydantic"}
{"title": "_repr", "anchor": "_repr", "heading_level": 0, "md_text": "Tools to provide pretty/human-readable display of objects.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_repr", "source_site": "pydantic"}
{"title": "PlainRepr", "anchor": "plainrepr", "heading_level": 0, "md_text": "String class where repr doesn't include quotes. Useful with Representation when you want to return a string\nrepresentation of something that is valid (or pseudo-valid) python.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_repr", "source_site": "pydantic"}
{"title": "display_as_type", "anchor": "display_as_type", "heading_level": 0, "md_text": "Pretty representation of a type, should be as close as possible to the original type definition string.\n\nTakes some logic from `typing._type_repr`.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_repr", "source_site": "pydantic"}
{"title": "Representation.__repr_args__", "anchor": "representation-__repr_args__", "heading_level": 0, "md_text": "Returns the attributes to show in __str__, __repr__, and __pretty__ this is generally overridden.\n\nCan either return:\n* name - value pairs, e.g.: `[('foo_name', 'foo'), ('bar_name', ['b', 'a', 'r'])]`\n* or, just values, e.g.: `[(None, 'foo'), (None, ['b', 'a', 'r'])]`", "url": "https://docs.pydantic.dev/latest/api/--repr-args--/", "page": "pydantic/_internal/_repr", "source_site": "pydantic"}
{"title": "Representation.__repr_name__", "anchor": "representation-__repr_name__", "heading_level": 0, "md_text": "Name of the instance's class, used in __repr__.", "url": "https://docs.pydantic.dev/latest/api/--repr-name--/", "page": "pydantic/_internal/_repr", "source_site": "pydantic"}
{"title": "Representation.__repr_recursion__", "anchor": "representation-__repr_recursion__", "heading_level": 0, "md_text": "Returns the string representation of a recursive object.", "url": "https://docs.pydantic.dev/latest/api/--repr-recursion--/", "page": "pydantic/_internal/_repr", "source_site": "pydantic"}
{"title": "Representation.__pretty__", "anchor": "representation-__pretty__", "heading_level": 0, "md_text": "Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.", "url": "https://docs.pydantic.dev/latest/api/--pretty--/", "page": "pydantic/_internal/_repr", "source_site": "pydantic"}
{"title": "Representation.__rich_repr__", "anchor": "representation-__rich_repr__", "heading_level": 0, "md_text": "Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.", "url": "https://docs.pydantic.dev/latest/api/--rich-repr--/", "page": "pydantic/_internal/_repr", "source_site": "pydantic"}
{"title": "_decorators", "anchor": "_decorators", "heading_level": 0, "md_text": "Logic related to validators applied to models etc. via the `@field_validator` and `@model_validator` decorators.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_decorators", "source_site": "pydantic"}
{"title": "ValidatorDecoratorInfo", "anchor": "validatordecoratorinfo", "heading_level": 0, "md_text": "A container for data from `@validator` so that we can access it\nwhile building the pydantic-core schema.\n\nAttributes:\n    decorator_repr: A class variable representing the decorator string, '@validator'.\n    fields: A tuple of field names the validator should be called on.\n    mode: The proposed validator mode.\n    each_item: For complex objects (sets, lists etc.) whether to validate individual\n        elements rather than the whole object.\n    always: Whether this method and other validators should be called even if the value is missing.\n    check_fields: Whether to check that the fields actually exist on the model.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_decorators", "source_site": "pydantic"}
{"title": "FieldValidatorDecoratorInfo", "anchor": "fieldvalidatordecoratorinfo", "heading_level": 0, "md_text": "A container for data from `@field_validator` so that we can access it\nwhile building the pydantic-core schema.\n\nAttributes:\n    decorator_repr: A class variable representing the decorator string, '@field_validator'.\n    fields: A tuple of field names the validator should be called on.\n    mode: The proposed validator mode.\n    check_fields: Whether to check that the fields actually exist on the model.\n    json_schema_input_type: The input type of the function. This is only used to generate\n        the appropriate JSON Schema (in validation mode) and can only specified\n        when `mode` is either `'before'`, `'plain'` or `'wrap'`.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_decorators", "source_site": "pydantic"}
{"title": "RootValidatorDecoratorInfo", "anchor": "rootvalidatordecoratorinfo", "heading_level": 0, "md_text": "A container for data from `@root_validator` so that we can access it\nwhile building the pydantic-core schema.\n\nAttributes:\n    decorator_repr: A class variable representing the decorator string, '@root_validator'.\n    mode: The proposed validator mode.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_decorators", "source_site": "pydantic"}
{"title": "FieldSerializerDecoratorInfo", "anchor": "fieldserializerdecoratorinfo", "heading_level": 0, "md_text": "A container for data from `@field_serializer` so that we can access it\nwhile building the pydantic-core schema.\n\nAttributes:\n    decorator_repr: A class variable representing the decorator string, '@field_serializer'.\n    fields: A tuple of field names the serializer should be called on.\n    mode: The proposed serializer mode.\n    return_type: The type of the serializer's return value.\n    when_used: The serialization condition. Accepts a string with values `'always'`, `'unless-none'`, `'json'`,\n        and `'json-unless-none'`.\n    check_fields: Whether to check that the fields actually exist on the model.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_decorators", "source_site": "pydantic"}
{"title": "ModelSerializerDecoratorInfo", "anchor": "modelserializerdecoratorinfo", "heading_level": 0, "md_text": "A container for data from `@model_serializer` so that we can access it\nwhile building the pydantic-core schema.\n\nAttributes:\n    decorator_repr: A class variable representing the decorator string, '@model_serializer'.\n    mode: The proposed serializer mode.\n    return_type: The type of the serializer's return value.\n    when_used: The serialization condition. Accepts a string with values `'always'`, `'unless-none'`, `'json'`,\n        and `'json-unless-none'`.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_decorators", "source_site": "pydantic"}
{"title": "ModelValidatorDecoratorInfo", "anchor": "modelvalidatordecoratorinfo", "heading_level": 0, "md_text": "A container for data from `@model_validator` so that we can access it\nwhile building the pydantic-core schema.\n\nAttributes:\n    decorator_repr: A class variable representing the decorator string, '@model_validator'.\n    mode: The proposed serializer mode.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_decorators", "source_site": "pydantic"}
{"title": "PydanticDescriptorProxy", "anchor": "pydanticdescriptorproxy", "heading_level": 0, "md_text": "Wrap a classmethod, staticmethod, property or unbound function\nand act as a descriptor that allows us to detect decorated items\nfrom the class' attributes.\n\nThis class' __get__ returns the wrapped item's __get__ result,\nwhich makes it transparent for classmethods and staticmethods.\n\nAttributes:\n    wrapped: The decorator that has to be wrapped.\n    decorator_info: The decorator info.\n    shim: A wrapper function to wrap V1 style function.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_decorators", "source_site": "pydantic"}
{"title": "Decorator", "anchor": "decorator", "heading_level": 0, "md_text": "A generic container class to join together the decorator metadata\n(metadata from decorator itself, which we have when the\ndecorator is called but not when we are building the core-schema)\nand the bound function (which we have after the class itself is created).\n\nAttributes:\n    cls_ref: The class ref.\n    cls_var_name: The decorated function name.\n    func: The decorated function.\n    shim: A wrapper function to wrap V1 style function.\n    info: The decorator info.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_decorators", "source_site": "pydantic"}
{"title": "get_bases", "anchor": "get_bases", "heading_level": 0, "md_text": "Get the base classes of a class or typeddict.\n\nArgs:\n    tp: The type or class to get the bases.\n\nReturns:\n    The base classes.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_decorators", "source_site": "pydantic"}
{"title": "mro", "anchor": "mro", "heading_level": 0, "md_text": "Calculate the Method Resolution Order of bases using the C3 algorithm.\n\nSee https://www.python.org/download/releases/2.3/mro/", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_decorators", "source_site": "pydantic"}
{"title": "get_attribute_from_bases", "anchor": "get_attribute_from_bases", "heading_level": 0, "md_text": "Get the attribute from the next class in the MRO that has it,\naiming to simulate calling the method on the actual class.\n\nThe reason for iterating over the mro instead of just getting\nthe attribute (which would do that for us) is to support TypedDict,\nwhich lacks a real __mro__, but can have a virtual one constructed\nfrom its bases (as done here).\n\nArgs:\n    tp: The type or class to search for the attribute. If a tuple, this is treated as a set of base classes.\n    name: The name of the attribute to retrieve.\n\nReturns:\n    Any: The attribute value, if found.\n\nRaises:\n    AttributeError: If the attribute is not found in any class in the MRO.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_decorators", "source_site": "pydantic"}
{"title": "get_attribute_from_base_dicts", "anchor": "get_attribute_from_base_dicts", "heading_level": 0, "md_text": "Get an attribute out of the `__dict__` following the MRO.\nThis prevents the call to `__get__` on the descriptor, and allows\nus to get the original function for classmethod properties.\n\nArgs:\n    tp: The type or class to search for the attribute.\n    name: The name of the attribute to retrieve.\n\nReturns:\n    Any: The attribute value, if found.\n\nRaises:\n    KeyError: If the attribute is not found in any class's `__dict__` in the MRO.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_decorators", "source_site": "pydantic"}
{"title": "DecoratorInfos", "anchor": "decoratorinfos", "heading_level": 0, "md_text": "Mapping of name in the class namespace to decorator info.\n\nnote that the name in the class namespace is the function or attribute name\nnot the field name!", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_decorators", "source_site": "pydantic"}
{"title": "inspect_validator", "anchor": "inspect_validator", "heading_level": 0, "md_text": "Look at a field or model validator function and determine whether it takes an info argument.\n\nAn error is raised if the function has an invalid signature.\n\nArgs:\n    validator: The validator function to inspect.\n    mode: The proposed validator mode.\n    type: The type of validator, either 'field' or 'model'.\n\nReturns:\n    Whether the validator takes an info argument.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_decorators", "source_site": "pydantic"}
{"title": "inspect_field_serializer", "anchor": "inspect_field_serializer", "heading_level": 0, "md_text": "Look at a field serializer function and determine if it is a field serializer,\nand whether it takes an info argument.\n\nAn error is raised if the function has an invalid signature.\n\nArgs:\n    serializer: The serializer function to inspect.\n    mode: The serializer mode, either 'plain' or 'wrap'.\n\nReturns:\n    Tuple of (is_field_serializer, info_arg).", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_decorators", "source_site": "pydantic"}
{"title": "inspect_annotated_serializer", "anchor": "inspect_annotated_serializer", "heading_level": 0, "md_text": "Look at a serializer function used via `Annotated` and determine whether it takes an info argument.\n\nAn error is raised if the function has an invalid signature.\n\nArgs:\n    serializer: The serializer function to check.\n    mode: The serializer mode, either 'plain' or 'wrap'.\n\nReturns:\n    info_arg", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_decorators", "source_site": "pydantic"}
{"title": "inspect_model_serializer", "anchor": "inspect_model_serializer", "heading_level": 0, "md_text": "Look at a model serializer function and determine whether it takes an info argument.\n\nAn error is raised if the function has an invalid signature.\n\nArgs:\n    serializer: The serializer function to check.\n    mode: The serializer mode, either 'plain' or 'wrap'.\n\nReturns:\n    `info_arg` - whether the function expects an info argument.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_decorators", "source_site": "pydantic"}
{"title": "is_instance_method_from_sig", "anchor": "is_instance_method_from_sig", "heading_level": 0, "md_text": "Whether the function is an instance method.\n\nIt will consider a function as instance method if the first parameter of\nfunction is `self`.\n\nArgs:\n    function: The function to check.\n\nReturns:\n    `True` if the function is an instance method, `False` otherwise.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_decorators", "source_site": "pydantic"}
{"title": "ensure_classmethod_based_on_signature", "anchor": "ensure_classmethod_based_on_signature", "heading_level": 0, "md_text": "Apply the `@classmethod` decorator on the function.\n\nArgs:\n    function: The function to apply the decorator on.\n\nReturn:\n    The `@classmethod` decorator applied function.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_decorators", "source_site": "pydantic"}
{"title": "unwrap_wrapped_function", "anchor": "unwrap_wrapped_function", "heading_level": 0, "md_text": "Recursively unwraps a wrapped function until the underlying function is reached.\nThis handles property, functools.partial, functools.partialmethod, staticmethod, and classmethod.\n\nArgs:\n    func: The function to unwrap.\n    unwrap_partial: If True (default), unwrap partial and partialmethod decorators.\n    unwrap_class_static_method: If True (default), also unwrap classmethod and staticmethod\n        decorators. If False, only unwrap partial and partialmethod decorators.\n\nReturns:\n    The underlying function of the wrapped function.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_decorators", "source_site": "pydantic"}
{"title": "get_callable_return_type", "anchor": "get_callable_return_type", "heading_level": 0, "md_text": "Get the callable return type.\n\nArgs:\n    callable_obj: The callable to analyze.\n    globalns: The globals namespace to use during type annotation evaluation.\n    localns: The locals namespace to use during type annotation evaluation.\n\nReturns:\n    The function return type.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_decorators", "source_site": "pydantic"}
{"title": "count_positional_required_params", "anchor": "count_positional_required_params", "heading_level": 0, "md_text": "Get the number of positional (required) arguments of a signature.\n\nThis function should only be used to inspect signatures of validation and serialization functions.\nThe first argument (the value being serialized or validated) is counted as a required argument\neven if a default value exists.\n\nReturns:\n    The number of positional arguments of a signature.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_decorators", "source_site": "pydantic"}
{"title": "ensure_property", "anchor": "ensure_property", "heading_level": 0, "md_text": "Ensure that a function is a `property` or `cached_property`, or is a valid descriptor.\n\nArgs:\n    f: The function to check.\n\nReturns:\n    The function, or a `property` or `cached_property` instance wrapping the function.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_decorators", "source_site": "pydantic"}
{"title": "_signature_no_eval", "anchor": "_signature_no_eval", "heading_level": 0, "md_text": "Get the signature of a callable without evaluating any annotations.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_decorators", "source_site": "pydantic"}
{"title": "PydanticDescriptorProxy.__getattr__", "anchor": "pydanticdescriptorproxy-__getattr__", "heading_level": 0, "md_text": "Forward checks for __isabstractmethod__ and such.", "url": "https://docs.pydantic.dev/latest/api/--getattr--/", "page": "pydantic/_internal/_decorators", "source_site": "pydantic"}
{"title": "Decorator.build", "anchor": "decorator-build", "heading_level": 0, "md_text": "Build a new decorator.\n\nArgs:\n    cls_: The class.\n    cls_var_name: The decorated function name.\n    shim: A wrapper function to wrap V1 style function.\n    info: The decorator info.\n\nReturns:\n    The new decorator instance.", "url": "https://docs.pydantic.dev/latest/api/build/", "page": "pydantic/_internal/_decorators", "source_site": "pydantic"}
{"title": "Decorator.bind_to_cls", "anchor": "decorator-bind_to_cls", "heading_level": 0, "md_text": "Bind the decorator to a class.\n\nArgs:\n    cls: the class.\n\nReturns:\n    The new decorator instance.", "url": "https://docs.pydantic.dev/latest/api/bind-to-cls/", "page": "pydantic/_internal/_decorators", "source_site": "pydantic"}
{"title": "DecoratorInfos.build", "anchor": "decoratorinfos-build", "heading_level": 0, "md_text": "We want to collect all DecFunc instances that exist as\nattributes in the namespace of the class (a BaseModel or dataclass)\nthat called us\nBut we want to collect these in the order of the bases\nSo instead of getting them all from the leaf class (the class that called us),\nwe traverse the bases from root (the oldest ancestor class) to leaf\nand collect all of the instances as we go, taking care to replace\nany duplicate ones with the last one we see to mimic how function overriding\nworks with inheritance.\nIf we do replace any functions we put the replacement into the position\nthe replaced function was in; that is, we maintain the order.", "url": "https://docs.pydantic.dev/latest/api/build/", "page": "pydantic/_internal/_decorators", "source_site": "pydantic"}
{"title": "DecoratorInfos.update_from_config", "anchor": "decoratorinfos-update_from_config", "heading_level": 0, "md_text": "Update the decorator infos from the configuration of the class they are attached to.", "url": "https://docs.pydantic.dev/latest/api/update-from-config/", "page": "pydantic/_internal/_decorators", "source_site": "pydantic"}
{"title": "get_type_ref", "anchor": "get_type_ref", "heading_level": 0, "md_text": "Produces the ref to be used for this type by pydantic_core's core schemas.\n\nThis `args_override` argument was added for the purpose of creating valid recursive references\nwhen creating generic models without needing to create a concrete class.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_core_utils", "source_site": "pydantic"}
{"title": "get_ref", "anchor": "get_ref", "heading_level": 0, "md_text": "Get the ref from the schema if it has one.\nThis exists just for type checking to work correctly.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_core_utils", "source_site": "pydantic"}
{"title": "_clean_schema_for_pretty_print", "anchor": "_clean_schema_for_pretty_print", "heading_level": 0, "md_text": "A utility function to remove irrelevant information from a core schema.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_core_utils", "source_site": "pydantic"}
{"title": "pretty_print_core_schema", "anchor": "pretty_print_core_schema", "heading_level": 0, "md_text": "Pretty-print a core schema using the `rich` library.\n\nArgs:\n    val: The core schema to print, or a Pydantic model/dataclass/type adapter\n        (in which case the cached core schema is fetched and printed).\n    console: A rich console to use when printing. Defaults to the global rich console instance.\n    max_depth: The number of nesting levels which may be printed.\n    strip_metadata: Whether to strip metadata in the output. If `True` any known core metadata\n        attributes will be stripped (but custom attributes are kept). Defaults to `True`.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_core_utils", "source_site": "pydantic"}
{"title": "_model_construction", "anchor": "_model_construction", "heading_level": 0, "md_text": "Private logic for creating models.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_model_construction", "source_site": "pydantic"}
{"title": "_ModelNamespaceDict", "anchor": "_modelnamespacedict", "heading_level": 0, "md_text": "A dictionary subclass that intercepts attribute setting on model classes and\nwarns about overriding of decorators.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_model_construction", "source_site": "pydantic"}
{"title": "NoInitField", "anchor": "noinitfield", "heading_level": 0, "md_text": "Only for typing purposes. Used as default value of `__pydantic_fields_set__`,\n`__pydantic_extra__`, `__pydantic_private__`, so they could be ignored when\nsynthesizing the `__init__` signature.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_model_construction", "source_site": "pydantic"}
{"title": "init_private_attributes", "anchor": "init_private_attributes", "heading_level": 0, "md_text": "This function is meant to behave like a BaseModel method to initialise private attributes.\n\nIt takes context as an argument since that's what pydantic-core passes when calling it.\n\nArgs:\n    self: The BaseModel instance.\n    context: The context.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_model_construction", "source_site": "pydantic"}
{"title": "get_model_post_init", "anchor": "get_model_post_init", "heading_level": 0, "md_text": "Get the `model_post_init` method from the namespace or the class bases, or `None` if not defined.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_model_construction", "source_site": "pydantic"}
{"title": "inspect_namespace", "anchor": "inspect_namespace", "heading_level": 0, "md_text": "Iterate over the namespace and:\n* gather private attributes\n* check for items which look like fields but are not (e.g. have no annotation) and warn.\n\nArgs:\n    namespace: The attribute dictionary of the class to be created.\n    raw_annotations: The (non-evaluated) annotations of the model.\n    ignored_types: A tuple of ignore types.\n    base_class_vars: A set of base class class variables.\n    base_class_fields: A set of base class fields.\n\nReturns:\n    A dict contains private attributes info.\n\nRaises:\n    TypeError: If there is a `__root__` field in model.\n    NameError: If private attribute name is invalid.\n    PydanticUserError:\n        - If a field does not have a type annotation.\n        - If a field on base class was overridden by a non-annotated attribute.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_model_construction", "source_site": "pydantic"}
{"title": "set_model_fields", "anchor": "set_model_fields", "heading_level": 0, "md_text": "Collect and set `cls.__pydantic_fields__` and `cls.__class_vars__`.\n\nArgs:\n    cls: BaseModel or dataclass.\n    config_wrapper: The config wrapper instance.\n    ns_resolver: Namespace resolver to use when getting model annotations.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_model_construction", "source_site": "pydantic"}
{"title": "complete_model_class", "anchor": "complete_model_class", "heading_level": 0, "md_text": "Finish building a model class.\n\nThis logic must be called after class has been created since validation functions must be bound\nand `get_type_hints` requires a class object.\n\nArgs:\n    cls: BaseModel or dataclass.\n    config_wrapper: The config wrapper instance.\n    ns_resolver: The namespace resolver instance to use during schema building.\n    raise_errors: Whether to raise errors.\n    call_on_complete_hook: Whether to call the `__pydantic_on_complete__` hook.\n    create_model_module: The module of the class to be created, if created by `create_model`.\n\nReturns:\n    `True` if the model is successfully completed, else `False`.\n\nRaises:\n    PydanticUndefinedAnnotation: If `PydanticUndefinedAnnotation` occurs in`__get_pydantic_core_schema__`\n        and `raise_errors=True`.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_model_construction", "source_site": "pydantic"}
{"title": "set_deprecated_descriptors", "anchor": "set_deprecated_descriptors", "heading_level": 0, "md_text": "Set data descriptors on the class for deprecated fields.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_model_construction", "source_site": "pydantic"}
{"title": "_DeprecatedFieldDescriptor", "anchor": "_deprecatedfielddescriptor", "heading_level": 0, "md_text": "Read-only data descriptor used to emit a runtime deprecation warning before accessing a deprecated field.\n\nAttributes:\n    msg: The deprecation message to be emitted.\n    wrapped_property: The property instance if the deprecated field is a computed field, or `None`.\n    field_name: The name of the field being deprecated.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_model_construction", "source_site": "pydantic"}
{"title": "_PydanticWeakRef", "anchor": "_pydanticweakref", "heading_level": 0, "md_text": "Wrapper for `weakref.ref` that enables `pickle` serialization.\n\nCloudpickle fails to serialize `weakref.ref` objects due to an arcane error related\nto abstract base classes (`abc.ABC`). This class works around the issue by wrapping\n`weakref.ref` instead of subclassing it.\n\nSee https://github.com/pydantic/pydantic/issues/6763 for context.\n\nSemantics:\n    - If not pickled, behaves the same as a `weakref.ref`.\n    - If pickled along with the referenced object, the same `weakref.ref` behavior\n      will be maintained between them after unpickling.\n    - If pickled without the referenced object, after unpickling the underlying\n      reference will be cleared (`__call__` will always return `None`).", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_model_construction", "source_site": "pydantic"}
{"title": "build_lenient_weakvaluedict", "anchor": "build_lenient_weakvaluedict", "heading_level": 0, "md_text": "Takes an input dictionary, and produces a new value that (invertibly) replaces the values with weakrefs.\n\nWe can't just use a WeakValueDictionary because many types (including int, str, etc.) can't be stored as values\nin a WeakValueDictionary.\n\nThe `unpack_lenient_weakvaluedict` function can be used to reverse this operation.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_model_construction", "source_site": "pydantic"}
{"title": "unpack_lenient_weakvaluedict", "anchor": "unpack_lenient_weakvaluedict", "heading_level": 0, "md_text": "Inverts the transform performed by `build_lenient_weakvaluedict`.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_model_construction", "source_site": "pydantic"}
{"title": "ModelMetaclass.__new__", "anchor": "modelmetaclass-__new__", "heading_level": 0, "md_text": "Metaclass for creating Pydantic models.\n\nArgs:\n    cls_name: The name of the class to be created.\n    bases: The base classes of the class to be created.\n    namespace: The attribute dictionary of the class to be created.\n    __pydantic_generic_metadata__: Metadata for generic models.\n    __pydantic_reset_parent_namespace__: Reset parent namespace.\n    _create_model_module: The module of the class to be created, if created by `create_model`.\n    **kwargs: Catch-all for any other keyword arguments.\n\nReturns:\n    The new class created by the metaclass.", "url": "https://docs.pydantic.dev/latest/api/--new--/", "page": "pydantic/_internal/_model_construction", "source_site": "pydantic"}
{"title": "ModelMetaclass.__pydantic_fields_complete__", "anchor": "modelmetaclass-__pydantic_fields_complete__", "heading_level": 0, "md_text": "Whether the fields where successfully collected (i.e. type hints were successfully resolves).\n\nThis is a private attribute, not meant to be used outside Pydantic.", "url": "https://docs.pydantic.dev/latest/api/--pydantic-fields-complete--/", "page": "pydantic/_internal/_model_construction", "source_site": "pydantic"}
{"title": "__getattr__", "anchor": "__getattr__", "heading_level": 0, "md_text": "This is necessary to keep attribute access working for class attribute access.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_model_construction", "source_site": "pydantic"}
{"title": "wrapped_model_post_init", "anchor": "wrapped_model_post_init", "heading_level": 0, "md_text": "We need to both initialize private attributes and call the user-defined model_post_init\nmethod.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_model_construction", "source_site": "pydantic"}
{"title": "GatherResult", "anchor": "gatherresult", "heading_level": 0, "md_text": "Schema traversing result.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_schema_gather", "source_site": "pydantic"}
{"title": "MissingDefinitionError", "anchor": "missingdefinitionerror", "heading_level": 0, "md_text": "A reference was pointing to a non-existing core schema.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_schema_gather", "source_site": "pydantic"}
{"title": "GatherContext", "anchor": "gathercontext", "heading_level": 0, "md_text": "The current context used during core schema traversing.\n\nContext instances should only be used during schema traversing.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_schema_gather", "source_site": "pydantic"}
{"title": "gather_schemas_for_cleaning", "anchor": "gather_schemas_for_cleaning", "heading_level": 0, "md_text": "Traverse the core schema and definitions and return the necessary information for schema cleaning.\n\nDuring the core schema traversing, any `'definition-ref'` schema is:\n\n- Validated: the reference must point to an existing definition. If this is not the case, a\n  `MissingDefinitionError` exception is raised.\n- Stored in the context: the actual reference is stored in the context. Depending on whether\n  the `'definition-ref'` schema is encountered more that once, the schema itself is also\n  saved in the context to be inlined (i.e. replaced by the definition it points to).", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_schema_gather", "source_site": "pydantic"}
{"title": "MockCoreSchema", "anchor": "mockcoreschema", "heading_level": 0, "md_text": "Mocker for `pydantic_core.CoreSchema` which optionally attempts to\nrebuild the thing it's mocking when one of its methods is accessed and raises an error if that fails.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_mock_val_ser", "source_site": "pydantic"}
{"title": "MockValSer", "anchor": "mockvalser", "heading_level": 0, "md_text": "Mocker for `pydantic_core.SchemaValidator` or `pydantic_core.SchemaSerializer` which optionally attempts to\nrebuild the thing it's mocking when one of its methods is accessed and raises an error if that fails.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_mock_val_ser", "source_site": "pydantic"}
{"title": "set_type_adapter_mocks", "anchor": "set_type_adapter_mocks", "heading_level": 0, "md_text": "Set `core_schema`, `validator` and `serializer` to mock core types on a type adapter instance.\n\nArgs:\n    adapter: The type adapter instance to set the mocks on", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_mock_val_ser", "source_site": "pydantic"}
{"title": "set_model_mocks", "anchor": "set_model_mocks", "heading_level": 0, "md_text": "Set `__pydantic_core_schema__`, `__pydantic_validator__` and `__pydantic_serializer__` to mock core types on a model.\n\nArgs:\n    cls: The model class to set the mocks on\n    undefined_name: Name of the undefined thing, used in error messages", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_mock_val_ser", "source_site": "pydantic"}
{"title": "set_dataclass_mocks", "anchor": "set_dataclass_mocks", "heading_level": 0, "md_text": "Set `__pydantic_validator__` and `__pydantic_serializer__` to `MockValSer`s on a dataclass.\n\nArgs:\n    cls: The model class to set the mocks on\n    undefined_name: Name of the undefined thing, used in error messages", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_mock_val_ser", "source_site": "pydantic"}
{"title": "NamespacesTuple", "anchor": "namespacestuple", "heading_level": 0, "md_text": "A tuple of globals and locals to be used during annotations evaluation.\n\nThis datastructure is defined as a named tuple so that it can easily be unpacked:\n\n```python {lint=\"skip\" test=\"skip\"}\ndef eval_type(typ: type[Any], ns: NamespacesTuple) -> None:\n    return eval(typ, *ns)\n```", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_namespace_utils", "source_site": "pydantic"}
{"title": "get_module_ns_of", "anchor": "get_module_ns_of", "heading_level": 0, "md_text": "Get the namespace of the module where the object is defined.\n\nCaution: this function does not return a copy of the module namespace, so the result\nshould not be mutated. The burden of enforcing this is on the caller.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_namespace_utils", "source_site": "pydantic"}
{"title": "LazyLocalNamespace", "anchor": "lazylocalnamespace", "heading_level": 0, "md_text": "A lazily evaluated mapping, to be used as the `locals` argument during annotations evaluation.\n\nWhile the [`eval`][eval] function expects a mapping as the `locals` argument, it only\nperforms `__getitem__` calls. The [`Mapping`][collections.abc.Mapping] abstract base class\nis fully implemented only for type checking purposes.\n\nArgs:\n    *namespaces: The namespaces to consider, in ascending order of priority.\n\nExample:\n    ```python {lint=\"skip\" test=\"skip\"}\n    ns = LazyLocalNamespace({'a': 1, 'b': 2}, {'a': 3})\n    ns['a']\n    #> 3\n    ns['b']\n    #> 2\n    ```", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_namespace_utils", "source_site": "pydantic"}
{"title": "ns_for_function", "anchor": "ns_for_function", "heading_level": 0, "md_text": "Return the global and local namespaces to be used when evaluating annotations for the provided function.\n\nThe global namespace will be the `__dict__` attribute of the module the function was defined in.\nThe local namespace will contain the `__type_params__` introduced by PEP 695.\n\nArgs:\n    obj: The object to use when building namespaces.\n    parent_namespace: Optional namespace to be added with the lowest priority in the local namespace.\n        If the passed function is a method, the `parent_namespace` will be the namespace of the class\n        the method is defined in. Thus, we also fetch type `__type_params__` from there (i.e. the\n        class-scoped type variables).", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_namespace_utils", "source_site": "pydantic"}
{"title": "NsResolver", "anchor": "nsresolver", "heading_level": 0, "md_text": "A class responsible for the namespaces resolving logic for annotations evaluation.\n\nThis class handles the namespace logic when evaluating annotations mainly for class objects.\n\nIt holds a stack of classes that are being inspected during the core schema building,\nand the `types_namespace` property exposes the globals and locals to be used for\ntype annotation evaluation. Additionally -- if no class is present in the stack -- a\nfallback globals and locals can be provided using the `namespaces_tuple` argument\n(this is useful when generating a schema for a simple annotation, e.g. when using\n`TypeAdapter`).\n\nThe namespace creation logic is unfortunately flawed in some cases, for backwards\ncompatibility reasons and to better support valid edge cases. See the description\nfor the `parent_namespace` argument and the example for more details.\n\nArgs:\n    namespaces_tuple: The default globals and locals to use if no class is present\n        on the stack. This can be useful when using the `GenerateSchema` class\n        with `TypeAdapter`, where the \"type\" being analyzed is a simple annotation.\n    parent_namespace: An optional parent namespace that will be added to the locals\n        with the lowest priority. For a given class defined in a function, the locals\n        of this function are usually used as the parent namespace:\n\n        ```python {lint=\"skip\" test=\"skip\"}\n        from pydantic import BaseModel\n\n        def func() -> None:\n            SomeType = int\n\n            class Model(BaseModel):\n                f: 'SomeType'\n\n            # when collecting fields, an namespace resolver instance will be created\n            # this way:\n            # ns_resolver = NsResolver(parent_namespace={'SomeType': SomeType})\n        ```\n\n        For backwards compatibility reasons and to support valid edge cases, this parent\n        namespace will be used for *every* type being pushed to the stack. In the future,\n        we might want to be smarter by only doing so when the type being pushed is defined\n        in the same module as the parent namespace.\n\nExample:\n    ```python {lint=\"skip\" test=\"skip\"}\n    ns_resolver = NsResolver(\n        parent_namespace={'fallback': 1},\n    )\n\n    class Sub:\n        m: 'Model'\n\n    class Model:\n        some_local = 1\n        sub: Sub\n\n    ns_resolver = NsResolver()\n\n    # This is roughly what happens when we build a core schema for `Model`:\n    with ns_resolver.push(Model):\n        ns_resolver.types_namespace\n        #> NamespacesTuple({'Sub': Sub}, {'Model': Model, 'some_local': 1})\n        # First thing to notice here, the model being pushed is added to the locals.\n        # Because `NsResolver` is being used during the model definition, it is not\n        # yet added to the globals. This is useful when resolving self-referencing annotations.\n\n        with ns_resolver.push(Sub):\n            ns_resolver.types_namespace\n            #> NamespacesTuple({'Sub': Sub}, {'Sub': Sub, 'Model': Model})\n            # Second thing to notice: `Sub` is present in both the globals and locals.\n            # This is not an issue, just that as described above, the model being pushed\n            # is added to the locals, but it happens to be present in the globals as well\n            # because it is already defined.\n            # Third thing to notice: `Model` is also added in locals. This is a backwards\n            # compatibility workaround that allows for `Sub` to be able to resolve `'Model'`\n            # correctly (as otherwise models would have to be rebuilt even though this\n            # doesn't look necessary).\n    ```", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_namespace_utils", "source_site": "pydantic"}
{"title": "NsResolver.types_namespace", "anchor": "nsresolver-types_namespace", "heading_level": 0, "md_text": "The current global and local namespaces to be used for annotations evaluation.", "url": "https://docs.pydantic.dev/latest/api/types-namespace/", "page": "pydantic/_internal/_namespace_utils", "source_site": "pydantic"}
{"title": "NsResolver.push", "anchor": "nsresolver-push", "heading_level": 0, "md_text": "Push a type to the stack.", "url": "https://docs.pydantic.dev/latest/api/push/", "page": "pydantic/_internal/_namespace_utils", "source_site": "pydantic"}
{"title": "_docs_extraction", "anchor": "_docs_extraction", "heading_level": 0, "md_text": "Utilities related to attribute docstring extraction.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_docs_extraction", "source_site": "pydantic"}
{"title": "extract_docstrings_from_cls", "anchor": "extract_docstrings_from_cls", "heading_level": 0, "md_text": "Map model attributes and their corresponding docstring.\n\nArgs:\n    cls: The class of the Pydantic model to inspect.\n    use_inspect: Whether to skip usage of frames to find the object and use\n        the `inspect` module instead.\n\nReturns:\n    A mapping containing attribute names and their corresponding docstring.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_docs_extraction", "source_site": "pydantic"}
{"title": "_decorators_v1", "anchor": "_decorators_v1", "heading_level": 0, "md_text": "Logic for V1 validators, e.g. `@validator` and `@root_validator`.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_decorators_v1", "source_site": "pydantic"}
{"title": "V1OnlyValueValidator", "anchor": "v1onlyvaluevalidator", "heading_level": 0, "md_text": "A simple validator, supported for V1 validators and V2 validators.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_decorators_v1", "source_site": "pydantic"}
{"title": "V1ValidatorWithValues", "anchor": "v1validatorwithvalues", "heading_level": 0, "md_text": "A validator with `values` argument, supported for V1 validators and V2 validators.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_decorators_v1", "source_site": "pydantic"}
{"title": "V1ValidatorWithValuesKwOnly", "anchor": "v1validatorwithvalueskwonly", "heading_level": 0, "md_text": "A validator with keyword only `values` argument, supported for V1 validators and V2 validators.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_decorators_v1", "source_site": "pydantic"}
{"title": "V1ValidatorWithKwargs", "anchor": "v1validatorwithkwargs", "heading_level": 0, "md_text": "A validator with `kwargs` argument, supported for V1 validators and V2 validators.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_decorators_v1", "source_site": "pydantic"}
{"title": "V1ValidatorWithValuesAndKwargs", "anchor": "v1validatorwithvaluesandkwargs", "heading_level": 0, "md_text": "A validator with `values` and `kwargs` arguments, supported for V1 validators and V2 validators.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_decorators_v1", "source_site": "pydantic"}
{"title": "make_generic_v1_field_validator", "anchor": "make_generic_v1_field_validator", "heading_level": 0, "md_text": "Wrap a V1 style field validator for V2 compatibility.\n\nArgs:\n    validator: The V1 style field validator.\n\nReturns:\n    A wrapped V2 style field validator.\n\nRaises:\n    PydanticUserError: If the signature is not supported or the parameters are\n        not available in Pydantic V2.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_decorators_v1", "source_site": "pydantic"}
{"title": "V1RootValidatorFunction", "anchor": "v1rootvalidatorfunction", "heading_level": 0, "md_text": "A simple root validator, supported for V1 validators and V2 validators.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_decorators_v1", "source_site": "pydantic"}
{"title": "V2CoreBeforeRootValidator", "anchor": "v2corebeforerootvalidator", "heading_level": 0, "md_text": "V2 validator with mode='before'.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_decorators_v1", "source_site": "pydantic"}
{"title": "V2CoreAfterRootValidator", "anchor": "v2coreafterrootvalidator", "heading_level": 0, "md_text": "V2 validator with mode='after'.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_decorators_v1", "source_site": "pydantic"}
{"title": "make_v1_generic_root_validator", "anchor": "make_v1_generic_root_validator", "heading_level": 0, "md_text": "Wrap a V1 style root validator for V2 compatibility.\n\nArgs:\n    validator: The V1 style field validator.\n    pre: Whether the validator is a pre validator.\n\nReturns:\n    A wrapped V2 style validator.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_decorators_v1", "source_site": "pydantic"}
{"title": "_fields", "anchor": "_fields", "heading_level": 0, "md_text": "Private logic related to fields (the `Field()` function and `FieldInfo` class), and arguments to `Annotated`.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_fields", "source_site": "pydantic"}
{"title": "PydanticMetadata", "anchor": "pydanticmetadata", "heading_level": 0, "md_text": "Base class for annotation markers like `Strict`.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_fields", "source_site": "pydantic"}
{"title": "pydantic_general_metadata", "anchor": "pydantic_general_metadata", "heading_level": 0, "md_text": "Create a new `_PydanticGeneralMetadata` class with the given metadata.\n\nArgs:\n    **metadata: The metadata to add.\n\nReturns:\n    The new `_PydanticGeneralMetadata` class.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_fields", "source_site": "pydantic"}
{"title": "_general_metadata_cls", "anchor": "_general_metadata_cls", "heading_level": 0, "md_text": "Do it this way to avoid importing `annotated_types` at import time.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_fields", "source_site": "pydantic"}
{"title": "_apply_alias_generator_to_field_info", "anchor": "_apply_alias_generator_to_field_info", "heading_level": 0, "md_text": "Apply an alias generator to aliases on a `FieldInfo` instance if appropriate.\n\nArgs:\n    alias_generator: A callable that takes a string and returns a string, or an `AliasGenerator` instance.\n    field_name: The name of the field from which to generate the alias.\n    field_info: The `FieldInfo` instance to which the alias generator is (maybe) applied.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_fields", "source_site": "pydantic"}
{"title": "update_field_from_config", "anchor": "update_field_from_config", "heading_level": 0, "md_text": "Update the `FieldInfo` instance from the configuration set on the model it belongs to.\n\nThis will apply the title and alias generators from the configuration.\n\nArgs:\n    config_wrapper: The configuration from the model.\n    field_name: The field name the `FieldInfo` instance is attached to.\n    field_info: The `FieldInfo` instance to update.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_fields", "source_site": "pydantic"}
{"title": "collect_model_fields", "anchor": "collect_model_fields", "heading_level": 0, "md_text": "Collect the fields and class variables names of a nascent Pydantic model.\n\nThe fields collection process is *lenient*, meaning it won't error if string annotations\nfail to evaluate. If this happens, the original annotation (and assigned value, if any)\nis stored on the created `FieldInfo` instance.\n\nThe `rebuild_model_fields()` should be called at a later point (e.g. when rebuilding the model),\nand will make use of these stored attributes.\n\nArgs:\n    cls: BaseModel or dataclass.\n    config_wrapper: The config wrapper instance.\n    ns_resolver: Namespace resolver to use when getting model annotations.\n    typevars_map: A dictionary mapping type variables to their concrete types.\n\nReturns:\n    A two-tuple containing model fields and class variables names.\n\nRaises:\n    NameError:\n        - If there is a conflict between a field name and protected namespaces.\n        - If there is a field other than `root` in `RootModel`.\n        - If a field shadows an attribute in the parent model.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_fields", "source_site": "pydantic"}
{"title": "rebuild_model_fields", "anchor": "rebuild_model_fields", "heading_level": 0, "md_text": "Rebuild the (already present) model fields by trying to reevaluate annotations.\n\nThis function should be called whenever a model with incomplete fields is encountered.\n\nRaises:\n    NameError: If one of the annotations failed to evaluate.\n\nNote:\n    This function *doesn't* mutate the model fields in place, as it can be called during\n    schema generation, where you don't want to mutate other model's fields.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_fields", "source_site": "pydantic"}
{"title": "collect_dataclass_fields", "anchor": "collect_dataclass_fields", "heading_level": 0, "md_text": "Collect the fields of a dataclass.\n\nArgs:\n    cls: dataclass.\n    config_wrapper: The config wrapper instance.\n    ns_resolver: Namespace resolver to use when getting dataclass annotations.\n        Defaults to an empty instance.\n    typevars_map: A dictionary mapping type variables to their concrete types.\n\nReturns:\n    The dataclass fields.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_fields", "source_site": "pydantic"}
{"title": "rebuild_dataclass_fields", "anchor": "rebuild_dataclass_fields", "heading_level": 0, "md_text": "Rebuild the (already present) dataclass fields by trying to reevaluate annotations.\n\nThis function should be called whenever a dataclass with incomplete fields is encountered.\n\nRaises:\n    NameError: If one of the annotations failed to evaluate.\n\nNote:\n    This function *doesn't* mutate the dataclass fields in place, as it can be called during\n    schema generation, where you don't want to mutate other dataclass's fields.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_fields", "source_site": "pydantic"}
{"title": "takes_validated_data_argument", "anchor": "takes_validated_data_argument", "heading_level": 0, "md_text": "Whether the provided default factory callable has a validated data parameter.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_fields", "source_site": "pydantic"}
{"title": "_PydanticGeneralMetadata", "anchor": "_pydanticgeneralmetadata", "heading_level": 0, "md_text": "Pydantic general metadata like `max_digits`.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_fields", "source_site": "pydantic"}
{"title": "_typing_extra", "anchor": "_typing_extra", "heading_level": 0, "md_text": "Logic for interacting with type annotations, mostly extensions, shims and hacks to wrap Python's typing module.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_typing_extra", "source_site": "pydantic"}
{"title": "is_annotated", "anchor": "is_annotated", "heading_level": 0, "md_text": "Return whether the provided argument is a `Annotated` special form.\n\n```python {test=\"skip\" lint=\"skip\"}\nis_annotated(Annotated[int, ...])\n#> True\n```", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_typing_extra", "source_site": "pydantic"}
{"title": "annotated_type", "anchor": "annotated_type", "heading_level": 0, "md_text": "Return the type of the `Annotated` special form, or `None`.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_typing_extra", "source_site": "pydantic"}
{"title": "unpack_type", "anchor": "unpack_type", "heading_level": 0, "md_text": "Return the type wrapped by the `Unpack` special form, or `None`.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_typing_extra", "source_site": "pydantic"}
{"title": "is_hashable", "anchor": "is_hashable", "heading_level": 0, "md_text": "Return whether the provided argument is the `Hashable` class.\n\n```python {test=\"skip\" lint=\"skip\"}\nis_hashable(Hashable)\n#> True\n```", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_typing_extra", "source_site": "pydantic"}
{"title": "is_callable", "anchor": "is_callable", "heading_level": 0, "md_text": "Return whether the provided argument is a `Callable`, parametrized or not.\n\n```python {test=\"skip\" lint=\"skip\"}\nis_callable(Callable[[int], str])\n#> True\nis_callable(typing.Callable)\n#> True\nis_callable(collections.abc.Callable)\n#> True\n```", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_typing_extra", "source_site": "pydantic"}
{"title": "is_classvar_annotation", "anchor": "is_classvar_annotation", "heading_level": 0, "md_text": "Return whether the provided argument represents a class variable annotation.\n\nAlthough not explicitly stated by the typing specification, `ClassVar` can be used\ninside `Annotated` and as such, this function checks for this specific scenario.\n\nBecause this function is used to detect class variables before evaluating forward references\n(or because evaluation failed), we also implement a naive regex match implementation. This is\nrequired because class variables are inspected before fields are collected, so we try to be\nas accurate as possible.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_typing_extra", "source_site": "pydantic"}
{"title": "is_finalvar", "anchor": "is_finalvar", "heading_level": 0, "md_text": "Return whether the provided argument is a `Final` special form, parametrized or not.\n\n```python {test=\"skip\" lint=\"skip\"}\nis_finalvar(Final[int])\n#> True\nis_finalvar(Final)\n#> True", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_typing_extra", "source_site": "pydantic"}
{"title": "is_none_type", "anchor": "is_none_type", "heading_level": 0, "md_text": "Return whether the argument represents the `None` type as part of an annotation.\n\n```python {test=\"skip\" lint=\"skip\"}\nis_none_type(None)\n#> True\nis_none_type(NoneType)\n#> True\nis_none_type(Literal[None])\n#> True\nis_none_type(type[None])\n#> False", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_typing_extra", "source_site": "pydantic"}
{"title": "is_namedtuple", "anchor": "is_namedtuple", "heading_level": 0, "md_text": "Return whether the provided argument is a named tuple class.\n\nThe class can be created using `typing.NamedTuple` or `collections.namedtuple`.\nParametrized generic classes are *not* assumed to be named tuples.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_typing_extra", "source_site": "pydantic"}
{"title": "parent_frame_namespace", "anchor": "parent_frame_namespace", "heading_level": 0, "md_text": "Fetch the local namespace of the parent frame where this function is called.\n\nUsing this function is mostly useful to resolve forward annotations pointing to members defined in a local namespace,\nsuch as assignments inside a function. Using the standard library tools, it is currently not possible to resolve\nsuch annotations:\n\n```python {lint=\"skip\" test=\"skip\"}\nfrom typing import get_type_hints\n\ndef func() -> None:\n    Alias = int\n\n    class C:\n        a: 'Alias'\n\n    # Raises a `NameError: 'Alias' is not defined`\n    get_type_hints(C)\n```\n\nPydantic uses this function when a Pydantic model is being defined to fetch the parent frame locals. However,\nthis only allows us to fetch the parent frame namespace and not other parents (e.g. a model defined in a function,\nitself defined in another function). Inspecting the next outer frames (using `f_back`) is not reliable enough\n(see https://discuss.python.org/t/20659).\n\nBecause this function is mostly used to better resolve forward annotations, nothing is returned if the parent frame's\ncode object is defined at the module level. In this case, the locals of the frame will be the same as the module\nglobals where the class is defined (see `_namespace_utils.get_module_ns_of`). However, if you still want to fetch\nthe module globals (e.g. when rebuilding a model, where the frame where the rebuild call is performed might contain\nmembers that you want to use for forward annotations evaluation), you can use the `force` parameter.\n\nArgs:\n    parent_depth: The depth at which to get the frame. Defaults to 2, meaning the parent frame where this function\n        is called will be used.\n    force: Whether to always return the frame locals, even if the frame's code object is defined at the module level.\n\nReturns:\n    The locals of the namespace, or `None` if it was skipped as per the described logic.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_typing_extra", "source_site": "pydantic"}
{"title": "_type_convert", "anchor": "_type_convert", "heading_level": 0, "md_text": "Convert `None` to `NoneType` and strings to `ForwardRef` instances.\n\nThis is a backport of the private `typing._type_convert` function. When\nevaluating a type, `ForwardRef._evaluate` ends up being called, and is\nresponsible for making this conversion. However, we still have to apply\nit for the first argument passed to our type evaluation functions, similarly\nto the `typing.get_type_hints` function.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_typing_extra", "source_site": "pydantic"}
{"title": "safe_get_annotations", "anchor": "safe_get_annotations", "heading_level": 0, "md_text": "Get the annotations for the provided class, accounting for potential deferred forward references.\n\nStarting with Python 3.14, accessing the `__annotations__` attribute might raise a `NameError` if\na referenced symbol isn't defined yet. In this case, we return the annotation in the *forward ref*\nformat.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_typing_extra", "source_site": "pydantic"}
{"title": "get_model_type_hints", "anchor": "get_model_type_hints", "heading_level": 0, "md_text": "Collect annotations from a Pydantic model class, including those from parent classes.\n\nArgs:\n    obj: The Pydantic model to inspect.\n    ns_resolver: A namespace resolver instance to use. Defaults to an empty instance.\n\nReturns:\n    A dictionary mapping annotation names to a two-tuple: the first element is the evaluated\n    type or the original annotation if a `NameError` occurred, the second element is a boolean\n    indicating if whether the evaluation succeeded.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_typing_extra", "source_site": "pydantic"}
{"title": "get_cls_type_hints", "anchor": "get_cls_type_hints", "heading_level": 0, "md_text": "Collect annotations from a class, including those from parent classes.\n\nArgs:\n    obj: The class to inspect.\n    ns_resolver: A namespace resolver instance to use. Defaults to an empty instance.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_typing_extra", "source_site": "pydantic"}
{"title": "try_eval_type", "anchor": "try_eval_type", "heading_level": 0, "md_text": "Try evaluating the annotation using the provided namespaces.\n\nArgs:\n    value: The value to evaluate. If `None`, it will be replaced by `type[None]`. If an instance\n        of `str`, it will be converted to a `ForwardRef`.\n    localns: The global namespace to use during annotation evaluation.\n    globalns: The local namespace to use during annotation evaluation.\n\nReturns:\n    A two-tuple containing the possibly evaluated type and a boolean indicating\n        whether the evaluation succeeded or not.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_typing_extra", "source_site": "pydantic"}
{"title": "eval_type", "anchor": "eval_type", "heading_level": 0, "md_text": "Evaluate the annotation using the provided namespaces.\n\nArgs:\n    value: The value to evaluate. If `None`, it will be replaced by `type[None]`. If an instance\n        of `str`, it will be converted to a `ForwardRef`.\n    localns: The global namespace to use during annotation evaluation.\n    globalns: The local namespace to use during annotation evaluation.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_typing_extra", "source_site": "pydantic"}
{"title": "eval_type_backport", "anchor": "eval_type_backport", "heading_level": 0, "md_text": "An enhanced version of `typing._eval_type` which will fall back to using the `eval_type_backport`\npackage if it's installed to let older Python versions use newer typing constructs.\n\nSpecifically, this transforms `X | Y` into `typing.Union[X, Y]` and `list[X]` into `typing.List[X]`\n(as well as all the types made generic in PEP 585) if the original syntax is not supported in the\ncurrent Python version.\n\nThis function will also display a helpful error if the value passed fails to evaluate.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_typing_extra", "source_site": "pydantic"}
{"title": "get_function_type_hints", "anchor": "get_function_type_hints", "heading_level": 0, "md_text": "Return type hints for a function.\n\nThis is similar to the `typing.get_type_hints` function, with a few differences:\n- Support `functools.partial` by using the underlying `func` attribute.\n- Do not wrap type annotation of a parameter with `Optional` if it has a default value of `None`\n  (related bug: https://github.com/python/cpython/issues/90353, only fixed in 3.11+).", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_typing_extra", "source_site": "pydantic"}
{"title": "_make_forward_ref", "anchor": "_make_forward_ref", "heading_level": 0, "md_text": "Wrapper for ForwardRef that accounts for the `is_class` argument missing in older versions.\nThe `module` argument is omitted as it breaks <3.9.8, =3.10.0 and isn't used in the calls below.\n\nSee https://github.com/python/cpython/pull/28560 for some background.\nThe backport happened on 3.9.8, see:\nhttps://github.com/pydantic/pydantic/discussions/6244#discussioncomment-6275458,\nand on 3.10.1 for the 3.10 branch, see:\nhttps://github.com/pydantic/pydantic/issues/6912\n\nImplemented as EAFP with memory.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_typing_extra", "source_site": "pydantic"}
{"title": "get_type_hints", "anchor": "get_type_hints", "heading_level": 0, "md_text": "Taken verbatim from python 3.10.8 unchanged, except:\n* type annotations of the function definition above.\n* prefixing `typing.` where appropriate\n* Use `_make_forward_ref` instead of `typing.ForwardRef` to handle the `is_class` argument.\n\nhttps://github.com/python/cpython/blob/aaaf5174241496afca7ce4d4584570190ff972fe/Lib/typing.py#L1773-L1875\n\nDO NOT CHANGE THIS METHOD UNLESS ABSOLUTELY NECESSARY.\n======================================================\n\nReturn type hints for an object.\n\nThis is often the same as obj.__annotations__, but it handles\nforward references encoded as string literals, adds Optional[t] if a\ndefault value equal to None is set and recursively replaces all\n'Annotated[T, ...]' with 'T' (unless 'include_extras=True').\n\nThe argument may be a module, class, method, or function. The annotations\nare returned as a dictionary. For classes, annotations include also\ninherited members.\n\nTypeError is raised if the argument is not of a type that can contain\nannotations, and an empty dictionary is returned if no annotations are\npresent.\n\nBEWARE -- the behavior of globalns and localns is counterintuitive\n(unless you are familiar with how eval() and exec() work).  The\nsearch order is locals first, then globals.\n\n- If no dict arguments are passed, an attempt is made to use the\n  globals from obj (or the respective module's globals for classes),\n  and these are also used as the locals.  If the object does not appear\n  to have globals, an empty dictionary is used.  For classes, the search\n  order is globals first then locals.\n\n- If one dict argument is passed, it is used for both globals and\n  locals.\n\n- If two dict arguments are passed, they specify globals and\n  locals, respectively.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/_internal/_typing_extra", "source_site": "pydantic"}
{"title": "validate_arguments", "anchor": "validate_arguments", "heading_level": 0, "md_text": "Decorator to validate the arguments passed to a function.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/decorator", "source_site": "pydantic"}
{"title": "dataclasses", "anchor": "dataclasses", "heading_level": 0, "md_text": "The main purpose is to enhance stdlib dataclasses by adding validation\nA pydantic dataclass can be generated from scratch or from a stdlib one.\n\nBehind the scene, a pydantic dataclass is just like a regular one on which we attach\na `BaseModel` and magic methods to trigger the validation of the data.\n`__init__` and `__post_init__` are hence overridden and have extra logic to be\nable to validate input data.\n\nWhen a pydantic dataclass is generated from scratch, it's just a plain dataclass\nwith validation triggered at initialization\n\nThe tricky part if for stdlib dataclasses that are converted after into pydantic ones e.g.\n\n```py\n@dataclasses.dataclass\nclass M:\n    x: int\n\nValidatedM = pydantic.dataclasses.dataclass(M)\n```\n\nWe indeed still want to support equality, hashing, repr, ... as if it was the stdlib one!\n\n```py\nassert isinstance(ValidatedM(x=1), M)\nassert ValidatedM(x=1) == M(x=1)\n```\n\nThis means we **don't want to create a new dataclass that inherits from it**\nThe trick is to create a wrapper around `M` that will act as a proxy to trigger\nvalidation without altering default `M` behaviour.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/dataclasses", "source_site": "pydantic"}
{"title": "dataclass", "anchor": "dataclass", "heading_level": 0, "md_text": "Like the python standard lib dataclasses but with type validation.\nThe result is either a pydantic dataclass that will validate input data\nor a wrapper that will trigger validation around a stdlib dataclass\nto avoid modifying it directly", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/dataclasses", "source_site": "pydantic"}
{"title": "_add_pydantic_validation_attributes", "anchor": "_add_pydantic_validation_attributes", "heading_level": 0, "md_text": "We need to replace the right method. If no `__post_init__` has been set in the stdlib dataclass\nit won't even exist (code is generated on the fly by `dataclasses`)\nBy default, we run validation after `__init__` or `__post_init__` if defined", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/dataclasses", "source_site": "pydantic"}
{"title": "is_builtin_dataclass", "anchor": "is_builtin_dataclass", "heading_level": 0, "md_text": "Whether a class is a stdlib dataclass\n(useful to discriminated a pydantic dataclass that is actually a wrapper around a stdlib dataclass)\n\nwe check that\n- `_cls` is a dataclass\n- `_cls` is not a processed pydantic dataclass (with a basemodel attached)\n- `_cls` is not a pydantic dataclass inheriting directly from a stdlib dataclass\ne.g.\n```\n@dataclasses.dataclass\nclass A:\n    x: int\n\n@pydantic.dataclasses.dataclass\nclass B(A):\n    y: int\n```\nIn this case, when we first check `B`, we make an extra check and look at the annotations ('y'),\nwhich won't be a superset of all the dataclass fields (only the stdlib fields i.e. 'x')", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/dataclasses", "source_site": "pydantic"}
{"title": "make_dataclass_validator", "anchor": "make_dataclass_validator", "heading_level": 0, "md_text": "Create a pydantic.dataclass from a builtin dataclass to add type validation\nand yield the validators\nIt retrieves the parameters of the dataclass and forwards them to the newly created dataclass", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/dataclasses", "source_site": "pydantic"}
{"title": "BaseSettings", "anchor": "basesettings", "heading_level": 0, "md_text": "Base class for settings, allowing values to be overridden by environment variables.\n\nThis is useful in production for secrets you do not wish to save in code, it plays nicely with docker(-compose),\nHeroku and any 12 factor app design.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/env_settings", "source_site": "pydantic"}
{"title": "find_case_path", "anchor": "find_case_path", "heading_level": 0, "md_text": "Find a file within path's directory matching filename, optionally ignoring case.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/env_settings", "source_site": "pydantic"}
{"title": "EnvSettingsSource.__call__", "anchor": "envsettingssource-__call__", "heading_level": 0, "md_text": "Build environment variables suitable for passing to the Model.", "url": "https://docs.pydantic.dev/latest/api/--call--/", "page": "pydantic/v1/env_settings", "source_site": "pydantic"}
{"title": "EnvSettingsSource.field_is_complex", "anchor": "envsettingssource-field_is_complex", "heading_level": 0, "md_text": "Find out if a field is complex, and if so whether JSON errors should be ignored", "url": "https://docs.pydantic.dev/latest/api/field-is-complex/", "page": "pydantic/v1/env_settings", "source_site": "pydantic"}
{"title": "EnvSettingsSource.explode_env_vars", "anchor": "envsettingssource-explode_env_vars", "heading_level": 0, "md_text": "Process env_vars and extract the values of keys containing env_nested_delimiter into nested dictionaries.\n\nThis is applied to a single field, hence filtering by env_var prefix.", "url": "https://docs.pydantic.dev/latest/api/explode-env-vars/", "page": "pydantic/v1/env_settings", "source_site": "pydantic"}
{"title": "SecretsSettingsSource.__call__", "anchor": "secretssettingssource-__call__", "heading_level": 0, "md_text": "Build fields from \"secrets\" files.", "url": "https://docs.pydantic.dev/latest/api/--call--/", "page": "pydantic/v1/env_settings", "source_site": "pydantic"}
{"title": "plugin", "anchor": "plugin", "heading_level": 0, "md_text": "`version` is the mypy version string\n\nWe might want to use this to print a warning if the mypy version being used is\nnewer, or especially older, than we expect (or need).", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/mypy", "source_site": "pydantic"}
{"title": "from_orm_callback", "anchor": "from_orm_callback", "heading_level": 0, "md_text": "Raise an error if orm_mode is not enabled", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/mypy", "source_site": "pydantic"}
{"title": "add_method", "anchor": "add_method", "heading_level": 0, "md_text": "Adds a new method to a class.\n\nThis can be dropped if/when https://github.com/python/mypy/issues/7301 is merged", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/mypy", "source_site": "pydantic"}
{"title": "get_fullname", "anchor": "get_fullname", "heading_level": 0, "md_text": "Used for compatibility with mypy 0.740; can be dropped once support for 0.740 is dropped.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/mypy", "source_site": "pydantic"}
{"title": "get_name", "anchor": "get_name", "heading_level": 0, "md_text": "Used for compatibility with mypy 0.740; can be dropped once support for 0.740 is dropped.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/mypy", "source_site": "pydantic"}
{"title": "PydanticPlugin.get_class_decorator_hook", "anchor": "pydanticplugin-get_class_decorator_hook", "heading_level": 0, "md_text": "Mark pydantic.dataclasses as dataclass.\n\nMypy version 1.1.1 added support for `@dataclass_transform` decorator.", "url": "https://docs.pydantic.dev/latest/api/get-class-decorator-hook/", "page": "pydantic/v1/mypy", "source_site": "pydantic"}
{"title": "PydanticPlugin.report_config_data", "anchor": "pydanticplugin-report_config_data", "heading_level": 0, "md_text": "Return all plugin config data.\n\nUsed by mypy to determine if cache needs to be discarded.", "url": "https://docs.pydantic.dev/latest/api/report-config-data/", "page": "pydantic/v1/mypy", "source_site": "pydantic"}
{"title": "PydanticPlugin._pydantic_model_metaclass_marker_callback", "anchor": "pydanticplugin-_pydantic_model_metaclass_marker_callback", "heading_level": 0, "md_text": "Reset dataclass_transform_spec attribute of ModelMetaclass.\n\nLet the plugin handle it. This behavior can be disabled\nif 'debug_dataclass_transform' is set to True', for testing purposes.", "url": "https://docs.pydantic.dev/latest/api/-pydantic-model-metaclass-marker-callback/", "page": "pydantic/v1/mypy", "source_site": "pydantic"}
{"title": "PydanticPlugin._pydantic_field_callback", "anchor": "pydanticplugin-_pydantic_field_callback", "heading_level": 0, "md_text": "Extract the type of the `default` argument from the Field function, and use it as the return type.\n\nIn particular:\n* Check whether the default and default_factory argument is specified.\n* Output an error if both are specified.\n* Retrieve the type of the argument which is specified, and use it as return type for the function.", "url": "https://docs.pydantic.dev/latest/api/-pydantic-field-callback/", "page": "pydantic/v1/mypy", "source_site": "pydantic"}
{"title": "PydanticModelTransformer.transform", "anchor": "pydanticmodeltransformer-transform", "heading_level": 0, "md_text": "Configures the BaseModel subclass according to the plugin settings.\n\nIn particular:\n* determines the model config and fields,\n* adds a fields-aware signature for the initializer and construct methods\n* freezes the class if allow_mutation = False or frozen = True\n* stores the fields, config, and if the class is settings in the mypy metadata for access by subclasses", "url": "https://docs.pydantic.dev/latest/api/transform/", "page": "pydantic/v1/mypy", "source_site": "pydantic"}
{"title": "PydanticModelTransformer.adjust_validator_signatures", "anchor": "pydanticmodeltransformer-adjust_validator_signatures", "heading_level": 0, "md_text": "When we decorate a function `f` with `pydantic.validator(...), mypy sees\n`f` as a regular method taking a `self` instance, even though pydantic\ninternally wraps `f` with `classmethod` if necessary.\n\nTeach mypy this by marking any function whose outermost decorator is a\n`validator()` call as a classmethod.", "url": "https://docs.pydantic.dev/latest/api/adjust-validator-signatures/", "page": "pydantic/v1/mypy", "source_site": "pydantic"}
{"title": "PydanticModelTransformer.collect_config", "anchor": "pydanticmodeltransformer-collect_config", "heading_level": 0, "md_text": "Collects the values of the config attributes that are used by the plugin, accounting for parent classes.", "url": "https://docs.pydantic.dev/latest/api/collect-config/", "page": "pydantic/v1/mypy", "source_site": "pydantic"}
{"title": "PydanticModelTransformer.collect_fields", "anchor": "pydanticmodeltransformer-collect_fields", "heading_level": 0, "md_text": "Collects the fields for the model, accounting for parent classes", "url": "https://docs.pydantic.dev/latest/api/collect-fields/", "page": "pydantic/v1/mypy", "source_site": "pydantic"}
{"title": "PydanticModelTransformer.add_initializer", "anchor": "pydanticmodeltransformer-add_initializer", "heading_level": 0, "md_text": "Adds a fields-aware `__init__` method to the class.\n\nThe added `__init__` will be annotated with types vs. all `Any` depending on the plugin settings.", "url": "https://docs.pydantic.dev/latest/api/add-initializer/", "page": "pydantic/v1/mypy", "source_site": "pydantic"}
{"title": "PydanticModelTransformer.add_construct_method", "anchor": "pydanticmodeltransformer-add_construct_method", "heading_level": 0, "md_text": "Adds a fully typed `construct` classmethod to the class.\n\nSimilar to the fields-aware __init__ method, but always uses the field names (not aliases),\nand does not treat settings fields as optional.", "url": "https://docs.pydantic.dev/latest/api/add-construct-method/", "page": "pydantic/v1/mypy", "source_site": "pydantic"}
{"title": "PydanticModelTransformer.set_frozen", "anchor": "pydanticmodeltransformer-set_frozen", "heading_level": 0, "md_text": "Marks all fields as properties so that attempts to set them trigger mypy errors.\n\nThis is the same approach used by the attrs and dataclasses plugins.", "url": "https://docs.pydantic.dev/latest/api/set-frozen/", "page": "pydantic/v1/mypy", "source_site": "pydantic"}
{"title": "PydanticModelTransformer.get_config_update", "anchor": "pydanticmodeltransformer-get_config_update", "heading_level": 0, "md_text": "Determines the config update due to a single statement in the Config class definition.\n\nWarns if a tracked config attribute is set to a value the plugin doesn't know how to interpret (e.g., an int)", "url": "https://docs.pydantic.dev/latest/api/get-config-update/", "page": "pydantic/v1/mypy", "source_site": "pydantic"}
{"title": "PydanticModelTransformer.get_is_required", "anchor": "pydanticmodeltransformer-get_is_required", "heading_level": 0, "md_text": "Returns a boolean indicating whether the field defined in `stmt` is a required field.", "url": "https://docs.pydantic.dev/latest/api/get-is-required/", "page": "pydantic/v1/mypy", "source_site": "pydantic"}
{"title": "PydanticModelTransformer.type_has_implicit_default", "anchor": "pydanticmodeltransformer-type_has_implicit_default", "heading_level": 0, "md_text": "Returns True if the passed type will be given an implicit default value.\n\nIn pydantic v1, this is the case for Optional types and Any (with default value None).", "url": "https://docs.pydantic.dev/latest/api/type-has-implicit-default/", "page": "pydantic/v1/mypy", "source_site": "pydantic"}
{"title": "PydanticModelTransformer.get_alias_info", "anchor": "pydanticmodeltransformer-get_alias_info", "heading_level": 0, "md_text": "Returns a pair (alias, has_dynamic_alias), extracted from the declaration of the field defined in `stmt`.\n\n`has_dynamic_alias` is True if and only if an alias is provided, but not as a string literal.\nIf `has_dynamic_alias` is True, `alias` will be None.", "url": "https://docs.pydantic.dev/latest/api/get-alias-info/", "page": "pydantic/v1/mypy", "source_site": "pydantic"}
{"title": "PydanticModelTransformer.get_field_arguments", "anchor": "pydanticmodeltransformer-get_field_arguments", "heading_level": 0, "md_text": "Helper function used during the construction of the `__init__` and `construct` method signatures.\n\nReturns a list of mypy Argument instances for use in the generated signatures.", "url": "https://docs.pydantic.dev/latest/api/get-field-arguments/", "page": "pydantic/v1/mypy", "source_site": "pydantic"}
{"title": "PydanticModelTransformer.should_init_forbid_extra", "anchor": "pydanticmodeltransformer-should_init_forbid_extra", "heading_level": 0, "md_text": "Indicates whether the generated `__init__` should get a `**kwargs` at the end of its signature\n\nWe disallow arbitrary kwargs if the extra config setting is \"forbid\", or if the plugin config says to,\n*unless* a required dynamic alias is present (since then we can't determine a valid signature).", "url": "https://docs.pydantic.dev/latest/api/should-init-forbid-extra/", "page": "pydantic/v1/mypy", "source_site": "pydantic"}
{"title": "PydanticModelTransformer.is_dynamic_alias_present", "anchor": "pydanticmodeltransformer-is_dynamic_alias_present", "heading_level": 0, "md_text": "Returns whether any fields on the model have a \"dynamic alias\", i.e., an alias that cannot be\ndetermined during static analysis.", "url": "https://docs.pydantic.dev/latest/api/is-dynamic-alias-present/", "page": "pydantic/v1/mypy", "source_site": "pydantic"}
{"title": "FieldInfo", "anchor": "fieldinfo", "heading_level": 0, "md_text": "Captures extra information about a field.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/fields", "source_site": "pydantic"}
{"title": "Field", "anchor": "field", "heading_level": 0, "md_text": "Used to provide extra information about a field, either for the model schema or complex validation. Some arguments\napply only to number fields (``int``, ``float``, ``Decimal``) and some apply only to ``str``.\n\n:param default: since this is replacing the field\u2019s default, its first argument is used\n  to set the default, use ellipsis (``...``) to indicate the field is required\n:param default_factory: callable that will be called when a default value is needed for this field\n  If both `default` and `default_factory` are set, an error is raised.\n:param alias: the public name of the field\n:param title: can be any string, used in the schema\n:param description: can be any string, used in the schema\n:param exclude: exclude this field while dumping.\n  Takes same values as the ``include`` and ``exclude`` arguments on the ``.dict`` method.\n:param include: include this field while dumping.\n  Takes same values as the ``include`` and ``exclude`` arguments on the ``.dict`` method.\n:param const: this field is required and *must* take it's default value\n:param gt: only applies to numbers, requires the field to be \"greater than\". The schema\n  will have an ``exclusiveMinimum`` validation keyword\n:param ge: only applies to numbers, requires the field to be \"greater than or equal to\". The\n  schema will have a ``minimum`` validation keyword\n:param lt: only applies to numbers, requires the field to be \"less than\". The schema\n  will have an ``exclusiveMaximum`` validation keyword\n:param le: only applies to numbers, requires the field to be \"less than or equal to\". The\n  schema will have a ``maximum`` validation keyword\n:param multiple_of: only applies to numbers, requires the field to be \"a multiple of\". The\n  schema will have a ``multipleOf`` validation keyword\n:param allow_inf_nan: only applies to numbers, allows the field to be NaN or infinity (+inf or -inf),\n    which is a valid Python float. Default True, set to False for compatibility with JSON.\n:param max_digits: only applies to Decimals, requires the field to have a maximum number\n  of digits within the decimal. It does not include a zero before the decimal point or trailing decimal zeroes.\n:param decimal_places: only applies to Decimals, requires the field to have at most a number of decimal places\n  allowed. It does not include trailing decimal zeroes.\n:param min_items: only applies to lists, requires the field to have a minimum number of\n  elements. The schema will have a ``minItems`` validation keyword\n:param max_items: only applies to lists, requires the field to have a maximum number of\n  elements. The schema will have a ``maxItems`` validation keyword\n:param unique_items: only applies to lists, requires the field not to have duplicated\n  elements. The schema will have a ``uniqueItems`` validation keyword\n:param min_length: only applies to strings, requires the field to have a minimum length. The\n  schema will have a ``minLength`` validation keyword\n:param max_length: only applies to strings, requires the field to have a maximum length. The\n  schema will have a ``maxLength`` validation keyword\n:param allow_mutation: a boolean which defaults to True. When False, the field raises a TypeError if the field is\n  assigned on an instance.  The BaseModel Config must set validate_assignment to True\n:param regex: only applies to strings, requires the field match against a regular expression\n  pattern string. The schema will have a ``pattern`` validation keyword\n:param discriminator: only useful with a (discriminated a.k.a. tagged) `Union` of sub models with a common field.\n  The `discriminator` is the name of this common field to shorten validation and improve generated schema\n:param repr: show this field in the representation\n:param **extra: any additional keyword arguments will be added as is to the schema", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/fields", "source_site": "pydantic"}
{"title": "PrivateAttr", "anchor": "privateattr", "heading_level": 0, "md_text": "Indicates that attribute is only used internally and never mixed with regular fields.\n\nTypes or values of private attrs are not checked by pydantic and it's up to you to keep them relevant.\n\nPrivate attrs are stored in model __slots__.\n\n:param default: the attribute\u2019s default value\n:param default_factory: callable that will be called when a default value is needed for this attribute\n  If both `default` and `default_factory` are set, an error is raised.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/fields", "source_site": "pydantic"}
{"title": "DeferredType", "anchor": "deferredtype", "heading_level": 0, "md_text": "Used to postpone field preparation, while creating recursive generic models.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/fields", "source_site": "pydantic"}
{"title": "FieldInfo.get_constraints", "anchor": "fieldinfo-get_constraints", "heading_level": 0, "md_text": "Gets the constraints set on the field by comparing the constraint value with its default value\n\n:return: the constraints set on field_info", "url": "https://docs.pydantic.dev/latest/api/get-constraints/", "page": "pydantic/v1/fields", "source_site": "pydantic"}
{"title": "FieldInfo.update_from_config", "anchor": "fieldinfo-update_from_config", "heading_level": 0, "md_text": "Update this FieldInfo based on a dict from get_field_info, only fields which have not been set are dated.", "url": "https://docs.pydantic.dev/latest/api/update-from-config/", "page": "pydantic/v1/fields", "source_site": "pydantic"}
{"title": "ModelField._get_field_info", "anchor": "modelfield-_get_field_info", "heading_level": 0, "md_text": "Get a FieldInfo from a root typing.Annotated annotation, value, or config default.\n\nThe FieldInfo may be set in typing.Annotated or the value, but not both. If neither contain\na FieldInfo, a new one will be created using the config.\n\n:param field_name: name of the field for use in error messages\n:param annotation: a type hint such as `str` or `Annotated[str, Field(..., min_length=5)]`\n:param value: the field's assigned value\n:param config: the model's config object\n:return: the FieldInfo contained in the `annotation`, the value, or a new one from the config.", "url": "https://docs.pydantic.dev/latest/api/-get-field-info/", "page": "pydantic/v1/fields", "source_site": "pydantic"}
{"title": "ModelField.prepare", "anchor": "modelfield-prepare", "heading_level": 0, "md_text": "Prepare the field but inspecting self.default, self.type_ etc.\n\nNote: this method is **not** idempotent (because _type_analysis is not idempotent),\ne.g. calling it it multiple times may modify the field and configure it incorrectly.", "url": "https://docs.pydantic.dev/latest/api/prepare/", "page": "pydantic/v1/fields", "source_site": "pydantic"}
{"title": "ModelField._set_default_and_type", "anchor": "modelfield-_set_default_and_type", "heading_level": 0, "md_text": "Set the default value, infer the type if needed and check if `None` value is valid.", "url": "https://docs.pydantic.dev/latest/api/-set-default-and-type/", "page": "pydantic/v1/fields", "source_site": "pydantic"}
{"title": "ModelField.prepare_discriminated_union_sub_fields", "anchor": "modelfield-prepare_discriminated_union_sub_fields", "heading_level": 0, "md_text": "Prepare the mapping <discriminator key> -> <ModelField> and update `sub_fields`\nNote that this process can be aborted if a `ForwardRef` is encountered", "url": "https://docs.pydantic.dev/latest/api/prepare-discriminated-union-sub-fields/", "page": "pydantic/v1/fields", "source_site": "pydantic"}
{"title": "ModelField.populate_validators", "anchor": "modelfield-populate_validators", "heading_level": 0, "md_text": "Prepare self.pre_validators, self.validators, and self.post_validators based on self.type_'s  __get_validators__\nand class validators. This method should be idempotent, e.g. it should be safe to call multiple times\nwithout mis-configuring the field.", "url": "https://docs.pydantic.dev/latest/api/populate-validators/", "page": "pydantic/v1/fields", "source_site": "pydantic"}
{"title": "ModelField._validate_sequence_like", "anchor": "modelfield-_validate_sequence_like", "heading_level": 0, "md_text": "Validate sequence-like containers: lists, tuples, sets and generators\nNote that large if-else blocks are necessary to enable Cython\noptimization, which is why we disable the complexity check above.", "url": "https://docs.pydantic.dev/latest/api/-validate-sequence-like/", "page": "pydantic/v1/fields", "source_site": "pydantic"}
{"title": "ModelField._validate_iterable", "anchor": "modelfield-_validate_iterable", "heading_level": 0, "md_text": "Validate Iterables.\n\nThis intentionally doesn't validate values to allow infinite generators.", "url": "https://docs.pydantic.dev/latest/api/-validate-iterable/", "page": "pydantic/v1/fields", "source_site": "pydantic"}
{"title": "ModelField._get_mapping_value", "anchor": "modelfield-_get_mapping_value", "heading_level": 0, "md_text": "When type is `Mapping[KT, KV]` (or another unsupported mapping), we try to avoid\ncoercing to `dict` unwillingly.", "url": "https://docs.pydantic.dev/latest/api/-get-mapping-value/", "page": "pydantic/v1/fields", "source_site": "pydantic"}
{"title": "ModelField.is_complex", "anchor": "modelfield-is_complex", "heading_level": 0, "md_text": "Whether the field is \"complex\" eg. env variables should be parsed as JSON.", "url": "https://docs.pydantic.dev/latest/api/is-complex/", "page": "pydantic/v1/fields", "source_site": "pydantic"}
{"title": "datetime_parse", "anchor": "datetime_parse", "heading_level": 0, "md_text": "Functions to parse datetime objects.\n\nWe're using regular expressions rather than time.strptime because:\n- They provide both validation and parsing.\n- They're more flexible for datetimes.\n- The date/datetime/time constructors produce friendlier error messages.\n\nStolen from https://raw.githubusercontent.com/django/django/main/django/utils/dateparse.py at\n9718fa2e8abe430c3526a9278dd976443d4ae3c6\n\nChanged to:\n* use standard python datetime types not django.utils.timezone\n* raise ValueError when regex doesn't match rather than returning None\n* support parsing unix timestamps for dates and datetimes", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/datetime_parse", "source_site": "pydantic"}
{"title": "parse_date", "anchor": "parse_date", "heading_level": 0, "md_text": "Parse a date/int/float/string and return a datetime.date.\n\nRaise ValueError if the input is well formatted but not a valid date.\nRaise ValueError if the input isn't well formatted.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/datetime_parse", "source_site": "pydantic"}
{"title": "parse_time", "anchor": "parse_time", "heading_level": 0, "md_text": "Parse a time/string and return a datetime.time.\n\nRaise ValueError if the input is well formatted but not a valid time.\nRaise ValueError if the input isn't well formatted, in particular if it contains an offset.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/datetime_parse", "source_site": "pydantic"}
{"title": "parse_datetime", "anchor": "parse_datetime", "heading_level": 0, "md_text": "Parse a datetime/int/float/string and return a datetime.datetime.\n\nThis function supports time zone offsets. When the input contains one,\nthe output uses a timezone with a fixed offset from UTC.\n\nRaise ValueError if the input is well formatted but not a valid datetime.\nRaise ValueError if the input isn't well formatted.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/datetime_parse", "source_site": "pydantic"}
{"title": "parse_duration", "anchor": "parse_duration", "heading_level": 0, "md_text": "Parse a duration int/float/string and return a datetime.timedelta.\n\nThe preferred format for durations in Django is '%d %H:%M:%S.%f'.\n\nAlso supports ISO 8601 representation.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/datetime_parse", "source_site": "pydantic"}
{"title": "cls_kwargs", "anchor": "cls_kwargs", "heading_level": 0, "md_text": "For built-in exceptions like ValueError or TypeError, we need to implement\n__reduce__ to override the default behaviour (instead of __getstate__/__setstate__)\nBy default pickle protocol 2 calls `cls.__new__(cls, *args)`.\nSince we only use kwargs, we need a little constructor to change that.\nNote: the callable can't be a lambda as pickle looks in the namespace to find it", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/errors", "source_site": "pydantic"}
{"title": "import_string", "anchor": "import_string", "heading_level": 0, "md_text": "Stolen approximately from django. Import a dotted module path and return the attribute/class designated by the\nlast name in the path. Raise ImportError if the import fails.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/utils", "source_site": "pydantic"}
{"title": "truncate", "anchor": "truncate", "heading_level": 0, "md_text": "Truncate a value and add a unicode ellipsis (three dots) to the end if it was too long", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/utils", "source_site": "pydantic"}
{"title": "validate_field_name", "anchor": "validate_field_name", "heading_level": 0, "md_text": "Ensure that the field's name does not shadow an existing attribute of the model.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/utils", "source_site": "pydantic"}
{"title": "in_ipython", "anchor": "in_ipython", "heading_level": 0, "md_text": "Check whether we're in an ipython environment, including jupyter notebooks.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/utils", "source_site": "pydantic"}
{"title": "is_valid_identifier", "anchor": "is_valid_identifier", "heading_level": 0, "md_text": "Checks that a string is a valid identifier and not a Python keyword.\n:param identifier: The identifier to test.\n:return: True if the identifier is valid.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/utils", "source_site": "pydantic"}
{"title": "almost_equal_floats", "anchor": "almost_equal_floats", "heading_level": 0, "md_text": "Return True if two floats are almost equal", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/utils", "source_site": "pydantic"}
{"title": "generate_model_signature", "anchor": "generate_model_signature", "heading_level": 0, "md_text": "Generate signature for model based on its fields", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/utils", "source_site": "pydantic"}
{"title": "unique_list", "anchor": "unique_list", "heading_level": 0, "md_text": "Make a list unique while maintaining order.\nWe update the list if another one with the same name is set\n(e.g. root validator overridden in subclass)", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/utils", "source_site": "pydantic"}
{"title": "PyObjectStr", "anchor": "pyobjectstr", "heading_level": 0, "md_text": "String class where repr doesn't include quotes. Useful with Representation when you want to return a string\nrepresentation of something that valid (or pseudo-valid) python.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/utils", "source_site": "pydantic"}
{"title": "Representation", "anchor": "representation", "heading_level": 0, "md_text": "Mixin to provide __str__, __repr__, and __pretty__ methods. See #884 for more details.\n\n__pretty__ is used by [devtools](https://python-devtools.helpmanual.io/) to provide human readable representations\nof objects.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/utils", "source_site": "pydantic"}
{"title": "GetterDict", "anchor": "getterdict", "heading_level": 0, "md_text": "Hack to make object's smell just enough like dicts for validate_model.\n\nWe can't inherit from Mapping[str, Any] because it upsets cython so we have to implement all methods ourselves.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/utils", "source_site": "pydantic"}
{"title": "ValueItems", "anchor": "valueitems", "heading_level": 0, "md_text": "Class for more convenient calculation of excluded or included fields on values.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/utils", "source_site": "pydantic"}
{"title": "ClassAttribute", "anchor": "classattribute", "heading_level": 0, "md_text": "Hide class attribute from its instances", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/utils", "source_site": "pydantic"}
{"title": "path_type", "anchor": "path_type", "heading_level": 0, "md_text": "Find out what sort of thing a path is.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/utils", "source_site": "pydantic"}
{"title": "smart_deepcopy", "anchor": "smart_deepcopy", "heading_level": 0, "md_text": "Return type as is for immutable built-in types\nUse obj.copy() for built-in empty collections\nUse copy.deepcopy() for non-empty collections and unknown objects", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/utils", "source_site": "pydantic"}
{"title": "all_identical", "anchor": "all_identical", "heading_level": 0, "md_text": "Check that the items of `left` are the same objects as those in `right`.\n\n>>> a, b = object(), object()\n>>> all_identical([a, b, a], [a, b, a])\nTrue\n>>> all_identical([a, b, [a]], [a, b, [a]])  # new list object, while \"equal\" is not \"identical\"\nFalse", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/utils", "source_site": "pydantic"}
{"title": "assert_never", "anchor": "assert_never", "heading_level": 0, "md_text": "Helper to make sure that we have covered all possible types.\n\nThis is mostly useful for ``mypy``, docs:\nhttps://mypy.readthedocs.io/en/latest/literal_types.html#exhaustive-checks", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/utils", "source_site": "pydantic"}
{"title": "get_unique_discriminator_alias", "anchor": "get_unique_discriminator_alias", "heading_level": 0, "md_text": "Validate that all aliases are the same and if that's the case return the alias", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/utils", "source_site": "pydantic"}
{"title": "get_discriminator_alias_and_values", "anchor": "get_discriminator_alias_and_values", "heading_level": 0, "md_text": "Get alias and all valid values in the `Literal` type of the discriminator field\n`tp` can be a `BaseModel` class or directly an `Annotated` `Union` of many.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/utils", "source_site": "pydantic"}
{"title": "Representation.__repr_args__", "anchor": "representation-__repr_args__", "heading_level": 0, "md_text": "Returns the attributes to show in __str__, __repr__, and __pretty__ this is generally overridden.\n\nCan either return:\n* name - value pairs, e.g.: `[('foo_name', 'foo'), ('bar_name', ['b', 'a', 'r'])]`\n* or, just values, e.g.: `[(None, 'foo'), (None, ['b', 'a', 'r'])]`", "url": "https://docs.pydantic.dev/latest/api/--repr-args--/", "page": "pydantic/v1/utils", "source_site": "pydantic"}
{"title": "Representation.__repr_name__", "anchor": "representation-__repr_name__", "heading_level": 0, "md_text": "Name of the instance's class, used in __repr__.", "url": "https://docs.pydantic.dev/latest/api/--repr-name--/", "page": "pydantic/v1/utils", "source_site": "pydantic"}
{"title": "Representation.__pretty__", "anchor": "representation-__pretty__", "heading_level": 0, "md_text": "Used by devtools (https://python-devtools.helpmanual.io/) to provide a human readable representations of objects", "url": "https://docs.pydantic.dev/latest/api/--pretty--/", "page": "pydantic/v1/utils", "source_site": "pydantic"}
{"title": "Representation.__rich_repr__", "anchor": "representation-__rich_repr__", "heading_level": 0, "md_text": "Get fields for Rich library", "url": "https://docs.pydantic.dev/latest/api/--rich-repr--/", "page": "pydantic/v1/utils", "source_site": "pydantic"}
{"title": "GetterDict.extra_keys", "anchor": "getterdict-extra_keys", "heading_level": 0, "md_text": "We don't want to get any other attributes of obj if the model didn't explicitly ask for them", "url": "https://docs.pydantic.dev/latest/api/extra-keys/", "page": "pydantic/v1/utils", "source_site": "pydantic"}
{"title": "GetterDict.keys", "anchor": "getterdict-keys", "heading_level": 0, "md_text": "Keys of the pseudo dictionary, uses a list not set so order information can be maintained like python\ndictionaries.", "url": "https://docs.pydantic.dev/latest/api/keys/", "page": "pydantic/v1/utils", "source_site": "pydantic"}
{"title": "ValueItems.is_excluded", "anchor": "valueitems-is_excluded", "heading_level": 0, "md_text": "Check if item is fully excluded.\n\n:param item: key or index of a value", "url": "https://docs.pydantic.dev/latest/api/is-excluded/", "page": "pydantic/v1/utils", "source_site": "pydantic"}
{"title": "ValueItems.is_included", "anchor": "valueitems-is_included", "heading_level": 0, "md_text": "Check if value is contained in self._items\n\n:param item: key or index of value", "url": "https://docs.pydantic.dev/latest/api/is-included/", "page": "pydantic/v1/utils", "source_site": "pydantic"}
{"title": "ValueItems.for_element", "anchor": "valueitems-for_element", "heading_level": 0, "md_text": ":param e: key or index of element on value\n:return: raw values for element if self._items is dict and contain needed element", "url": "https://docs.pydantic.dev/latest/api/for-element/", "page": "pydantic/v1/utils", "source_site": "pydantic"}
{"title": "ValueItems._normalize_indexes", "anchor": "valueitems-_normalize_indexes", "heading_level": 0, "md_text": ":param items: dict or set of indexes which will be normalized\n:param v_length: length of sequence indexes of which will be\n\n>>> self._normalize_indexes({0: True, -2: True, -1: True}, 4)\n{0: True, 2: True, 3: True}\n>>> self._normalize_indexes({'__all__': True}, 4)\n{0: True, 1: True, 2: True, 3: True}", "url": "https://docs.pydantic.dev/latest/api/-normalize-indexes/", "page": "pydantic/v1/utils", "source_site": "pydantic"}
{"title": "ValueItems.merge", "anchor": "valueitems-merge", "heading_level": 0, "md_text": "Merge a ``base`` item with an ``override`` item.\n\nBoth ``base`` and ``override`` are converted to dictionaries if possible.\nSets are converted to dictionaries with the sets entries as keys and\nEllipsis as values.\n\nEach key-value pair existing in ``base`` is merged with ``override``,\nwhile the rest of the key-value pairs are updated recursively with this function.\n\nMerging takes place based on the \"union\" of keys if ``intersect`` is\nset to ``False`` (default) and on the intersection of keys if\n``intersect`` is set to ``True``.", "url": "https://docs.pydantic.dev/latest/api/merge/", "page": "pydantic/v1/utils", "source_site": "pydantic"}
{"title": "schema_of", "anchor": "schema_of", "heading_level": 0, "md_text": "Generate a JSON schema (as dict) for the passed model or dynamically generated one", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/tools", "source_site": "pydantic"}
{"title": "schema_json_of", "anchor": "schema_json_of", "heading_level": 0, "md_text": "Generate a JSON schema (as JSON) for the passed model or dynamically generated one", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/tools", "source_site": "pydantic"}
{"title": "validator", "anchor": "validator", "heading_level": 0, "md_text": "Decorate methods on the class indicating that they should be used to validate fields\n:param fields: which field(s) the method should be called on\n:param pre: whether or not this validator should be called before the standard validators (else after)\n:param each_item: for complex objects (sets, lists etc.) whether to validate individual elements rather than the\n  whole object\n:param always: whether this method and other validators should be called even if the value is missing\n:param check_fields: whether to check that the fields actually exist on the model\n:param allow_reuse: whether to track and raise an error if another validator refers to the decorated function", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/class_validators", "source_site": "pydantic"}
{"title": "root_validator", "anchor": "root_validator", "heading_level": 0, "md_text": "Decorate methods on a model indicating that they should be used to validate (and perhaps modify) data either\nbefore or after standard model parsing/validation is performed.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/class_validators", "source_site": "pydantic"}
{"title": "_prepare_validator", "anchor": "_prepare_validator", "heading_level": 0, "md_text": "Avoid validators with duplicated names since without this, validators can be overwritten silently\nwhich generally isn't the intended behaviour, don't run in ipython (see #312) or if allow_reuse is False.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/class_validators", "source_site": "pydantic"}
{"title": "make_generic_validator", "anchor": "make_generic_validator", "heading_level": 0, "md_text": "Make a generic function which calls a validator with the right arguments.\n\nUnfortunately other approaches (eg. return a partial of a function that builds the arguments) is slow,\nhence this laborious way of doing things.\n\nIt's done like this so validators don't all need **kwargs in their signature, eg. any combination of\nthe arguments \"values\", \"fields\" and/or \"config\" are permitted.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/class_validators", "source_site": "pydantic"}
{"title": "create_model_from_typeddict", "anchor": "create_model_from_typeddict", "heading_level": 0, "md_text": "Create a `BaseModel` based on the fields of a `TypedDict`.\nSince `typing.TypedDict` in Python 3.8 does not store runtime information about optional keys,\nwe raise an error if this happens (see https://bugs.python.org/issue38834).", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/annotated_types", "source_site": "pydantic"}
{"title": "create_model_from_namedtuple", "anchor": "create_model_from_namedtuple", "heading_level": 0, "md_text": "Create a `BaseModel` based on the fields of a named tuple.\nA named tuple can be created with `typing.NamedTuple` and declared annotations\nbut also with `collections.namedtuple`, in this case we consider all fields\nto have type `Any`.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/annotated_types", "source_site": "pydantic"}
{"title": "multi_host_url_regex", "anchor": "multi_host_url_regex", "heading_level": 0, "md_text": "Compiled multi host url regex.\n\nAdditionally to `url_regex` it allows to match multiple hosts.\nE.g. host1.db.net,host2.db.net", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/networks", "source_site": "pydantic"}
{"title": "validate_email", "anchor": "validate_email", "heading_level": 0, "md_text": "Email address validation using https://pypi.org/project/email-validator/\nNotes:\n* raw ip address (literal) domain parts are not allowed.\n* \"John Doe <local_part@domain.com>\" style \"pretty\" email addresses are processed\n* spaces are striped from the beginning and end of addresses but no error is raised", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/networks", "source_site": "pydantic"}
{"title": "AnyUrl._build_url", "anchor": "anyurl-_build_url", "heading_level": 0, "md_text": "Validate hosts and build the AnyUrl object. Split from `validate` so this method\ncan be altered in `MultiHostDsn`.", "url": "https://docs.pydantic.dev/latest/api/-build-url/", "page": "pydantic/v1/networks", "source_site": "pydantic"}
{"title": "AnyUrl.validate_parts", "anchor": "anyurl-validate_parts", "heading_level": 0, "md_text": "A method used to validate parts of a URL.\nCould be overridden to set default values for parts if missing", "url": "https://docs.pydantic.dev/latest/api/validate-parts/", "page": "pydantic/v1/networks", "source_site": "pydantic"}
{"title": "create_model", "anchor": "create_model", "heading_level": 0, "md_text": "Dynamically create a model.\n:param __model_name: name of the created model\n:param __config__: config class to use for the new model\n:param __base__: base class for the new model to inherit from\n:param __module__: module of the created model\n:param __validators__: a dict of method names and @validator class methods\n:param __cls_kwargs__: a dict for class creation\n:param __slots__: Deprecated, `__slots__` should not be passed to `create_model`\n:param field_definitions: fields of the model (or extra fields if a base is supplied)\n    in the format `<name>=(<type>, <default default>)` or `<name>=<default value>, e.g.\n    `foobar=(str, ...)` or `foobar=123`, or, for complex use-cases, in the format\n    `<name>=<Field>` or `<name>=(<type>, <FieldInfo>)`, e.g.\n    `foo=Field(datetime, default_factory=datetime.utcnow, alias='bar')` or\n    `foo=(str, FieldInfo(title='Foo'))`", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/main", "source_site": "pydantic"}
{"title": "validate_model", "anchor": "validate_model", "heading_level": 0, "md_text": "validate data against a model.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/main", "source_site": "pydantic"}
{"title": "ModelMetaclass.__instancecheck__", "anchor": "modelmetaclass-__instancecheck__", "heading_level": 0, "md_text": "Avoid calling ABC _abc_subclasscheck unless we're pretty sure.\n\nSee #3829 and python/cpython#92810", "url": "https://docs.pydantic.dev/latest/api/--instancecheck--/", "page": "pydantic/v1/main", "source_site": "pydantic"}
{"title": "BaseModel.__init__", "anchor": "basemodel-__init__", "heading_level": 0, "md_text": "Create a new model by parsing and validating input data from keyword arguments.\n\nRaises ValidationError if the input data cannot be parsed to form a valid model.", "url": "https://docs.pydantic.dev/latest/api/--init--/", "page": "pydantic/v1/main", "source_site": "pydantic"}
{"title": "BaseModel.dict", "anchor": "basemodel-dict", "heading_level": 0, "md_text": "Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.", "url": "https://docs.pydantic.dev/latest/api/dict/", "page": "pydantic/v1/main", "source_site": "pydantic"}
{"title": "BaseModel.json", "anchor": "basemodel-json", "heading_level": 0, "md_text": "Generate a JSON representation of the model, `include` and `exclude` arguments as per `dict()`.\n\n`encoder` is an optional function to supply as `default` to json.dumps(), other arguments as per `json.dumps()`.", "url": "https://docs.pydantic.dev/latest/api/json/", "page": "pydantic/v1/main", "source_site": "pydantic"}
{"title": "BaseModel.construct", "anchor": "basemodel-construct", "heading_level": 0, "md_text": "Creates a new model setting __dict__ and __fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\nBehaves as if `Config.extra = 'allow'` was set since it adds all passed values", "url": "https://docs.pydantic.dev/latest/api/construct/", "page": "pydantic/v1/main", "source_site": "pydantic"}
{"title": "BaseModel.copy", "anchor": "basemodel-copy", "heading_level": 0, "md_text": "Duplicate a model, optionally choose which fields to include, exclude and change.\n\n:param include: fields to include in new model\n:param exclude: fields to exclude from new model, as with values this takes precedence over include\n:param update: values to change/add in the new model. Note: the data is not validated before creating\n    the new model: you should trust this data\n:param deep: set to `True` to make a deep copy of the model\n:return: new model instance", "url": "https://docs.pydantic.dev/latest/api/copy/", "page": "pydantic/v1/main", "source_site": "pydantic"}
{"title": "BaseModel.__try_update_forward_refs__", "anchor": "basemodel-__try_update_forward_refs__", "heading_level": 0, "md_text": "Same as update_forward_refs but will not raise exception\nwhen forward references are not defined.", "url": "https://docs.pydantic.dev/latest/api/--try-update-forward-refs--/", "page": "pydantic/v1/main", "source_site": "pydantic"}
{"title": "BaseModel.update_forward_refs", "anchor": "basemodel-update_forward_refs", "heading_level": 0, "md_text": "Try to update ForwardRefs on fields based on this Model, globalns and localns.", "url": "https://docs.pydantic.dev/latest/api/update-forward-refs/", "page": "pydantic/v1/main", "source_site": "pydantic"}
{"title": "BaseModel.__iter__", "anchor": "basemodel-__iter__", "heading_level": 0, "md_text": "so `dict(model)` works", "url": "https://docs.pydantic.dev/latest/api/--iter--/", "page": "pydantic/v1/main", "source_site": "pydantic"}
{"title": "constant_validator", "anchor": "constant_validator", "heading_level": 0, "md_text": "Validate ``const`` fields.\n\nThe value provided for a ``const`` field must be equal to the default value\nof the field. This is to support the keyword of the same name in JSON\nSchema.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/validators", "source_site": "pydantic"}
{"title": "ip_v4_network_validator", "anchor": "ip_v4_network_validator", "heading_level": 0, "md_text": "Assume IPv4Network initialised with a default ``strict`` argument\n\nSee more:\nhttps://docs.python.org/library/ipaddress.html#ipaddress.IPv4Network", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/validators", "source_site": "pydantic"}
{"title": "ip_v6_network_validator", "anchor": "ip_v6_network_validator", "heading_level": 0, "md_text": "Assume IPv6Network initialised with a default ``strict`` argument\n\nSee more:\nhttps://docs.python.org/library/ipaddress.html#ipaddress.IPv6Network", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/validators", "source_site": "pydantic"}
{"title": "callable_validator", "anchor": "callable_validator", "heading_level": 0, "md_text": "Perform a simple check if the value is callable.\n\nNote: complete matching of argument type hints and return types is not performed", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/validators", "source_site": "pydantic"}
{"title": "SecretField", "anchor": "secretfield", "heading_level": 0, "md_text": "Note: this should be implemented as a generic like `SecretField(ABC, Generic[T])`,\n      the `__init__()` should be part of the abstract class and the\n      `get_secret_value()` method should use the generic `T` type.\n\n      However Cython doesn't support very well generics at the moment and\n      the generated code fails to be imported (see\n      https://github.com/cython/cython/issues/2753).", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/types", "source_site": "pydantic"}
{"title": "PaymentCardNumber", "anchor": "paymentcardnumber", "heading_level": 0, "md_text": "Based on: https://en.wikipedia.org/wiki/Payment_card_number", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/types", "source_site": "pydantic"}
{"title": "StrictBool", "anchor": "strictbool", "heading_level": 0, "md_text": "StrictBool to allow for bools which are not type-coerced.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/types", "source_site": "pydantic"}
{"title": "PaymentCardNumber.validate_luhn_check_digit", "anchor": "paymentcardnumber-validate_luhn_check_digit", "heading_level": 0, "md_text": "Based on: https://en.wikipedia.org/wiki/Luhn_algorithm", "url": "https://docs.pydantic.dev/latest/api/validate-luhn-check-digit/", "page": "pydantic/v1/types", "source_site": "pydantic"}
{"title": "PaymentCardNumber.validate_length_for_brand", "anchor": "paymentcardnumber-validate_length_for_brand", "heading_level": 0, "md_text": "Validate length based on BIN for major brands:\nhttps://en.wikipedia.org/wiki/Payment_card_number#Issuer_identification_number_(IIN)", "url": "https://docs.pydantic.dev/latest/api/validate-length-for-brand/", "page": "pydantic/v1/types", "source_site": "pydantic"}
{"title": "StrictBool.validate", "anchor": "strictbool-validate", "heading_level": 0, "md_text": "Ensure that we only allow bools.", "url": "https://docs.pydantic.dev/latest/api/validate/", "page": "pydantic/v1/types", "source_site": "pydantic"}
{"title": "resolve_annotations", "anchor": "resolve_annotations", "heading_level": 0, "md_text": "Partially taken from typing.get_type_hints.\n\nResolve string or ForwardRef annotations into type objects if possible.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/typing", "source_site": "pydantic"}
{"title": "all_literal_values", "anchor": "all_literal_values", "heading_level": 0, "md_text": "This method is used to retrieve all Literal values as\nLiteral can be used recursively (see https://www.python.org/dev/peps/pep-0586)\ne.g. `Literal[Literal[Literal[1, 2, 3], \"foo\"], 5, None]`", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/typing", "source_site": "pydantic"}
{"title": "is_namedtuple", "anchor": "is_namedtuple", "heading_level": 0, "md_text": "Check if a given class is a named tuple.\nIt can be either a `typing.NamedTuple` or `collections.namedtuple`", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/typing", "source_site": "pydantic"}
{"title": "is_typeddict", "anchor": "is_typeddict", "heading_level": 0, "md_text": "Check if a given class is a typed dict (from `typing` or `typing_extensions`)\nIn 3.10, there will be a public method (https://docs.python.org/3.10/library/typing.html#typing.is_typeddict)", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/typing", "source_site": "pydantic"}
{"title": "is_typeddict_special", "anchor": "is_typeddict_special", "heading_level": 0, "md_text": "Check if type is a TypedDict special form (Required or NotRequired).", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/typing", "source_site": "pydantic"}
{"title": "is_new_type", "anchor": "is_new_type", "heading_level": 0, "md_text": "Check whether type_ was created using typing.NewType", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/typing", "source_site": "pydantic"}
{"title": "_check_finalvar", "anchor": "_check_finalvar", "heading_level": 0, "md_text": "Check if a given type is a `typing.Final` type.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/typing", "source_site": "pydantic"}
{"title": "update_field_forward_refs", "anchor": "update_field_forward_refs", "heading_level": 0, "md_text": "Try to update ForwardRefs on fields based on this ModelField, globalns and localns.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/typing", "source_site": "pydantic"}
{"title": "update_model_forward_refs", "anchor": "update_model_forward_refs", "heading_level": 0, "md_text": "Try to update model fields ForwardRefs based on model and localns.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/typing", "source_site": "pydantic"}
{"title": "get_class", "anchor": "get_class", "heading_level": 0, "md_text": "Tries to get the class of a Type[T] annotation. Returns True if Type is used\nwithout brackets. Otherwise returns None.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/typing", "source_site": "pydantic"}
{"title": "get_sub_types", "anchor": "get_sub_types", "heading_level": 0, "md_text": "Return all the types that are allowed by type `tp`\n`tp` can be a `Union` of allowed types or an `Annotated` type", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/typing", "source_site": "pydantic"}
{"title": "get_origin", "anchor": "get_origin", "heading_level": 0, "md_text": "We can't directly use `typing.get_origin` since we need a fallback to support\ncustom generic classes like `ConstrainedList`\nIt should be useless once https://github.com/cython/cython/issues/3537 is\nsolved and https://github.com/pydantic/pydantic/pull/1753 is merged.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/typing", "source_site": "pydantic"}
{"title": "get_args", "anchor": "get_args", "heading_level": 0, "md_text": "Compatibility version of get_args for python 3.7.\n\nMostly compatible with the python 3.8 `typing` module version\nand able to handle almost all use cases.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/typing", "source_site": "pydantic"}
{"title": "_generic_get_args", "anchor": "_generic_get_args", "heading_level": 0, "md_text": "In python 3.9, `typing.Dict`, `typing.List`, ...\ndo have an empty `__args__` by default (instead of the generic ~T for example).\nIn order to still support `Dict` for example and consider it as `Dict[Any, Any]`,\nwe retrieve the `_nparams` value that tells us how many parameters it needs.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/typing", "source_site": "pydantic"}
{"title": "get_args", "anchor": "get_args", "heading_level": 0, "md_text": "Get type arguments with all substitutions performed.\n\nFor unions, basic simplifications used by Union constructor are performed.\nExamples::\n    get_args(Dict[str, int]) == (str, int)\n    get_args(int) == ()\n    get_args(Union[int, Union[T, int], str][int]) == (int, str)\n    get_args(Union[int, Tuple[T, int]][str]) == (int, Tuple[str, int])\n    get_args(Callable[[], T][int]) == ([], int)", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/typing", "source_site": "pydantic"}
{"title": "convert_generics", "anchor": "convert_generics", "heading_level": 0, "md_text": "Python 3.9 and older only supports generics from `typing` module.\nThey convert strings to ForwardRef automatically.\n\nExamples::\n    typing.List['Hero'] == typing.List[ForwardRef('Hero')]", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/typing", "source_site": "pydantic"}
{"title": "convert_generics", "anchor": "convert_generics", "heading_level": 0, "md_text": "Recursively searches for `str` type hints and replaces them with ForwardRef.\n\nExamples::\n    convert_generics(list['Hero']) == list[ForwardRef('Hero')]\n    convert_generics(dict['Hero', 'Team']) == dict[ForwardRef('Hero'), ForwardRef('Team')]\n    convert_generics(typing.Dict['Hero', 'Team']) == typing.Dict[ForwardRef('Hero'), ForwardRef('Team')]\n    convert_generics(list[str | 'Hero'] | int) == list[str | ForwardRef('Hero')] | int", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/typing", "source_site": "pydantic"}
{"title": "replace_types", "anchor": "replace_types", "heading_level": 0, "md_text": "Return type with all occurrences of `type_map` keys recursively replaced with their values.\n\n:param type_: Any type, class or generic alias\n:param type_map: Mapping from `TypeVar` instance to concrete types.\n:return: New type representing the basic structure of `type_` with all\n    `typevar_map` keys recursively replaced.\n\n>>> replace_types(Tuple[str, Union[List[str], float]], {str: int})\nTuple[int, Union[List[int], float]]", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/generics", "source_site": "pydantic"}
{"title": "iter_contained_typevars", "anchor": "iter_contained_typevars", "heading_level": 0, "md_text": "Recursively iterate through all subtypes and type args of `v` and yield any typevars that are found.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/generics", "source_site": "pydantic"}
{"title": "get_caller_frame_info", "anchor": "get_caller_frame_info", "heading_level": 0, "md_text": "Used inside a function to check whether it was called globally\n\nWill only work against non-compiled code, therefore used only in pydantic.generics\n\n:returns Tuple[module_name, called_globally]", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/generics", "source_site": "pydantic"}
{"title": "_prepare_model_fields", "anchor": "_prepare_model_fields", "heading_level": 0, "md_text": "Replace DeferredType fields with concrete type hints and prepare them.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/generics", "source_site": "pydantic"}
{"title": "GenericModel.__class_getitem__", "anchor": "genericmodel-__class_getitem__", "heading_level": 0, "md_text": "Instantiates a new class from a generic class `cls` and type variables `params`.\n\n:param params: Tuple of types the class . Given a generic class\n    `Model` with 2 type variables and a concrete model `Model[str, int]`,\n    the value `(str, int)` would be passed to `params`.\n:return: New model class inheriting from `cls` with instantiated\n    types described by `params`. If no parameters are given, `cls` is\n    returned as is.", "url": "https://docs.pydantic.dev/latest/api/--class-getitem--/", "page": "pydantic/v1/generics", "source_site": "pydantic"}
{"title": "GenericModel.__concrete_name__", "anchor": "genericmodel-__concrete_name__", "heading_level": 0, "md_text": "Compute class name for child classes.\n\n:param params: Tuple of types the class . Given a generic class\n    `Model` with 2 type variables and a concrete model `Model[str, int]`,\n    the value `(str, int)` would be passed to `params`.\n:return: String representing a the new class where `params` are\n    passed to `cls` as type variables.\n\nThis method can be overridden to achieve a custom naming scheme for GenericModels.", "url": "https://docs.pydantic.dev/latest/api/--concrete-name--/", "page": "pydantic/v1/generics", "source_site": "pydantic"}
{"title": "GenericModel.__parameterized_bases__", "anchor": "genericmodel-__parameterized_bases__", "heading_level": 0, "md_text": "Returns unbound bases of cls parameterised to given type variables\n\n:param typevars_map: Dictionary of type applications for binding subclasses.\n    Given a generic class `Model` with 2 type variables [S, T]\n    and a concrete model `Model[str, int]`,\n    the value `{S: str, T: int}` would be passed to `typevars_map`.\n:return: an iterator of generic sub classes, parameterised by `typevars_map`\n    and other assigned parameters of `cls`\n\ne.g.:\n```\nclass A(GenericModel, Generic[T]):\n    ...\n\nclass B(A[V], Generic[V]):\n    ...\n\nassert A[int] in B.__parameterized_bases__({V: int})\n```", "url": "https://docs.pydantic.dev/latest/api/--parameterized-bases--/", "page": "pydantic/v1/generics", "source_site": "pydantic"}
{"title": "_hypothesis_plugin", "anchor": "_hypothesis_plugin", "heading_level": 0, "md_text": "Register Hypothesis strategies for Pydantic custom types.\n\nThis enables fully-automatic generation of test data for most Pydantic classes.\n\nNote that this module has *no* runtime impact on Pydantic itself; instead it\nis registered as a setuptools entry point and Hypothesis will import it if\nPydantic is installed.  See also:\n\nhttps://hypothesis.readthedocs.io/en/latest/strategies.html#registering-strategies-via-setuptools-entry-points\nhttps://hypothesis.readthedocs.io/en/latest/data.html#hypothesis.strategies.register_type_strategy\nhttps://hypothesis.readthedocs.io/en/latest/strategies.html#interaction-with-pytest-cov\nhttps://docs.pydantic.dev/usage/types/#pydantic-types\n\nNote that because our motivation is to *improve user experience*, the strategies\nare always sound (never generate invalid data) but sacrifice completeness for\nmaintainability (ie may be unable to generate some tricky but valid data).\n\nFinally, this module makes liberal use of `# type: ignore[<code>]` pragmas.\nThis is because Hypothesis annotates `register_type_strategy()` with\n`(T, SearchStrategy[T])`, but in most cases we register e.g. `ConstrainedInt`\nto generate instances of the builtin `int` type which match the constraints.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/_hypothesis_plugin", "source_site": "pydantic"}
{"title": "schema", "anchor": "schema", "heading_level": 0, "md_text": "Process a list of models and generate a single JSON Schema with all of them defined in the ``definitions``\ntop-level JSON key, including their sub-models.\n\n:param models: a list of models to include in the generated JSON Schema\n:param by_alias: generate the schemas using the aliases defined, if any\n:param title: title for the generated schema that includes the definitions\n:param description: description for the generated schema\n:param ref_prefix: the JSON Pointer prefix for schema references with ``$ref``, if None, will be set to the\n  default of ``#/definitions/``. Update it if you want the schemas to reference the definitions somewhere\n  else, e.g. for OpenAPI use ``#/components/schemas/``. The resulting generated schemas will still be at the\n  top-level key ``definitions``, so you can extract them from there. But all the references will have the set\n  prefix.\n:param ref_template: Use a ``string.format()`` template for ``$ref`` instead of a prefix. This can be useful\n  for references that cannot be represented by ``ref_prefix`` such as a definition stored in another file. For\n  a sibling json file in a ``/schemas`` directory use ``\"/schemas/${model}.json#\"``.\n:return: dict with the JSON Schema with a ``definitions`` top-level key including the schema definitions for\n  the models and sub-models passed in ``models``.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/schema", "source_site": "pydantic"}
{"title": "model_schema", "anchor": "model_schema", "heading_level": 0, "md_text": "Generate a JSON Schema for one model. With all the sub-models defined in the ``definitions`` top-level\nJSON key.\n\n:param model: a Pydantic model (a class that inherits from BaseModel)\n:param by_alias: generate the schemas using the aliases defined, if any\n:param ref_prefix: the JSON Pointer prefix for schema references with ``$ref``, if None, will be set to the\n  default of ``#/definitions/``. Update it if you want the schemas to reference the definitions somewhere\n  else, e.g. for OpenAPI use ``#/components/schemas/``. The resulting generated schemas will still be at the\n  top-level key ``definitions``, so you can extract them from there. But all the references will have the set\n  prefix.\n:param ref_template: Use a ``string.format()`` template for ``$ref`` instead of a prefix. This can be useful for\n  references that cannot be represented by ``ref_prefix`` such as a definition stored in another file. For a\n  sibling json file in a ``/schemas`` directory use ``\"/schemas/${model}.json#\"``.\n:return: dict with the JSON Schema for the passed ``model``", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/schema", "source_site": "pydantic"}
{"title": "field_schema", "anchor": "field_schema", "heading_level": 0, "md_text": "Process a Pydantic field and return a tuple with a JSON Schema for it as the first item.\nAlso return a dictionary of definitions with models as keys and their schemas as values. If the passed field\nis a model and has sub-models, and those sub-models don't have overrides (as ``title``, ``default``, etc), they\nwill be included in the definitions and referenced in the schema instead of included recursively.\n\n:param field: a Pydantic ``ModelField``\n:param by_alias: use the defined alias (if any) in the returned schema\n:param model_name_map: used to generate the JSON Schema references to other models included in the definitions\n:param ref_prefix: the JSON Pointer prefix to use for references to other schemas, if None, the default of\n  #/definitions/ will be used\n:param ref_template: Use a ``string.format()`` template for ``$ref`` instead of a prefix. This can be useful for\n  references that cannot be represented by ``ref_prefix`` such as a definition stored in another file. For a\n  sibling json file in a ``/schemas`` directory use ``\"/schemas/${model}.json#\"``.\n:param known_models: used to solve circular references\n:return: tuple of the schema for this field and additional definitions", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/schema", "source_site": "pydantic"}
{"title": "get_field_schema_validations", "anchor": "get_field_schema_validations", "heading_level": 0, "md_text": "Get the JSON Schema validation keywords for a ``field`` with an annotation of\na Pydantic ``FieldInfo`` with validation arguments.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/schema", "source_site": "pydantic"}
{"title": "get_model_name_map", "anchor": "get_model_name_map", "heading_level": 0, "md_text": "Process a set of models and generate unique names for them to be used as keys in the JSON Schema\ndefinitions. By default the names are the same as the class name. But if two models in different Python\nmodules have the same name (e.g. \"users.Model\" and \"items.Model\"), the generated names will be\nbased on the Python module path for those conflicting models to prevent name collisions.\n\n:param unique_models: a Python set of models\n:return: dict mapping models to names", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/schema", "source_site": "pydantic"}
{"title": "get_flat_models_from_model", "anchor": "get_flat_models_from_model", "heading_level": 0, "md_text": "Take a single ``model`` and generate a set with itself and all the sub-models in the tree. I.e. if you pass\nmodel ``Foo`` (subclass of Pydantic ``BaseModel``) as ``model``, and it has a field of type ``Bar`` (also\nsubclass of ``BaseModel``) and that model ``Bar`` has a field of type ``Baz`` (also subclass of ``BaseModel``),\nthe return value will be ``set([Foo, Bar, Baz])``.\n\n:param model: a Pydantic ``BaseModel`` subclass\n:param known_models: used to solve circular references\n:return: a set with the initial model and all its sub-models", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/schema", "source_site": "pydantic"}
{"title": "get_flat_models_from_field", "anchor": "get_flat_models_from_field", "heading_level": 0, "md_text": "Take a single Pydantic ``ModelField`` (from a model) that could have been declared as a subclass of BaseModel\n(so, it could be a submodel), and generate a set with its model and all the sub-models in the tree.\nI.e. if you pass a field that was declared to be of type ``Foo`` (subclass of BaseModel) as ``field``, and that\nmodel ``Foo`` has a field of type ``Bar`` (also subclass of ``BaseModel``) and that model ``Bar`` has a field of\ntype ``Baz`` (also subclass of ``BaseModel``), the return value will be ``set([Foo, Bar, Baz])``.\n\n:param field: a Pydantic ``ModelField``\n:param known_models: used to solve circular references\n:return: a set with the model used in the declaration for this field, if any, and all its sub-models", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/schema", "source_site": "pydantic"}
{"title": "get_flat_models_from_fields", "anchor": "get_flat_models_from_fields", "heading_level": 0, "md_text": "Take a list of Pydantic  ``ModelField``s (from a model) that could have been declared as subclasses of ``BaseModel``\n(so, any of them could be a submodel), and generate a set with their models and all the sub-models in the tree.\nI.e. if you pass a the fields of a model ``Foo`` (subclass of ``BaseModel``) as ``fields``, and on of them has a\nfield of type ``Bar`` (also subclass of ``BaseModel``) and that model ``Bar`` has a field of type ``Baz`` (also\nsubclass of ``BaseModel``), the return value will be ``set([Foo, Bar, Baz])``.\n\n:param fields: a list of Pydantic ``ModelField``s\n:param known_models: used to solve circular references\n:return: a set with any model declared in the fields, and all their sub-models", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/schema", "source_site": "pydantic"}
{"title": "get_flat_models_from_models", "anchor": "get_flat_models_from_models", "heading_level": 0, "md_text": "Take a list of ``models`` and generate a set with them and all their sub-models in their trees. I.e. if you pass\na list of two models, ``Foo`` and ``Bar``, both subclasses of Pydantic ``BaseModel`` as models, and ``Bar`` has\na field of type ``Baz`` (also subclass of ``BaseModel``), the return value will be ``set([Foo, Bar, Baz])``.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/schema", "source_site": "pydantic"}
{"title": "field_type_schema", "anchor": "field_type_schema", "heading_level": 0, "md_text": "Used by ``field_schema()``, you probably should be using that function.\n\nTake a single ``field`` and generate the schema for its type only, not including additional\ninformation as title, etc. Also return additional schema definitions, from sub-models.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/schema", "source_site": "pydantic"}
{"title": "model_process_schema", "anchor": "model_process_schema", "heading_level": 0, "md_text": "Used by ``model_schema()``, you probably should be using that function.\n\nTake a single ``model`` and generate its schema. Also return additional schema definitions, from sub-models. The\nsub-models of the returned schema will be referenced, but their definitions will not be included in the schema. All\nthe definitions are returned as the second value.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/schema", "source_site": "pydantic"}
{"title": "model_type_schema", "anchor": "model_type_schema", "heading_level": 0, "md_text": "You probably should be using ``model_schema()``, this function is indirectly used by that function.\n\nTake a single ``model`` and generate the schema for its type only, not including additional\ninformation as title, etc. Also return additional schema definitions, from sub-models.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/schema", "source_site": "pydantic"}
{"title": "enum_process_schema", "anchor": "enum_process_schema", "heading_level": 0, "md_text": "Take a single `enum` and generate its schema.\n\nThis is similar to the `model_process_schema` function, but applies to ``Enum`` objects.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/schema", "source_site": "pydantic"}
{"title": "field_singleton_sub_fields_schema", "anchor": "field_singleton_sub_fields_schema", "heading_level": 0, "md_text": "This function is indirectly used by ``field_schema()``, you probably should be using that function.\n\nTake a list of Pydantic ``ModelField`` from the declaration of a type with parameters, and generate their\nschema. I.e., fields used as \"type parameters\", like ``str`` and ``int`` in ``Tuple[str, int]``.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/schema", "source_site": "pydantic"}
{"title": "add_field_type_to_schema", "anchor": "add_field_type_to_schema", "heading_level": 0, "md_text": "Update the given `schema` with the type-specific metadata for the given `field_type`.\n\nThis function looks through `field_class_to_schema` for a class that matches the given `field_type`,\nand then modifies the given `schema` with the information from that type.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/schema", "source_site": "pydantic"}
{"title": "field_singleton_schema", "anchor": "field_singleton_schema", "heading_level": 0, "md_text": "This function is indirectly used by ``field_schema()``, you should probably be using that function.\n\nTake a single Pydantic ``ModelField``, and return its schema and any additional definitions from sub-models.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/schema", "source_site": "pydantic"}
{"title": "multitypes_literal_field_for_schema", "anchor": "multitypes_literal_field_for_schema", "heading_level": 0, "md_text": "To support `Literal` with values of different types, we split it into multiple `Literal` with same type\ne.g. `Literal['qwe', 'asd', 1, 2]` becomes `Union[Literal['qwe', 'asd'], Literal[1, 2]]`", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/schema", "source_site": "pydantic"}
{"title": "get_annotation_from_field_info", "anchor": "get_annotation_from_field_info", "heading_level": 0, "md_text": "Get an annotation with validation implemented for numbers and strings based on the field_info.\n:param annotation: an annotation from a field specification, as ``str``, ``ConstrainedStr``\n:param field_info: an instance of FieldInfo, possibly with declarations for validations and JSON Schema\n:param field_name: name of the field for use in error messages\n:param validate_assignment: default False, flag for BaseModel Config value of validate_assignment\n:return: the same ``annotation`` if unmodified or a new annotation with validation in place", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/schema", "source_site": "pydantic"}
{"title": "get_annotation_with_constraints", "anchor": "get_annotation_with_constraints", "heading_level": 0, "md_text": "Get an annotation with used constraints implemented for numbers and strings based on the field_info.\n\n:param annotation: an annotation from a field specification, as ``str``, ``ConstrainedStr``\n:param field_info: an instance of FieldInfo, possibly with declarations for validations and JSON Schema\n:return: the same ``annotation`` if unmodified or a new annotation along with the used constraints.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/schema", "source_site": "pydantic"}
{"title": "normalize_name", "anchor": "normalize_name", "heading_level": 0, "md_text": "Normalizes the given name. This can be applied to either a model *or* enum.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/schema", "source_site": "pydantic"}
{"title": "SkipField", "anchor": "skipfield", "heading_level": 0, "md_text": "Utility exception used to exclude fields from schema.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/schema", "source_site": "pydantic"}
{"title": "BaseConfig.get_field_info", "anchor": "baseconfig-get_field_info", "heading_level": 0, "md_text": "Get properties of FieldInfo from the `fields` property of the config class.", "url": "https://docs.pydantic.dev/latest/api/get-field-info/", "page": "pydantic/v1/config", "source_site": "pydantic"}
{"title": "BaseConfig.prepare_field", "anchor": "baseconfig-prepare_field", "heading_level": 0, "md_text": "Optional hook to check or modify fields during model creation.", "url": "https://docs.pydantic.dev/latest/api/prepare-field/", "page": "pydantic/v1/config", "source_site": "pydantic"}
{"title": "color", "anchor": "color", "heading_level": 0, "md_text": "Color definitions are  used as per CSS3 specification:\nhttp://www.w3.org/TR/css3-color/#svg-color\n\nA few colors have multiple names referring to the sames colors, eg. `grey` and `gray` or `aqua` and `cyan`.\n\nIn these cases the LAST color when sorted alphabetically takes preferences,\neg. Color((0, 255, 255)).as_named() == 'cyan' because \"cyan\" comes after \"aqua\".", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/color", "source_site": "pydantic"}
{"title": "RGBA", "anchor": "rgba", "heading_level": 0, "md_text": "Internal use only as a representation of a color.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/color", "source_site": "pydantic"}
{"title": "parse_tuple", "anchor": "parse_tuple", "heading_level": 0, "md_text": "Parse a tuple or list as a color.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/color", "source_site": "pydantic"}
{"title": "parse_str", "anchor": "parse_str", "heading_level": 0, "md_text": "Parse a string to an RGBA tuple, trying the following formats (in this order):\n* named color, see COLORS_BY_NAME below\n* hex short eg. `<prefix>fff` (prefix can be `#`, `0x` or nothing)\n* hex long eg. `<prefix>ffffff` (prefix can be `#`, `0x` or nothing)\n* `rgb(<r>, <g>, <b>) `\n* `rgba(<r>, <g>, <b>, <a>)`", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/color", "source_site": "pydantic"}
{"title": "parse_color_value", "anchor": "parse_color_value", "heading_level": 0, "md_text": "Parse a value checking it's a valid int in the range 0 to max_val and divide by max_val to give a number\nin the range 0 to 1", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/color", "source_site": "pydantic"}
{"title": "parse_float_alpha", "anchor": "parse_float_alpha", "heading_level": 0, "md_text": "Parse a value checking it's a valid float in the range 0 to 1", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/color", "source_site": "pydantic"}
{"title": "parse_hsl", "anchor": "parse_hsl", "heading_level": 0, "md_text": "Parse raw hue, saturation, lightness and alpha values and convert to RGBA.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/color", "source_site": "pydantic"}
{"title": "Color.original", "anchor": "color-original", "heading_level": 0, "md_text": "Original value passed to Color", "url": "https://docs.pydantic.dev/latest/api/original/", "page": "pydantic/v1/color", "source_site": "pydantic"}
{"title": "Color.as_hex", "anchor": "color-as_hex", "heading_level": 0, "md_text": "Hex string representing the color can be 3, 4, 6 or 8 characters depending on whether the string\na \"short\" representation of the color is possible and whether there's an alpha channel.", "url": "https://docs.pydantic.dev/latest/api/as-hex/", "page": "pydantic/v1/color", "source_site": "pydantic"}
{"title": "Color.as_rgb", "anchor": "color-as_rgb", "heading_level": 0, "md_text": "Color as an rgb(<r>, <g>, <b>) or rgba(<r>, <g>, <b>, <a>) string.", "url": "https://docs.pydantic.dev/latest/api/as-rgb/", "page": "pydantic/v1/color", "source_site": "pydantic"}
{"title": "Color.as_rgb_tuple", "anchor": "color-as_rgb_tuple", "heading_level": 0, "md_text": "Color as an RGB or RGBA tuple; red, green and blue are in the range 0 to 255, alpha if included is\nin the range 0 to 1.\n\n:param alpha: whether to include the alpha channel, options are\n  None - (default) include alpha only if it's set (e.g. not None)\n  True - always include alpha,\n  False - always omit alpha,", "url": "https://docs.pydantic.dev/latest/api/as-rgb-tuple/", "page": "pydantic/v1/color", "source_site": "pydantic"}
{"title": "Color.as_hsl", "anchor": "color-as_hsl", "heading_level": 0, "md_text": "Color as an hsl(<h>, <s>, <l>) or hsl(<h>, <s>, <l>, <a>) string.", "url": "https://docs.pydantic.dev/latest/api/as-hsl/", "page": "pydantic/v1/color", "source_site": "pydantic"}
{"title": "Color.as_hsl_tuple", "anchor": "color-as_hsl_tuple", "heading_level": 0, "md_text": "Color as an HSL or HSLA tuple, e.g. hue, saturation, lightness and optionally alpha; all elements are in\nthe range 0 to 1.\n\nNOTE: this is HSL as used in HTML and most other places, not HLS as used in python's colorsys.\n\n:param alpha: whether to include the alpha channel, options are\n  None - (default) include alpha only if it's set (e.g. not None)\n  True - always include alpha,\n  False - always omit alpha,", "url": "https://docs.pydantic.dev/latest/api/as-hsl-tuple/", "page": "pydantic/v1/color", "source_site": "pydantic"}
{"title": "decimal_encoder", "anchor": "decimal_encoder", "heading_level": 0, "md_text": "Encodes a Decimal as int of there's no exponent, otherwise float\n\nThis is useful when we use ConstrainedDecimal to represent Numeric(x,0)\nwhere a integer (but not int typed) is used. Encoding this as a float\nresults in failed round-tripping between encode and parse.\nOur Id type is a prime example of this.\n\n>>> decimal_encoder(Decimal(\"1.0\"))\n1.0\n\n>>> decimal_encoder(Decimal(\"1\"))\n1", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/json", "source_site": "pydantic"}
{"title": "timedelta_isoformat", "anchor": "timedelta_isoformat", "heading_level": 0, "md_text": "ISO 8601 encoding for Python timedelta object.", "url": "https://docs.pydantic.dev/latest/api/", "page": "pydantic/v1/json", "source_site": "pydantic"}
