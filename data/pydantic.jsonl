{"title": "Why use Pydantic?[Â¶](index.html#why-use-pydantic \"Permanent link\")", "anchor": "why-use-pydanticindexhtmlwhy-use-pydantic-permanent-link", "md_text": "* **Powered by type hints** â€” with Pydantic, schema validation and serialization are controlled by type annotations; less to learn, less code to write, and integration with your IDE and static analysis tools. [Learn moreâ€¦](why/index.html#type-hints)\n* **Speed** â€” Pydantic's core validation logic is written in Rust. As a result, Pydantic is among the fastest data validation libraries for Python. [Learn moreâ€¦](why/index.html#performance)\n* **JSON Schema** â€” Pydantic models can emit JSON Schema, allowing for easy integration with other tools. [Learn moreâ€¦](why/index.html#json-schema)\n* **Strict** and **Lax** mode â€” Pydantic can run in either strict mode (where data is not converted) or lax mode where Pydantic tries to coerce data to the correct type where appropriate. [Learn moreâ€¦](why/index.html#strict-lax)\n* **Dataclasses**, **TypedDicts** and more â€” Pydantic supports validation of many standard library types including `dataclass` and `TypedDict`. [Learn moreâ€¦](why/index.html#dataclasses-typeddict-more)\n* **Customisation** â€” Pydantic allows custom validators and serializers to alter how data is processed in many powerful ways. [Learn moreâ€¦](why/index.html#customisation)\n* **Ecosystem** â€” around 8,000 packages on PyPI use Pydantic, including massively popular libraries like\n  *FastAPI*, *huggingface*, *Django Ninja*, *SQLModel*, & *LangChain*. [Learn moreâ€¦](why/index.html#ecosystem)\n* **Battle tested** â€” Pydantic is downloaded over 360M times/month and is used by all FAANG companies and 20 of the 25 largest companies on NASDAQ. If you're trying to do something with Pydantic, someone else has probably already done it. [Learn moreâ€¦](why/index.html#using-pydantic)\n\n[Installing Pydantic](install/index.html) is as simple as: `pip install pydantic`", "url": "https://docs.pydantic.dev/latest/index.html#why-use-pydanticindexhtmlwhy-use-pydantic-permanent-link", "page": "index.html", "source_site": "pydantic"}
{"title": "Pydantic examples[Â¶](index.html#pydantic-examples \"Permanent link\")", "anchor": "pydantic-examplesindexhtmlpydantic-examples-permanent-link", "md_text": "To see Pydantic at work, let's start with a simple example, creating a custom class that inherits from `BaseModel`:\n\nValidation Successful\n\n```\nfrom datetime import datetime\n\nfrom pydantic import BaseModel, PositiveInt\n\n\nclass User(BaseModel):\n    id: int  # (1)!\n    name: str = 'John Doe'  # (2)!\n    signup_ts: datetime | None  # (3)!\n    tastes: dict[str, PositiveInt]  # (4)!\n\n\nexternal_data = {\n    'id': 123,\n    'signup_ts': '2019-06-01 12:22',  # (5)!\n    'tastes': {\n        'wine': 9,\n        b'cheese': 7,  # (6)!\n        'cabbage': '1',  # (7)!\n    },\n}\n\nuser = User(**external_data)  # (8)!\n\nprint(user.id)  # (9)!\n#> 123\nprint(user.model_dump())  # (10)!\n\"\"\"\n{\n    'id': 123,\n    'name': 'John Doe',\n    'signup_ts': datetime.datetime(2019, 6, 1, 12, 22),\n    'tastes': {'wine': 9, 'cheese': 7, 'cabbage': 1},\n}\n\"\"\"\n```\n\n1. `id` is of type `int`; the annotation-only declaration tells Pydantic that this field is required. Strings,\n   bytes, or floats will be coerced to integers if possible; otherwise an exception will be raised.\n2. `name` is a string; because it has a default, it is not required.\n3. `signup_ts` is a [`datetime`](https://docs.python.org/3/library/datetime.html#datetime.datetime) field that is required, but the value `None` may be provided;\n   Pydantic will process either a [Unix timestamp](https://en.wikipedia.org/wiki/Unix_time) integer (e.g. `1496498400`)\n   or a string representing the date and time.\n4. `tastes` is a dictionary with string keys and positive integer values. The `PositiveInt` type is\n   shorthand for `Annotated[int, annotated_types.Gt(0)]`.\n5. The input here is an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) formatted datetime, but Pydantic will\n   convert it to a [`datetime`](https://docs.python.org/3/library/datetime.html#datetime.datetime) object.\n6. The key here is `bytes`, but Pydantic will take care of coercing it to a string.\n7. Similarly, Pydantic will coerce the string `'1'` to the integer `1`.\n8. We create instance of `User` by passing our external data to `User` as keyword arguments.\n9. We can access fields as attributes of the model.\n10. We can convert the model to a dictionary with [`model_dump()`](api/base_model/index.html#pydantic.BaseModel.model_dump).\n\nIf validation fails, Pydantic will raise an error with a breakdown of what was wrong:\n\nValidation Error\n\n```\n# continuing the above example...\n\nfrom datetime import datetime\nfrom pydantic import BaseModel, PositiveInt, ValidationError\n\n\nclass User(BaseModel):\n    id: int\n    name: str = 'John Doe'\n    signup_ts: datetime | None\n    tastes: dict[str, PositiveInt]\n\n\nexternal_data = {'id': 'not an int', 'tastes': {}}  # (1)!\n\ntry:\n    User(**external_data)  # (2)!\nexcept ValidationError as e:\n    print(e.errors())\n    \"\"\"\n    [\n        {\n            'type': 'int_parsing',\n            'loc': ('id',),\n            'msg': 'Input should be a valid integer, unable to parse string as an integer',\n            'input': 'not an int',\n            'url': 'https://errors.pydantic.dev/2/v/int_parsing',\n        },\n        {\n            'type': 'missing',\n            'loc': ('signup_ts',),\n            'msg': 'Field required',\n            'input': {'id': 'not an int', 'tastes': {}},\n            'url': 'https://errors.pydantic.dev/2/v/missing',\n        },\n    ]\n    \"\"\"\n```\n\n1. The input data is wrong here â€” `id` is not a valid integer, and `signup_ts` is missing.\n2. Trying to instantiate `User` will raise a [`ValidationError`](api/pydantic_core/index.html#pydantic_core.ValidationError) with a list of errors.", "url": "https://docs.pydantic.dev/latest/index.html#pydantic-examplesindexhtmlpydantic-examples-permanent-link", "page": "index.html", "source_site": "pydantic"}
{"title": "Who is using Pydantic?[Â¶](index.html#who-is-using-pydantic \"Permanent link\")", "anchor": "who-is-using-pydanticindexhtmlwho-is-using-pydantic-permanent-link", "md_text": "Hundreds of organisations and packages are using Pydantic. Some of the prominent companies and organizations around the world who are using Pydantic include:\n\n[![Adobe](logos/adobe_logo.png)](why/index.html#org-adobe \"Adobe\")\n\n[![Amazon and AWS](logos/amazon_logo.png)](why/index.html#org-amazon \"Amazon and AWS\")\n\n[![Anthropic](logos/anthropic_logo.png)](why/index.html#org-anthropic \"Anthropic\")\n\n[![Apple](logos/apple_logo.png)](why/index.html#org-apple \"Apple\")\n\n[![ASML](logos/asml_logo.png)](why/index.html#org-asml \"ASML\")\n\n[![AstraZeneca](logos/astrazeneca_logo.png)](why/index.html#org-astrazeneca \"AstraZeneca\")\n\n[![Cisco Systems](logos/cisco_logo.png)](why/index.html#org-cisco \"Cisco Systems\")\n\n[![Comcast](logos/comcast_logo.png)](why/index.html#org-comcast \"Comcast\")\n\n[![Datadog](logos/datadog_logo.png)](why/index.html#org-datadog \"Datadog\")\n\n[![Facebook](logos/facebook_logo.png)](why/index.html#org-facebook \"Facebook\")\n\n[![GitHub](logos/github_logo.png)](why/index.html#org-github \"GitHub\")\n\n[![Google](logos/google_logo.png)](why/index.html#org-google \"Google\")\n\n[![HSBC](logos/hsbc_logo.png)](why/index.html#org-hsbc \"HSBC\")\n\n[![IBM](logos/ibm_logo.png)](why/index.html#org-ibm \"IBM\")\n\n[![Intel](logos/intel_logo.png)](why/index.html#org-intel \"Intel\")\n\n[![Intuit](logos/intuit_logo.png)](why/index.html#org-intuit \"Intuit\")\n\n[![Intergovernmental Panel on Climate Change](logos/ipcc_logo.png)](why/index.html#org-ipcc \"Intergovernmental Panel on Climate Change\")\n\n[![JPMorgan](logos/jpmorgan_logo.png)](why/index.html#org-jpmorgan \"JPMorgan\")\n\n[![Jupyter](logos/jupyter_logo.png)](why/index.html#org-jupyter \"Jupyter\")\n\n[![Microsoft](logos/microsoft_logo.png)](why/index.html#org-microsoft \"Microsoft\")\n\n[![Molecular Science Software Institute](logos/molssi_logo.png)](why/index.html#org-molssi \"Molecular Science Software Institute\")\n\n[![NASA](logos/nasa_logo.png)](why/index.html#org-nasa \"NASA\")\n\n[![Netflix](logos/netflix_logo.png)](why/index.html#org-netflix \"Netflix\")\n\n[![NSA](logos/nsa_logo.png)](why/index.html#org-nsa \"NSA\")\n\n[![NVIDIA](logos/nvidia_logo.png)](why/index.html#org-nvidia \"NVIDIA\")\n\n[![OpenAI](logos/openai_logo.png)](why/index.html#org-openai \"OpenAI\")\n\n[![Oracle](logos/oracle_logo.png)](why/index.html#org-oracle \"Oracle\")\n\n[![Palantir](logos/palantir_logo.png)](why/index.html#org-palantir \"Palantir\")\n\n[![Qualcomm](logos/qualcomm_logo.png)](why/index.html#org-qualcomm \"Qualcomm\")\n\n[![Red Hat](logos/redhat_logo.png)](why/index.html#org-redhat \"Red Hat\")\n\n[![Revolut](logos/revolut_logo.png)](why/index.html#org-revolut \"Revolut\")\n\n[![Robusta](logos/robusta_logo.png)](why/index.html#org-robusta \"Robusta\")\n\n[![Salesforce](logos/salesforce_logo.png)](why/index.html#org-salesforce \"Salesforce\")\n\n[![Starbucks](logos/starbucks_logo.png)](why/index.html#org-starbucks \"Starbucks\")\n\n[![Texas Instruments](logos/ti_logo.png)](why/index.html#org-ti \"Texas Instruments\")\n\n[![Twilio](logos/twilio_logo.png)](why/index.html#org-twilio \"Twilio\")\n\n[![Twitter](logos/twitter_logo.png)](why/index.html#org-twitter \"Twitter\")\n\n[![UK Home Office](logos/ukhomeoffice_logo.png)](why/index.html#org-ukhomeoffice \"UK Home Office\")\n\nFor a more comprehensive list of open-source projects using Pydantic see the\n[list of dependents on github](https://github.com/pydantic/pydantic/network/dependents), or you can find some awesome projects using Pydantic in [awesome-pydantic](https://github.com/Kludex/awesome-pydantic).\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/index.html#who-is-using-pydanticindexhtmlwho-is-using-pydantic-permanent-link", "page": "index.html", "source_site": "pydantic"}
{"title": "Issues[Â¶](index.html#issues \"Permanent link\")", "anchor": "issuesindexhtmlissues-permanent-link", "md_text": "Questions, feature requests and bug reports are all welcome as [discussions or issues](https://github.com/pydantic/pydantic/issues/new/choose).\n**However, to report a security vulnerability, please see our [security policy](https://github.com/pydantic/pydantic/security/policy).**\n\nTo make it as simple as possible for us to help you, please include the output of the following call in your issue:\n\n```\npython -c \"import pydantic.version; print(pydantic.version.version_info())\"\n```\n\nIf you're using Pydantic prior to **v2.0** please use:\n\n```\npython -c \"import pydantic.utils; print(pydantic.utils.version_info())\"\n```\n\nPlease try to always include the above unless you're unable to install Pydantic or **know** it's not relevant\nto your question or feature request.", "url": "https://docs.pydantic.dev/latest/contributing/index.html#issuesindexhtmlissues-permanent-link", "page": "contributing/index.html", "source_site": "pydantic"}
{"title": "Pull Requests[Â¶](index.html#pull-requests \"Permanent link\")", "anchor": "pull-requestsindexhtmlpull-requests-permanent-link", "md_text": "It should be extremely simple to get started and create a Pull Request.\nPydantic is released regularly so you should see your improvements release in a matter of days or weeks ðŸš€.\n\nUnless your change is trivial (typo, docs tweak etc.), please create an issue to discuss the change before\ncreating a pull request.\n\nPydantic v1 is in maintenance mode, meaning that only bug fixes and security fixes will be accepted.\nNew features should be targeted at Pydantic v2.\n\nTo submit a fix to Pydantic v1, use the `1.10.X-fixes` as a target branch.\n\nIf you're looking for something to get your teeth into, check out the\n[\"help wanted\"](https://github.com/pydantic/pydantic/issues?q=is%3Aopen+is%3Aissue+label%3A%22help+wanted%22)\nlabel on github.\n\nTo make contributing as easy and fast as possible, you'll want to run tests and linting locally. Luckily,\nPydantic has few dependencies, doesn't require compiling and tests don't need access to databases, etc.\nBecause of this, setting up and running the tests should be very simple.\n\n**tl;dr**: use `make format` to fix formatting, `make` to run tests and linting and `make docs`\nto build the docs.", "url": "https://docs.pydantic.dev/latest/contributing/index.html#pull-requestsindexhtmlpull-requests-permanent-link", "page": "contributing/index.html", "source_site": "pydantic"}
{"title": "Prerequisites[Â¶](index.html#prerequisites \"Permanent link\")", "anchor": "prerequisitesindexhtmlprerequisites-permanent-link", "md_text": "You'll need the following prerequisites:\n\n* Any Python version between **Python 3.9 and 3.12**\n* [**uv**](https://docs.astral.sh/uv/getting-started/installation/) or other virtual environment tool\n* **git**\n* **make**", "url": "https://docs.pydantic.dev/latest/contributing/index.html#prerequisitesindexhtmlprerequisites-permanent-link", "page": "contributing/index.html", "source_site": "pydantic"}
{"title": "Installation and setup[Â¶](index.html#installation-and-setup \"Permanent link\")", "anchor": "installation-and-setupindexhtmlinstallation-and-setup-permanent-link", "md_text": "Fork the repository on GitHub and clone your fork locally.\n\n```\n# Clone your fork and cd into the repo directory\ngit clone [emailÂ protected]:<your username>/pydantic.git\ncd pydantic\n\n# Install UV and pre-commit\n# We use pipx here, for other options see:\n# https://docs.astral.sh/uv/getting-started/installation/\n# https://pre-commit.com/#install\n# To get pipx itself:\n# https://pypa.github.io/pipx/\npipx install uv\npipx install pre-commit\n\n# Install pydantic, dependencies, test dependencies and doc dependencies\nmake install\n```", "url": "https://docs.pydantic.dev/latest/contributing/index.html#installation-and-setupindexhtmlinstallation-and-setup-permanent-link", "page": "contributing/index.html", "source_site": "pydantic"}
{"title": "Check out a new branch and make your changes[Â¶](index.html#check-out-a-new-branch-and-make-your-changes \"Permanent link\")", "anchor": "check-out-a-new-branch-and-make-your-changesindexhtmlcheck-out-a-new-branch-and-make-your-changes-permanent-link", "md_text": "Create a new branch for your changes.\n\n```\n# Checkout a new branch and make your changes\ngit checkout -b my-new-feature-branch\n# Make your changes...\n```", "url": "https://docs.pydantic.dev/latest/contributing/index.html#check-out-a-new-branch-and-make-your-changesindexhtmlcheck-out-a-new-branch-and-make-your-changes-permanent-link", "page": "contributing/index.html", "source_site": "pydantic"}
{"title": "Run tests and linting[Â¶](index.html#run-tests-and-linting \"Permanent link\")", "anchor": "run-tests-and-lintingindexhtmlrun-tests-and-linting-permanent-link", "md_text": "Run tests and linting locally to make sure everything is working as expected.\n\n```\n# Run automated code formatting and linting\nmake format\n# Pydantic uses ruff, an awesome Python linter written in rust\n# https://github.com/astral-sh/ruff\n\n# Run tests and linting\nmake\n# There are a few sub-commands in Makefile like `test`, `testcov` and `lint`\n# which you might want to use, but generally just `make` should be all you need.\n# You can run `make help` to see more options.\n```", "url": "https://docs.pydantic.dev/latest/contributing/index.html#run-tests-and-lintingindexhtmlrun-tests-and-linting-permanent-link", "page": "contributing/index.html", "source_site": "pydantic"}
{"title": "Build documentation[Â¶](index.html#build-documentation \"Permanent link\")", "anchor": "build-documentationindexhtmlbuild-documentation-permanent-link", "md_text": "If you've made any changes to the documentation (including changes to function signatures, class definitions, or docstrings that will appear in the API documentation), make sure it builds successfully.\n\nWe use `mkdocs-material[imaging]` to support social previews (see the [plugin documentation](https://squidfunk.github.io/mkdocs-material/plugins/requirements/image-processing/)).\n\n```\n# Build documentation\nmake docs\n# If you have changed the documentation, make sure it builds successfully.\n# You can also use `uv run mkdocs serve` to serve the documentation at localhost:8000\n```\n\nIf this isn't working due to issues with the imaging plugin, try commenting out the `social` plugin line in `mkdocs.yml` and running `make docs` again.\n\n#### Updating the documentation[Â¶](index.html#updating-the-documentation \"Permanent link\")\n\nWe push a new version of the documentation with each minor release, and we push to a `dev` path with each commit to `main`.\n\nIf you're updating the documentation out of cycle with a minor release and want your changes to be reflected on `latest`,\ndo the following:\n\n1. Open a PR against `main` with your docs changes\n2. Once the PR is merged, checkout the `docs-update` branch. This branch should be up to date with the latest patch release.\n   For example, if the latest release is `v2.9.2`, you should make sure `docs-update` is up to date with the `v2.9.2` tag.\n3. Checkout a new branch from `docs-update` and cherry-pick your changes onto this branch.\n4. Push your changes and open a PR against `docs-update`.\n5. Once the PR is merged, the new docs will be built and deployed.\n\nMaintainer shortcut - as a maintainer, you can skip the second PR and just cherry pick directly onto the `docs-update` branch.", "url": "https://docs.pydantic.dev/latest/contributing/index.html#build-documentationindexhtmlbuild-documentation-permanent-link", "page": "contributing/index.html", "source_site": "pydantic"}
{"title": "Commit and push your changes[Â¶](index.html#commit-and-push-your-changes \"Permanent link\")", "anchor": "commit-and-push-your-changesindexhtmlcommit-and-push-your-changes-permanent-link", "md_text": "Commit your changes, push your branch to GitHub, and create a pull request.\n\nPlease follow the pull request template and fill in as much information as possible. Link to any relevant issues and include a description of your changes.\n\nWhen your pull request is ready for review, add a comment with the message \"please review\" and we'll take a look as soon as we can.", "url": "https://docs.pydantic.dev/latest/contributing/index.html#commit-and-push-your-changesindexhtmlcommit-and-push-your-changes-permanent-link", "page": "contributing/index.html", "source_site": "pydantic"}
{"title": "Documentation style[Â¶](index.html#documentation-style \"Permanent link\")", "anchor": "documentation-styleindexhtmldocumentation-style-permanent-link", "md_text": "Documentation is written in Markdown and built using [Material for MkDocs](https://squidfunk.github.io/mkdocs-material/). API documentation is build from docstrings using [mkdocstrings](https://mkdocstrings.github.io/).", "url": "https://docs.pydantic.dev/latest/contributing/index.html#documentation-styleindexhtmldocumentation-style-permanent-link", "page": "contributing/index.html", "source_site": "pydantic"}
{"title": "Code documentation[Â¶](index.html#code-documentation \"Permanent link\")", "anchor": "code-documentationindexhtmlcode-documentation-permanent-link", "md_text": "When contributing to Pydantic, please make sure that all code is well documented. The following should be documented using properly formatted docstrings:\n\n* Modules\n* Class definitions\n* Function definitions\n* Module-level variables\n\nPydantic uses [Google-style docstrings](https://google.github.io/styleguide/pyguide.html#38-comments-and-docstrings) formatted according to [PEP 257](https://www.python.org/dev/peps/pep-0257/) guidelines. (See [Example Google Style Python Docstrings](https://sphinxcontrib-napoleon.readthedocs.io/en/latest/example_google.html) for further examples.)\n\n[pydocstyle](https://www.pydocstyle.org/en/stable/index.html) is used for linting docstrings. You can run `make format` to check your docstrings.\n\nWhere this is a conflict between Google-style docstrings and pydocstyle linting, follow the pydocstyle linting hints.\n\nClass attributes and function arguments should be documented in the format \"name: description.\" When applicable, a return type should be documented with just a description. Types are inferred from the signature.\n\n```\nclass Foo:\n    \"\"\"A class docstring.\n\n    Attributes:\n        bar: A description of bar. Defaults to \"bar\".\n    \"\"\"\n\n    bar: str = 'bar'\n\ndef bar(self, baz: int) -> str:\n    \"\"\"A function docstring.\n\n    Args:\n        baz: A description of `baz`.\n\n    Returns:\n        A description of the return value.\n    \"\"\"\n\n    return 'bar'\n```\n\nYou may include example code in docstrings. This code should be complete, self-contained, and runnable. Docstring examples are tested, so make sure they are correct and complete. See [`BeforeValidator`](../api/functional_validators/index.html#pydantic.functional_validators.AfterValidator) for an example.\n\nClass attributes should be documented in the class docstring.\n\nInstance attributes should be documented as \"Args\" in the `__init__` docstring.", "url": "https://docs.pydantic.dev/latest/contributing/index.html#code-documentationindexhtmlcode-documentation-permanent-link", "page": "contributing/index.html", "source_site": "pydantic"}
{"title": "Documentation Style[Â¶](index.html#documentation-style_1 \"Permanent link\")", "anchor": "documentation-styleindexhtmldocumentation-style1-permanent-link", "md_text": "In general, documentation should be written in a friendly, approachable style. It should be easy to read and understand, and should be as concise as possible while still being complete.\n\nCode examples are encouraged, but should be kept short and simple. However, every code example should be complete, self-contained, and runnable. (If you're not sure how to do this, ask for help!) We prefer print output to naked asserts, but if you're testing something that doesn't have a useful print output, asserts are fine.\n\nPydantic's unit test will test all code examples in the documentation, so it's important that they are correct and complete. When adding a new code example, use the following to test examples and update their formatting and output:\n\n```\n# Run tests and update code examples\npytest tests/test_docs.py --update-examples\n```", "url": "https://docs.pydantic.dev/latest/contributing/index.html#documentation-styleindexhtmldocumentation-style1-permanent-link", "page": "contributing/index.html", "source_site": "pydantic"}
{"title": "Debugging Python and Rust[Â¶](index.html#debugging-python-and-rust \"Permanent link\")", "anchor": "debugging-python-and-rustindexhtmldebugging-python-and-rust-permanent-link", "md_text": "If you're working with `pydantic` and `pydantic-core`, you might find it helpful to debug Python and Rust code together.\nHere's a quick guide on how to do that. This tutorial is done in VSCode, but you can use similar steps in other IDEs.", "url": "https://docs.pydantic.dev/latest/contributing/index.html#debugging-python-and-rustindexhtmldebugging-python-and-rust-permanent-link", "page": "contributing/index.html", "source_site": "pydantic"}
{"title": "Badges[Â¶](index.html#badges \"Permanent link\")", "anchor": "badgesindexhtmlbadges-permanent-link", "md_text": "[![Pydantic v1](https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/pydantic/pydantic/main/docs/badge/v1.json)](https://pydantic.dev)\n[![Pydantic v2](https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/pydantic/pydantic/main/docs/badge/v2.json)](https://pydantic.dev)\n\nPydantic has a badge that you can use to show that your project uses Pydantic. You can use this badge in your `README.md`:", "url": "https://docs.pydantic.dev/latest/contributing/index.html#badgesindexhtmlbadges-permanent-link", "page": "contributing/index.html", "source_site": "pydantic"}
{"title": "With Markdown[Â¶](index.html#with-markdown \"Permanent link\")", "anchor": "with-markdownindexhtmlwith-markdown-permanent-link", "md_text": "```\n[![Pydantic v1](https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/pydantic/pydantic/main/docs/badge/v1.json)](https://pydantic.dev)\n\n[![Pydantic v2](https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/pydantic/pydantic/main/docs/badge/v2.json)](https://pydantic.dev)\n```", "url": "https://docs.pydantic.dev/latest/contributing/index.html#with-markdownindexhtmlwith-markdown-permanent-link", "page": "contributing/index.html", "source_site": "pydantic"}
{"title": "With reStructuredText[Â¶](index.html#with-restructuredtext \"Permanent link\")", "anchor": "with-restructuredtextindexhtmlwith-restructuredtext-permanent-link", "md_text": "```\n.. image:: https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/pydantic/pydantic/main/docs/badge/v1.json\n    :target: https://pydantic.dev\n    :alt: Pydantic\n\n.. image:: https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/pydantic/pydantic/main/docs/badge/v2.json\n    :target: https://pydantic.dev\n    :alt: Pydantic\n```", "url": "https://docs.pydantic.dev/latest/contributing/index.html#with-restructuredtextindexhtmlwith-restructuredtext-permanent-link", "page": "contributing/index.html", "source_site": "pydantic"}
{"title": "With HTML[Â¶](index.html#with-html \"Permanent link\")", "anchor": "with-htmlindexhtmlwith-html-permanent-link", "md_text": "```\n<a href=\"https://pydantic.dev\"><img src=\"https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/pydantic/pydantic/main/docs/badge/v1.json\" alt=\"Pydantic Version 1\" style=\"max-width:100%;\"></a>\n\n<a href=\"https://pydantic.dev\"><img src=\"https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/pydantic/pydantic/main/docs/badge/v2.json\" alt=\"Pydantic Version 2\" style=\"max-width:100%;\"></a>\n```", "url": "https://docs.pydantic.dev/latest/contributing/index.html#with-htmlindexhtmlwith-html-permanent-link", "page": "contributing/index.html", "source_site": "pydantic"}
{"title": "Adding your library as part of Pydantic's third party test suite[Â¶](index.html#adding-your-library-as-part-of-pydantics-third-party-test-suite \"Permanent link\")", "anchor": "adding-your-library-as-part-of-pydantics-third-party-test-suiteindexhtmladding-your-library-as-part-of-pydantics-third-party-test-suite-permanent-link", "md_text": "To be able to identify regressions early during development, Pydantic runs tests on various third-party projects\nusing Pydantic. We consider adding support for testing new open source projects (that rely heavily on Pydantic) if your said project matches some of the following criteria:\n\n* The project is actively maintained.\n* The project makes use of Pydantic internals (e.g. relying on the [`BaseModel`](../api/base_model/index.html#pydantic.BaseModel) metaclass, typing utilities).\n* The project is popular enough (although small projects can still be included depending on how Pydantic is being used).\n* The project CI is simple enough to be ported into Pydantic's testing workflow.\n\nIf your project meets some of these criteria, you can [open feature request](https://github.com/pydantic/pydantic/issues/new?assignees=&labels=feature+request&projects=&template=feature_request.yml)\nto discuss the inclusion of your project.\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/contributing/index.html#adding-your-library-as-part-of-pydantics-third-party-test-suiteindexhtmladding-your-library-as-part-of-pydantics-third-party-test-suite-permanent-link", "page": "contributing/index.html", "source_site": "pydantic"}
{"title": "Maintainers[Â¶](index.html#maintainers \"Permanent link\")", "anchor": "maintainersindexhtmlmaintainers-permanent-link", "md_text": "These are the current maintainers of the Pydantic repository. Feel free to tag us if you have questions, review requests, or feature requests for which you'd like feedback!\n\n[![](https://avatars.githubusercontent.com/u/4039449?u=42eb3b833047c8c4b4f647a031eaef148c16d93f&v=4)\n\n@samuelcolvin](https://github.com/samuelcolvin)\n\n[![](https://avatars.githubusercontent.com/u/65306057?u=fcd677dc1b9bef12aa103613e5ccb3f8ce305af9&v=4)\n\n@Viicos](https://github.com/Viicos)\n\n[![](https://avatars.githubusercontent.com/u/35119617?u=540f30c937a6450812628b9592a1dfe91bbe148e&v=4)\n\n@dmontagu](https://github.com/dmontagu)\n\n[![](https://avatars.githubusercontent.com/u/3627481?u=9bb2e0cf1c5ef3d0609d2e639a135b7b4ca8b463&v=4)\n\n@alexmojaki](https://github.com/alexmojaki)\n\n[![](https://avatars.githubusercontent.com/u/1755071?u=612704256e38d6ac9cbed24f10e4b6ac2da74ecb&v=4)\n\n@adriangb](https://github.com/adriangb)\n\n[![](https://avatars.githubusercontent.com/u/7353520?u=df8a3f06ba8f55ae1967a3e2d5ed882903a4e330&v=4)\n\n@Kludex](https://github.com/Kludex)\n\n[![](https://avatars.githubusercontent.com/u/1939362?u=b4b48981c3a097daaad16c4c5417aa7a3e5e32d9&v=4)\n\n@davidhewitt](https://github.com/davidhewitt)\n\n[![](https://avatars.githubusercontent.com/u/3122442?u=f387fc2dbc0c681f23e80e2ad705790fafcec9a2&v=4)\n\n@hramezani](https://github.com/hramezani)", "url": "https://docs.pydantic.dev/latest/pydantic_people/index.html#maintainersindexhtmlmaintainers-permanent-link", "page": "pydantic_people/index.html", "source_site": "pydantic"}
{"title": "Experts[Â¶](index.html#experts \"Permanent link\")", "anchor": "expertsindexhtmlexperts-permanent-link", "md_text": "These are the users that have helped others the most with questions in GitHub through *all time*.\n\n[![](https://avatars.githubusercontent.com/u/18406791?u=4853940cf5eeffb5bbb9ba06ad862f28bc68d69e&v=4)\n\n@PrettyWood](https://github.com/PrettyWood)\n\nQuestions replied: 143\n\n[![](https://avatars.githubusercontent.com/u/32038156?u=0c68019beb28381ce5205a838937c61e0fe3fee2&v=4)\n\n@uriyyo](https://github.com/uriyyo)\n\nQuestions replied: 96\n\n[![](https://avatars.githubusercontent.com/u/54324534?u=acc3756515d6f87acc91e36a4478557cba9d9dac&v=4)\n\n@sydney-runkle](https://github.com/sydney-runkle)\n\nQuestions replied: 38\n\n[![](https://avatars.githubusercontent.com/u/2184855?u=5670768b7efda993c4887d91df3cf330dc7bc9de&v=4)\n\n@lesnik512](https://github.com/lesnik512)\n\nQuestions replied: 21\n\n[![](https://avatars.githubusercontent.com/u/1765494?u=5b1ab7c582db4b4016fa31affe977d10af108ad4&v=4)\n\n@harunyasar](https://github.com/harunyasar)\n\nQuestions replied: 17\n\n[![](https://avatars.githubusercontent.com/u/48211033?u=51305680dd325d56d5e38d66a82ad530606e3d25&v=4)\n\n@janas-adam](https://github.com/janas-adam)\n\nQuestions replied: 13\n\n[![](https://avatars.githubusercontent.com/u/4216559?u=360a36fb602cded27273cbfc0afc296eece90662&v=4)\n\n@nymous](https://github.com/nymous)\n\nQuestions replied: 13\n\n[![](https://avatars.githubusercontent.com/u/40807730?v=4)\n\n@ybressler](https://github.com/ybressler)\n\nQuestions replied: None", "url": "https://docs.pydantic.dev/latest/pydantic_people/index.html#expertsindexhtmlexperts-permanent-link", "page": "pydantic_people/index.html", "source_site": "pydantic"}
{"title": "Most active users last month[Â¶](index.html#most-active-users-last-month \"Permanent link\")", "anchor": "most-active-users-last-monthindexhtmlmost-active-users-last-month-permanent-link", "md_text": "These are the users that have helped others the most with questions in GitHub during the last month.", "url": "https://docs.pydantic.dev/latest/pydantic_people/index.html#most-active-users-last-monthindexhtmlmost-active-users-last-month-permanent-link", "page": "pydantic_people/index.html", "source_site": "pydantic"}
{"title": "Top contributors[Â¶](index.html#top-contributors \"Permanent link\")", "anchor": "top-contributorsindexhtmltop-contributors-permanent-link", "md_text": "These are the users that have created the most pull requests that have been *merged*.\n\n[![](https://avatars.githubusercontent.com/u/54324534?u=acc3756515d6f87acc91e36a4478557cba9d9dac&v=4)\n\n@sydney-runkle](https://github.com/sydney-runkle)\n\nContributions: 382\n\n[![](https://avatars.githubusercontent.com/u/18406791?u=4853940cf5eeffb5bbb9ba06ad862f28bc68d69e&v=4)\n\n@PrettyWood](https://github.com/PrettyWood)\n\nContributions: 122\n\n[![](https://avatars.githubusercontent.com/in/2141?v=4)\n\n@dependabot-preview](https://github.com/apps/dependabot-preview)\n\nContributions: 75\n\n[![](https://avatars.githubusercontent.com/u/370316?u=eb206070cfe47f242d5fcea2e6c7514f4d0f27f5&v=4)\n\n@tpdorsey](https://github.com/tpdorsey)\n\nContributions: 71\n\n[![](https://avatars.githubusercontent.com/u/38705?v=4)\n\n@lig](https://github.com/lig)\n\nContributions: 49\n\n[![](https://avatars.githubusercontent.com/u/16239342?u=8454ae029661131445080f023e1efccc29166485&v=4)\n\n@pyup-bot](https://github.com/pyup-bot)\n\nContributions: 46\n\n[![](https://avatars.githubusercontent.com/u/1326112?u=cb5d06e73a9e1998141b1641aa88e443c6717651&v=4)\n\n@tiangolo](https://github.com/tiangolo)\n\nContributions: 22\n\n[![](https://avatars.githubusercontent.com/u/36469655?u=f67d8fa6d67d35d2f5ebd5b15e24efeb41036fd3&v=4)\n\n@Bobronium](https://github.com/Bobronium)\n\nContributions: 19\n\n[![](https://avatars.githubusercontent.com/u/1087619?u=cd78c4f602bf9f9667277dd0af9302a7fe9dd75a&v=4)\n\n@Gr1N](https://github.com/Gr1N)\n\nContributions: 17\n\n[![](https://avatars.githubusercontent.com/u/1271289?u=b83b0a82b2c95990d93cefbeb8f548d9f2f090c2&v=4)\n\n@misrasaurabh1](https://github.com/misrasaurabh1)\n\nContributions: 16\n\n[![](https://avatars.githubusercontent.com/u/32038156?u=0c68019beb28381ce5205a838937c61e0fe3fee2&v=4)\n\n@uriyyo](https://github.com/uriyyo)\n\nContributions: 15\n\n[![](https://avatars.githubusercontent.com/u/6400248?u=88cadd1dd6376e7000934e93712c5eb0138c1616&v=4)\n\n@pilosus](https://github.com/pilosus)\n\nContributions: 12\n\n[![](https://avatars.githubusercontent.com/u/52716203?u=21b53ce4115062b1e20cb513e64ca0000c2ef127&v=4)\n\n@yezz123](https://github.com/yezz123)\n\nContributions: 12\n\n[![](https://avatars.githubusercontent.com/u/30130371?v=4)\n\n@cdce8p](https://github.com/cdce8p)\n\nContributions: 12\n\n[![](https://avatars.githubusercontent.com/u/89458301?u=75f53e971fcba3ff61836c389505a420bddd865c&v=4)\n\n@kc0506](https://github.com/kc0506)\n\nContributions: 12\n\n[![](https://avatars.githubusercontent.com/u/1148665?u=b69e6fe797302f025a2d125e377e27f8ea0b8058&v=4)\n\n@StephenBrown2](https://github.com/StephenBrown2)\n\nContributions: 10\n\n[![](https://avatars.githubusercontent.com/u/630670?u=507d8577b4b3670546b449c4c2ccbc5af40d72f7&v=4)\n\n@koxudaxi](https://github.com/koxudaxi)\n\nContributions: 9\n\n[![](https://avatars.githubusercontent.com/u/19784933?v=4)\n\n@aminalaee](https://github.com/aminalaee)\n\nContributions: 8\n\n[![](https://avatars.githubusercontent.com/u/70970900?u=573a3175906348e0d1529104d56b391e93ca0250&v=4)\n\n@NeevCohen](https://github.com/NeevCohen)\n\nContributions: 8\n\n[![](https://avatars.githubusercontent.com/u/31134424?u=e8afd95a97b5556c467d1be27788950e67378ef1&v=4)\n\n@layday](https://github.com/layday)\n\nContributions: 7", "url": "https://docs.pydantic.dev/latest/pydantic_people/index.html#top-contributorsindexhtmltop-contributors-permanent-link", "page": "pydantic_people/index.html", "source_site": "pydantic"}
{"title": "Top contributors[Â¶](index.html#top-contributors \"Permanent link\")", "anchor": "top-contributorsindexhtmltop-contributors-permanent-link", "md_text": "[![](https://avatars.githubusercontent.com/u/1049817?u=b42e1148d23ea9039b325975bbea3ff8c5b4e3ec&v=4)\n\n@daviskirk](https://github.com/daviskirk)\n\nContributions: 7\n\n[![](https://avatars.githubusercontent.com/u/1609449?u=922abf0524b47739b37095e553c99488814b05db&v=4)\n\n@tlambert03](https://github.com/tlambert03)\n\nContributions: 7\n\n[![](https://avatars.githubusercontent.com/u/1769841?u=44e83d7974f0ab5c431340f1669d98f781594980&v=4)\n\n@dgasmith](https://github.com/dgasmith)\n\nContributions: 6\n\n[![](https://avatars.githubusercontent.com/u/202696?v=4)\n\n@Atheuz](https://github.com/Atheuz)\n\nContributions: 6\n\n[![](https://avatars.githubusercontent.com/u/3709715?u=0745d1d2473894c33f3b35f0b965d71cc9aec553&v=4)\n\n@cclauss](https://github.com/cclauss)\n\nContributions: 6\n\n[![](https://avatars.githubusercontent.com/u/16639270?u=faa71bcfb3273a32cd81711a56998e115bca7fcc&v=4)\n\n@AdolfoVillalobos](https://github.com/AdolfoVillalobos)\n\nContributions: 6\n\n[![](https://avatars.githubusercontent.com/u/6339494?u=893876f31ce65fa8ad8cfcc592392a77f0f8af38&v=4)\n\n@nuno-andre](https://github.com/nuno-andre)\n\nContributions: 5\n\n[![](https://avatars.githubusercontent.com/u/9677399?u=386c330f212ce467ce7119d9615c75d0e9b9f1ce&v=4)\n\n@ofek](https://github.com/ofek)\n\nContributions: 5\n\n[![](https://avatars.githubusercontent.com/u/9328433?u=8546519cb04223cd878285d72c27850b5f3f0882&v=4)\n\n@mschoettle](https://github.com/mschoettle)\n\nContributions: 5\n\n[![](https://avatars.githubusercontent.com/u/44468031?u=1590b6d141e6cbcc1862a95959b9a134fdb1f108&v=4)\n\n@karta9821](https://github.com/karta9821)\n\nContributions: 5\n\n[![](https://avatars.githubusercontent.com/u/1734544?v=4)\n\n@hmvp](https://github.com/hmvp)\n\nContributions: 4\n\n[![](https://avatars.githubusercontent.com/u/24581770?v=4)\n\n@retnikt](https://github.com/retnikt)\n\nContributions: 4\n\n[![](https://avatars.githubusercontent.com/u/197540?v=4)\n\n@therefromhere](https://github.com/therefromhere)\n\nContributions: 4\n\n[![](https://avatars.githubusercontent.com/u/10811879?v=4)\n\n@JeanArhancet](https://github.com/JeanArhancet)\n\nContributions: 4\n\n[![](https://avatars.githubusercontent.com/u/164513?v=4)\n\n@commonism](https://github.com/commonism)\n\nContributions: 4\n\n[![](https://avatars.githubusercontent.com/u/12939780?v=4)\n\n@MarkusSintonen](https://github.com/MarkusSintonen)\n\nContributions: 4\n\n[![](https://avatars.githubusercontent.com/u/59469646?u=86d6a20768cc4cc65622eafd86672147321bd8f8&v=4)\n\n@JensHeinrich](https://github.com/JensHeinrich)\n\nContributions: 4\n\n[![](https://avatars.githubusercontent.com/u/110765?u=7386b9cb55c1973a510d2785832424bc80e7c265&v=4)\n\n@mgorny](https://github.com/mgorny)\n\nContributions: 4\n\n[![](https://avatars.githubusercontent.com/u/25489980?u=1e9b5cbbbb1516fbea6da00429e4eef0ef79e4e6&v=4)\n\n@ornariece](https://github.com/ornariece)\n\nContributions: 4\n\n[![](https://avatars.githubusercontent.com/u/166007669?u=cd5df427a775972595777471436c673e94e03a1f&v=4)\n\n@rx-dwoodward](https://github.com/rx-dwoodward)\n\nContributions: 4", "url": "https://docs.pydantic.dev/latest/pydantic_people/index.html#top-contributorsindexhtmltop-contributors-permanent-link", "page": "pydantic_people/index.html", "source_site": "pydantic"}
{"title": "Top Reviewers[Â¶](index.html#top-reviewers \"Permanent link\")", "anchor": "top-reviewersindexhtmltop-reviewers-permanent-link", "md_text": "These are the users that have reviewed the most Pull Requests from others, assisting with code quality, documentation, bug fixes, feature requests, etc.\n\n[![](https://avatars.githubusercontent.com/u/54324534?u=acc3756515d6f87acc91e36a4478557cba9d9dac&v=4)\n\n@sydney-runkle](https://github.com/sydney-runkle)\n\nReviews: 691\n\n[![](https://avatars.githubusercontent.com/u/18406791?u=4853940cf5eeffb5bbb9ba06ad862f28bc68d69e&v=4)\n\n@PrettyWood](https://github.com/PrettyWood)\n\nReviews: 211\n\n[![](https://avatars.githubusercontent.com/u/38705?v=4)\n\n@lig](https://github.com/lig)\n\nReviews: 103\n\n[![](https://avatars.githubusercontent.com/u/370316?u=eb206070cfe47f242d5fcea2e6c7514f4d0f27f5&v=4)\n\n@tpdorsey](https://github.com/tpdorsey)\n\nReviews: 77\n\n[![](https://avatars.githubusercontent.com/in/718456?v=4)\n\n@hyperlint-ai](https://github.com/apps/hyperlint-ai)\n\nReviews: 57\n\n[![](https://avatars.githubusercontent.com/u/1326112?u=cb5d06e73a9e1998141b1641aa88e443c6717651&v=4)\n\n@tiangolo](https://github.com/tiangolo)\n\nReviews: 44\n\n[![](https://avatars.githubusercontent.com/u/159434?v=4)\n\n@DouweM](https://github.com/DouweM)\n\nReviews: 42\n\n[![](https://avatars.githubusercontent.com/u/36469655?u=f67d8fa6d67d35d2f5ebd5b15e24efeb41036fd3&v=4)\n\n@Bobronium](https://github.com/Bobronium)\n\nReviews: 27\n\n[![](https://avatars.githubusercontent.com/u/1087619?u=cd78c4f602bf9f9667277dd0af9302a7fe9dd75a&v=4)\n\n@Gr1N](https://github.com/Gr1N)\n\nReviews: 17\n\n[![](https://avatars.githubusercontent.com/u/1148665?u=b69e6fe797302f025a2d125e377e27f8ea0b8058&v=4)\n\n@StephenBrown2](https://github.com/StephenBrown2)\n\nReviews: 17\n\n[![](https://avatars.githubusercontent.com/u/12939780?v=4)\n\n@MarkusSintonen](https://github.com/MarkusSintonen)\n\nReviews: 16\n\n[![](https://avatars.githubusercontent.com/u/40807730?u=fa12d64259ccf9eca18847102335ee6408cb9eaa&v=4)\n\n@ybressler](https://github.com/ybressler)\n\nReviews: 15\n\n[![](https://avatars.githubusercontent.com/u/32038156?u=0c68019beb28381ce5205a838937c61e0fe3fee2&v=4)\n\n@uriyyo](https://github.com/uriyyo)\n\nReviews: 11\n\n[![](https://avatars.githubusercontent.com/u/630670?u=507d8577b4b3670546b449c4c2ccbc5af40d72f7&v=4)\n\n@koxudaxi](https://github.com/koxudaxi)\n\nReviews: 10\n\n[![](https://avatars.githubusercontent.com/u/1049817?u=b42e1148d23ea9039b325975bbea3ff8c5b4e3ec&v=4)\n\n@daviskirk](https://github.com/daviskirk)\n\nReviews: 10\n\n[![](https://avatars.githubusercontent.com/u/52716203?u=21b53ce4115062b1e20cb513e64ca0000c2ef127&v=4)\n\n@yezz123](https://github.com/yezz123)\n\nReviews: 10\n\n[![](https://avatars.githubusercontent.com/u/12229877?u=abc44dbce4bb3eca2def638bd0d4ab4cfef91b74&v=4)\n\n@Zac-HD](https://github.com/Zac-HD)\n\nReviews: 8\n\n[![](https://avatars.githubusercontent.com/u/31134424?u=e8afd95a97b5556c467d1be27788950e67378ef1&v=4)\n\n@layday](https://github.com/layday)\n\nReviews: 7\n\n[![](https://avatars.githubusercontent.com/u/89458301?u=75f53e971fcba3ff61836c389505a420bddd865c&v=4)\n\n@kc0506](https://github.com/kc0506)\n\nReviews: 7\n\n[![](https://avatars.githubusercontent.com/u/6400248?u=88cadd1dd6376e7000934e93712c5eb0138c1616&v=4)\n\n@pilosus](https://github.com/pilosus)\n\nReviews: 6", "url": "https://docs.pydantic.dev/latest/pydantic_people/index.html#top-reviewersindexhtmltop-reviewers-permanent-link", "page": "pydantic_people/index.html", "source_site": "pydantic"}
{"title": "Top Reviewers[Â¶](index.html#top-reviewers \"Permanent link\")", "anchor": "top-reviewersindexhtmltop-reviewers-permanent-link", "md_text": "[![](https://avatars.githubusercontent.com/u/13108583?u=0d34d39c0628091596c9d5ebb4e802009e8c4aca&v=4)\n\n@Kilo59](https://github.com/Kilo59)\n\nReviews: 6\n\n[![](https://avatars.githubusercontent.com/u/10811879?v=4)\n\n@JeanArhancet](https://github.com/JeanArhancet)\n\nReviews: 6\n\n[![](https://avatars.githubusercontent.com/u/1609449?u=922abf0524b47739b37095e553c99488814b05db&v=4)\n\n@tlambert03](https://github.com/tlambert03)\n\nReviews: 5\n\n[![](https://avatars.githubusercontent.com/u/537700?u=d6cc48076a656f94710d8e1266c92792b8c9d7c4&v=4)\n\n@christianbundy](https://github.com/christianbundy)\n\nReviews: 5\n\n[![](https://avatars.githubusercontent.com/u/16438204?u=f700f440b89e715795c3bc091800b8d3f39c58d9&v=4)\n\n@nix010](https://github.com/nix010)\n\nReviews: 5\n\n[![](https://avatars.githubusercontent.com/u/44468031?u=1590b6d141e6cbcc1862a95959b9a134fdb1f108&v=4)\n\n@karta9821](https://github.com/karta9821)\n\nReviews: 5\n\n[![](https://avatars.githubusercontent.com/u/413772?v=4)\n\n@graingert](https://github.com/graingert)\n\nReviews: 4\n\n[![](https://avatars.githubusercontent.com/u/1734544?v=4)\n\n@hmvp](https://github.com/hmvp)\n\nReviews: 4\n\n[![](https://avatars.githubusercontent.com/u/5042313?u=8917c345dcb528733073ff1ce8a512e33f548512&v=4)\n\n@wozniakty](https://github.com/wozniakty)\n\nReviews: 4\n\n[![](https://avatars.githubusercontent.com/u/6339494?u=893876f31ce65fa8ad8cfcc592392a77f0f8af38&v=4)\n\n@nuno-andre](https://github.com/nuno-andre)\n\nReviews: 4\n\n[![](https://avatars.githubusercontent.com/u/2099618?u=a9899c1fea247d500e5368a1157a392bcd82e81d&v=4)\n\n@antdking](https://github.com/antdking)\n\nReviews: 4\n\n[![](https://avatars.githubusercontent.com/u/662249?u=15313dec91bae789685e4abb3c2152251de41948&v=4)\n\n@dimaqq](https://github.com/dimaqq)\n\nReviews: 4\n\n[![](https://avatars.githubusercontent.com/u/57028336?u=387c51980cb3734c41543ae2276a23736906bdb9&v=4)\n\n@DetachHead](https://github.com/DetachHead)\n\nReviews: 4\n\n[![](https://avatars.githubusercontent.com/u/59469646?u=86d6a20768cc4cc65622eafd86672147321bd8f8&v=4)\n\n@JensHeinrich](https://github.com/JensHeinrich)\n\nReviews: 4", "url": "https://docs.pydantic.dev/latest/pydantic_people/index.html#top-reviewersindexhtmltop-reviewers-permanent-link", "page": "pydantic_people/index.html", "source_site": "pydantic"}
{"title": "About the data[Â¶](index.html#about-the-data \"Permanent link\")", "anchor": "about-the-dataindexhtmlabout-the-data-permanent-link", "md_text": "The data displayed above is calculated monthly via the Github GraphQL API (see\n[source code](https://github.com/pydantic/pydantic/tree/main/.github/actions/people/people.py),\nmany thanks to [SebastiÃ¡n RamÃ­rez](https://github.com/tiangolo) for the script from which we based this logic).\n\nDepending on changing conditions, the thresholds for the different categories of contributors may change in the future.\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/pydantic_people/index.html#about-the-dataindexhtmlabout-the-data-permanent-link", "page": "pydantic_people/index.html", "source_site": "pydantic"}
{"title": "Pydantic V1[Â¶](index.html#pydantic-v1 \"Permanent link\")", "anchor": "pydantic-v1indexhtmlpydantic-v1-permanent-link", "md_text": "Active development of V1 has already stopped, however critical bug fixes and security vulnerabilities will be fixed in V1 until\nthe release of Pydantic V3.", "url": "https://docs.pydantic.dev/latest/version-policy/index.html#pydantic-v1indexhtmlpydantic-v1-permanent-link", "page": "version-policy/index.html", "source_site": "pydantic"}
{"title": "Pydantic V2[Â¶](index.html#pydantic-v2 \"Permanent link\")", "anchor": "pydantic-v2indexhtmlpydantic-v2-permanent-link", "md_text": "We will not intentionally make breaking changes in minor releases of V2.\n\nFunctionality marked as deprecated will not be removed until the next major V3 release.\n\nOf course, some apparently safe changes and bug fixes will inevitably break some users' code â€” obligatory link to [xkcd](https://xkcd.com/1172/).\n\nThe following changes will **NOT** be considered breaking changes, and may occur in minor releases:\n\n* Bug fixes that may result in existing code breaking, provided that such code was relying on undocumented features/constructs.\n* Changing the format of JSON Schema [references](https://json-schema.org/understanding-json-schema/structuring#dollarref).\n* Changing the `msg`, `ctx`, and `loc` fields of [`ValidationError`](../api/pydantic_core/index.html#pydantic_core.ValidationError) exceptions. `type` will not change â€” if you're programmatically parsing error messages, you should use `type`.\n* Adding new keys to [`ValidationError`](../api/pydantic_core/index.html#pydantic_core.ValidationError) exceptions â€” e.g. we intend to add `line_number` and `column_number` to errors when validating JSON once we migrate to a new JSON parser.\n* Adding new [`ValidationError`](../api/pydantic_core/index.html#pydantic_core.ValidationError) errors.\n* Changing how `__repr__` behaves, even of public classes.\n* The contents of the [core schemas](../internals/architecture/index.html#communicating-between-pydantic-and-pydantic-core-the-core-schema) (usually available under the\n\n\n\n[`__pydantic_core_schema__`](../api/base_model/index.html#pydantic.BaseModel.__pydantic_core_schema__) attribute for Pydantic models and `core_schema` for [type adapters](../concepts/type_adapter/index.html))\nmay change between releases (this is a low-level format Pydantic uses to plan how to execute validation and serialization).\n\nIn all cases we will aim to minimize churn and do so only when justified by the increase of quality of Pydantic for users.", "url": "https://docs.pydantic.dev/latest/version-policy/index.html#pydantic-v2indexhtmlpydantic-v2-permanent-link", "page": "version-policy/index.html", "source_site": "pydantic"}
{"title": "Pydantic V3 and beyond[Â¶](index.html#pydantic-v3-and-beyond \"Permanent link\")", "anchor": "pydantic-v3-and-beyondindexhtmlpydantic-v3-and-beyond-permanent-link", "md_text": "We expect to make new major releases roughly once a year going forward, although as mentioned above, any associated breaking changes should be trivial to fix compared to the V1-to-V2 transition.", "url": "https://docs.pydantic.dev/latest/version-policy/index.html#pydantic-v3-and-beyondindexhtmlpydantic-v3-and-beyond-permanent-link", "page": "version-policy/index.html", "source_site": "pydantic"}
{"title": "Experimental Features[Â¶](index.html#experimental-features \"Permanent link\")", "anchor": "experimental-featuresindexhtmlexperimental-features-permanent-link", "md_text": "At Pydantic, we like to move quickly and innovate! To that end, we may introduce experimental features in minor releases.\n\nTo learn more about our current experimental features, see the [experimental features documentation](../concepts/experimental/index.html).\n\nPlease keep in mind, experimental features are active works in progress. If these features are successful, they'll eventually become part of Pydantic. If unsuccessful, said features will be removed with little notice. While in its experimental phase, a feature's API and behaviors may not be stable, and it's very possible that changes made to the feature will not be backward-compatible.", "url": "https://docs.pydantic.dev/latest/version-policy/index.html#experimental-featuresindexhtmlexperimental-features-permanent-link", "page": "version-policy/index.html", "source_site": "pydantic"}
{"title": "Naming Conventions[Â¶](index.html#naming-conventions \"Permanent link\")", "anchor": "naming-conventionsindexhtmlnaming-conventions-permanent-link", "md_text": "We use one of the following naming conventions to indicate that a feature is experimental:\n\n1. The feature is located in the [`experimental`](../api/experimental/index.html) module. In this case, you can access the feature like this:\n\n   ```\n   from pydantic.experimental import feature_name\n   ```\n2. The feature is located in the main module, but prefixed with `experimental_`. This case occurs when we add a new field, argument, or method to an existing data structure already within the main `pydantic` module.\n\nNew features with these naming conventions are subject to change or removal, and we are looking for feedback and suggestions before making them a permanent part of Pydantic. See the [feedback section](../concepts/experimental/index.html#feedback) for more information.", "url": "https://docs.pydantic.dev/latest/version-policy/index.html#naming-conventionsindexhtmlnaming-conventions-permanent-link", "page": "version-policy/index.html", "source_site": "pydantic"}
{"title": "Lifecycle of Experimental Features[Â¶](index.html#lifecycle-of-experimental-features \"Permanent link\")", "anchor": "lifecycle-of-experimental-featuresindexhtmllifecycle-of-experimental-features-permanent-link", "md_text": "1. A new feature is added, either in the [`experimental`](../api/experimental/index.html) module or with the `experimental_` prefix.\n2. The behavior is often modified during patch/minor releases, with potential API/behavior changes.\n3. If the feature is successful, we promote it to Pydantic with the following steps:\n\n   a. If it was in the [`experimental`](../api/experimental/index.html) module, the feature is cloned to Pydantic's main module. The original experimental feature still remains in the [`experimental`](../api/experimental/index.html) module, but it will show a warning when used. If the feature was already in the main Pydantic module, we create a copy of the feature without the `experimental_` prefix, so the feature exists with both the official and experimental names. A deprecation warning is attached to the experimental version.\n\n   b. At some point, the code of the experimental feature is removed, but there will still be a stub of the feature that provides an error message with appropriate instructions.\n\n   c. As a last step, the experimental version of the feature is entirely removed from the codebase.\n\nIf the feature is unsuccessful or unpopular, it's removed with little notice. A stub will remain in the location of the deprecated feature with an error message.\n\nThanks to [streamlit](https://docs.streamlit.io/develop/quick-reference/prerelease) for the inspiration for the lifecycle and naming conventions of our new experimental feature patterns.", "url": "https://docs.pydantic.dev/latest/version-policy/index.html#lifecycle-of-experimental-featuresindexhtmllifecycle-of-experimental-features-permanent-link", "page": "version-policy/index.html", "source_site": "pydantic"}
{"title": "Support for Python versions[Â¶](index.html#support-for-python-versions \"Permanent link\")", "anchor": "support-for-python-versionsindexhtmlsupport-for-python-versions-permanent-link", "md_text": "Pydantic will drop support for a Python version when the following conditions are met:\n\n* The Python version has reached its [expected end of life](https://devguide.python.org/versions/).\n* less than 5% of downloads of the most recent minor release are using that version.\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/version-policy/index.html#support-for-python-versionsindexhtmlsupport-for-python-versions-permanent-link", "page": "version-policy/index.html", "source_site": "pydantic"}
{"title": "v2.12.3 (2025-10-17)[Â¶](index.html#v2123-2025-10-17 \"Permanent link\")", "anchor": "v2123-2025-10-17indexhtmlv2123-2025-10-17-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.12.3)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v2123-2025-10-17indexhtmlv2123-2025-10-17-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed-permanent-link", "md_text": "This is the third 2.13 patch release, fixing issues related to the `FieldInfo` class, and reverting a change to the supported\n[*after* model validator](../concepts/validators/index.html#model-validators) function signatures.\n\n* Raise a warning when an invalid after model validator function signature is raised by [@Viicos](https://github.com/Viicos) in [#12414](https://github.com/pydantic/pydantic/pull/12414).\n  Starting in 2.12.0, using class methods for *after* model validators raised an error, but the error wasn't raised concistently. We decided\n  to emit a deprecation warning instead.\n* Add [`FieldInfo.asdict()`](../api/fields/index.html#pydantic.fields.FieldInfo.asdict) method, improve documentation around `FieldInfo` by [@Viicos](https://github.com/Viicos) in [#12411](https://github.com/pydantic/pydantic/pull/12411).\n  This also add back support for mutations on `FieldInfo` classes, that are reused as `Annotated` metadata. **However**, note that this is still\n  *not* a supported pattern. Instead, please refer to the [added example](../examples/dynamic_models/index.html) in the documentation.\n\nThe [blog post](https://pydantic.dev/articles/pydantic-v2-12-release#changes) section on changes was also updated to document the changes related to `serialize_as_any`.\n\n#### Fixes[Â¶](index.html#fixes \"Permanent link\")\n\n* Release a new `pydantic-core` version, as a corrupted CPython 3.10 `manylinux2014_aarch64` wheel got uploaded ([pydantic-core#1843](https://github.com/pydantic/pydantic-core/pull/1843)).\n* Fix issue with recursive generic models with a parent model class by [@Viicos](https://github.com/Viicos) in [#12398](https://github.com/pydantic/pydantic/pull/12398)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.12.2 (2025-10-14)[Â¶](index.html#v2122-2025-10-14 \"Permanent link\")", "anchor": "v2122-2025-10-14indexhtmlv2122-2025-10-14-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.12.2)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v2122-2025-10-14indexhtmlv2122-2025-10-14-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_1 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed1-permanent-link", "md_text": "#### Fixes[Â¶](index.html#fixes_1 \"Permanent link\")\n\n* Release a new `pydantic-core` version, as a corrupted CPython 3.10 `manylinux2014_aarch64` wheel got uploaded ([pydantic-core#1843](https://github.com/pydantic/pydantic-core/pull/1843)).\n* Fix issue with recursive generic models with a parent model class by [@Viicos](https://github.com/Viicos) in [#12398](https://github.com/pydantic/pydantic/pull/12398)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed1-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.12.1 (2025-10-13)[Â¶](index.html#v2121-2025-10-13 \"Permanent link\")", "anchor": "v2121-2025-10-13indexhtmlv2121-2025-10-13-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.12.1)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v2121-2025-10-13indexhtmlv2121-2025-10-13-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_2 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed2-permanent-link", "md_text": "This is the first 2.12 patch release, addressing most (but not all yet) regressions from the initial 2.12.0 release.\n\n#### Fixes[Â¶](index.html#fixes_2 \"Permanent link\")\n\n* Do not evaluate annotations when inspecting validators and serializers by [@Viicos](https://github.com/Viicos) in [#12355](https://github.com/pydantic/pydantic/pull/12355)\n* Make sure `None` is converted as `NoneType` in Python 3.14 by [@Viicos](https://github.com/Viicos) in [#12370](https://github.com/pydantic/pydantic/pull/12370)\n* Backport V1 runtime warning when using Python 3.14 by [@Viicos](https://github.com/Viicos) in [#12367](https://github.com/pydantic/pydantic/pull/12367)\n* Fix error message for invalid validator signatures by [@Viicos](https://github.com/Viicos) in [#12366](https://github.com/pydantic/pydantic/pull/12366)\n* Populate field name in `ValidationInfo` for validation of default value by [@Viicos](https://github.com/Viicos) in [pydantic-core#1826](https://github.com/pydantic/pydantic-core/pull/1826)\n* Encode credentials in `MultiHostUrl` builder by [@willswire](https://github.com/willswire) in [pydantic-core#1829](https://github.com/pydantic/pydantic-core/pull/1829)\n* Respect field serializers when using `serialize_as_any` serialization flag by [@davidhewitt](https://github.com/davidhewitt) in [pydantic-core#1829](https://github.com/pydantic/pydantic-core/pull/1829)\n* Fix various `RootModel` serialization issues by [@davidhewitt](https://github.com/davidhewitt) in [pydantic-core#1836](https://github.com/pydantic/pydantic-core/pull/1836)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed2-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "New Contributors[Â¶](index.html#new-contributors \"Permanent link\")", "anchor": "new-contributorsindexhtmlnew-contributors-permanent-link", "md_text": "* [@willswire](https://github.com/willswire) made their first contribution in [pydantic-core#1829](https://github.com/pydantic/pydantic-core/pull/1829)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#new-contributorsindexhtmlnew-contributors-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.12.0 (2025-10-07)[Â¶](index.html#v2120-2025-10-07 \"Permanent link\")", "anchor": "v2120-2025-10-07indexhtmlv2120-2025-10-07-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.12.0)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v2120-2025-10-07indexhtmlv2120-2025-10-07-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_3 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed3-permanent-link", "md_text": "This is the final 2.12 release. It features the work of 20 external contributors and provides useful new features, along with initial Python 3.14 support.\nSeveral minor changes (considered non-breaking changes according to our [versioning policy](https://docs.pydantic.dev/2.12/version-policy/#pydantic-v2))\nare also included in this release. Make sure to look into them before upgrading.\n\n**Note that Pydantic V1 is not compatible with Python 3.14 and greater**.\n\nChanges (see the alpha and beta releases for additional changes since 2.11):\n\n#### Packaging[Â¶](index.html#packaging \"Permanent link\")\n\n* Update V1 copy to v1.10.24 by [@Viicos](https://github.com/Viicos) in [#12338](https://github.com/pydantic/pydantic/pull/12338)\n\n#### New Features[Â¶](index.html#new-features \"Permanent link\")\n\n* Add `extra` parameter to the validate functions by [@anvilpete](https://github.com/anvilpete) in [#12233](https://github.com/pydantic/pydantic/pull/12233)\n* Add `exclude_computed_fields` serialization option by [@Viicos](https://github.com/Viicos) in [#12334](https://github.com/pydantic/pydantic/pull/12334)\n* Add `preverse_empty_path` URL options by [@Viicos](https://github.com/Viicos) in [#12336](https://github.com/pydantic/pydantic/pull/12336)\n* Add `union_format` parameter to JSON Schema generation by [@Viicos](https://github.com/Viicos) in [#12147](https://github.com/pydantic/pydantic/pull/12147)\n* Add `__qualname__` parameter for `create_model` by [@Atry](https://github.com/Atry) in [#12001](https://github.com/pydantic/pydantic/pull/12001)\n\n#### Fixes[Â¶](index.html#fixes_3 \"Permanent link\")\n\n* Do not try to infer name from lambda definitions in pipelines API by [@Viicos](https://github.com/Viicos) in [#12289](https://github.com/pydantic/pydantic/pull/12289)\n* Use proper namespace for functions in `TypeAdapter` by [@Viicos](https://github.com/Viicos) in [#12324](https://github.com/pydantic/pydantic/pull/12324)\n* Use `Any` for context type annotation in `TypeAdapter` by [@inducer](https://github.com/inducer) in [#12279](https://github.com/pydantic/pydantic/pull/12279)\n* Expose `FieldInfo` in `pydantic.fields.__all__` by [@Viicos](https://github.com/Viicos) in [#12339](https://github.com/pydantic/pydantic/pull/12339)\n* Respect `validation_alias` in `@validate_call` by [@Viicos](https://github.com/Viicos) in [#12340](https://github.com/pydantic/pydantic/pull/12340)\n* Use `Any` as context annotation in plugin API by [@Viicos](https://github.com/Viicos) in [#12341](https://github.com/pydantic/pydantic/pull/12341)\n* Use proper `stacklevel` in warnings when possible by [@Viicos](https://github.com/Viicos) in [#12342](https://github.com/pydantic/pydantic/pull/12342)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed3-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "New Contributors[Â¶](index.html#new-contributors_1 \"Permanent link\")", "anchor": "new-contributorsindexhtmlnew-contributors1-permanent-link", "md_text": "* [@anvilpete](https://github.com/anvilpete) made their first contribution in [#12233](https://github.com/pydantic/pydantic/pull/12233)\n* [@JonathanWindell](https://github.com/JonathanWindell) made their first contribution in [#12327](https://github.com/pydantic/pydantic/pull/12327)\n* [@inducer](https://github.com/inducer) made their first contribution in [#12279](https://github.com/pydantic/pydantic/pull/12279)\n* [@Atry](https://github.com/Atry) made their first contribution in [#12001](https://github.com/pydantic/pydantic/pull/12001)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#new-contributorsindexhtmlnew-contributors1-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.12.0b1 (2025-10-03)[Â¶](index.html#v2120b1-2025-10-03 \"Permanent link\")", "anchor": "v2120b1-2025-10-03indexhtmlv2120b1-2025-10-03-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.12.0b1)\n\nThis is the first beta release of the upcoming 2.12 release.", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v2120b1-2025-10-03indexhtmlv2120b1-2025-10-03-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_4 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed4-permanent-link", "md_text": "#### Packaging[Â¶](index.html#packaging_1 \"Permanent link\")\n\n* Bump `pydantic-core` to v2.40.1 by [@Viicos](https://github.com/Viicos) in [#12314](https://github.com/pydantic/pydantic/pull/12314)\n\n#### New Features[Â¶](index.html#new-features_1 \"Permanent link\")\n\n* Add support for `exclude_if` at the field level by [@andresliszt](https://github.com/andresliszt) in [#12141](https://github.com/pydantic/pydantic/pull/12141)\n* Add `ValidateAs` annotation helper by [@Viicos](https://github.com/Viicos) in [#11942](https://github.com/pydantic/pydantic/pull/11942)\n* Add configuration options for validation and JSON serialization of temporal types by [@ollz272](https://github.com/ollz272) in [#12068](https://github.com/pydantic/pydantic/pull/12068)\n* Add support for PEP 728 by [@Viicos](https://github.com/Viicos) in [#12179](https://github.com/pydantic/pydantic/pull/12179)\n* Add field name in serialization error by [@NicolasPllr1](https://github.com/NicolasPllr1) in [pydantic-core#1799](https://github.com/pydantic/pydantic-core/pull/1799)\n* Add option to preserve empty URL paths by [@davidhewitt](https://github.com/davidhewitt) in [pydantic-core#1789](https://github.com/pydantic/pydantic-core/pull/1789)\n\n#### Changes[Â¶](index.html#changes \"Permanent link\")\n\n* Raise error if an incompatible `pydantic-core` version is installed by [@Viicos](https://github.com/Viicos) in [#12196](https://github.com/pydantic/pydantic/pull/12196)\n* Remove runtime warning for experimental features by [@Viicos](https://github.com/Viicos) in [#12265](https://github.com/pydantic/pydantic/pull/12265)\n* Warn if registering virtual subclasses on Pydantic models by [@Viicos](https://github.com/Viicos) in [#11669](https://github.com/pydantic/pydantic/pull/11669)\n\n#### Fixes[Â¶](index.html#fixes_4 \"Permanent link\")\n\n* Fix `__getattr__()` behavior on Pydantic models when a property raised an `AttributeError` and extra values are present by [@raspuchin](https://github.com/raspuchin) in [#12106](https://github.com/pydantic/pydantic/pull/12106)\n* Add test to prevent regression with Pydantic models used as annotated metadata by [@Viicos](https://github.com/Viicos) in [#12133](https://github.com/pydantic/pydantic/pull/12133)\n* Allow to use property setters on Pydantic dataclasses with `validate_assignment` set by [@Viicos](https://github.com/Viicos) in [#12173](https://github.com/pydantic/pydantic/pull/12173)\n* Fix mypy v2 plugin for upcoming mypy release by [@cdce8p](https://github.com/cdce8p) in [#12209](https://github.com/pydantic/pydantic/pull/12209)\n* Respect custom title in functions JSON Schema by [@Viicos](https://github.com/Viicos) in [#11892](https://github.com/pydantic/pydantic/pull/11892)\n* Fix `ImportString` JSON serialization for objects with a `name` attribute by [@chr1sj0nes](https://github.com/chr1sj0nes) in [#12219](https://github.com/pydantic/pydantic/pull/12219)\n* Do not error on fields overridden by methods in the mypy plugin by [@Viicos](https://github.com/Viicos) in [#12290](https://github.com/pydantic/pydantic/pull/12290)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed4-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "New Contributors[Â¶](index.html#new-contributors_2 \"Permanent link\")", "anchor": "new-contributorsindexhtmlnew-contributors2-permanent-link", "md_text": "* [@raspuchin](https://github.com/raspuchin) made their first contribution in [#12106](https://github.com/pydantic/pydantic/pull/12106)\n* [@chr1sj0nes](https://github.com/chr1sj0nes) made their first contribution in [#12219](https://github.com/pydantic/pydantic/pull/12219)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#new-contributorsindexhtmlnew-contributors2-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.12.0a1 (2025-07-26)[Â¶](index.html#v2120a1-2025-07-26 \"Permanent link\")", "anchor": "v2120a1-2025-07-26indexhtmlv2120a1-2025-07-26-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.12.0a1)\n\nThis is the first alpha release of the upcoming 2.12 release, which adds initial support for Python 3.14.", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v2120a1-2025-07-26indexhtmlv2120a1-2025-07-26-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_5 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed5-permanent-link", "md_text": "#### New Features[Â¶](index.html#new-features_2 \"Permanent link\")\n\n* Add `__pydantic_on_complete__()` hook that is called once model is fully ready to be used by [@DouweM](https://github.com/DouweM) in [#11762](https://github.com/pydantic/pydantic/pull/11762)\n* Add initial support for Python 3.14 by [@Viicos](https://github.com/Viicos) in [#11991](https://github.com/pydantic/pydantic/pull/11991)\n* Add regex patterns to JSON schema for `Decimal` type by [@Dima-Bulavenko](https://github.com/Dima-Bulavenko) in [#11987](https://github.com/pydantic/pydantic/pull/11987)\n* Add support for `doc` attribute on dataclass fields by [@Viicos](https://github.com/Viicos) in [#12077](https://github.com/pydantic/pydantic/pull/12077)\n* Add experimental `MISSING` sentinel by [@Viicos](https://github.com/Viicos) in [#11883](https://github.com/pydantic/pydantic/pull/11883)\n\n#### Changes[Â¶](index.html#changes_1 \"Permanent link\")\n\n* Allow config and bases to be specified together in `create_model()` by [@Viicos](https://github.com/Viicos) in [#11714](https://github.com/pydantic/pydantic/pull/11714)\n* Move some field logic out of the `GenerateSchema` class by [@Viicos](https://github.com/Viicos) in [#11733](https://github.com/pydantic/pydantic/pull/11733)\n* Always make use of `inspect.getsourcelines()` for docstring extraction on Python 3.13 and greater by [@Viicos](https://github.com/Viicos) in [#11829](https://github.com/pydantic/pydantic/pull/11829)\n* Only support the latest Mypy version by [@Viicos](https://github.com/Viicos) in [#11832](https://github.com/pydantic/pydantic/pull/11832)\n* Do not implicitly convert after model validators to class methods by [@Viicos](https://github.com/Viicos) in [#11957](https://github.com/pydantic/pydantic/pull/11957)\n* Refactor `FieldInfo` creation implementation by [@Viicos](https://github.com/Viicos) in [#11898](https://github.com/pydantic/pydantic/pull/11898)\n* Make `Secret` covariant by [@bluenote10](https://github.com/bluenote10) in [#12008](https://github.com/pydantic/pydantic/pull/12008)\n* Emit warning when field-specific metadata is used in invalid contexts by [@Viicos](https://github.com/Viicos) in [#12028](https://github.com/pydantic/pydantic/pull/12028)\n\n#### Fixes[Â¶](index.html#fixes_5 \"Permanent link\")", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed5-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_5 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed5-permanent-link", "md_text": "* Properly fetch plain serializer function when serializing default value in JSON Schema by [@Viicos](https://github.com/Viicos) in [#11721](https://github.com/pydantic/pydantic/pull/11721)\n* Remove generics cache workaround by [@Viicos](https://github.com/Viicos) in [#11755](https://github.com/pydantic/pydantic/pull/11755)\n* Remove coercion of decimal constraints by [@Viicos](https://github.com/Viicos) in [#11772](https://github.com/pydantic/pydantic/pull/11772)\n* Fix crash when expanding root type in the mypy plugin by [@Viicos](https://github.com/Viicos) in [#11735](https://github.com/pydantic/pydantic/pull/11735)\n* Only mark model as complete once all fields are complete by [@DouweM](https://github.com/DouweM) in [#11759](https://github.com/pydantic/pydantic/pull/11759)\n* Do not provide `field_name` in validator core schemas by [@DouweM](https://github.com/DouweM) in [#11761](https://github.com/pydantic/pydantic/pull/11761)\n* Fix issue with recursive generic models by [@Viicos](https://github.com/Viicos) in [#11775](https://github.com/pydantic/pydantic/pull/11775)\n* Fix qualified name comparison of private attributes during namespace inspection by [@karta9821](https://github.com/karta9821) in [#11803](https://github.com/pydantic/pydantic/pull/11803)\n* Make sure Pydantic dataclasses with slots and `validate_assignment` can be unpickled by [@Viicos](https://github.com/Viicos) in [#11769](https://github.com/pydantic/pydantic/pull/11769)\n* Traverse `function-before` schemas during schema gathering by [@Viicos](https://github.com/Viicos) in [#11801](https://github.com/pydantic/pydantic/pull/11801)\n* Fix check for stdlib dataclasses by [@Viicos](https://github.com/Viicos) in [#11822](https://github.com/pydantic/pydantic/pull/11822)\n* Check if `FieldInfo` is complete after applying type variable map by [@Viicos](https://github.com/Viicos) in [#11855](https://github.com/pydantic/pydantic/pull/11855)\n* Do not delete mock validator/serializer in `model_rebuild()` by [@Viicos](https://github.com/Viicos) in [#11890](https://github.com/pydantic/pydantic/pull/11890)\n* Rebuild dataclass fields before schema generation by [@Viicos](https://github.com/Viicos) in [#11949](https://github.com/pydantic/pydantic/pull/11949)\n* Always store the original field assignment on `FieldInfo` by [@Viicos](https://github.com/Viicos) in [#11946](https://github.com/pydantic/pydantic/pull/11946)\n* Do not use deprecated methods as default field values by [@Viicos](https://github.com/Viicos) in [#11914](https://github.com/pydantic/pydantic/pull/11914)\n* Allow callable discriminator to be applied on PEP 695 type aliases by [@Viicos](https://github.com/Viicos) in [#11941](https://github.com/pydantic/pydantic/pull/11941)\n* Suppress core schema generation warning when using `SkipValidation` by [@ygsh0816](https://github.com/ygsh0816) in [#12002](https://github.com/pydantic/pydantic/pull/12002)\n* Do not emit typechecking error for invalid `Field()` default with `validate_default` set to `True` by [@Viicos](https://github.com/Viicos) in [#11988](https://github.com/pydantic/pydantic/pull/11988)\n* Refactor logic to support Pydantic's `Field()` function in dataclasses by [@Viicos](https://github.com/Viicos) in [#12051](https://github.com/pydantic/pydantic/pull/12051)\n\n#### Packaging[Â¶](index.html#packaging_2 \"Permanent link\")", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed5-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_5 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed5-permanent-link", "md_text": "* Update project metadata to use PEP 639 by [@Viicos](https://github.com/Viicos) in [#11694](https://github.com/pydantic/pydantic/pull/11694)\n* Bump `mkdocs-llmstxt` to v0.2.0 by [@Viicos](https://github.com/Viicos) in [#11725](https://github.com/pydantic/pydantic/pull/11725)\n* Bump `pydantic-core` to v2.35.1 by [@Viicos](https://github.com/Viicos) in [#11963](https://github.com/pydantic/pydantic/pull/11963)\n* Bump dawidd6/action-download-artifact from 10 to 11 by [@dependabot](https://github.com/dependabot)[bot] in [#12033](https://github.com/pydantic/pydantic/pull/12033)\n* Bump astral-sh/setup-uv from 5 to 6 by [@dependabot](https://github.com/dependabot)[bot] in [#11826](https://github.com/pydantic/pydantic/pull/11826)\n* Update mypy to 1.17.0 by [@Viicos](https://github.com/Viicos) in [#12076](https://github.com/pydantic/pydantic/pull/12076)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed5-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "New Contributors[Â¶](index.html#new-contributors_3 \"Permanent link\")", "anchor": "new-contributorsindexhtmlnew-contributors3-permanent-link", "md_text": "* [@parth-paradkar](https://github.com/parth-paradkar) made their first contribution in [#11695](https://github.com/pydantic/pydantic/pull/11695)\n* [@dqkqd](https://github.com/dqkqd) made their first contribution in [#11739](https://github.com/pydantic/pydantic/pull/11739)\n* [@fhightower](https://github.com/fhightower) made their first contribution in [#11722](https://github.com/pydantic/pydantic/pull/11722)\n* [@gbaian10](https://github.com/gbaian10) made their first contribution in [#11766](https://github.com/pydantic/pydantic/pull/11766)\n* [@DouweM](https://github.com/DouweM) made their first contribution in [#11759](https://github.com/pydantic/pydantic/pull/11759)\n* [@bowenliang123](https://github.com/bowenliang123) made their first contribution in [#11719](https://github.com/pydantic/pydantic/pull/11719)\n* [@rawwar](https://github.com/rawwar) made their first contribution in [#11799](https://github.com/pydantic/pydantic/pull/11799)\n* [@karta9821](https://github.com/karta9821) made their first contribution in [#11803](https://github.com/pydantic/pydantic/pull/11803)\n* [@jinnovation](https://github.com/jinnovation) made their first contribution in [#11834](https://github.com/pydantic/pydantic/pull/11834)\n* [@zmievsa](https://github.com/zmievsa) made their first contribution in [#11861](https://github.com/pydantic/pydantic/pull/11861)\n* [@Otto-AA](https://github.com/Otto-AA) made their first contribution in [#11860](https://github.com/pydantic/pydantic/pull/11860)\n* [@ygsh0816](https://github.com/ygsh0816) made their first contribution in [#12002](https://github.com/pydantic/pydantic/pull/12002)\n* [@lukland](https://github.com/lukland) made their first contribution in [#12015](https://github.com/pydantic/pydantic/pull/12015)\n* [@Dima-Bulavenko](https://github.com/Dima-Bulavenko) made their first contribution in [#11987](https://github.com/pydantic/pydantic/pull/11987)\n* [@GSemikozov](https://github.com/GSemikozov) made their first contribution in [#12050](https://github.com/pydantic/pydantic/pull/12050)\n* [@hannah-heywa](https://github.com/hannah-heywa) made their first contribution in [#12082](https://github.com/pydantic/pydantic/pull/12082)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#new-contributorsindexhtmlnew-contributors3-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.11.7 (2025-06-14)[Â¶](index.html#v2117-2025-06-14 \"Permanent link\")", "anchor": "v2117-2025-06-14indexhtmlv2117-2025-06-14-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.11.7)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v2117-2025-06-14indexhtmlv2117-2025-06-14-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_6 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed6-permanent-link", "md_text": "#### Fixes[Â¶](index.html#fixes_6 \"Permanent link\")\n\n* Copy `FieldInfo` instance if necessary during `FieldInfo` build by [@Viicos](https://github.com/Viicos) in [#11898](https://github.com/pydantic/pydantic/pull/11898)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed6-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.11.6 (2025-06-13)[Â¶](index.html#v2116-2025-06-13 \"Permanent link\")", "anchor": "v2116-2025-06-13indexhtmlv2116-2025-06-13-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.11.6)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v2116-2025-06-13indexhtmlv2116-2025-06-13-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_7 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed7-permanent-link", "md_text": "#### Fixes[Â¶](index.html#fixes_7 \"Permanent link\")\n\n* Rebuild dataclass fields before schema generation by [@Viicos](https://github.com/Viicos) in [#11949](https://github.com/pydantic/pydantic/pull/11949)\n* Always store the original field assignment on `FieldInfo` by [@Viicos](https://github.com/Viicos) in [#11946](https://github.com/pydantic/pydantic/pull/11946)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed7-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.11.5 (2025-05-22)[Â¶](index.html#v2115-2025-05-22 \"Permanent link\")", "anchor": "v2115-2025-05-22indexhtmlv2115-2025-05-22-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.11.5)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v2115-2025-05-22indexhtmlv2115-2025-05-22-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_8 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed8-permanent-link", "md_text": "#### Fixes[Â¶](index.html#fixes_8 \"Permanent link\")\n\n* Check if `FieldInfo` is complete after applying type variable map by [@Viicos](https://github.com/Viicos) in [#11855](https://github.com/pydantic/pydantic/pull/11855)\n* Do not delete mock validator/serializer in `model_rebuild()` by [@Viicos](https://github.com/Viicos) in [#11890](https://github.com/pydantic/pydantic/pull/11890)\n* Do not duplicate metadata on model rebuild by [@Viicos](https://github.com/Viicos) in [#11902](https://github.com/pydantic/pydantic/pull/11902)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed8-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.11.4 (2025-04-29)[Â¶](index.html#v2114-2025-04-29 \"Permanent link\")", "anchor": "v2114-2025-04-29indexhtmlv2114-2025-04-29-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.11.4)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v2114-2025-04-29indexhtmlv2114-2025-04-29-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_9 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed9-permanent-link", "md_text": "#### Packaging[Â¶](index.html#packaging_3 \"Permanent link\")\n\n* Bump `mkdocs-llmstxt` to v0.2.0 by [@Viicos](https://github.com/Viicos) in [#11725](https://github.com/pydantic/pydantic/pull/11725)\n\n#### Changes[Â¶](index.html#changes_2 \"Permanent link\")\n\n* Allow config and bases to be specified together in `create_model()` by [@Viicos](https://github.com/Viicos) in [#11714](https://github.com/pydantic/pydantic/pull/11714).\n  This change was backported as it was previously possible (although not meant to be supported)\n  to provide `model_config` as a field, which would make it possible to provide both configuration\n  and bases.\n\n#### Fixes[Â¶](index.html#fixes_9 \"Permanent link\")\n\n* Remove generics cache workaround by [@Viicos](https://github.com/Viicos) in [#11755](https://github.com/pydantic/pydantic/pull/11755)\n* Remove coercion of decimal constraints by [@Viicos](https://github.com/Viicos) in [#11772](https://github.com/pydantic/pydantic/pull/11772)\n* Fix crash when expanding root type in the mypy plugin by [@Viicos](https://github.com/Viicos) in [#11735](https://github.com/pydantic/pydantic/pull/11735)\n* Fix issue with recursive generic models by [@Viicos](https://github.com/Viicos) in [#11775](https://github.com/pydantic/pydantic/pull/11775)\n* Traverse `function-before` schemas during schema gathering by [@Viicos](https://github.com/Viicos) in [#11801](https://github.com/pydantic/pydantic/pull/11801)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed9-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.11.3 (2025-04-08)[Â¶](index.html#v2113-2025-04-08 \"Permanent link\")", "anchor": "v2113-2025-04-08indexhtmlv2113-2025-04-08-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.11.3)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v2113-2025-04-08indexhtmlv2113-2025-04-08-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_10 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed10-permanent-link", "md_text": "#### Packaging[Â¶](index.html#packaging_4 \"Permanent link\")\n\n* Update V1 copy to v1.10.21 by [@Viicos](https://github.com/Viicos) in [#11706](https://github.com/pydantic/pydantic/pull/11706)\n\n#### Fixes[Â¶](index.html#fixes_10 \"Permanent link\")\n\n* Preserve field description when rebuilding model fields by [@Viicos](https://github.com/Viicos) in [#11698](https://github.com/pydantic/pydantic/pull/11698)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed10-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.11.2 (2025-04-03)[Â¶](index.html#v2112-2025-04-03 \"Permanent link\")", "anchor": "v2112-2025-04-03indexhtmlv2112-2025-04-03-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.11.2)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v2112-2025-04-03indexhtmlv2112-2025-04-03-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_11 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed11-permanent-link", "md_text": "#### Fixes[Â¶](index.html#fixes_11 \"Permanent link\")\n\n* Bump `pydantic-core` to v2.33.1 by [@Viicos](https://github.com/Viicos) in [#11678](https://github.com/pydantic/pydantic/pull/11678)\n* Make sure `__pydantic_private__` exists before setting private attributes by [@Viicos](https://github.com/Viicos) in [#11666](https://github.com/pydantic/pydantic/pull/11666)\n* Do not override `FieldInfo._complete` when using field from parent class by [@Viicos](https://github.com/Viicos) in [#11668](https://github.com/pydantic/pydantic/pull/11668)\n* Provide the available definitions when applying discriminated unions by [@Viicos](https://github.com/Viicos) in [#11670](https://github.com/pydantic/pydantic/pull/11670)\n* Do not expand root type in the mypy plugin for variables by [@Viicos](https://github.com/Viicos) in [#11676](https://github.com/pydantic/pydantic/pull/11676)\n* Mention the attribute name in model fields deprecation message by [@Viicos](https://github.com/Viicos) in [#11674](https://github.com/pydantic/pydantic/pull/11674)\n* Properly validate parameterized mappings by [@Viicos](https://github.com/Viicos) in [#11658](https://github.com/pydantic/pydantic/pull/11658)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed11-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.11.1 (2025-03-28)[Â¶](index.html#v2111-2025-03-28 \"Permanent link\")", "anchor": "v2111-2025-03-28indexhtmlv2111-2025-03-28-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.11.1)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v2111-2025-03-28indexhtmlv2111-2025-03-28-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_12 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed12-permanent-link", "md_text": "#### Fixes[Â¶](index.html#fixes_12 \"Permanent link\")\n\n* Do not override `'definitions-ref'` schemas containing serialization schemas or metadata by [@Viicos](https://github.com/Viicos) in [#11644](https://github.com/pydantic/pydantic/pull/11644)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed12-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.11.0 (2025-03-27)[Â¶](index.html#v2110-2025-03-27 \"Permanent link\")", "anchor": "v2110-2025-03-27indexhtmlv2110-2025-03-27-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.11.0)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v2110-2025-03-27indexhtmlv2110-2025-03-27-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_13 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed13-permanent-link", "md_text": "Pydantic v2.11 is a version strongly focused on build time performance of Pydantic models (and core schema generation in general).\nSee the [blog post](https://pydantic.dev/articles/pydantic-v2-11-release) for more details.\n\n#### Packaging[Â¶](index.html#packaging_5 \"Permanent link\")\n\n* Bump `pydantic-core` to v2.33.0 by [@Viicos](https://github.com/Viicos) in [#11631](https://github.com/pydantic/pydantic/pull/11631)\n\n#### New Features[Â¶](index.html#new-features_3 \"Permanent link\")\n\n* Add `encoded_string()` method to the URL types by [@YassinNouh21](https://github.com/YassinNouh21) in [#11580](https://github.com/pydantic/pydantic/pull/11580)\n* Add support for `defer_build` with `@validate_call` decorator by [@Viicos](https://github.com/Viicos) in [#11584](https://github.com/pydantic/pydantic/pull/11584)\n* Allow `@with_config` decorator to be used with keyword arguments by [@Viicos](https://github.com/Viicos) in [#11608](https://github.com/pydantic/pydantic/pull/11608)\n* Simplify customization of default value inclusion in JSON Schema generation by [@Viicos](https://github.com/Viicos) in [#11634](https://github.com/pydantic/pydantic/pull/11634)\n* Add `generate_arguments_schema()` function by [@Viicos](https://github.com/Viicos) in [#11572](https://github.com/pydantic/pydantic/pull/11572)\n\n#### Fixes[Â¶](index.html#fixes_13 \"Permanent link\")\n\n* Allow generic typed dictionaries to be used for unpacked variadic keyword parameters by [@Viicos](https://github.com/Viicos) in [#11571](https://github.com/pydantic/pydantic/pull/11571)\n* Fix runtime error when computing model string representation involving cached properties and self-referenced models by [@Viicos](https://github.com/Viicos) in [#11579](https://github.com/pydantic/pydantic/pull/11579)\n* Preserve other steps when using the ellipsis in the pipeline API by [@Viicos](https://github.com/Viicos) in [#11626](https://github.com/pydantic/pydantic/pull/11626)\n* Fix deferred discriminator application logic by [@Viicos](https://github.com/Viicos) in [#11591](https://github.com/pydantic/pydantic/pull/11591)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed13-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "New Contributors[Â¶](index.html#new-contributors_4 \"Permanent link\")", "anchor": "new-contributorsindexhtmlnew-contributors4-permanent-link", "md_text": "* [@cmenon12](https://github.com/cmenon12) made their first contribution in [#11562](https://github.com/pydantic/pydantic/pull/11562)\n* [@Jeukoh](https://github.com/Jeukoh) made their first contribution in [#11611](https://github.com/pydantic/pydantic/pull/11611)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#new-contributorsindexhtmlnew-contributors4-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.11.0b2 (2025-03-17)[Â¶](index.html#v2110b2-2025-03-17 \"Permanent link\")", "anchor": "v2110b2-2025-03-17indexhtmlv2110b2-2025-03-17-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.11.0b2)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v2110b2-2025-03-17indexhtmlv2110b2-2025-03-17-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_14 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed14-permanent-link", "md_text": "#### Packaging[Â¶](index.html#packaging_6 \"Permanent link\")\n\n* Bump `pydantic-core` to v2.32.0 by [@Viicos](https://github.com/Viicos) in [#11567](https://github.com/pydantic/pydantic/pull/11567)\n\n#### New Features[Â¶](index.html#new-features_4 \"Permanent link\")\n\n* Add experimental support for free threading by [@Viicos](https://github.com/Viicos) in [#11516](https://github.com/pydantic/pydantic/pull/11516)\n\n#### Fixes[Â¶](index.html#fixes_14 \"Permanent link\")\n\n* Fix `NotRequired` qualifier not taken into account in stringified annotation by [@Viicos](https://github.com/Viicos) in [#11559](https://github.com/pydantic/pydantic/pull/11559)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed14-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "New Contributors[Â¶](index.html#new-contributors_5 \"Permanent link\")", "anchor": "new-contributorsindexhtmlnew-contributors5-permanent-link", "md_text": "* [@joren485](https://github.com/joren485) made their first contribution in [#11547](https://github.com/pydantic/pydantic/pull/11547)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#new-contributorsindexhtmlnew-contributors5-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.11.0b1 (2025-03-06)[Â¶](index.html#v2110b1-2025-03-06 \"Permanent link\")", "anchor": "v2110b1-2025-03-06indexhtmlv2110b1-2025-03-06-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.11.0b1)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v2110b1-2025-03-06indexhtmlv2110b1-2025-03-06-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_15 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed15-permanent-link", "md_text": "#### Packaging[Â¶](index.html#packaging_7 \"Permanent link\")\n\n* Add a `check_pydantic_core_version()` function by [@Viicos](https://github.com/Viicos) in https://github.com/pydantic/pydantic/pull/11324\n* Remove `greenlet` development dependency by [@Viicos](https://github.com/Viicos) in https://github.com/pydantic/pydantic/pull/11351\n* Use the `typing-inspection` library by [@Viicos](https://github.com/Viicos) in https://github.com/pydantic/pydantic/pull/11479\n* Bump `pydantic-core` to `v2.31.1` by [@sydney-runkle](https://github.com/sydney-runkle) in https://github.com/pydantic/pydantic/pull/11526\n\n#### New Features[Â¶](index.html#new-features_5 \"Permanent link\")\n\n* Support unsubstituted type variables with both a default and a bound or constraints by [@FyZzyss](https://github.com/FyZzyss) in https://github.com/pydantic/pydantic/pull/10789\n* Add a `default_factory_takes_validated_data` property to `FieldInfo` by [@Viicos](https://github.com/Viicos) in https://github.com/pydantic/pydantic/pull/11034\n* Raise a better error when a generic alias is used inside `type[]` by [@Viicos](https://github.com/Viicos) in https://github.com/pydantic/pydantic/pull/11088\n* Properly support PEP 695 generics syntax by [@Viicos](https://github.com/Viicos) in https://github.com/pydantic/pydantic/pull/11189\n* Properly support type variable defaults by [@Viicos](https://github.com/Viicos) in https://github.com/pydantic/pydantic/pull/11332\n* Add support for validating v6, v7, v8 UUIDs by [@astei](https://github.com/astei) in https://github.com/pydantic/pydantic/pull/11436\n* Improve alias configuration APIs by [@sydney-runkle](https://github.com/sydney-runkle) in https://github.com/pydantic/pydantic/pull/11468\n\n#### Changes[Â¶](index.html#changes_3 \"Permanent link\")\n\n* Rework `create_model` field definitions format by [@Viicos](https://github.com/Viicos) in https://github.com/pydantic/pydantic/pull/11032\n* Raise a deprecation warning when a field is annotated as final with a default value by [@Viicos](https://github.com/Viicos) in https://github.com/pydantic/pydantic/pull/11168\n* Deprecate accessing `model_fields` and `model_computed_fields` on instances by [@Viicos](https://github.com/Viicos) in https://github.com/pydantic/pydantic/pull/11169\n* **Breaking Change:** Move core schema generation logic for path types inside the `GenerateSchema` class by [@sydney-runkle](https://github.com/sydney-runkle) in https://github.com/pydantic/pydantic/pull/10846\n* Remove Python 3.8 Support by [@sydney-runkle](https://github.com/sydney-runkle) in https://github.com/pydantic/pydantic/pull/11258\n* Optimize calls to `get_type_ref` by [@Viicos](https://github.com/Viicos) in https://github.com/pydantic/pydantic/pull/10863\n* Disable `pydantic-core` core schema validation by [@sydney-runkle](https://github.com/sydney-runkle) in https://github.com/pydantic/pydantic/pull/11271\n\n#### Performance[Â¶](index.html#performance \"Permanent link\")", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed15-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_15 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed15-permanent-link", "md_text": "* Only evaluate `FieldInfo` annotations if required during schema building by [@Viicos](https://github.com/Viicos) in https://github.com/pydantic/pydantic/pull/10769\n* Improve `__setattr__` performance of Pydantic models by caching setter functions by [@MarkusSintonen](https://github.com/MarkusSintonen) in https://github.com/pydantic/pydantic/pull/10868\n* Improve annotation application performance by [@Viicos](https://github.com/Viicos) in https://github.com/pydantic/pydantic/pull/11186\n* Improve performance of `_typing_extra` module by [@Viicos](https://github.com/Viicos) in https://github.com/pydantic/pydantic/pull/11255\n* Refactor and optimize schema cleaning logic by [@Viicos](https://github.com/Viicos) in https://github.com/pydantic/pydantic/pull/11244\n* Create a single dictionary when creating a `CoreConfig` instance by [@sydney-runkle](https://github.com/sydney-runkle) in https://github.com/pydantic/pydantic/pull/11384\n* Bump `pydantic-core` and thus use `SchemaValidator` and `SchemaSerializer` caching by [@sydney-runkle](https://github.com/sydney-runkle) in https://github.com/pydantic/pydantic/pull/11402\n* Reuse cached core schemas for parametrized generic Pydantic models by [@MarkusSintonen](https://github.com/MarkusSintonen) in https://github.com/pydantic/pydantic/pull/11434\n\n#### Fixes[Â¶](index.html#fixes_15 \"Permanent link\")", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed15-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_15 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed15-permanent-link", "md_text": "* Improve `TypeAdapter` instance repr by [@sydney-runkle](https://github.com/sydney-runkle) in https://github.com/pydantic/pydantic/pull/10872\n* Use the correct frame when instantiating a parametrized `TypeAdapter` by [@Viicos](https://github.com/Viicos) in https://github.com/pydantic/pydantic/pull/10893\n* Infer final fields with a default value as class variables in the mypy plugin by [@Viicos](https://github.com/Viicos) in https://github.com/pydantic/pydantic/pull/11121\n* Recursively unpack `Literal` values if using PEP 695 type aliases by [@Viicos](https://github.com/Viicos) in https://github.com/pydantic/pydantic/pull/11114\n* Override `__subclasscheck__` on `ModelMetaclass` to avoid memory leak and performance issues by [@Viicos](https://github.com/Viicos) in https://github.com/pydantic/pydantic/pull/11116\n* Remove unused `_extract_get_pydantic_json_schema()` parameter by [@Viicos](https://github.com/Viicos) in https://github.com/pydantic/pydantic/pull/11155\n* Improve discriminated union error message for invalid union variants by [@Viicos](https://github.com/Viicos) in https://github.com/pydantic/pydantic/pull/11161\n* Unpack PEP 695 type aliases if using the `Annotated` form by [@Viicos](https://github.com/Viicos) in https://github.com/pydantic/pydantic/pull/11109\n* Add missing stacklevel in `deprecated_instance_property` warning by [@Viicos](https://github.com/Viicos) in https://github.com/pydantic/pydantic/pull/11200\n* Copy `WithJsonSchema` schema to avoid sharing mutated data by [@thejcannon](https://github.com/thejcannon) in https://github.com/pydantic/pydantic/pull/11014\n* Do not cache parametrized models when in the process of parametrizing another model by [@Viicos](https://github.com/Viicos) in https://github.com/pydantic/pydantic/pull/10704\n* Add discriminated union related metadata entries to the `CoreMetadata` definition by [@Viicos](https://github.com/Viicos) in https://github.com/pydantic/pydantic/pull/11216\n* Consolidate schema definitions logic in the `_Definitions` class by [@Viicos](https://github.com/Viicos) in https://github.com/pydantic/pydantic/pull/11208\n* Support initializing root model fields with values of the `root` type in the mypy plugin by [@Viicos](https://github.com/Viicos) in https://github.com/pydantic/pydantic/pull/11212\n* Fix various issues with dataclasses and `use_attribute_docstrings` by [@Viicos](https://github.com/Viicos) in https://github.com/pydantic/pydantic/pull/11246\n* Only compute normalized decimal places if necessary in `decimal_places_validator` by [@misrasaurabh1](https://github.com/misrasaurabh1) in https://github.com/pydantic/pydantic/pull/11281\n* Add support for `validation_alias` in the mypy plugin by [@Viicos](https://github.com/Viicos) in https://github.com/pydantic/pydantic/pull/11295\n* Fix JSON Schema reference collection with `\"examples\"` keys by [@Viicos](https://github.com/Viicos) in https://github.com/pydantic/pydantic/pull/11305\n* Do not transform model serializer functions as class methods in the mypy plugin by [@Viicos](https://github.com/Viicos) in https://github.com/pydantic/pydantic/pull/11298\n* Simplify `GenerateJsonSchema.literal_schema()` implementation by [@misrasaurabh1](https://github.com/misrasaurabh1) in https://github.com/pydantic/pydantic/pull/11321\n* Add additional allowed schemes for `ClickHouseDsn` by [@Maze21127](https://github.com/Maze21127) in https://github.com/pydantic/pydantic/pull/11319\n* Coerce decimal constraints to `Decimal` instances by [@Viicos](https://github.com/Viicos) in https://github.com/pydantic/pydantic/pull/11350\n* Use the correct JSON Schema mode when handling function schemas by [@Viicos](https://github.com/Viicos) in https://github.com/pydantic/pydantic/pull/11367\n* Improve exception message when encountering recursion errors during type evaluation by [@Viicos](https://github.com/Viicos) in https://github.com/pydantic/pydantic/pull/11356\n* Always include `additionalProperties: True` for arbitrary dictionary schemas by [@austinyu](https://github.com/austinyu) in https://github.com/pydantic/pydantic/pull/11392\n* Expose `fallback` parameter in serialization methods by [@Viicos](https://github.com/Viicos) in https://github.com/pydantic/pydantic/pull/11398\n* Fix path serialization behavior by [@sydney-runkle](https://github.com/sydney-runkle) in https://github.com/pydantic/pydantic/pull/11416\n* Do not reuse validators and serializers during model rebuild by [@Viicos](https://github.com/Viicos) in https://github.com/pydantic/pydantic/pull/11429\n* Collect model fields when rebuilding a model by [@Viicos](https://github.com/Viicos) in https://github.com/pydantic/pydantic/pull/11388\n* Allow cached properties to be altered on frozen models by [@Viicos](https://github.com/Viicos) in https://github.com/pydantic/pydantic/pull/11432\n* Fix tuple serialization for `Sequence` types by [@sydney-runkle](https://github.com/sydney-runkle) in https://github.com/pydantic/pydantic/pull/11435\n* Fix: do not check for `__get_validators__` on classes where `__get_pydantic_core_schema__` is also defined by [@tlambert03](https://github.com/tlambert03) in https://github.com/pydantic/pydantic/pull/11444\n* Allow callable instances to be used as serializers by [@Viicos](https://github.com/Viicos) in https://github.com/pydantic/pydantic/pull/11451\n* Improve error thrown when overriding field with a property by [@sydney-runkle](https://github.com/sydney-runkle) in https://github.com/pydantic/pydantic/pull/11459\n* Fix JSON Schema generation with referenceable core schemas holding JSON metadata by [@Viicos](https://github.com/Viicos) in https://github.com/pydantic/pydantic/pull/11475\n* Support strict specification on union member types by [@sydney-runkle](https://github.com/sydney-runkle) in https://github.com/pydantic/pydantic/pull/11481\n* Implicitly set `validate_by_name` to `True` when `validate_by_alias` is `False` by [@sydney-runkle](https://github.com/sydney-runkle) in https://github.com/pydantic/pydantic/pull/11503\n* Change type of `Any` when synthesizing `BaseSettings.__init__` signature in the mypy plugin by [@Viicos](https://github.com/Viicos) in https://github.com/pydantic/pydantic/pull/11497\n* Support type variable defaults referencing other type variables by [@Viicos](https://github.com/Viicos) in https://github.com/pydantic/pydantic/pull/11520\n* Fix `ValueError` on year zero by [@davidhewitt](https://github.com/davidhewitt) in https://github.com/pydantic/pydantic-core/pull/1583\n* `dataclass` `InitVar` shouldn't be required on serialization by [@sydney-runkle](https://github.com/sydney-runkle) in https://github.com/pydantic/pydantic-core/pull/1602", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed15-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "New Contributors[Â¶](index.html#new-contributors_6 \"Permanent link\")", "anchor": "new-contributorsindexhtmlnew-contributors6-permanent-link", "md_text": "* [@FyZzyss](https://github.com/FyZzyss) made their first contribution in https://github.com/pydantic/pydantic/pull/10789\n* [@tamird](https://github.com/tamird) made their first contribution in https://github.com/pydantic/pydantic/pull/10948\n* [@felixxm](https://github.com/felixxm) made their first contribution in https://github.com/pydantic/pydantic/pull/11077\n* [@alexprabhat99](https://github.com/alexprabhat99) made their first contribution in https://github.com/pydantic/pydantic/pull/11082\n* [@Kharianne](https://github.com/Kharianne) made their first contribution in https://github.com/pydantic/pydantic/pull/11111\n* [@mdaffad](https://github.com/mdaffad) made their first contribution in https://github.com/pydantic/pydantic/pull/11177\n* [@thejcannon](https://github.com/thejcannon) made their first contribution in https://github.com/pydantic/pydantic/pull/11014\n* [@thomasfrimannkoren](https://github.com/thomasfrimannkoren) made their first contribution in https://github.com/pydantic/pydantic/pull/11251\n* [@usernameMAI](https://github.com/usernameMAI) made their first contribution in https://github.com/pydantic/pydantic/pull/11275\n* [@ananiavito](https://github.com/ananiavito) made their first contribution in https://github.com/pydantic/pydantic/pull/11302\n* [@pawamoy](https://github.com/pawamoy) made their first contribution in https://github.com/pydantic/pydantic/pull/11311\n* [@Maze21127](https://github.com/Maze21127) made their first contribution in https://github.com/pydantic/pydantic/pull/11319\n* [@kauabh](https://github.com/kauabh) made their first contribution in https://github.com/pydantic/pydantic/pull/11369\n* [@jaceklaskowski](https://github.com/jaceklaskowski) made their first contribution in https://github.com/pydantic/pydantic/pull/11353\n* [@tmpbeing](https://github.com/tmpbeing) made their first contribution in https://github.com/pydantic/pydantic/pull/11375\n* [@petyosi](https://github.com/petyosi) made their first contribution in https://github.com/pydantic/pydantic/pull/11405\n* [@austinyu](https://github.com/austinyu) made their first contribution in https://github.com/pydantic/pydantic/pull/11392\n* [@mikeedjones](https://github.com/mikeedjones) made their first contribution in https://github.com/pydantic/pydantic/pull/11402\n* [@astei](https://github.com/astei) made their first contribution in https://github.com/pydantic/pydantic/pull/11436\n* [@dsayling](https://github.com/dsayling) made their first contribution in https://github.com/pydantic/pydantic/pull/11522\n* [@sobolevn](https://github.com/sobolevn) made their first contribution in https://github.com/pydantic/pydantic-core/pull/1645", "url": "https://docs.pydantic.dev/latest/changelog/index.html#new-contributorsindexhtmlnew-contributors6-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.11.0a2 (2025-02-10)[Â¶](index.html#v2110a2-2025-02-10 \"Permanent link\")", "anchor": "v2110a2-2025-02-10indexhtmlv2110a2-2025-02-10-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.11.0a2)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v2110a2-2025-02-10indexhtmlv2110a2-2025-02-10-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_16 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed16-permanent-link", "md_text": "Pydantic v2.11 is a version strongly focused on build time performance of Pydantic models (and core schema generation in general).\nThis is another early alpha release, meant to collect early feedback from users having issues with core schema builds.\n\n#### Packaging[Â¶](index.html#packaging_8 \"Permanent link\")\n\n* Bump `ruff` from 0.9.2 to 0.9.5 by [@Viicos](https://github.com/Viicos) in [#11407](https://github.com/pydantic/pydantic/pull/11407)\n* Bump `pydantic-core` to v2.29.0 by [@mikeedjones](https://github.com/mikeedjones) in [#11402](https://github.com/pydantic/pydantic/pull/11402)\n* Use locally-built rust with symbols & pgo by [@davidhewitt](https://github.com/davidhewitt) in [#11403](https://github.com/pydantic/pydantic/pull/11403)\n\n#### Performance[Â¶](index.html#performance_1 \"Permanent link\")\n\n* Create a single dictionary when creating a `CoreConfig` instance by [@sydney-runkle](https://github.com/sydney-runkle) in [#11384](https://github.com/pydantic/pydantic/pull/11384)\n\n#### Fixes[Â¶](index.html#fixes_16 \"Permanent link\")\n\n* Use the correct JSON Schema mode when handling function schemas by [@Viicos](https://github.com/Viicos) in [#11367](https://github.com/pydantic/pydantic/pull/11367)\n* Fix JSON Schema reference logic with `examples` keys by [@Viicos](https://github.com/Viicos) in [#11366](https://github.com/pydantic/pydantic/pull/11366)\n* Improve exception message when encountering recursion errors during type evaluation by [@Viicos](https://github.com/Viicos) in [#11356](https://github.com/pydantic/pydantic/pull/11356)\n* Always include `additionalProperties: True` for arbitrary dictionary schemas by [@austinyu](https://github.com/austinyu) in [#11392](https://github.com/pydantic/pydantic/pull/11392)\n* Expose `fallback` parameter in serialization methods by [@Viicos](https://github.com/Viicos) in [#11398](https://github.com/pydantic/pydantic/pull/11398)\n* Fix path serialization behavior by [@sydney-runkle](https://github.com/sydney-runkle) in [#11416](https://github.com/pydantic/pydantic/pull/11416)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed16-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "New Contributors[Â¶](index.html#new-contributors_7 \"Permanent link\")", "anchor": "new-contributorsindexhtmlnew-contributors7-permanent-link", "md_text": "* [@kauabh](https://github.com/kauabh) made their first contribution in [#11369](https://github.com/pydantic/pydantic/pull/11369)\n* [@jaceklaskowski](https://github.com/jaceklaskowski) made their first contribution in [#11353](https://github.com/pydantic/pydantic/pull/11353)\n* [@tmpbeing](https://github.com/tmpbeing) made their first contribution in [#11375](https://github.com/pydantic/pydantic/pull/11375)\n* [@petyosi](https://github.com/petyosi) made their first contribution in [#11405](https://github.com/pydantic/pydantic/pull/11405)\n* [@austinyu](https://github.com/austinyu) made their first contribution in [#11392](https://github.com/pydantic/pydantic/pull/11392)\n* [@mikeedjones](https://github.com/mikeedjones) made their first contribution in [#11402](https://github.com/pydantic/pydantic/pull/11402)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#new-contributorsindexhtmlnew-contributors7-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.11.0a1 (2025-01-30)[Â¶](index.html#v2110a1-2025-01-30 \"Permanent link\")", "anchor": "v2110a1-2025-01-30indexhtmlv2110a1-2025-01-30-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.11.0a1)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v2110a1-2025-01-30indexhtmlv2110a1-2025-01-30-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_17 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed17-permanent-link", "md_text": "Pydantic v2.11 is a version strongly focused on build time performance of Pydantic models (and core schema generation in general).\nThis is an early alpha release, meant to collect early feedback from users having issues with core schema builds.\n\n#### Packaging[Â¶](index.html#packaging_9 \"Permanent link\")\n\n* Bump dawidd6/action-download-artifact from 6 to 7 by [@dependabot](https://github.com/dependabot) in [#11018](https://github.com/pydantic/pydantic/pull/11018)\n* Re-enable memray related tests on Python 3.12+ by [@Viicos](https://github.com/Viicos) in [#11191](https://github.com/pydantic/pydantic/pull/11191)\n* Bump astral-sh/setup-uv to 5 by [@dependabot](https://github.com/dependabot) in [#11205](https://github.com/pydantic/pydantic/pull/11205)\n* Bump `ruff` to v0.9.0 by [@sydney-runkle](https://github.com/sydney-runkle) in [#11254](https://github.com/pydantic/pydantic/pull/11254)\n* Regular `uv.lock` deps update by [@sydney-runkle](https://github.com/sydney-runkle) in [#11333](https://github.com/pydantic/pydantic/pull/11333)\n* Add a `check_pydantic_core_version()` function by [@Viicos](https://github.com/Viicos) in [#11324](https://github.com/pydantic/pydantic/pull/11324)\n* Remove `greenlet` development dependency by [@Viicos](https://github.com/Viicos) in [#11351](https://github.com/pydantic/pydantic/pull/11351)\n* Bump `pydantic-core` to v2.28.0 by [@Viicos](https://github.com/Viicos) in [#11364](https://github.com/pydantic/pydantic/pull/11364)\n\n#### New Features[Â¶](index.html#new-features_6 \"Permanent link\")\n\n* Support unsubstituted type variables with both a default and a bound or constraints by [@FyZzyss](https://github.com/FyZzyss) in [#10789](https://github.com/pydantic/pydantic/pull/10789)\n* Add a `default_factory_takes_validated_data` property to `FieldInfo` by [@Viicos](https://github.com/Viicos) in [#11034](https://github.com/pydantic/pydantic/pull/11034)\n* Raise a better error when a generic alias is used inside `type[]` by [@Viicos](https://github.com/Viicos) in [#11088](https://github.com/pydantic/pydantic/pull/11088)\n* Properly support PEP 695 generics syntax by [@Viicos](https://github.com/Viicos) in [#11189](https://github.com/pydantic/pydantic/pull/11189)\n* Properly support type variable defaults by [@Viicos](https://github.com/Viicos) in [#11332](https://github.com/pydantic/pydantic/pull/11332)\n\n#### Changes[Â¶](index.html#changes_4 \"Permanent link\")\n\n* Rework `create_model` field definitions format by [@Viicos](https://github.com/Viicos) in [#11032](https://github.com/pydantic/pydantic/pull/11032)\n* Raise a deprecation warning when a field is annotated as final with a default value by [@Viicos](https://github.com/Viicos) in [#11168](https://github.com/pydantic/pydantic/pull/11168)\n* Deprecate accessing `model_fields` and `model_computed_fields` on instances by [@Viicos](https://github.com/Viicos) in [#11169](https://github.com/pydantic/pydantic/pull/11169)\n* Move core schema generation logic for path types inside the `GenerateSchema` class by [@sydney-runkle](https://github.com/sydney-runkle) in [#10846](https://github.com/pydantic/pydantic/pull/10846)\n* Move `deque` schema gen to `GenerateSchema` class by [@sydney-runkle](https://github.com/sydney-runkle) in [#11239](https://github.com/pydantic/pydantic/pull/11239)\n* Move `Mapping` schema gen to `GenerateSchema` to complete removal of `prepare_annotations_for_known_type` workaround by [@sydney-runkle](https://github.com/sydney-runkle) in [#11247](https://github.com/pydantic/pydantic/pull/11247)\n* Remove Python 3.8 Support by [@sydney-runkle](https://github.com/sydney-runkle) in [#11258](https://github.com/pydantic/pydantic/pull/11258)\n* Disable `pydantic-core` core schema validation by [@sydney-runkle](https://github.com/sydney-runkle) in [#11271](https://github.com/pydantic/pydantic/pull/11271)\n\n#### Performance[Â¶](index.html#performance_2 \"Permanent link\")", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed17-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_17 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed17-permanent-link", "md_text": "* Only evaluate `FieldInfo` annotations if required during schema building by [@Viicos](https://github.com/Viicos) in [#10769](https://github.com/pydantic/pydantic/pull/10769)\n* Optimize calls to `get_type_ref` by [@Viicos](https://github.com/Viicos) in [#10863](https://github.com/pydantic/pydantic/pull/10863)\n* Improve `__setattr__` performance of Pydantic models by caching setter functions by [@MarkusSintonen](https://github.com/MarkusSintonen) in [#10868](https://github.com/pydantic/pydantic/pull/10868)\n* Improve annotation application performance by [@Viicos](https://github.com/Viicos) in [#11186](https://github.com/pydantic/pydantic/pull/11186)\n* Improve performance of `_typing_extra` module by [@Viicos](https://github.com/Viicos) in [#11255](https://github.com/pydantic/pydantic/pull/11255)\n* Refactor and optimize schema cleaning logic by [@Viicos](https://github.com/Viicos) and [@MarkusSintonen](https://github.com/MarkusSintonen) in [#11244](https://github.com/pydantic/pydantic/pull/11244)\n\n#### Fixes[Â¶](index.html#fixes_17 \"Permanent link\")", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed17-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_17 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed17-permanent-link", "md_text": "* Add validation tests for `_internal/_validators.py` by [@tkasuz](https://github.com/tkasuz) in [#10763](https://github.com/pydantic/pydantic/pull/10763)\n* Improve `TypeAdapter` instance repr by [@sydney-runkle](https://github.com/sydney-runkle) in [#10872](https://github.com/pydantic/pydantic/pull/10872)\n* Revert \"ci: use locally built pydantic-core with debug symbols by [@sydney-runkle](https://github.com/sydney-runkle) in [#10942](https://github.com/pydantic/pydantic/pull/10942)\n* Re-enable all FastAPI tests by [@tamird](https://github.com/tamird) in [#10948](https://github.com/pydantic/pydantic/pull/10948)\n* Fix typo in HISTORY.md. by [@felixxm](https://github.com/felixxm) in [#11077](https://github.com/pydantic/pydantic/pull/11077)\n* Infer final fields with a default value as class variables in the mypy plugin by [@Viicos](https://github.com/Viicos) in [#11121](https://github.com/pydantic/pydantic/pull/11121)\n* Recursively unpack `Literal` values if using PEP 695 type aliases by [@Viicos](https://github.com/Viicos) in [#11114](https://github.com/pydantic/pydantic/pull/11114)\n* Override `__subclasscheck__` on `ModelMetaclass` to avoid memory leak and performance issues by [@Viicos](https://github.com/Viicos) in [#11116](https://github.com/pydantic/pydantic/pull/11116)\n* Remove unused `_extract_get_pydantic_json_schema()` parameter by [@Viicos](https://github.com/Viicos) in [#11155](https://github.com/pydantic/pydantic/pull/11155)\n* Add FastAPI and SQLModel to third-party tests by [@sydney-runkle](https://github.com/sydney-runkle) in [#11044](https://github.com/pydantic/pydantic/pull/11044)\n* Fix conditional expressions syntax for third-party tests by [@Viicos](https://github.com/Viicos) in [#11162](https://github.com/pydantic/pydantic/pull/11162)\n* Move FastAPI tests to third-party workflow by [@Viicos](https://github.com/Viicos) in [#11164](https://github.com/pydantic/pydantic/pull/11164)\n* Improve discriminated union error message for invalid union variants by [@Viicos](https://github.com/Viicos) in [#11161](https://github.com/pydantic/pydantic/pull/11161)\n* Unpack PEP 695 type aliases if using the `Annotated` form by [@Viicos](https://github.com/Viicos) in [#11109](https://github.com/pydantic/pydantic/pull/11109)\n* Include `openapi-python-client` check in issue creation for third-party failures, use `main` branch by [@sydney-runkle](https://github.com/sydney-runkle) in [#11182](https://github.com/pydantic/pydantic/pull/11182)\n* Add pandera third-party tests by [@Viicos](https://github.com/Viicos) in [#11193](https://github.com/pydantic/pydantic/pull/11193)\n* Add ODMantic third-party tests by [@sydney-runkle](https://github.com/sydney-runkle) in [#11197](https://github.com/pydantic/pydantic/pull/11197)\n* Add missing stacklevel in `deprecated_instance_property` warning by [@Viicos](https://github.com/Viicos) in [#11200](https://github.com/pydantic/pydantic/pull/11200)\n* Copy `WithJsonSchema` schema to avoid sharing mutated data by [@thejcannon](https://github.com/thejcannon) in [#11014](https://github.com/pydantic/pydantic/pull/11014)\n* Do not cache parametrized models when in the process of parametrizing another model by [@Viicos](https://github.com/Viicos) in [#10704](https://github.com/pydantic/pydantic/pull/10704)\n* Re-enable Beanie third-party tests by [@Viicos](https://github.com/Viicos) in [#11214](https://github.com/pydantic/pydantic/pull/11214)\n* Add discriminated union related metadata entries to the `CoreMetadata` definition by [@Viicos](https://github.com/Viicos) in [#11216](https://github.com/pydantic/pydantic/pull/11216)\n* Consolidate schema definitions logic in the `_Definitions` class by [@Viicos](https://github.com/Viicos) in [#11208](https://github.com/pydantic/pydantic/pull/11208)\n* Support initializing root model fields with values of the `root` type in the mypy plugin by [@Viicos](https://github.com/Viicos) in [#11212](https://github.com/pydantic/pydantic/pull/11212)\n* Fix various issues with dataclasses and `use_attribute_docstrings` by [@Viicos](https://github.com/Viicos) in [#11246](https://github.com/pydantic/pydantic/pull/11246)\n* Only compute normalized decimal places if necessary in `decimal_places_validator` by [@misrasaurabh1](https://github.com/misrasaurabh1) in [#11281](https://github.com/pydantic/pydantic/pull/11281)\n* Fix two misplaced sentences in validation errors documentation by [@ananiavito](https://github.com/ananiavito) in [#11302](https://github.com/pydantic/pydantic/pull/11302)\n* Fix mkdocstrings inventory example in documentation by [@pawamoy](https://github.com/pawamoy) in [#11311](https://github.com/pydantic/pydantic/pull/11311)\n* Add support for `validation_alias` in the mypy plugin by [@Viicos](https://github.com/Viicos) in [#11295](https://github.com/pydantic/pydantic/pull/11295)\n* Do not transform model serializer functions as class methods in the mypy plugin by [@Viicos](https://github.com/Viicos) in [#11298](https://github.com/pydantic/pydantic/pull/11298)\n* Simplify `GenerateJsonSchema.literal_schema()` implementation by [@misrasaurabh1](https://github.com/misrasaurabh1) in [#11321](https://github.com/pydantic/pydantic/pull/11321)\n* Add additional allowed schemes for `ClickHouseDsn` by [@Maze21127](https://github.com/Maze21127) in [#11319](https://github.com/pydantic/pydantic/pull/11319)\n* Coerce decimal constraints to `Decimal` instances by [@Viicos](https://github.com/Viicos) in [#11350](https://github.com/pydantic/pydantic/pull/11350)\n* Fix `ValueError` on year zero by [@davidhewitt](https://github.com/davidhewitt) in [pydantic-core#1583](https://github.com/pydantic/pydantic-core/pull/1583)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed17-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "New Contributors[Â¶](index.html#new-contributors_8 \"Permanent link\")", "anchor": "new-contributorsindexhtmlnew-contributors8-permanent-link", "md_text": "* [@FyZzyss](https://github.com/FyZzyss) made their first contribution in [#10789](https://github.com/pydantic/pydantic/pull/10789)\n* [@tamird](https://github.com/tamird) made their first contribution in [#10948](https://github.com/pydantic/pydantic/pull/10948)\n* [@felixxm](https://github.com/felixxm) made their first contribution in [#11077](https://github.com/pydantic/pydantic/pull/11077)\n* [@alexprabhat99](https://github.com/alexprabhat99) made their first contribution in [#11082](https://github.com/pydantic/pydantic/pull/11082)\n* [@Kharianne](https://github.com/Kharianne) made their first contribution in [#11111](https://github.com/pydantic/pydantic/pull/11111)\n* [@mdaffad](https://github.com/mdaffad) made their first contribution in [#11177](https://github.com/pydantic/pydantic/pull/11177)\n* [@thejcannon](https://github.com/thejcannon) made their first contribution in [#11014](https://github.com/pydantic/pydantic/pull/11014)\n* [@thomasfrimannkoren](https://github.com/thomasfrimannkoren) made their first contribution in [#11251](https://github.com/pydantic/pydantic/pull/11251)\n* [@usernameMAI](https://github.com/usernameMAI) made their first contribution in [#11275](https://github.com/pydantic/pydantic/pull/11275)\n* [@ananiavito](https://github.com/ananiavito) made their first contribution in [#11302](https://github.com/pydantic/pydantic/pull/11302)\n* [@pawamoy](https://github.com/pawamoy) made their first contribution in [#11311](https://github.com/pydantic/pydantic/pull/11311)\n* [@Maze21127](https://github.com/Maze21127) made their first contribution in [#11319](https://github.com/pydantic/pydantic/pull/11319)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#new-contributorsindexhtmlnew-contributors8-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.10.6 (2025-01-23)[Â¶](index.html#v2106-2025-01-23 \"Permanent link\")", "anchor": "v2106-2025-01-23indexhtmlv2106-2025-01-23-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.10.6)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v2106-2025-01-23indexhtmlv2106-2025-01-23-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_18 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed18-permanent-link", "md_text": "#### Fixes[Â¶](index.html#fixes_18 \"Permanent link\")\n\n* Fix JSON Schema reference collection with `'examples'` keys by [@Viicos](https://github.com/Viicos) in [#11325](https://github.com/pydantic/pydantic/pull/11325)\n* Fix url python serialization by [@sydney-runkle](https://github.com/sydney-runkle) in [#11331](https://github.com/pydantic/pydantic/pull/11331)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed18-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.10.5 (2025-01-08)[Â¶](index.html#v2105-2025-01-08 \"Permanent link\")", "anchor": "v2105-2025-01-08indexhtmlv2105-2025-01-08-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.10.5)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v2105-2025-01-08indexhtmlv2105-2025-01-08-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_19 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed19-permanent-link", "md_text": "#### Fixes[Â¶](index.html#fixes_19 \"Permanent link\")\n\n* Remove custom MRO implementation of Pydantic models by [@Viicos](https://github.com/Viicos) in [#11184](https://github.com/pydantic/pydantic/pull/11184)\n* Fix URL serialization for unions by [@sydney-runkle](https://github.com/sydney-runkle) in [#11233](https://github.com/pydantic/pydantic/pull/11233)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed19-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.10.4 (2024-12-18)[Â¶](index.html#v2104-2024-12-18 \"Permanent link\")", "anchor": "v2104-2024-12-18indexhtmlv2104-2024-12-18-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.10.4)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v2104-2024-12-18indexhtmlv2104-2024-12-18-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_20 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed20-permanent-link", "md_text": "#### Packaging[Â¶](index.html#packaging_10 \"Permanent link\")\n\n* Bump `pydantic-core` to v2.27.2 by [@davidhewitt](https://github.com/davidhewitt) in [#11138](https://github.com/pydantic/pydantic/pull/11138)\n\n#### Fixes[Â¶](index.html#fixes_20 \"Permanent link\")\n\n* Fix for comparison of `AnyUrl` objects by [@alexprabhat99](https://github.com/alexprabhat99) in [#11082](https://github.com/pydantic/pydantic/pull/11082)\n* Properly fetch PEP 695 type params for functions, do not fetch annotations from signature by [@Viicos](https://github.com/Viicos) in [#11093](https://github.com/pydantic/pydantic/pull/11093)\n* Include JSON Schema input core schema in function schemas by [@Viicos](https://github.com/Viicos) in [#11085](https://github.com/pydantic/pydantic/pull/11085)\n* Add `len` to `_BaseUrl` to avoid TypeError by [@Kharianne](https://github.com/Kharianne) in [#11111](https://github.com/pydantic/pydantic/pull/11111)\n* Make sure the type reference is removed from the seen references by [@Viicos](https://github.com/Viicos) in [#11143](https://github.com/pydantic/pydantic/pull/11143)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed20-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "New Contributors[Â¶](index.html#new-contributors_9 \"Permanent link\")", "anchor": "new-contributorsindexhtmlnew-contributors9-permanent-link", "md_text": "* [@FyZzyss](https://github.com/FyZzyss) made their first contribution in [#10789](https://github.com/pydantic/pydantic/pull/10789)\n* [@tamird](https://github.com/tamird) made their first contribution in [#10948](https://github.com/pydantic/pydantic/pull/10948)\n* [@felixxm](https://github.com/felixxm) made their first contribution in [#11077](https://github.com/pydantic/pydantic/pull/11077)\n* [@alexprabhat99](https://github.com/alexprabhat99) made their first contribution in [#11082](https://github.com/pydantic/pydantic/pull/11082)\n* [@Kharianne](https://github.com/Kharianne) made their first contribution in [#11111](https://github.com/pydantic/pydantic/pull/11111)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#new-contributorsindexhtmlnew-contributors9-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.10.3 (2024-12-03)[Â¶](index.html#v2103-2024-12-03 \"Permanent link\")", "anchor": "v2103-2024-12-03indexhtmlv2103-2024-12-03-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.10.3)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v2103-2024-12-03indexhtmlv2103-2024-12-03-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_21 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed21-permanent-link", "md_text": "#### Fixes[Â¶](index.html#fixes_21 \"Permanent link\")\n\n* Set fields when `defer_build` is set on Pydantic dataclasses by [@Viicos](https://github.com/Viicos) in [#10984](https://github.com/pydantic/pydantic/pull/10984)\n* Do not resolve the JSON Schema reference for `dict` core schema keys by [@Viicos](https://github.com/Viicos) in [#10989](https://github.com/pydantic/pydantic/pull/10989)\n* Use the globals of the function when evaluating the return type for `PlainSerializer` and `WrapSerializer` functions by [@Viicos](https://github.com/Viicos) in [#11008](https://github.com/pydantic/pydantic/pull/11008)\n* Fix host required enforcement for urls to be compatible with v2.9 behavior by [@sydney-runkle](https://github.com/sydney-runkle) in [#11027](https://github.com/pydantic/pydantic/pull/11027)\n* Add a `default_factory_takes_validated_data` property to `FieldInfo` by [@Viicos](https://github.com/Viicos) in [#11034](https://github.com/pydantic/pydantic/pull/11034)\n* Fix url json schema in `serialization` mode by [@sydney-runkle](https://github.com/sydney-runkle) in [#11035](https://github.com/pydantic/pydantic/pull/11035)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed21-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.10.2 (2024-11-25)[Â¶](index.html#v2102-2024-11-25 \"Permanent link\")", "anchor": "v2102-2024-11-25indexhtmlv2102-2024-11-25-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.10.2)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v2102-2024-11-25indexhtmlv2102-2024-11-25-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_22 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed22-permanent-link", "md_text": "#### Fixes[Â¶](index.html#fixes_22 \"Permanent link\")\n\n* Only evaluate FieldInfo annotations if required during schema building by [@Viicos](https://github.com/Viicos) in [#10769](https://github.com/pydantic/pydantic/pull/10769)\n* Do not evaluate annotations for private fields by [@Viicos](https://github.com/Viicos) in [#10962](https://github.com/pydantic/pydantic/pull/10962)\n* Support serialization as any for `Secret` types and `Url` types by [@sydney-runkle](https://github.com/sydney-runkle) in [#10947](https://github.com/pydantic/pydantic/pull/10947)\n* Fix type hint of `Field.default` to be compatible with Python 3.8 and 3.9 by [@Viicos](https://github.com/Viicos) in [#10972](https://github.com/pydantic/pydantic/pull/10972)\n* Add hashing support for URL types by [@sydney-runkle](https://github.com/sydney-runkle) in [#10975](https://github.com/pydantic/pydantic/pull/10975)\n* Hide `BaseModel.__replace__` definition from type checkers by [@Viicos](https://github.com/Viicos) in [#10979](https://github.com/pydantic/pydantic/pull/10979)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed22-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.10.1 (2024-11-21)[Â¶](index.html#v2101-2024-11-21 \"Permanent link\")", "anchor": "v2101-2024-11-21indexhtmlv2101-2024-11-21-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.10.1)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v2101-2024-11-21indexhtmlv2101-2024-11-21-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_23 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed23-permanent-link", "md_text": "#### Packaging[Â¶](index.html#packaging_11 \"Permanent link\")\n\n* Bump `pydantic-core` version to `v2.27.1` by [@sydney-runkle](https://github.com/sydney-runkle) in [#10938](https://github.com/pydantic/pydantic/pull/10938)\n\n#### Fixes[Â¶](index.html#fixes_23 \"Permanent link\")\n\n* Use the correct frame when instantiating a parametrized `TypeAdapter` by [@Viicos](https://github.com/Viicos) in [#10893](https://github.com/pydantic/pydantic/pull/10893)\n* Relax check for validated data in `default_factory` utils by [@sydney-runkle](https://github.com/sydney-runkle) in [#10909](https://github.com/pydantic/pydantic/pull/10909)\n* Fix type checking issue with `model_fields` and `model_computed_fields` by [@sydney-runkle](https://github.com/sydney-runkle) in [#10911](https://github.com/pydantic/pydantic/pull/10911)\n* Use the parent configuration during schema generation for stdlib `dataclass`es by [@sydney-runkle](https://github.com/sydney-runkle) in [#10928](https://github.com/pydantic/pydantic/pull/10928)\n* Use the `globals` of the function when evaluating the return type of serializers and `computed_field`s by [@Viicos](https://github.com/Viicos) in [#10929](https://github.com/pydantic/pydantic/pull/10929)\n* Fix URL constraint application by [@sydney-runkle](https://github.com/sydney-runkle) in [#10922](https://github.com/pydantic/pydantic/pull/10922)\n* Fix URL equality with different validation methods by [@sydney-runkle](https://github.com/sydney-runkle) in [#10934](https://github.com/pydantic/pydantic/pull/10934)\n* Fix JSON schema title when specified as `''` by [@sydney-runkle](https://github.com/sydney-runkle) in [#10936](https://github.com/pydantic/pydantic/pull/10936)\n* Fix `python` mode serialization for `complex` inference by [@sydney-runkle](https://github.com/sydney-runkle) in [pydantic-core#1549](https://github.com/pydantic/pydantic-core/pull/1549)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed23-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "New Contributors[Â¶](index.html#new-contributors_10 \"Permanent link\")", "anchor": "new-contributorsindexhtmlnew-contributors10-permanent-link", "md_text": "", "url": "https://docs.pydantic.dev/latest/changelog/index.html#new-contributorsindexhtmlnew-contributors10-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.10.0 (2024-11-20)[Â¶](index.html#v2100-2024-11-20 \"Permanent link\")", "anchor": "v2100-2024-11-20indexhtmlv2100-2024-11-20-permanent-link", "md_text": "The code released in v2.10.0 is practically identical to that of v2.10.0b2.\n\n[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.10.0)\n\nSee the [v2.10 release blog post](https://pydantic.dev/articles/pydantic-v2-10-release) for the highlights!", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v2100-2024-11-20indexhtmlv2100-2024-11-20-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_24 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed24-permanent-link", "md_text": "#### Packaging[Â¶](index.html#packaging_12 \"Permanent link\")\n\n* Bump `pydantic-core` to `v2.27.0` by [@sydney-runkle](https://github.com/sydney-runkle) in [#10825](https://github.com/pydantic/pydantic/pull/10825)\n* Replaced pdm with uv by [@frfahim](https://github.com/frfahim) in [#10727](https://github.com/pydantic/pydantic/pull/10727)\n\n#### New Features[Â¶](index.html#new-features_7 \"Permanent link\")\n\n* Support `fractions.Fraction` by [@sydney-runkle](https://github.com/sydney-runkle) in [#10318](https://github.com/pydantic/pydantic/pull/10318)\n* Support `Hashable` for json validation by [@sydney-runkle](https://github.com/sydney-runkle) in [#10324](https://github.com/pydantic/pydantic/pull/10324)\n* Add a `SocketPath` type for `linux` systems by [@theunkn0wn1](https://github.com/theunkn0wn1) in [#10378](https://github.com/pydantic/pydantic/pull/10378)\n* Allow arbitrary refs in JSON schema `examples` by [@sydney-runkle](https://github.com/sydney-runkle) in [#10417](https://github.com/pydantic/pydantic/pull/10417)\n* Support `defer_build` for Pydantic dataclasses by [@Viicos](https://github.com/Viicos) in [#10313](https://github.com/pydantic/pydantic/pull/10313)\n* Adding v1 / v2 incompatibility warning for nested v1 model by [@sydney-runkle](https://github.com/sydney-runkle) in [#10431](https://github.com/pydantic/pydantic/pull/10431)\n* Add support for unpacked `TypedDict` to type hint variadic keyword arguments with `@validate_call` by [@Viicos](https://github.com/Viicos) in [#10416](https://github.com/pydantic/pydantic/pull/10416)\n* Support compiled patterns in `protected_namespaces` by [@sydney-runkle](https://github.com/sydney-runkle) in [#10522](https://github.com/pydantic/pydantic/pull/10522)\n* Add support for `propertyNames` in JSON schema by [@FlorianSW](https://github.com/FlorianSW) in [#10478](https://github.com/pydantic/pydantic/pull/10478)\n* Adding `__replace__` protocol for Python 3.13+ support by [@sydney-runkle](https://github.com/sydney-runkle) in [#10596](https://github.com/pydantic/pydantic/pull/10596)\n* Expose public `sort` method for JSON schema generation by [@sydney-runkle](https://github.com/sydney-runkle) in [#10595](https://github.com/pydantic/pydantic/pull/10595)\n* Add runtime validation of `@validate_call` callable argument by [@kc0506](https://github.com/kc0506) in [#10627](https://github.com/pydantic/pydantic/pull/10627)\n* Add `experimental_allow_partial` support by [@samuelcolvin](https://github.com/samuelcolvin) in [#10748](https://github.com/pydantic/pydantic/pull/10748)\n* Support default factories taking validated data as an argument by [@Viicos](https://github.com/Viicos) in [#10678](https://github.com/pydantic/pydantic/pull/10678)\n* Allow subclassing `ValidationError` and `PydanticCustomError` by [@Youssefares](https://github.com/Youssefares) in [pydantic/pydantic-core#1413](https://github.com/pydantic/pydantic-core/pull/1413)\n* Add `trailing-strings` support to `experimental_allow_partial` by [@sydney-runkle](https://github.com/sydney-runkle) in [#10825](https://github.com/pydantic/pydantic/pull/10825)\n* Add `rebuild()` method for `TypeAdapter` and simplify `defer_build` patterns by [@sydney-runkle](https://github.com/sydney-runkle) in [#10537](https://github.com/pydantic/pydantic/pull/10537)\n* Improve `TypeAdapter` instance repr by [@sydney-runkle](https://github.com/sydney-runkle) in [#10872](https://github.com/pydantic/pydantic/pull/10872)\n\n#### Changes[Â¶](index.html#changes_5 \"Permanent link\")", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed24-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_24 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed24-permanent-link", "md_text": "* Don't allow customization of `SchemaGenerator` until interface is more stable by [@sydney-runkle](https://github.com/sydney-runkle) in [#10303](https://github.com/pydantic/pydantic/pull/10303)\n* Cleanly `defer_build` on `TypeAdapters`, removing experimental flag by [@sydney-runkle](https://github.com/sydney-runkle) in [#10329](https://github.com/pydantic/pydantic/pull/10329)\n* Fix `mro` of generic subclass by [@kc0506](https://github.com/kc0506) in [#10100](https://github.com/pydantic/pydantic/pull/10100)\n* Strip whitespaces on JSON Schema title generation by [@sydney-runkle](https://github.com/sydney-runkle) in [#10404](https://github.com/pydantic/pydantic/pull/10404)\n* Use `b64decode` and `b64encode` for `Base64Bytes` type by [@sydney-runkle](https://github.com/sydney-runkle) in [#10486](https://github.com/pydantic/pydantic/pull/10486)\n* Relax protected namespace config default by [@sydney-runkle](https://github.com/sydney-runkle) in [#10441](https://github.com/pydantic/pydantic/pull/10441)\n* Revalidate parametrized generics if instance's origin is subclass of OG class by [@sydney-runkle](https://github.com/sydney-runkle) in [#10666](https://github.com/pydantic/pydantic/pull/10666)\n* Warn if configuration is specified on the `@dataclass` decorator and with the `__pydantic_config__` attribute by [@sydney-runkle](https://github.com/sydney-runkle) in [#10406](https://github.com/pydantic/pydantic/pull/10406)\n* Recommend against using `Ellipsis` (...) with `Field` by [@Viicos](https://github.com/Viicos) in [#10661](https://github.com/pydantic/pydantic/pull/10661)\n* Migrate to subclassing instead of annotated approach for pydantic url types by [@sydney-runkle](https://github.com/sydney-runkle) in [#10662](https://github.com/pydantic/pydantic/pull/10662)\n* Change JSON schema generation of `Literal`s and `Enums` by [@Viicos](https://github.com/Viicos) in [#10692](https://github.com/pydantic/pydantic/pull/10692)\n* Simplify unions involving `Any` or `Never` when replacing type variables by [@Viicos](https://github.com/Viicos) in [#10338](https://github.com/pydantic/pydantic/pull/10338)\n* Do not require padding when decoding `base64` bytes by [@bschoenmaeckers](https://github.com/bschoenmaeckers) in [pydantic/pydantic-core#1448](https://github.com/pydantic/pydantic-core/pull/1448)\n* Support dates all the way to 1BC by [@changhc](https://github.com/changhc) in [pydantic/speedate#77](https://github.com/pydantic/speedate/pull/77)\n\n#### Performance[Â¶](index.html#performance_3 \"Permanent link\")\n\n* Schema cleaning: skip unnecessary copies during schema walking by [@Viicos](https://github.com/Viicos) in [#10286](https://github.com/pydantic/pydantic/pull/10286)\n* Refactor namespace logic for annotations evaluation by [@Viicos](https://github.com/Viicos) in [#10530](https://github.com/pydantic/pydantic/pull/10530)\n* Improve email regexp on edge cases by [@AlekseyLobanov](https://github.com/AlekseyLobanov) in [#10601](https://github.com/pydantic/pydantic/pull/10601)\n* `CoreMetadata` refactor with an emphasis on documentation, schema build time performance, and reducing complexity by [@sydney-runkle](https://github.com/sydney-runkle) in [#10675](https://github.com/pydantic/pydantic/pull/10675)\n\n#### Fixes[Â¶](index.html#fixes_24 \"Permanent link\")", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed24-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_24 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed24-permanent-link", "md_text": "* Remove guarding check on `computed_field` with `field_serializer` by [@nix010](https://github.com/nix010) in [#10390](https://github.com/pydantic/pydantic/pull/10390)\n* Fix `Predicate` issue in `v2.9.0` by [@sydney-runkle](https://github.com/sydney-runkle) in [#10321](https://github.com/pydantic/pydantic/pull/10321)\n* Fixing `annotated-types` bound by [@sydney-runkle](https://github.com/sydney-runkle) in [#10327](https://github.com/pydantic/pydantic/pull/10327)\n* Turn `tzdata` install requirement into optional `timezone` dependency by [@jakob-keller](https://github.com/jakob-keller) in [#10331](https://github.com/pydantic/pydantic/pull/10331)\n* Use correct types namespace when building `namedtuple` core schemas by [@Viicos](https://github.com/Viicos) in [#10337](https://github.com/pydantic/pydantic/pull/10337)\n* Fix evaluation of stringified annotations during namespace inspection by [@Viicos](https://github.com/Viicos) in [#10347](https://github.com/pydantic/pydantic/pull/10347)\n* Fix `IncEx` type alias definition by [@Viicos](https://github.com/Viicos) in [#10339](https://github.com/pydantic/pydantic/pull/10339)\n* Do not error when trying to evaluate annotations of private attributes by [@Viicos](https://github.com/Viicos) in [#10358](https://github.com/pydantic/pydantic/pull/10358)\n* Fix nested type statement by [@kc0506](https://github.com/kc0506) in [#10369](https://github.com/pydantic/pydantic/pull/10369)\n* Improve typing of `ModelMetaclass.mro` by [@Viicos](https://github.com/Viicos) in [#10372](https://github.com/pydantic/pydantic/pull/10372)\n* Fix class access of deprecated `computed_field`s by [@Viicos](https://github.com/Viicos) in [#10391](https://github.com/pydantic/pydantic/pull/10391)\n* Make sure `inspect.iscoroutinefunction` works on coroutines decorated with `@validate_call` by [@MovisLi](https://github.com/MovisLi) in [#10374](https://github.com/pydantic/pydantic/pull/10374)\n* Fix `NameError` when using `validate_call` with PEP 695 on a class by [@kc0506](https://github.com/kc0506) in [#10380](https://github.com/pydantic/pydantic/pull/10380)\n* Fix `ZoneInfo` with various invalid types by [@sydney-runkle](https://github.com/sydney-runkle) in [#10408](https://github.com/pydantic/pydantic/pull/10408)\n* Fix `PydanticUserError` on empty `model_config` with annotations by [@cdwilson](https://github.com/cdwilson) in [#10412](https://github.com/pydantic/pydantic/pull/10412)\n* Fix variance issue in `_IncEx` type alias, only allow `True` by [@Viicos](https://github.com/Viicos) in [#10414](https://github.com/pydantic/pydantic/pull/10414)\n* Fix serialization schema generation when using `PlainValidator` by [@Viicos](https://github.com/Viicos) in [#10427](https://github.com/pydantic/pydantic/pull/10427)\n* Fix schema generation error when serialization schema holds references by [@Viicos](https://github.com/Viicos) in [#10444](https://github.com/pydantic/pydantic/pull/10444)\n* Inline references if possible when generating schema for `json_schema_input_type` by [@Viicos](https://github.com/Viicos) in [#10439](https://github.com/pydantic/pydantic/pull/10439)\n* Fix recursive arguments in `Representation` by [@Viicos](https://github.com/Viicos) in [#10480](https://github.com/pydantic/pydantic/pull/10480)\n* Fix representation for builtin function types by [@kschwab](https://github.com/kschwab) in [#10479](https://github.com/pydantic/pydantic/pull/10479)\n* Add python validators for decimal constraints (`max_digits` and `decimal_places`) by [@sydney-runkle](https://github.com/sydney-runkle) in [#10506](https://github.com/pydantic/pydantic/pull/10506)\n* Only fetch `__pydantic_core_schema__` from the current class during schema generation by [@Viicos](https://github.com/Viicos) in [#10518](https://github.com/pydantic/pydantic/pull/10518)\n* Fix `stacklevel` on deprecation warnings for `BaseModel` by [@sydney-runkle](https://github.com/sydney-runkle) in [#10520](https://github.com/pydantic/pydantic/pull/10520)\n* Fix warning `stacklevel` in `BaseModel.__init__` by [@Viicos](https://github.com/Viicos) in [#10526](https://github.com/pydantic/pydantic/pull/10526)\n* Improve error handling for in-evaluable refs for discriminator application by [@sydney-runkle](https://github.com/sydney-runkle) in [#10440](https://github.com/pydantic/pydantic/pull/10440)\n* Change the signature of `ConfigWrapper.core_config` to take the title directly by [@Viicos](https://github.com/Viicos) in [#10562](https://github.com/pydantic/pydantic/pull/10562)\n* Do not use the previous config from the stack for dataclasses without config by [@Viicos](https://github.com/Viicos) in [#10576](https://github.com/pydantic/pydantic/pull/10576)\n* Fix serialization for IP types with `mode='python'` by [@sydney-runkle](https://github.com/sydney-runkle) in [#10594](https://github.com/pydantic/pydantic/pull/10594)\n* Support constraint application for `Base64Etc` types by [@sydney-runkle](https://github.com/sydney-runkle) in [#10584](https://github.com/pydantic/pydantic/pull/10584)\n* Fix `validate_call` ignoring `Field` in `Annotated` by [@kc0506](https://github.com/kc0506) in [#10610](https://github.com/pydantic/pydantic/pull/10610)\n* Raise an error when `Self` is invalid by [@kc0506](https://github.com/kc0506) in [#10609](https://github.com/pydantic/pydantic/pull/10609)\n* Using `core_schema.InvalidSchema` instead of metadata injection + checks by [@sydney-runkle](https://github.com/sydney-runkle) in [#10523](https://github.com/pydantic/pydantic/pull/10523)\n* Tweak type alias logic by [@kc0506](https://github.com/kc0506) in [#10643](https://github.com/pydantic/pydantic/pull/10643)\n* Support usage of `type` with `typing.Self` and type aliases by [@kc0506](https://github.com/kc0506) in [#10621](https://github.com/pydantic/pydantic/pull/10621)\n* Use overloads for `Field` and `PrivateAttr` functions by [@Viicos](https://github.com/Viicos) in [#10651](https://github.com/pydantic/pydantic/pull/10651)\n* Clean up the `mypy` plugin implementation by [@Viicos](https://github.com/Viicos) in [#10669](https://github.com/pydantic/pydantic/pull/10669)\n* Properly check for `typing_extensions` variant of `TypeAliasType` by [@Daraan](https://github.com/Daraan) in [#10713](https://github.com/pydantic/pydantic/pull/10713)\n* Allow any mapping in `BaseModel.model_copy()` by [@Viicos](https://github.com/Viicos) in [#10751](https://github.com/pydantic/pydantic/pull/10751)\n* Fix `isinstance` behavior for urls by [@sydney-runkle](https://github.com/sydney-runkle) in [#10766](https://github.com/pydantic/pydantic/pull/10766)\n* Ensure `cached_property` can be set on Pydantic models by [@Viicos](https://github.com/Viicos) in [#10774](https://github.com/pydantic/pydantic/pull/10774)\n* Fix equality checks for primitives in literals by [@sydney-runkle](https://github.com/sydney-runkle) in [pydantic/pydantic-core#1459](https://github.com/pydantic/pydantic-core/pull/1459)\n* Properly enforce `host_required` for URLs by [@Viicos](https://github.com/Viicos) in [pydantic/pydantic-core#1488](https://github.com/pydantic/pydantic-core/pull/1488)\n* Fix when `coerce_numbers_to_str` enabled and string has invalid Unicode character by [@andrey-berenda](https://github.com/andrey-berenda) in [pydantic/pydantic-core#1515](https://github.com/pydantic/pydantic-core/pull/1515)\n* Fix serializing `complex` values in `Enum`s by [@changhc](https://github.com/changhc) in [pydantic/pydantic-core#1524](https://github.com/pydantic/pydantic-core/pull/1524)\n* Refactor `_typing_extra` module by [@Viicos](https://github.com/Viicos) in [#10725](https://github.com/pydantic/pydantic/pull/10725)\n* Support intuitive equality for urls by [@sydney-runkle](https://github.com/sydney-runkle) in [#10798](https://github.com/pydantic/pydantic/pull/10798)\n* Add `bytearray` to `TypeAdapter.validate_json` signature by [@samuelcolvin](https://github.com/samuelcolvin) in [#10802](https://github.com/pydantic/pydantic/pull/10802)\n* Ensure class access of method descriptors is performed when used as a default with `Field` by [@Viicos](https://github.com/Viicos) in [#10816](https://github.com/pydantic/pydantic/pull/10816)\n* Fix circular import with `validate_call` by [@sydney-runkle](https://github.com/sydney-runkle) in [#10807](https://github.com/pydantic/pydantic/pull/10807)\n* Fix error when using type aliases referencing other type aliases by [@Viicos](https://github.com/Viicos) in [#10809](https://github.com/pydantic/pydantic/pull/10809)\n* Fix `IncEx` type alias to be compatible with mypy by [@Viicos](https://github.com/Viicos) in [#10813](https://github.com/pydantic/pydantic/pull/10813)\n* Make `__signature__` a lazy property, do not deepcopy defaults by [@Viicos](https://github.com/Viicos) in [#10818](https://github.com/pydantic/pydantic/pull/10818)\n* Make `__signature__` lazy for dataclasses, too by [@sydney-runkle](https://github.com/sydney-runkle) in [#10832](https://github.com/pydantic/pydantic/pull/10832)\n* Subclass all single host url classes from `AnyUrl` to preserve behavior from v2.9 by [@sydney-runkle](https://github.com/sydney-runkle) in [#10856](https://github.com/pydantic/pydantic/pull/10856)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed24-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "New Contributors[Â¶](index.html#new-contributors_11 \"Permanent link\")", "anchor": "new-contributorsindexhtmlnew-contributors11-permanent-link", "md_text": "* [@jakob-keller](https://github.com/jakob-keller) made their first contribution in [#10331](https://github.com/pydantic/pydantic/pull/10331)\n* [@MovisLi](https://github.com/MovisLi) made their first contribution in [#10374](https://github.com/pydantic/pydantic/pull/10374)\n* [@joaopalmeiro](https://github.com/joaopalmeiro) made their first contribution in [#10405](https://github.com/pydantic/pydantic/pull/10405)\n* [@theunkn0wn1](https://github.com/theunkn0wn1) made their first contribution in [#10378](https://github.com/pydantic/pydantic/pull/10378)\n* [@cdwilson](https://github.com/cdwilson) made their first contribution in [#10412](https://github.com/pydantic/pydantic/pull/10412)\n* [@dlax](https://github.com/dlax) made their first contribution in [#10421](https://github.com/pydantic/pydantic/pull/10421)\n* [@kschwab](https://github.com/kschwab) made their first contribution in [#10479](https://github.com/pydantic/pydantic/pull/10479)\n* [@santibreo](https://github.com/santibreo) made their first contribution in [#10453](https://github.com/pydantic/pydantic/pull/10453)\n* [@FlorianSW](https://github.com/FlorianSW) made their first contribution in [#10478](https://github.com/pydantic/pydantic/pull/10478)\n* [@tkasuz](https://github.com/tkasuz) made their first contribution in [#10555](https://github.com/pydantic/pydantic/pull/10555)\n* [@AlekseyLobanov](https://github.com/AlekseyLobanov) made their first contribution in [#10601](https://github.com/pydantic/pydantic/pull/10601)\n* [@NiclasvanEyk](https://github.com/NiclasvanEyk) made their first contribution in [#10667](https://github.com/pydantic/pydantic/pull/10667)\n* [@mschoettle](https://github.com/mschoettle) made their first contribution in [#10677](https://github.com/pydantic/pydantic/pull/10677)\n* [@Daraan](https://github.com/Daraan) made their first contribution in [#10713](https://github.com/pydantic/pydantic/pull/10713)\n* [@k4nar](https://github.com/k4nar) made their first contribution in [#10736](https://github.com/pydantic/pydantic/pull/10736)\n* [@UriyaHarpeness](https://github.com/UriyaHarpeness) made their first contribution in [#10740](https://github.com/pydantic/pydantic/pull/10740)\n* [@frfahim](https://github.com/frfahim) made their first contribution in [#10727](https://github.com/pydantic/pydantic/pull/10727)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#new-contributorsindexhtmlnew-contributors11-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.10.0b2 (2024-11-13)[Â¶](index.html#v2100b2-2024-11-13 \"Permanent link\")", "anchor": "v2100b2-2024-11-13indexhtmlv2100b2-2024-11-13-permanent-link", "md_text": "Pre-release, see [the GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.10.0b2) for details.", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v2100b2-2024-11-13indexhtmlv2100b2-2024-11-13-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.10.0b1 (2024-11-06)[Â¶](index.html#v2100b1-2024-11-06 \"Permanent link\")", "anchor": "v2100b1-2024-11-06indexhtmlv2100b1-2024-11-06-permanent-link", "md_text": "Pre-release, see [the GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.10.0b1) for details.", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v2100b1-2024-11-06indexhtmlv2100b1-2024-11-06-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.9.2 (2024-09-17)[Â¶](index.html#v292-2024-09-17 \"Permanent link\")", "anchor": "v292-2024-09-17indexhtmlv292-2024-09-17-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.9.2)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v292-2024-09-17indexhtmlv292-2024-09-17-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_25 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed25-permanent-link", "md_text": "#### Fixes[Â¶](index.html#fixes_25 \"Permanent link\")\n\n* Do not error when trying to evaluate annotations of private attributes by [@Viicos](https://github.com/Viicos) in [#10358](https://github.com/pydantic/pydantic/pull/10358)\n* Adding notes on designing sound `Callable` discriminators by [@sydney-runkle](https://github.com/sydney-runkle) in [#10400](https://github.com/pydantic/pydantic/pull/10400)\n* Fix serialization schema generation when using `PlainValidator` by [@Viicos](https://github.com/Viicos) in [#10427](https://github.com/pydantic/pydantic/pull/10427)\n* Fix `Union` serialization warnings by [@sydney-runkle](https://github.com/sydney-runkle) in [pydantic/pydantic-core#1449](https://github.com/pydantic/pydantic-core/pull/1449)\n* Fix variance issue in `_IncEx` type alias, only allow `True` by [@Viicos](https://github.com/Viicos) in [#10414](https://github.com/pydantic/pydantic/pull/10414)\n* Fix `ZoneInfo` validation with various invalid types by [@sydney-runkle](https://github.com/sydney-runkle) in [#10408](https://github.com/pydantic/pydantic/pull/10408)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed25-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.9.1 (2024-09-09)[Â¶](index.html#v291-2024-09-09 \"Permanent link\")", "anchor": "v291-2024-09-09indexhtmlv291-2024-09-09-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.9.1)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v291-2024-09-09indexhtmlv291-2024-09-09-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_26 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed26-permanent-link", "md_text": "#### Fixes[Â¶](index.html#fixes_26 \"Permanent link\")\n\n* Fix Predicate issue in v2.9.0 by [@sydney-runkle](https://github.com/sydney-runkle) in [#10321](https://github.com/pydantic/pydantic/pull/10321)\n* Fixing `annotated-types` bound to `>=0.6.0` by [@sydney-runkle](https://github.com/sydney-runkle) in [#10327](https://github.com/pydantic/pydantic/pull/10327)\n* Turn `tzdata` install requirement into optional `timezone` dependency by [@jakob-keller](https://github.com/jakob-keller) in [#10331](https://github.com/pydantic/pydantic/pull/10331)\n* Fix `IncExc` type alias definition by [@Viicos](https://github.com/Viicos) in [#10339](https://github.com/pydantic/pydantic/pull/10339)\n* Use correct types namespace when building namedtuple core schemas by [@Viicos](https://github.com/Viicos) in [#10337](https://github.com/pydantic/pydantic/pull/10337)\n* Fix evaluation of stringified annotations during namespace inspection by [@Viicos](https://github.com/Viicos) in [#10347](https://github.com/pydantic/pydantic/pull/10347)\n* Fix tagged union serialization with alias generators by [@sydney-runkle](https://github.com/sydney-runkle) in [pydantic/pydantic-core#1442](https://github.com/pydantic/pydantic-core/pull/1442)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed26-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.9.0 (2024-09-05)[Â¶](index.html#v290-2024-09-05 \"Permanent link\")", "anchor": "v290-2024-09-05indexhtmlv290-2024-09-05-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.9.0)\n\nThe code released in v2.9.0 is practically identical to that of v2.9.0b2.", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v290-2024-09-05indexhtmlv290-2024-09-05-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_27 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed27-permanent-link", "md_text": "#### Packaging[Â¶](index.html#packaging_13 \"Permanent link\")\n\n* Bump `ruff` to `v0.5.0` and `pyright` to `v1.1.369` by [@sydney-runkle](https://github.com/sydney-runkle) in [#9801](https://github.com/pydantic/pydantic/pull/9801)\n* Bump `pydantic-extra-types` to `v2.9.0` by [@sydney-runkle](https://github.com/sydney-runkle) in [#9832](https://github.com/pydantic/pydantic/pull/9832)\n* Support compatibility with `pdm v2.18.1` by [@Viicos](https://github.com/Viicos) in [#10138](https://github.com/pydantic/pydantic/pull/10138)\n* Bump `v1` version stub to `v1.10.18` by [@sydney-runkle](https://github.com/sydney-runkle) in [#10214](https://github.com/pydantic/pydantic/pull/10214)\n* Bump `pydantic-core` to `v2.23.2` by [@sydney-runkle](https://github.com/sydney-runkle) in [#10311](https://github.com/pydantic/pydantic/pull/10311)\n\n#### New Features[Â¶](index.html#new-features_8 \"Permanent link\")\n\n* Add support for `ZoneInfo` by [@Youssefares](https://github.com/Youssefares) in [#9896](https://github.com/pydantic/pydantic/pull/9896)\n* Add `Config.val_json_bytes` by [@josh-newman](https://github.com/josh-newman) in [#9770](https://github.com/pydantic/pydantic/pull/9770)\n* Add DSN for Snowflake by [@aditkumar72](https://github.com/aditkumar72) in [#10128](https://github.com/pydantic/pydantic/pull/10128)\n* Support `complex` number by [@changhc](https://github.com/changhc) in [#9654](https://github.com/pydantic/pydantic/pull/9654)\n* Add support for `annotated_types.Not` by [@aditkumar72](https://github.com/aditkumar72) in [#10210](https://github.com/pydantic/pydantic/pull/10210)\n* Allow `WithJsonSchema` to inject `$ref`s w/ `http` or `https` links by [@dAIsySHEng1](https://github.com/dAIsySHEng1) in [#9863](https://github.com/pydantic/pydantic/pull/9863)\n* Allow validators to customize validation JSON schema by [@Viicos](https://github.com/Viicos) in [#10094](https://github.com/pydantic/pydantic/pull/10094)\n* Support parametrized `PathLike` types by [@nix010](https://github.com/nix010) in [#9764](https://github.com/pydantic/pydantic/pull/9764)\n* Add tagged union serializer that attempts to use `str` or `callable` discriminators to select the correct serializer by [@sydney-runkle](https://github.com/sydney-runkle) in in [pydantic/pydantic-core#1397](https://github.com/pydantic/pydantic-core/pull/1397)\n\n#### Changes[Â¶](index.html#changes_6 \"Permanent link\")", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed27-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_27 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed27-permanent-link", "md_text": "* Breaking Change: Merge `dict` type `json_schema_extra` by [@sydney-runkle](https://github.com/sydney-runkle) in [#9792](https://github.com/pydantic/pydantic/pull/9792)\n  + For more info (how to replicate old behavior) on this change, see [here](https://docs.pydantic.dev/dev/concepts/json_schema/#merging-json_schema_extra)\n* Refactor annotation injection for known (often generic) types by [@sydney-runkle](https://github.com/sydney-runkle) in [#9979](https://github.com/pydantic/pydantic/pull/9979)\n* Move annotation compatibility errors to validation phase by [@sydney-runkle](https://github.com/sydney-runkle) in [#9999](https://github.com/pydantic/pydantic/pull/9999)\n* Improve runtime errors for string constraints like `pattern` for incompatible types by [@sydney-runkle](https://github.com/sydney-runkle) in [#10158](https://github.com/pydantic/pydantic/pull/10158)\n* Remove `'allOf'` JSON schema workarounds by [@dpeachey](https://github.com/dpeachey) in [#10029](https://github.com/pydantic/pydantic/pull/10029)\n* Remove `typed_dict_cls` data from `CoreMetadata` by [@sydney-runkle](https://github.com/sydney-runkle) in [#10180](https://github.com/pydantic/pydantic/pull/10180)\n* Deprecate passing a dict to the `Examples` class by [@Viicos](https://github.com/Viicos) in [#10181](https://github.com/pydantic/pydantic/pull/10181)\n* Remove `initial_metadata` from internal metadata construct by [@sydney-runkle](https://github.com/sydney-runkle) in [#10194](https://github.com/pydantic/pydantic/pull/10194)\n* Use `re.Pattern.search` instead of `re.Pattern.match` for consistency with `rust` behavior by [@tinez](https://github.com/tinez) in [pydantic/pydantic-core#1368](https://github.com/pydantic/pydantic-core/pull/1368)\n* Show value of wrongly typed data in `pydantic-core` serialization warning by [@BoxyUwU](https://github.com/BoxyUwU) in [pydantic/pydantic-core#1377](https://github.com/pydantic/pydantic-core/pull/1377)\n* Breaking Change: in `pydantic-core`, change `metadata` type hint in core schemas from `Any` -> `Dict[str, Any] | None` by [@sydney-runkle](https://github.com/sydney-runkle) in [pydantic/pydantic-core#1411](https://github.com/pydantic/pydantic-core/pull/1411)\n* Raise helpful warning when `self` isn't returned from model validator by [@sydney-runkle](https://github.com/sydney-runkle) in [#10255](https://github.com/pydantic/pydantic/pull/10255)\n\n#### Performance[Â¶](index.html#performance_4 \"Permanent link\")\n\n* Initial start at improving import times for modules, using caching primarily by [@sydney-runkle](https://github.com/sydney-runkle) in [#10009](https://github.com/pydantic/pydantic/pull/10009)\n* Using cached internal import for `BaseModel` by [@sydney-runkle](https://github.com/sydney-runkle) in [#10013](https://github.com/pydantic/pydantic/pull/10013)\n* Simplify internal generics logic - remove generator overhead by [@sydney-runkle](https://github.com/sydney-runkle) in [#10059](https://github.com/pydantic/pydantic/pull/10059)\n* Remove default module globals from types namespace by [@sydney-runkle](https://github.com/sydney-runkle) in [#10123](https://github.com/pydantic/pydantic/pull/10123)\n* Performance boost: skip caching parent namespaces in most cases by [@sydney-runkle](https://github.com/sydney-runkle) in [#10113](https://github.com/pydantic/pydantic/pull/10113)\n* Update ns stack with already copied ns by [@sydney-runkle](https://github.com/sydney-runkle) in [#10267](https://github.com/pydantic/pydantic/pull/10267)\n\n##### Minor Internal Improvements[Â¶](index.html#minor-internal-improvements \"Permanent link\")", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed27-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_27 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed27-permanent-link", "md_text": "* âš¡ï¸ Speed up `multiple_of_validator()` by 31% in `pydantic/_internal/_validators.py` by [@misrasaurabh1](https://github.com/misrasaurabh1) in [#9839](https://github.com/pydantic/pydantic/pull/9839)\n* âš¡ï¸ Speed up `ModelPrivateAttr.__set_name__()` by 18% in `pydantic/fields.py` by [@misrasaurabh1](https://github.com/misrasaurabh1) in [#9841](https://github.com/pydantic/pydantic/pull/9841)\n* âš¡ï¸ Speed up `dataclass()` by 7% in `pydantic/dataclasses.py` by [@misrasaurabh1](https://github.com/misrasaurabh1) in [#9843](https://github.com/pydantic/pydantic/pull/9843)\n* âš¡ï¸ Speed up function `_field_name_for_signature` by 37% in `pydantic/_internal/_signature.py` by [@misrasaurabh1](https://github.com/misrasaurabh1) in [#9951](https://github.com/pydantic/pydantic/pull/9951)\n* âš¡ï¸ Speed up method `GenerateSchema._unpack_refs_defs` by 26% in `pydantic/_internal/_generate_schema.py` by [@misrasaurabh1](https://github.com/misrasaurabh1) in [#9949](https://github.com/pydantic/pydantic/pull/9949)\n* âš¡ï¸ Speed up function `apply_each_item_validators` by 100% in `pydantic/_internal/_generate_schema.py` by [@misrasaurabh1](https://github.com/misrasaurabh1) in [#9950](https://github.com/pydantic/pydantic/pull/9950)\n* âš¡ï¸ Speed up method `ConfigWrapper.core_config` by 28% in `pydantic/_internal/_config.py` by [@misrasaurabh1](https://github.com/misrasaurabh1) in [#9953](https://github.com/pydantic/pydantic/pull/9953)\n\n#### Fixes[Â¶](index.html#fixes_27 \"Permanent link\")", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed27-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_27 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed27-permanent-link", "md_text": "* Respect `use_enum_values` on `Literal` types by [@kwint](https://github.com/kwint) in [#9787](https://github.com/pydantic/pydantic/pull/9787)\n* Prevent type error for exotic `BaseModel/RootModel` inheritance by [@dmontagu](https://github.com/dmontagu) in [#9913](https://github.com/pydantic/pydantic/pull/9913)\n* Fix typing issue with field\\_validator-decorated methods by [@dmontagu](https://github.com/dmontagu) in [#9914](https://github.com/pydantic/pydantic/pull/9914)\n* Replace `str` type annotation with `Any` in validator factories in documentation on validators by [@maximilianfellhuber](https://github.com/maximilianfellhuber) in [#9885](https://github.com/pydantic/pydantic/pull/9885)\n* Fix `ComputedFieldInfo.wrapped_property` pointer when a property setter is assigned by [@tlambert03](https://github.com/tlambert03) in [#9892](https://github.com/pydantic/pydantic/pull/9892)\n* Fix recursive typing of `main.IncEnx` by [@tlambert03](https://github.com/tlambert03) in [#9924](https://github.com/pydantic/pydantic/pull/9924)\n* Allow usage of `type[Annotated[...]]` by [@Viicos](https://github.com/Viicos) in [#9932](https://github.com/pydantic/pydantic/pull/9932)\n* `mypy` plugin: handle frozen fields on a per-field basis by [@dmontagu](https://github.com/dmontagu) in [#9935](https://github.com/pydantic/pydantic/pull/9935)\n* Fix typo in `invalid-annotated-type` error code by [@sydney-runkle](https://github.com/sydney-runkle) in [#9948](https://github.com/pydantic/pydantic/pull/9948)\n* Simplify schema generation for `uuid`, `url`, and `ip` types by [@sydney-runkle](https://github.com/sydney-runkle) in [#9975](https://github.com/pydantic/pydantic/pull/9975)\n* Move `date` schemas to `_generate_schema.py` by [@sydney-runkle](https://github.com/sydney-runkle) in [#9976](https://github.com/pydantic/pydantic/pull/9976)\n* Move `decimal.Decimal` validation to `_generate_schema.py` by [@sydney-runkle](https://github.com/sydney-runkle) in [#9977](https://github.com/pydantic/pydantic/pull/9977)\n* Simplify IP address schema in `_std_types_schema.py` by [@sydney-runkle](https://github.com/sydney-runkle) in [#9959](https://github.com/pydantic/pydantic/pull/9959)\n* Fix type annotations for some potentially generic `GenerateSchema.match_type` options by [@sydney-runkle](https://github.com/sydney-runkle) in [#9961](https://github.com/pydantic/pydantic/pull/9961)\n* Add class name to \"has conflict\" warnings by [@msabramo](https://github.com/msabramo) in [#9964](https://github.com/pydantic/pydantic/pull/9964)\n* Fix `dataclass` ignoring `default_factory` passed in Annotated by [@kc0506](https://github.com/kc0506) in [#9971](https://github.com/pydantic/pydantic/pull/9971)\n* Fix `Sequence` ignoring `discriminator` by [@kc0506](https://github.com/kc0506) in [#9980](https://github.com/pydantic/pydantic/pull/9980)\n* Fix typing for `IPvAnyAddress` and `IPvAnyInterface` by [@haoyun](https://github.com/haoyun) in [#9990](https://github.com/pydantic/pydantic/pull/9990)\n* Fix false positives on v1 models in `mypy` plugin for `from_orm` check requiring from\\_attributes=True config by [@radekwlsk](https://github.com/radekwlsk) in [#9938](https://github.com/pydantic/pydantic/pull/9938)\n* Apply `strict=True` to `__init__` in `mypy` plugin by [@kc0506](https://github.com/kc0506) in [#9998](https://github.com/pydantic/pydantic/pull/9998)\n* Refactor application of `deque` annotations by [@sydney-runkle](https://github.com/sydney-runkle) in [#10018](https://github.com/pydantic/pydantic/pull/10018)\n* Raise a better user error when failing to evaluate a forward reference by [@Viicos](https://github.com/Viicos) in [#10030](https://github.com/pydantic/pydantic/pull/10030)\n* Fix evaluation of `__pydantic_extra__` annotation in specific circumstances by [@Viicos](https://github.com/Viicos) in [#10070](https://github.com/pydantic/pydantic/pull/10070)\n* Fix `frozen` enforcement for `dataclasses` by [@sydney-runkle](https://github.com/sydney-runkle) in [#10066](https://github.com/pydantic/pydantic/pull/10066)\n* Remove logic to handle unused `__get_pydantic_core_schema__` signature by [@Viicos](https://github.com/Viicos) in [#10075](https://github.com/pydantic/pydantic/pull/10075)\n* Use `is_annotated` consistently by [@Viicos](https://github.com/Viicos) in [#10095](https://github.com/pydantic/pydantic/pull/10095)\n* Fix `PydanticDeprecatedSince26` typo by [@kc0506](https://github.com/kc0506) in [#10101](https://github.com/pydantic/pydantic/pull/10101)\n* Improve `pyright` tests, refactor model decorators signatures by [@Viicos](https://github.com/Viicos) in [#10092](https://github.com/pydantic/pydantic/pull/10092)\n* Fix `ip` serialization logic by [@sydney-runkle](https://github.com/sydney-runkle) in [#10112](https://github.com/pydantic/pydantic/pull/10112)\n* Warn when frozen defined twice for `dataclasses` by [@mochi22](https://github.com/mochi22) in [#10082](https://github.com/pydantic/pydantic/pull/10082)\n* Do not compute JSON Schema default when plain serializers are used with `when_used` set to `'json-unless-none'` and the default value is `None` by [@Viicos](https://github.com/Viicos) in [#10121](https://github.com/pydantic/pydantic/pull/10121)\n* Fix `ImportString` special cases by [@sydney-runkle](https://github.com/sydney-runkle) in [#10137](https://github.com/pydantic/pydantic/pull/10137)\n* Blacklist default globals to support exotic user code with `__` prefixed annotations by [@sydney-runkle](https://github.com/sydney-runkle) in [#10136](https://github.com/pydantic/pydantic/pull/10136)\n* Handle `nullable` schemas with `serialization` schema available during JSON Schema generation by [@Viicos](https://github.com/Viicos) in [#10132](https://github.com/pydantic/pydantic/pull/10132)\n* Reorganize `BaseModel` annotations by [@kc0506](https://github.com/kc0506) in [#10110](https://github.com/pydantic/pydantic/pull/10110)\n* Fix core schema simplification when serialization schemas are involved in specific scenarios by [@Viicos](https://github.com/Viicos) in [#10155](https://github.com/pydantic/pydantic/pull/10155)\n* Add support for stringified annotations when using `PrivateAttr` with `Annotated` by [@Viicos](https://github.com/Viicos) in [#10157](https://github.com/pydantic/pydantic/pull/10157)\n* Fix JSON Schema `number` type for literal and enum schemas by [@Viicos](https://github.com/Viicos) in [#10172](https://github.com/pydantic/pydantic/pull/10172)\n* Fix JSON Schema generation of fields with plain validators in serialization mode by [@Viicos](https://github.com/Viicos) in [#10167](https://github.com/pydantic/pydantic/pull/10167)\n* Fix invalid JSON Schemas being generated for functions in certain scenarios by [@Viicos](https://github.com/Viicos) in [#10188](https://github.com/pydantic/pydantic/pull/10188)\n* Make sure generated JSON Schemas are valid in tests by [@Viicos](https://github.com/Viicos) in [#10182](https://github.com/pydantic/pydantic/pull/10182)\n* Fix key error with custom serializer by [@sydney-runkle](https://github.com/sydney-runkle) in [#10200](https://github.com/pydantic/pydantic/pull/10200)\n* Add 'wss' for allowed schemes in NatsDsn by [@swelborn](https://github.com/swelborn) in [#10224](https://github.com/pydantic/pydantic/pull/10224)\n* Fix `Mapping` and `MutableMapping` annotations to use mapping schema instead of dict schema by [@sydney-runkle](https://github.com/sydney-runkle) in [#10020](https://github.com/pydantic/pydantic/pull/10020)\n* Fix JSON Schema generation for constrained dates by [@Viicos](https://github.com/Viicos) in [#10185](https://github.com/pydantic/pydantic/pull/10185)\n* Fix discriminated union bug regression when using enums by [@kfreezen](https://github.com/kfreezen) in [pydantic/pydantic-core#1286](https://github.com/pydantic/pydantic-core/pull/1286)\n* Fix `field_serializer` with computed field when using `*` by [@nix010](https://github.com/nix010) in [pydantic/pydantic-core#1349](https://github.com/pydantic/pydantic-core/pull/1349)\n* Try each option in `Union` serializer before inference by [@sydney-runkle](https://github.com/sydney-runkle) in [pydantic/pydantic-core#1398](https://github.com/pydantic/pydantic-core/pull/1398)\n* Fix `float` serialization behavior in `strict` mode by [@sydney-runkle](https://github.com/sydney-runkle) in [pydantic/pydantic-core#1400](https://github.com/pydantic/pydantic-core/pull/1400)\n* Introduce `exactness` into Decimal validation logic to improve union validation behavior by [@sydney-runkle](https://github.com/sydney-runkle) in in [pydantic/pydantic-core#1405](https://github.com/pydantic/pydantic-core/pull/1405)\n* Fix new warnings assertions to use `pytest.warns()` by [@mgorny](https://github.com/mgorny) in [#10241](https://github.com/pydantic/pydantic/pull/10241)\n* Fix a crash when cleaning the namespace in `ModelMetaclass` by [@Viicos](https://github.com/Viicos) in [#10242](https://github.com/pydantic/pydantic/pull/10242)\n* Fix parent namespace issue with model rebuilds by [@sydney-runkle](https://github.com/sydney-runkle) in [#10257](https://github.com/pydantic/pydantic/pull/10257)\n* Remove defaults filter for namespace by [@sydney-runkle](https://github.com/sydney-runkle) in [#10261](https://github.com/pydantic/pydantic/pull/10261)\n* Use identity instead of equality after validating model in `__init__` by [@Viicos](https://github.com/Viicos) in [#10264](https://github.com/pydantic/pydantic/pull/10264)\n* Support `BigInt` serialization for `int` subclasses by [@kxx317](https://github.com/kxx317) in [pydantic/pydantic-core#1417](https://github.com/pydantic/pydantic-core/pull/1417)\n* Support signature for wrap validators without `info` by [@sydney-runkle](https://github.com/sydney-runkle) in [#10277](https://github.com/pydantic/pydantic/pull/10277)\n* Ensure `__pydantic_complete__` is set when rebuilding `dataclasses` by [@Viicos](https://github.com/Viicos) in [#10291](https://github.com/pydantic/pydantic/pull/10291)\n* Respect `schema_generator` config value in `TypeAdapter` by [@sydney-runkle](https://github.com/sydney-runkle) in [#10300](https://github.com/pydantic/pydantic/pull/10300)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed27-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "New Contributors[Â¶](index.html#new-contributors_12 \"Permanent link\")", "anchor": "new-contributorsindexhtmlnew-contributors12-permanent-link", "md_text": "#### `pydantic`[Â¶](index.html#pydantic \"Permanent link\")\n\n* [@kwint](https://github.com/kwint) made their first contribution in [#9787](https://github.com/pydantic/pydantic/pull/9787)\n* [@seekinginfiniteloop](https://github.com/seekinginfiniteloop) made their first contribution in [#9822](https://github.com/pydantic/pydantic/pull/9822)\n* [@a-alexander](https://github.com/a-alexander) made their first contribution in [#9848](https://github.com/pydantic/pydantic/pull/9848)\n* [@maximilianfellhuber](https://github.com/maximilianfellhuber) made their first contribution in [#9885](https://github.com/pydantic/pydantic/pull/9885)\n* [@karmaBonfire](https://github.com/karmaBonfire) made their first contribution in [#9945](https://github.com/pydantic/pydantic/pull/9945)\n* [@s-rigaud](https://github.com/s-rigaud) made their first contribution in [#9958](https://github.com/pydantic/pydantic/pull/9958)\n* [@msabramo](https://github.com/msabramo) made their first contribution in [#9964](https://github.com/pydantic/pydantic/pull/9964)\n* [@DimaCybr](https://github.com/DimaCybr) made their first contribution in [#9972](https://github.com/pydantic/pydantic/pull/9972)\n* [@kc0506](https://github.com/kc0506) made their first contribution in [#9971](https://github.com/pydantic/pydantic/pull/9971)\n* [@haoyun](https://github.com/haoyun) made their first contribution in [#9990](https://github.com/pydantic/pydantic/pull/9990)\n* [@radekwlsk](https://github.com/radekwlsk) made their first contribution in [#9938](https://github.com/pydantic/pydantic/pull/9938)\n* [@dpeachey](https://github.com/dpeachey) made their first contribution in [#10029](https://github.com/pydantic/pydantic/pull/10029)\n* [@BoxyUwU](https://github.com/BoxyUwU) made their first contribution in [#10085](https://github.com/pydantic/pydantic/pull/10085)\n* [@mochi22](https://github.com/mochi22) made their first contribution in [#10082](https://github.com/pydantic/pydantic/pull/10082)\n* [@aditkumar72](https://github.com/aditkumar72) made their first contribution in [#10128](https://github.com/pydantic/pydantic/pull/10128)\n* [@changhc](https://github.com/changhc) made their first contribution in [#9654](https://github.com/pydantic/pydantic/pull/9654)\n* [@insumanth](https://github.com/insumanth) made their first contribution in [#10229](https://github.com/pydantic/pydantic/pull/10229)\n* [@AdolfoVillalobos](https://github.com/AdolfoVillalobos) made their first contribution in [#10240](https://github.com/pydantic/pydantic/pull/10240)\n* [@bllchmbrs](https://github.com/bllchmbrs) made their first contribution in [#10270](https://github.com/pydantic/pydantic/pull/10270)\n\n#### `pydantic-core`[Â¶](index.html#pydantic-core \"Permanent link\")\n\n* [@kfreezen](https://github.com/kfreezen) made their first contribution in [pydantic/pydantic-core#1286](https://github.com/pydantic/pydantic-core/pull/1286)\n* [@tinez](https://github.com/tinez) made their first contribution in [pydantic/pydantic-core#1368](https://github.com/pydantic/pydantic-core/pull/1368)\n* [@fft001](https://github.com/fft001) made their first contribution in [pydantic/pydantic-core#1362](https://github.com/pydantic/pydantic-core/pull/1362)\n* [@nix010](https://github.com/nix010) made their first contribution in [pydantic/pydantic-core#1349](https://github.com/pydantic/pydantic-core/pull/1349)\n* [@BoxyUwU](https://github.com/BoxyUwU) made their first contribution in [pydantic/pydantic-core#1379](https://github.com/pydantic/pydantic-core/pull/1379)\n* [@candleindark](https://github.com/candleindark) made their first contribution in [pydantic/pydantic-core#1404](https://github.com/pydantic/pydantic-core/pull/1404)\n* [@changhc](https://github.com/changhc) made their first contribution in [pydantic/pydantic-core#1331](https://github.com/pydantic/pydantic-core/pull/1331)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#new-contributorsindexhtmlnew-contributors12-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.9.0b2 (2024-08-30)[Â¶](index.html#v290b2-2024-08-30 \"Permanent link\")", "anchor": "v290b2-2024-08-30indexhtmlv290b2-2024-08-30-permanent-link", "md_text": "Pre-release, see [the GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.9.0b2) for details.", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v290b2-2024-08-30indexhtmlv290b2-2024-08-30-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.9.0b1 (2024-08-26)[Â¶](index.html#v290b1-2024-08-26 \"Permanent link\")", "anchor": "v290b1-2024-08-26indexhtmlv290b1-2024-08-26-permanent-link", "md_text": "Pre-release, see [the GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.9.0b1) for details.", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v290b1-2024-08-26indexhtmlv290b1-2024-08-26-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.8.2 (2024-07-03)[Â¶](index.html#v282-2024-07-03 \"Permanent link\")", "anchor": "v282-2024-07-03indexhtmlv282-2024-07-03-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.8.2)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v282-2024-07-03indexhtmlv282-2024-07-03-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_28 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed28-permanent-link", "md_text": "#### Fixes[Â¶](index.html#fixes_28 \"Permanent link\")\n\n* Fix issue with assertion caused by pluggable schema validator by [@dmontagu](https://github.com/dmontagu) in [#9838](https://github.com/pydantic/pydantic/pull/9838)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed28-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.8.1 (2024-07-03)[Â¶](index.html#v281-2024-07-03 \"Permanent link\")", "anchor": "v281-2024-07-03indexhtmlv281-2024-07-03-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.8.1)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v281-2024-07-03indexhtmlv281-2024-07-03-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_29 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed29-permanent-link", "md_text": "#### Packaging[Â¶](index.html#packaging_14 \"Permanent link\")\n\n* Bump `ruff` to `v0.5.0` and `pyright` to `v1.1.369` by [@sydney-runkle](https://github.com/sydney-runkle) in [#9801](https://github.com/pydantic/pydantic/pull/9801)\n* Bump `pydantic-core` to `v2.20.1`, `pydantic-extra-types` to `v2.9.0` by [@sydney-runkle](https://github.com/sydney-runkle) in [#9832](https://github.com/pydantic/pydantic/pull/9832)\n\n#### Fixes[Â¶](index.html#fixes_29 \"Permanent link\")\n\n* Fix breaking change in `to_snake` from v2.7 -> v2.8 by [@sydney-runkle](https://github.com/sydney-runkle) in [#9812](https://github.com/pydantic/pydantic/pull/9812)\n* Fix list constraint json schema application by [@sydney-runkle](https://github.com/sydney-runkle) in [#9818](https://github.com/pydantic/pydantic/pull/9818)\n* Support time duration more than 23 by [@nix010](https://github.com/nix010) in [pydantic/speedate#64](https://github.com/pydantic/speedate/pull/64)\n* Fix millisecond fraction being handled with the wrong scale by [@davidhewitt](https://github.com/davidhewitt) in [pydantic/speedate#65](https://github.com/pydantic/speedate/pull/65)\n* Handle negative fractional durations correctly by [@sydney-runkle](https://github.com/sydney-runkle) in [pydantic/speedate#71](https://github.com/pydantic/speedate/pull/71)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed29-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.8.0 (2024-07-01)[Â¶](index.html#v280-2024-07-01 \"Permanent link\")", "anchor": "v280-2024-07-01indexhtmlv280-2024-07-01-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.8.0)\n\nThe code released in v2.8.0 is functionally identical to that of v2.8.0b1.", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v280-2024-07-01indexhtmlv280-2024-07-01-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_30 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed30-permanent-link", "md_text": "#### Packaging[Â¶](index.html#packaging_15 \"Permanent link\")\n\n* Update citation version automatically with new releases by [@sydney-runkle](https://github.com/sydney-runkle) in [#9673](https://github.com/pydantic/pydantic/pull/9673)\n* Bump pyright to `v1.1.367` and add type checking tests for pipeline API by [@adriangb](https://github.com/adriangb) in [#9674](https://github.com/pydantic/pydantic/pull/9674)\n* Update `pydantic.v1` stub to `v1.10.17` by [@sydney-runkle](https://github.com/sydney-runkle) in [#9707](https://github.com/pydantic/pydantic/pull/9707)\n* General package updates to prep for `v2.8.0b1` by [@sydney-runkle](https://github.com/sydney-runkle) in [#9741](https://github.com/pydantic/pydantic/pull/9741)\n* Bump `pydantic-core` to `v2.20.0` by [@sydney-runkle](https://github.com/sydney-runkle) in [#9745](https://github.com/pydantic/pydantic/pull/9745)\n* Add support for Python 3.13 by [@sydney-runkle](https://github.com/sydney-runkle) in [#9743](https://github.com/pydantic/pydantic/pull/9743)\n* Update `pdm` version used for `pdm.lock` to v2.16.1 by [@sydney-runkle](https://github.com/sydney-runkle) in [#9761](https://github.com/pydantic/pydantic/pull/9761)\n* Update to `ruff` `v0.4.8` by [@Viicos](https://github.com/Viicos) in [#9585](https://github.com/pydantic/pydantic/pull/9585)\n\n#### New Features[Â¶](index.html#new-features_9 \"Permanent link\")\n\n* Experimental: support `defer_build` for `TypeAdapter` by [@MarkusSintonen](https://github.com/MarkusSintonen) in [#8939](https://github.com/pydantic/pydantic/pull/8939)\n* Implement `deprecated` field in json schema by [@NeevCohen](https://github.com/NeevCohen) in [#9298](https://github.com/pydantic/pydantic/pull/9298)\n* Experimental: Add pipeline API by [@adriangb](https://github.com/adriangb) in [#9459](https://github.com/pydantic/pydantic/pull/9459)\n* Add support for programmatic title generation by [@NeevCohen](https://github.com/NeevCohen) in [#9183](https://github.com/pydantic/pydantic/pull/9183)\n* Implement `fail_fast` feature by [@uriyyo](https://github.com/uriyyo) in [#9708](https://github.com/pydantic/pydantic/pull/9708)\n* Add `ser_json_inf_nan='strings'` mode to produce valid JSON by [@josh-newman](https://github.com/josh-newman) in [pydantic/pydantic-core#1307](https://github.com/pydantic/pydantic-core/pull/1307)\n\n#### Changes[Â¶](index.html#changes_7 \"Permanent link\")\n\n* Add warning when \"alias\" is set in ignored `Annotated` field by [@nix010](https://github.com/nix010) in [#9170](https://github.com/pydantic/pydantic/pull/9170)\n* Support serialization of some serializable defaults in JSON schema by [@sydney-runkle](https://github.com/sydney-runkle) in [#9624](https://github.com/pydantic/pydantic/pull/9624)\n* Relax type specification for `__validators__` values in `create_model` by [@sydney-runkle](https://github.com/sydney-runkle) in [#9697](https://github.com/pydantic/pydantic/pull/9697)\n* **Breaking Change:** Improve `smart` union matching logic by [@sydney-runkle](https://github.com/sydney-runkle) in [pydantic/pydantic-core#1322](https://github.com/pydantic/pydantic-core/pull/1322)\n  You can read more about our `smart` union matching logic [here](https://docs.pydantic.dev/dev/concepts/unions/#smart-mode). In some cases, if the old behavior\n  is desired, you can switch to `left-to-right` mode and change the order of your `Union` members.\n\n#### Performance[Â¶](index.html#performance_5 \"Permanent link\")\n\n##### Internal Improvements[Â¶](index.html#internal-improvements \"Permanent link\")", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed30-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_30 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed30-permanent-link", "md_text": "* âš¡ï¸ Speed up `_display_error_loc()` by 25% in `pydantic/v1/error_wrappers.py` by [@misrasaurabh1](https://github.com/misrasaurabh1) in [#9653](https://github.com/pydantic/pydantic/pull/9653)\n* âš¡ï¸ Speed up `_get_all_json_refs()` by 34% in `pydantic/json_schema.py` by [@misrasaurabh1](https://github.com/misrasaurabh1) in [#9650](https://github.com/pydantic/pydantic/pull/9650)\n* âš¡ï¸ Speed up `is_pydantic_dataclass()` by 41% in `pydantic/dataclasses.py` by [@misrasaurabh1](https://github.com/misrasaurabh1) in [#9652](https://github.com/pydantic/pydantic/pull/9652)\n* âš¡ï¸ Speed up `to_snake()` by 27% in `pydantic/alias_generators.py` by [@misrasaurabh1](https://github.com/misrasaurabh1) in [#9747](https://github.com/pydantic/pydantic/pull/9747)\n* âš¡ï¸ Speed up `unwrap_wrapped_function()` by 93% in `pydantic/_internal/_decorators.py` by [@misrasaurabh1](https://github.com/misrasaurabh1) in [#9727](https://github.com/pydantic/pydantic/pull/9727)\n\n#### Fixes[Â¶](index.html#fixes_30 \"Permanent link\")", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed30-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_30 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed30-permanent-link", "md_text": "* Replace `__spec__.parent` with `__package__` by [@hramezani](https://github.com/hramezani) in [#9331](https://github.com/pydantic/pydantic/pull/9331)\n* Fix Outputted Model JSON Schema for `Sequence` type by [@anesmemisevic](https://github.com/anesmemisevic) in [#9303](https://github.com/pydantic/pydantic/pull/9303)\n* Fix typing of `_frame_depth` by [@Viicos](https://github.com/Viicos) in [#9353](https://github.com/pydantic/pydantic/pull/9353)\n* Make `ImportString` json schema compatible by [@amitschang](https://github.com/amitschang) in [#9344](https://github.com/pydantic/pydantic/pull/9344)\n* Hide private attributes (`PrivateAttr`) from `__init__` signature in type checkers by [@idan22moral](https://github.com/idan22moral) in [#9293](https://github.com/pydantic/pydantic/pull/9293)\n* Make detection of `TypeVar` defaults robust to the CPython `PEP-696` implementation by [@AlexWaygood](https://github.com/AlexWaygood) in [#9426](https://github.com/pydantic/pydantic/pull/9426)\n* Fix usage of `PlainSerializer` with builtin types by [@Viicos](https://github.com/Viicos) in [#9450](https://github.com/pydantic/pydantic/pull/9450)\n* Add more robust custom validation examples by [@ChrisPappalardo](https://github.com/ChrisPappalardo) in [#9468](https://github.com/pydantic/pydantic/pull/9468)\n* Fix ignored `strict` specification for `StringConstraint(strict=False)` by [@vbmendes](https://github.com/vbmendes) in [#9476](https://github.com/pydantic/pydantic/pull/9476)\n* **Breaking Change:** Use PEP 570 syntax by [@Viicos](https://github.com/Viicos) in [#9479](https://github.com/pydantic/pydantic/pull/9479)\n* Use `Self` where possible by [@Viicos](https://github.com/Viicos) in [#9479](https://github.com/pydantic/pydantic/pull/9479)\n* Do not alter `RootModel.model_construct` signature in the `mypy` plugin by [@Viicos](https://github.com/Viicos) in [#9480](https://github.com/pydantic/pydantic/pull/9480)\n* Fixed type hint of `validation_context` by [@OhioDschungel6](https://github.com/OhioDschungel6) in [#9508](https://github.com/pydantic/pydantic/pull/9508)\n* Support context being passed to TypeAdapter's `dump_json`/`dump_python` by [@alexcouper](https://github.com/alexcouper) in [#9495](https://github.com/pydantic/pydantic/pull/9495)\n* Updates type signature for `Field()` constructor by [@bjmc](https://github.com/bjmc) in [#9484](https://github.com/pydantic/pydantic/pull/9484)\n* Improve builtin alias generators by [@sydney-runkle](https://github.com/sydney-runkle) in [#9561](https://github.com/pydantic/pydantic/pull/9561)\n* Fix typing of `TypeAdapter` by [@Viicos](https://github.com/Viicos) in [#9570](https://github.com/pydantic/pydantic/pull/9570)\n* Add fallback default value for private fields in `__setstate__` of BaseModel by [@anhpham1509](https://github.com/anhpham1509) in [#9584](https://github.com/pydantic/pydantic/pull/9584)\n* Support `PEP 746` by [@adriangb](https://github.com/adriangb) in [#9587](https://github.com/pydantic/pydantic/pull/9587)\n* Allow validator and serializer functions to have default values by [@Viicos](https://github.com/Viicos) in [#9478](https://github.com/pydantic/pydantic/pull/9478)\n* Fix bug with mypy plugin's handling of covariant `TypeVar` fields by [@dmontagu](https://github.com/dmontagu) in [#9606](https://github.com/pydantic/pydantic/pull/9606)\n* Fix multiple annotation / constraint application logic by [@sydney-runkle](https://github.com/sydney-runkle) in [#9623](https://github.com/pydantic/pydantic/pull/9623)\n* Respect `regex` flags in validation and json schema by [@sydney-runkle](https://github.com/sydney-runkle) in [#9591](https://github.com/pydantic/pydantic/pull/9591)\n* Fix type hint on `IpvAnyAddress` by [@sydney-runkle](https://github.com/sydney-runkle) in [#9640](https://github.com/pydantic/pydantic/pull/9640)\n* Allow a field specifier on `__pydantic_extra__` by [@dmontagu](https://github.com/dmontagu) in [#9659](https://github.com/pydantic/pydantic/pull/9659)\n* Use normalized case for file path comparison by [@sydney-runkle](https://github.com/sydney-runkle) in [#9737](https://github.com/pydantic/pydantic/pull/9737)\n* Modify constraint application logic to allow field constraints on `Optional[Decimal]` by [@lazyhope](https://github.com/lazyhope) in [#9754](https://github.com/pydantic/pydantic/pull/9754)\n* `validate_call` type params fix by [@sydney-runkle](https://github.com/sydney-runkle) in [#9760](https://github.com/pydantic/pydantic/pull/9760)\n* Check all warnings returned by pytest.warns() by [@s-t-e-v-e-n-k](https://github.com/s-t-e-v-e-n-k) in [#9702](https://github.com/pydantic/pydantic/pull/9702)\n* Reuse `re.Pattern` object in regex patterns to allow for regex flags by [@sydney-runkle](https://github.com/sydney-runkle) in [pydantic/pydantic-core#1318](https://github.com/pydantic/pydantic-core/pull/1318)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed30-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "New Contributors[Â¶](index.html#new-contributors_13 \"Permanent link\")", "anchor": "new-contributorsindexhtmlnew-contributors13-permanent-link", "md_text": "* [@idan22moral](https://github.com/idan22moral) made their first contribution in [#9294](https://github.com/pydantic/pydantic/pull/9294)\n* [@anesmemisevic](https://github.com/anesmemisevic) made their first contribution in [#9303](https://github.com/pydantic/pydantic/pull/9303)\n* [@max-muoto](https://github.com/max-muoto) made their first contribution in [#9338](https://github.com/pydantic/pydantic/pull/9338)\n* [@amitschang](https://github.com/amitschang) made their first contribution in [#9344](https://github.com/pydantic/pydantic/pull/9344)\n* [@paulmartin91](https://github.com/paulmartin91) made their first contribution in [#9410](https://github.com/pydantic/pydantic/pull/9410)\n* [@OhioDschungel6](https://github.com/OhioDschungel6) made their first contribution in [#9405](https://github.com/pydantic/pydantic/pull/9405)\n* [@AlexWaygood](https://github.com/AlexWaygood) made their first contribution in [#9426](https://github.com/pydantic/pydantic/pull/9426)\n* [@kinuax](https://github.com/kinuax) made their first contribution in [#9433](https://github.com/pydantic/pydantic/pull/9433)\n* [@antoni-jamiolkowski](https://github.com/antoni-jamiolkowski) made their first contribution in [#9431](https://github.com/pydantic/pydantic/pull/9431)\n* [@candleindark](https://github.com/candleindark) made their first contribution in [#9448](https://github.com/pydantic/pydantic/pull/9448)\n* [@nix010](https://github.com/nix010) made their first contribution in [#9170](https://github.com/pydantic/pydantic/pull/9170)\n* [@tomy0000000](https://github.com/tomy0000000) made their first contribution in [#9457](https://github.com/pydantic/pydantic/pull/9457)\n* [@vbmendes](https://github.com/vbmendes) made their first contribution in [#9470](https://github.com/pydantic/pydantic/pull/9470)\n* [@micheleAlberto](https://github.com/micheleAlberto) made their first contribution in [#9471](https://github.com/pydantic/pydantic/pull/9471)\n* [@ChrisPappalardo](https://github.com/ChrisPappalardo) made their first contribution in [#9468](https://github.com/pydantic/pydantic/pull/9468)\n* [@blueTurtz](https://github.com/blueTurtz) made their first contribution in [#9475](https://github.com/pydantic/pydantic/pull/9475)\n* [@WinterBlue16](https://github.com/WinterBlue16) made their first contribution in [#9477](https://github.com/pydantic/pydantic/pull/9477)\n* [@bittner](https://github.com/bittner) made their first contribution in [#9500](https://github.com/pydantic/pydantic/pull/9500)\n* [@alexcouper](https://github.com/alexcouper) made their first contribution in [#9495](https://github.com/pydantic/pydantic/pull/9495)\n* [@bjmc](https://github.com/bjmc) made their first contribution in [#9484](https://github.com/pydantic/pydantic/pull/9484)\n* [@pjvv](https://github.com/pjvv) made their first contribution in [#9529](https://github.com/pydantic/pydantic/pull/9529)\n* [@nedbat](https://github.com/nedbat) made their first contribution in [#9530](https://github.com/pydantic/pydantic/pull/9530)\n* [@gunnellEvan](https://github.com/gunnellEvan) made their first contribution in [#9469](https://github.com/pydantic/pydantic/pull/9469)\n* [@jaymbans](https://github.com/jaymbans) made their first contribution in [#9531](https://github.com/pydantic/pydantic/pull/9531)\n* [@MarcBresson](https://github.com/MarcBresson) made their first contribution in [#9534](https://github.com/pydantic/pydantic/pull/9534)\n* [@anhpham1509](https://github.com/anhpham1509) made their first contribution in [#9584](https://github.com/pydantic/pydantic/pull/9584)\n* [@K-dash](https://github.com/K-dash) made their first contribution in [#9595](https://github.com/pydantic/pydantic/pull/9595)\n* [@s-t-e-v-e-n-k](https://github.com/s-t-e-v-e-n-k) made their first contribution in [#9527](https://github.com/pydantic/pydantic/pull/9527)\n* [@airwoodix](https://github.com/airwoodix) made their first contribution in [#9506](https://github.com/pydantic/pydantic/pull/9506)\n* [@misrasaurabh1](https://github.com/misrasaurabh1) made their first contribution in [#9653](https://github.com/pydantic/pydantic/pull/9653)\n* [@AlessandroMiola](https://github.com/AlessandroMiola) made their first contribution in [#9740](https://github.com/pydantic/pydantic/pull/9740)\n* [@mylapallilavanyaa](https://github.com/mylapallilavanyaa) made their first contribution in [#9746](https://github.com/pydantic/pydantic/pull/9746)\n* [@lazyhope](https://github.com/lazyhope) made their first contribution in [#9754](https://github.com/pydantic/pydantic/pull/9754)\n* [@YassinNouh21](https://github.com/YassinNouh21) made their first contribution in [#9759](https://github.com/pydantic/pydantic/pull/9759)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#new-contributorsindexhtmlnew-contributors13-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.8.0b1 (2024-06-27)[Â¶](index.html#v280b1-2024-06-27 \"Permanent link\")", "anchor": "v280b1-2024-06-27indexhtmlv280b1-2024-06-27-permanent-link", "md_text": "Pre-release, see [the GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.8.0b1) for details.", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v280b1-2024-06-27indexhtmlv280b1-2024-06-27-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.7.4 (2024-06-12)[Â¶](index.html#v274-2024-06-12 \"Permanent link\")", "anchor": "v274-2024-06-12indexhtmlv274-2024-06-12-permanent-link", "md_text": "[Github release](https://github.com/pydantic/pydantic/releases/tag/v2.7.4)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v274-2024-06-12indexhtmlv274-2024-06-12-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_31 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed31-permanent-link", "md_text": "#### Packaging[Â¶](index.html#packaging_16 \"Permanent link\")\n\n* Bump `pydantic.v1` to `v1.10.16` reference by [@sydney-runkle](https://github.com/sydney-runkle) in [#9639](https://github.com/pydantic/pydantic/pull/9639)\n\n#### Fixes[Â¶](index.html#fixes_31 \"Permanent link\")\n\n* Specify `recursive_guard` as kwarg in `FutureRef._evaluate` by [@vfazio](https://github.com/vfazio) in [#9612](https://github.com/pydantic/pydantic/pull/9612)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed31-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.7.3 (2024-06-03)[Â¶](index.html#v273-2024-06-03 \"Permanent link\")", "anchor": "v273-2024-06-03indexhtmlv273-2024-06-03-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.7.3)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v273-2024-06-03indexhtmlv273-2024-06-03-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_32 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed32-permanent-link", "md_text": "#### Packaging[Â¶](index.html#packaging_17 \"Permanent link\")\n\n* Bump `pydantic-core` to `v2.18.4` by [@sydney-runkle](https://github.com/sydney-runkle) in [#9550](https://github.com/pydantic/pydantic/pull/9550)\n\n#### Fixes[Â¶](index.html#fixes_32 \"Permanent link\")\n\n* Fix u style unicode strings in python [@samuelcolvin](https://github.com/samuelcolvin) in [pydantic/jiter#110](https://github.com/pydantic/jiter/pull/110)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed32-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.7.2 (2024-05-28)[Â¶](index.html#v272-2024-05-28 \"Permanent link\")", "anchor": "v272-2024-05-28indexhtmlv272-2024-05-28-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.7.2)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v272-2024-05-28indexhtmlv272-2024-05-28-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_33 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed33-permanent-link", "md_text": "#### Packaging[Â¶](index.html#packaging_18 \"Permanent link\")\n\n* Bump `pydantic-core` to `v2.18.3` by [@sydney-runkle](https://github.com/sydney-runkle) in [#9515](https://github.com/pydantic/pydantic/pull/9515)\n\n#### Fixes[Â¶](index.html#fixes_33 \"Permanent link\")\n\n* Replace `__spec__.parent` with `__package__` by [@hramezani](https://github.com/hramezani) in [#9331](https://github.com/pydantic/pydantic/pull/9331)\n* Fix validation of `int`s with leading unary minus by [@RajatRajdeep](https://github.com/RajatRajdeep) in [pydantic/pydantic-core#1291](https://github.com/pydantic/pydantic-core/pull/1291)\n* Fix `str` subclass validation for enums by [@sydney-runkle](https://github.com/sydney-runkle) in [pydantic/pydantic-core#1273](https://github.com/pydantic/pydantic-core/pull/1273)\n* Support `BigInt`s in `Literal`s and `Enum`s by [@samuelcolvin](https://github.com/samuelcolvin) in [pydantic/pydantic-core#1297](https://github.com/pydantic/pydantic-core/pull/1297)\n* Fix: uuid - allow `str` subclass as input by [@davidhewitt](https://github.com/davidhewitt) in [pydantic/pydantic-core#1296](https://github.com/pydantic/pydantic-core/pull/1296)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed33-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.7.1 (2024-04-23)[Â¶](index.html#v271-2024-04-23 \"Permanent link\")", "anchor": "v271-2024-04-23indexhtmlv271-2024-04-23-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.7.1)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v271-2024-04-23indexhtmlv271-2024-04-23-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_34 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed34-permanent-link", "md_text": "#### Packaging[Â¶](index.html#packaging_19 \"Permanent link\")\n\n* Bump `pydantic-core` to `v2.18.2` by [@sydney-runkle](https://github.com/sydney-runkle) in [#9307](https://github.com/pydantic/pydantic/pull/9307)\n\n#### New Features[Â¶](index.html#new-features_10 \"Permanent link\")\n\n* Ftp and Websocket connection strings support by [@CherrySuryp](https://github.com/CherrySuryp) in [#9205](https://github.com/pydantic/pydantic/pull/9205)\n\n#### Changes[Â¶](index.html#changes_8 \"Permanent link\")\n\n* Use field description for RootModel schema description when there is `â€¦` by [@LouisGobert](https://github.com/LouisGobert) in [#9214](https://github.com/pydantic/pydantic/pull/9214)\n\n#### Fixes[Â¶](index.html#fixes_34 \"Permanent link\")\n\n* Fix `validation_alias` behavior with `model_construct` for `AliasChoices` and `AliasPath` by [@sydney-runkle](https://github.com/sydney-runkle) in [#9223](https://github.com/pydantic/pydantic/pull/9223)\n* Revert `typing.Literal` and import it outside the TYPE\\_CHECKING block by [@frost-nzcr4](https://github.com/frost-nzcr4) in [#9232](https://github.com/pydantic/pydantic/pull/9232)\n* Fix `Secret` serialization schema, applicable for unions by [@sydney-runkle](https://github.com/sydney-runkle) in [#9240](https://github.com/pydantic/pydantic/pull/9240)\n* Fix `strict` application to `function-after` with `use_enum_values` by [@sydney-runkle](https://github.com/sydney-runkle) in [#9279](https://github.com/pydantic/pydantic/pull/9279)\n* Address case where `model_construct` on a class which defines `model_post_init` fails with `AttributeError` by [@babygrimes](https://github.com/babygrimes) in [#9168](https://github.com/pydantic/pydantic/pull/9168)\n* Fix `model_json_schema` with config types by [@NeevCohen](https://github.com/NeevCohen) in [#9287](https://github.com/pydantic/pydantic/pull/9287)\n* Support multiple zeros as an `int` by [@samuelcolvin](https://github.com/samuelcolvin) in [pydantic/pydantic-core#1269](https://github.com/pydantic/pydantic-core/pull/1269)\n* Fix validation of `int`s with leading unary plus by [@cknv](https://github.com/cknv) in [pydantic/pydantic-core#1272](https://github.com/pydantic/pydantic-core/pull/1272)\n* Fix interaction between `extra != 'ignore'` and `from_attributes=True` by [@davidhewitt](https://github.com/davidhewitt) in [pydantic/pydantic-core#1276](https://github.com/pydantic/pydantic-core/pull/1276)\n* Handle error from `Enum`'s `missing` function as `ValidationError` by [@sydney-runkle](https://github.com/sydney-runkle) in [pydantic/pydantic-core#1274](https://github.com/pydantic/pydantic-core/pull/1754)\n* Fix memory leak with `Iterable` validation by [@davidhewitt](https://github.com/davidhewitt) in [pydantic/pydantic-core#1271](https://github.com/pydantic/pydantic-core/pull/1751)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed34-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "New Contributors[Â¶](index.html#new-contributors_14 \"Permanent link\")", "anchor": "new-contributorsindexhtmlnew-contributors14-permanent-link", "md_text": "* [@zzstoatzz](https://github.com/zzstoatzz) made their first contribution in [#9219](https://github.com/pydantic/pydantic/pull/9219)\n* [@frost-nzcr4](https://github.com/frost-nzcr4) made their first contribution in [#9232](https://github.com/pydantic/pydantic/pull/9232)\n* [@CherrySuryp](https://github.com/CherrySuryp) made their first contribution in [#9205](https://github.com/pydantic/pydantic/pull/9205)\n* [@vagenas](https://github.com/vagenas) made their first contribution in [#9268](https://github.com/pydantic/pydantic/pull/9268)\n* [@ollz272](https://github.com/ollz272) made their first contribution in [#9262](https://github.com/pydantic/pydantic/pull/9262)\n* [@babygrimes](https://github.com/babygrimes) made their first contribution in [#9168](https://github.com/pydantic/pydantic/pull/9168)\n* [@swelborn](https://github.com/swelborn) made their first contribution in [#9296](https://github.com/pydantic/pydantic/pull/9296)\n* [@kf-novi](https://github.com/kf-novi) made their first contribution in [#9236](https://github.com/pydantic/pydantic/pull/9236)\n* [@lgeiger](https://github.com/lgeiger) made their first contribution in [#9288](https://github.com/pydantic/pydantic/pull/9288)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#new-contributorsindexhtmlnew-contributors14-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.7.0 (2024-04-11)[Â¶](index.html#v270-2024-04-11 \"Permanent link\")", "anchor": "v270-2024-04-11indexhtmlv270-2024-04-11-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.7.0)\n\nThe code released in v2.7.0 is practically identical to that of v2.7.0b1.", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v270-2024-04-11indexhtmlv270-2024-04-11-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_35 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed35-permanent-link", "md_text": "#### Packaging[Â¶](index.html#packaging_20 \"Permanent link\")\n\n* Reorganize `pyproject.toml` sections by [@Viicos](https://github.com/Viicos) in [#8899](https://github.com/pydantic/pydantic/pull/8899)\n* Bump `pydantic-core` to `v2.18.1` by [@sydney-runkle](https://github.com/sydney-runkle) in [#9211](https://github.com/pydantic/pydantic/pull/9211)\n* Adopt `jiter` `v0.2.0` by [@samuelcolvin](https://github.com/samuelcolvin) in [pydantic/pydantic-core#1250](https://github.com/pydantic/pydantic-core/pull/1250)\n\n#### New Features[Â¶](index.html#new-features_11 \"Permanent link\")\n\n* Extract attribute docstrings from `FieldInfo.description` by [@Viicos](https://github.com/Viicos) in [#6563](https://github.com/pydantic/pydantic/pull/6563)\n* Add a `with_config` decorator to comply with typing spec by [@Viicos](https://github.com/Viicos) in [#8611](https://github.com/pydantic/pydantic/pull/8611)\n* Allow an optional separator splitting the value and unit of the result of `ByteSize.human_readable` by [@jks15satoshi](https://github.com/jks15satoshi) in [#8706](https://github.com/pydantic/pydantic/pull/8706)\n* Add generic `Secret` base type by [@conradogarciaberrotaran](https://github.com/conradogarciaberrotaran) in [#8519](https://github.com/pydantic/pydantic/pull/8519)\n* Make use of `Sphinx` inventories for cross references in docs by [@Viicos](https://github.com/Viicos) in [#8682](https://github.com/pydantic/pydantic/pull/8682)\n* Add environment variable to disable plugins by [@geospackle](https://github.com/geospackle) in [#8767](https://github.com/pydantic/pydantic/pull/8767)\n* Add support for `deprecated` fields by [@Viicos](https://github.com/Viicos) in [#8237](https://github.com/pydantic/pydantic/pull/8237)\n* Allow `field_serializer('*')` by [@ornariece](https://github.com/ornariece) in [#9001](https://github.com/pydantic/pydantic/pull/9001)\n* Handle a case when `model_config` is defined as a model property by [@alexeyt101](https://github.com/alexeyt101) in [#9004](https://github.com/pydantic/pydantic/pull/9004)\n* Update `create_model()` to support `typing.Annotated` as input by [@wannieman98](https://github.com/wannieman98) in [#8947](https://github.com/pydantic/pydantic/pull/8947)\n* Add `ClickhouseDsn` support by [@solidguy7](https://github.com/solidguy7) in [#9062](https://github.com/pydantic/pydantic/pull/9062)\n* Add support for `re.Pattern[str]` to `pattern` field by [@jag-k](https://github.com/jag-k) in [#9053](https://github.com/pydantic/pydantic/pull/9053)\n* Support for `serialize_as_any` runtime setting by [@sydney-runkle](https://github.com/sydney-runkle) in [#8830](https://github.com/pydantic/pydantic/pull/8830)\n* Add support for `typing.Self` by [@Youssefares](https://github.com/Youssefares) in [#9023](https://github.com/pydantic/pydantic/pull/9023)\n* Ability to pass `context` to serialization by [@ornariece](https://github.com/ornariece) in [#8965](https://github.com/pydantic/pydantic/pull/8965)\n* Add feedback widget to docs with flarelytics integration by [@sydney-runkle](https://github.com/sydney-runkle) in [#9129](https://github.com/pydantic/pydantic/pull/9129)\n* Support for parsing partial JSON strings in Python by [@samuelcolvin](https://github.com/samuelcolvin) in [pydantic/jiter#66](https://github.com/pydantic/jiter/pull/66)\n\n**Finalized in v2.7.0, rather than v2.7.0b1:**\n\n* Add support for field level number to str coercion option by [@NeevCohen](https://github.com/NeevCohen) in [#9137](https://github.com/pydantic/pydantic/pull/9137)\n* Update `warnings` parameter for serialization utilities to allow raising a warning by [@Lance-Drane](https://github.com/Lance-Drane) in [#9166](https://github.com/pydantic/pydantic/pull/9166)\n\n#### Changes[Â¶](index.html#changes_9 \"Permanent link\")", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed35-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_35 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed35-permanent-link", "md_text": "* Correct docs, logic for `model_construct` behavior with `extra` by [@sydney-runkle](https://github.com/sydney-runkle) in [#8807](https://github.com/pydantic/pydantic/pull/8807)\n* Improve error message for improper `RootModel` subclasses by [@sydney-runkle](https://github.com/sydney-runkle) in [#8857](https://github.com/pydantic/pydantic/pull/8857)\n* **Breaking Change:** Use `PEP570` syntax by [@Viicos](https://github.com/Viicos) in [#8940](https://github.com/pydantic/pydantic/pull/8940)\n* Add `enum` and `type` to the JSON schema for single item literals by [@dmontagu](https://github.com/dmontagu) in [#8944](https://github.com/pydantic/pydantic/pull/8944)\n* Deprecate `update_json_schema` internal function by [@sydney-runkle](https://github.com/sydney-runkle) in [#9125](https://github.com/pydantic/pydantic/pull/9125)\n* Serialize duration to hour minute second, instead of just seconds by [@kakilangit](https://github.com/kakilangit) in [pydantic/speedate#50](https://github.com/pydantic/speedate/pull/50)\n* Trimming str before parsing to int and float by [@hungtsetse](https://github.com/hungtsetse) in [pydantic/pydantic-core#1203](https://github.com/pydantic/pydantic-core/pull/1203)\n\n#### Performance[Â¶](index.html#performance_6 \"Permanent link\")\n\n* `enum` validator improvements by [@samuelcolvin](https://github.com/samuelcolvin) in [#9045](https://github.com/pydantic/pydantic/pull/9045)\n* Move `enum` validation and serialization to Rust by [@samuelcolvin](https://github.com/samuelcolvin) in [#9064](https://github.com/pydantic/pydantic/pull/9064)\n* Improve schema generation for nested dataclasses by [@sydney-runkle](https://github.com/sydney-runkle) in [#9114](https://github.com/pydantic/pydantic/pull/9114)\n* Fast path for ASCII python string creation in JSON by [@samuelcolvin](https://github.com/samuelcolvin) in in [pydantic/jiter#72](https://github.com/pydantic/jiter/pull/72)\n* SIMD integer and string JSON parsing on `aarch64`(**Note:** SIMD on x86 will be implemented in a future release) by [@samuelcolvin](https://github.com/samuelcolvin) in in [pydantic/jiter#65](https://github.com/pydantic/jiter/pull/65)\n* Support JSON `Cow<str>` from `jiter` by [@davidhewitt](https://github.com/davidhewitt) in [pydantic/pydantic-core#1231](https://github.com/pydantic/pydantic-core/pull/1231)\n* MAJOR performance improvement: update to PyO3 0.21 final by [@davidhewitt](https://github.com/davidhewitt) in [pydantic/pydantic-core#1248](https://github.com/pydantic/pydantic-core/pull/1248)\n* cache Python strings by [@samuelcolvin](https://github.com/samuelcolvin) in [pydantic/pydantic-core#1240](https://github.com/pydantic/pydantic-core/pull/1240)\n\n#### Fixes[Â¶](index.html#fixes_35 \"Permanent link\")", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed35-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_35 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed35-permanent-link", "md_text": "* Fix strict parsing for some `Sequence`s by [@sydney-runkle](https://github.com/sydney-runkle) in [#8614](https://github.com/pydantic/pydantic/pull/8614)\n* Add a check on the existence of `__qualname__` by [@anci3ntr0ck](https://github.com/anci3ntr0ck) in [#8642](https://github.com/pydantic/pydantic/pull/8642)\n* Handle `__pydantic_extra__` annotation being a string or inherited by [@alexmojaki](https://github.com/alexmojaki) in [#8659](https://github.com/pydantic/pydantic/pull/8659)\n* Fix json validation for `NameEmail` by [@Holi0317](https://github.com/Holi0317) in [#8650](https://github.com/pydantic/pydantic/pull/8650)\n* Fix type-safety of attribute access in `BaseModel` by [@bluenote10](https://github.com/bluenote10) in [#8651](https://github.com/pydantic/pydantic/pull/8651)\n* Fix bug with `mypy` plugin and `no_strict_optional = True` by [@dmontagu](https://github.com/dmontagu) in [#8666](https://github.com/pydantic/pydantic/pull/8666)\n* Fix `ByteSize` error `type` change by [@sydney-runkle](https://github.com/sydney-runkle) in [#8681](https://github.com/pydantic/pydantic/pull/8681)\n* Fix inheriting annotations in dataclasses by [@sydney-runkle](https://github.com/sydney-runkle) in [#8679](https://github.com/pydantic/pydantic/pull/8679)\n* Fix regression in core schema generation for indirect definition references by [@dmontagu](https://github.com/dmontagu) in [#8702](https://github.com/pydantic/pydantic/pull/8702)\n* Fix unsupported types bug with plain validator by [@sydney-runkle](https://github.com/sydney-runkle) in [#8710](https://github.com/pydantic/pydantic/pull/8710)\n* Reverting problematic fix from 2.6 release, fixing schema building bug by [@sydney-runkle](https://github.com/sydney-runkle) in [#8718](https://github.com/pydantic/pydantic/pull/8718)\n* fixes `__pydantic_config__` ignored for TypeDict by [@13sin](https://github.com/13sin) in [#8734](https://github.com/pydantic/pydantic/pull/8734)\n* Fix test failures with `pytest v8.0.0` due to `pytest.warns()` starting to work inside `pytest.raises()` by [@mgorny](https://github.com/mgorny) in [#8678](https://github.com/pydantic/pydantic/pull/8678)\n* Use `is_valid_field` from 1.x for `mypy` plugin by [@DanielNoord](https://github.com/DanielNoord) in [#8738](https://github.com/pydantic/pydantic/pull/8738)\n* Better-support `mypy` strict equality flag by [@dmontagu](https://github.com/dmontagu) in [#8799](https://github.com/pydantic/pydantic/pull/8799)\n* model\\_json\\_schema export with Annotated types misses 'required' parameters by [@LouisGobert](https://github.com/LouisGobert) in [#8793](https://github.com/pydantic/pydantic/pull/8793)\n* Fix default inclusion in `FieldInfo.__repr_args__` by [@sydney-runkle](https://github.com/sydney-runkle) in [#8801](https://github.com/pydantic/pydantic/pull/8801)\n* Fix resolution of forward refs in dataclass base classes that are not present in the subclass module namespace by [@matsjoyce-refeyn](https://github.com/matsjoyce-refeyn) in [#8751](https://github.com/pydantic/pydantic/pull/8751)\n* Fix `BaseModel` type annotations to be resolvable by `typing.get_type_hints` by [@devmonkey22](https://github.com/devmonkey22) in [#7680](https://github.com/pydantic/pydantic/pull/7680)\n* Fix: allow empty string aliases with `AliasGenerator` by [@sydney-runkle](https://github.com/sydney-runkle) in [#8810](https://github.com/pydantic/pydantic/pull/8810)\n* Fix test along with `date` -> `datetime` timezone assumption fix by [@sydney-runkle](https://github.com/sydney-runkle) in [#8823](https://github.com/pydantic/pydantic/pull/8823)\n* Fix deprecation warning with usage of `ast.Str` by [@Viicos](https://github.com/Viicos) in [#8837](https://github.com/pydantic/pydantic/pull/8837)\n* Add missing `deprecated` decorators by [@Viicos](https://github.com/Viicos) in [#8877](https://github.com/pydantic/pydantic/pull/8877)\n* Fix serialization of `NameEmail` if name includes an email address by [@NeevCohen](https://github.com/NeevCohen) in [#8860](https://github.com/pydantic/pydantic/pull/8860)\n* Add information about class in error message of schema generation by [@Czaki](https://github.com/Czaki) in [#8917](https://github.com/pydantic/pydantic/pull/8917)\n* Make `TypeAdapter`'s typing compatible with special forms by [@adriangb](https://github.com/adriangb) in [#8923](https://github.com/pydantic/pydantic/pull/8923)\n* Fix issue with config behavior being baked into the ref schema for `enum`s by [@dmontagu](https://github.com/dmontagu) in [#8920](https://github.com/pydantic/pydantic/pull/8920)\n* More helpful error re wrong `model_json_schema` usage by [@sydney-runkle](https://github.com/sydney-runkle) in [#8928](https://github.com/pydantic/pydantic/pull/8928)\n* Fix nested discriminated union schema gen, pt 2 by [@sydney-runkle](https://github.com/sydney-runkle) in [#8932](https://github.com/pydantic/pydantic/pull/8932)\n* Fix schema build for nested dataclasses / TypedDicts with discriminators by [@sydney-runkle](https://github.com/sydney-runkle) in [#8950](https://github.com/pydantic/pydantic/pull/8950)\n* Remove unnecessary logic for definitions schema gen with discriminated unions by [@sydney-runkle](https://github.com/sydney-runkle) in [#8951](https://github.com/pydantic/pydantic/pull/8951)\n* Fix handling of optionals in `mypy` plugin by [@dmontagu](https://github.com/dmontagu) in [#9008](https://github.com/pydantic/pydantic/pull/9008)\n* Fix `PlainSerializer` usage with std type constructor by [@sydney-runkle](https://github.com/sydney-runkle) in [#9031](https://github.com/pydantic/pydantic/pull/9031)\n* Remove unnecessary warning for config in plugin by [@dmontagu](https://github.com/dmontagu) in [#9039](https://github.com/pydantic/pydantic/pull/9039)\n* Fix default value serializing by [@NeevCohen](https://github.com/NeevCohen) in [#9066](https://github.com/pydantic/pydantic/pull/9066)\n* Fix extra fields check in `Model.__getattr__()` by [@NeevCohen](https://github.com/NeevCohen) in [#9082](https://github.com/pydantic/pydantic/pull/9082)\n* Fix `ClassVar` forward ref inherited from parent class by [@alexmojaki](https://github.com/alexmojaki) in [#9097](https://github.com/pydantic/pydantic/pull/9097)\n* fix sequence like validator with strict `True` by [@andresliszt](https://github.com/andresliszt) in [#8977](https://github.com/pydantic/pydantic/pull/8977)\n* Improve warning message when a field name shadows a field in a parent model by [@chan-vince](https://github.com/chan-vince) in [#9105](https://github.com/pydantic/pydantic/pull/9105)\n* Do not warn about shadowed fields if they are not redefined in a child class by [@chan-vince](https://github.com/chan-vince) in [#9111](https://github.com/pydantic/pydantic/pull/9111)\n* Fix discriminated union bug with unsubstituted type var by [@sydney-runkle](https://github.com/sydney-runkle) in [#9124](https://github.com/pydantic/pydantic/pull/9124)\n* Support serialization of `deque` when passed to `Sequence[blah blah blah]` by [@sydney-runkle](https://github.com/sydney-runkle) in [#9128](https://github.com/pydantic/pydantic/pull/9128)\n* Init private attributes from super-types in `model_post_init` by [@Viicos](https://github.com/Viicos) in [#9134](https://github.com/pydantic/pydantic/pull/9134)\n* fix `model_construct` with `validation_alias` by [@ornariece](https://github.com/ornariece) in [#9144](https://github.com/pydantic/pydantic/pull/9144)\n* Ensure json-schema generator handles `Literal` `null` types by [@bruno-f-cruz](https://github.com/bruno-f-cruz) in [#9135](https://github.com/pydantic/pydantic/pull/9135)\n* **Fixed in v2.7.0**: Fix allow extra generic by [@dmontagu](https://github.com/dmontagu) in [#9193](https://github.com/pydantic/pydantic/pull/9193)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed35-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "New Contributors[Â¶](index.html#new-contributors_15 \"Permanent link\")", "anchor": "new-contributorsindexhtmlnew-contributors15-permanent-link", "md_text": "* [@hungtsetse](https://github.com/hungtsetse) made their first contribution in [#8546](https://github.com/pydantic/pydantic/pull/8546)\n* [@StrawHatDrag0n](https://github.com/StrawHatDrag0n) made their first contribution in [#8583](https://github.com/pydantic/pydantic/pull/8583)\n* [@anci3ntr0ck](https://github.com/anci3ntr0ck) made their first contribution in [#8642](https://github.com/pydantic/pydantic/pull/8642)\n* [@Holi0317](https://github.com/Holi0317) made their first contribution in [#8650](https://github.com/pydantic/pydantic/pull/8650)\n* [@bluenote10](https://github.com/bluenote10) made their first contribution in [#8651](https://github.com/pydantic/pydantic/pull/8651)\n* [@ADSteele916](https://github.com/ADSteele916) made their first contribution in [#8703](https://github.com/pydantic/pydantic/pull/8703)\n* [@musicinmybrain](https://github.com/musicinmybrain) made their first contribution in [#8731](https://github.com/pydantic/pydantic/pull/8731)\n* [@jks15satoshi](https://github.com/jks15satoshi) made their first contribution in [#8706](https://github.com/pydantic/pydantic/pull/8706)\n* [@13sin](https://github.com/13sin) made their first contribution in [#8734](https://github.com/pydantic/pydantic/pull/8734)\n* [@DanielNoord](https://github.com/DanielNoord) made their first contribution in [#8738](https://github.com/pydantic/pydantic/pull/8738)\n* [@conradogarciaberrotaran](https://github.com/conradogarciaberrotaran) made their first contribution in [#8519](https://github.com/pydantic/pydantic/pull/8519)\n* [@chris-griffin](https://github.com/chris-griffin) made their first contribution in [#8775](https://github.com/pydantic/pydantic/pull/8775)\n* [@LouisGobert](https://github.com/LouisGobert) made their first contribution in [#8793](https://github.com/pydantic/pydantic/pull/8793)\n* [@matsjoyce-refeyn](https://github.com/matsjoyce-refeyn) made their first contribution in [#8751](https://github.com/pydantic/pydantic/pull/8751)\n* [@devmonkey22](https://github.com/devmonkey22) made their first contribution in [#7680](https://github.com/pydantic/pydantic/pull/7680)\n* [@adamency](https://github.com/adamency) made their first contribution in [#8847](https://github.com/pydantic/pydantic/pull/8847)\n* [@MamfTheKramf](https://github.com/MamfTheKramf) made their first contribution in [#8851](https://github.com/pydantic/pydantic/pull/8851)\n* [@ornariece](https://github.com/ornariece) made their first contribution in [#9001](https://github.com/pydantic/pydantic/pull/9001)\n* [@alexeyt101](https://github.com/alexeyt101) made their first contribution in [#9004](https://github.com/pydantic/pydantic/pull/9004)\n* [@wannieman98](https://github.com/wannieman98) made their first contribution in [#8947](https://github.com/pydantic/pydantic/pull/8947)\n* [@solidguy7](https://github.com/solidguy7) made their first contribution in [#9062](https://github.com/pydantic/pydantic/pull/9062)\n* [@kloczek](https://github.com/kloczek) made their first contribution in [#9047](https://github.com/pydantic/pydantic/pull/9047)\n* [@jag-k](https://github.com/jag-k) made their first contribution in [#9053](https://github.com/pydantic/pydantic/pull/9053)\n* [@priya-gitTest](https://github.com/priya-gitTest) made their first contribution in [#9088](https://github.com/pydantic/pydantic/pull/9088)\n* [@Youssefares](https://github.com/Youssefares) made their first contribution in [#9023](https://github.com/pydantic/pydantic/pull/9023)\n* [@chan-vince](https://github.com/chan-vince) made their first contribution in [#9105](https://github.com/pydantic/pydantic/pull/9105)\n* [@bruno-f-cruz](https://github.com/bruno-f-cruz) made their first contribution in [#9135](https://github.com/pydantic/pydantic/pull/9135)\n* [@Lance-Drane](https://github.com/Lance-Drane) made their first contribution in [#9166](https://github.com/pydantic/pydantic/pull/9166)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#new-contributorsindexhtmlnew-contributors15-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.7.0b1 (2024-04-03)[Â¶](index.html#v270b1-2024-04-03 \"Permanent link\")", "anchor": "v270b1-2024-04-03indexhtmlv270b1-2024-04-03-permanent-link", "md_text": "Pre-release, see [the GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.7.0b1) for details.", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v270b1-2024-04-03indexhtmlv270b1-2024-04-03-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.6.4 (2024-03-12)[Â¶](index.html#v264-2024-03-12 \"Permanent link\")", "anchor": "v264-2024-03-12indexhtmlv264-2024-03-12-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.6.4)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v264-2024-03-12indexhtmlv264-2024-03-12-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_36 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed36-permanent-link", "md_text": "#### Fixes[Â¶](index.html#fixes_36 \"Permanent link\")\n\n* Fix usage of `AliasGenerator` with `computed_field` decorator by [@sydney-runkle](https://github.com/sydney-runkle) in [#8806](https://github.com/pydantic/pydantic/pull/8806)\n* Fix nested discriminated union schema gen, pt 2 by [@sydney-runkle](https://github.com/sydney-runkle) in [#8932](https://github.com/pydantic/pydantic/pull/8932)\n* Fix bug with no\\_strict\\_optional=True caused by API deferral by [@dmontagu](https://github.com/dmontagu) in [#8826](https://github.com/pydantic/pydantic/pull/8826)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed36-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.6.3 (2024-02-27)[Â¶](index.html#v263-2024-02-27 \"Permanent link\")", "anchor": "v263-2024-02-27indexhtmlv263-2024-02-27-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.6.3)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v263-2024-02-27indexhtmlv263-2024-02-27-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_37 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed37-permanent-link", "md_text": "#### Packaging[Â¶](index.html#packaging_21 \"Permanent link\")\n\n* Update `pydantic-settings` version in the docs by [@hramezani](https://github.com/hramezani) in [#8906](https://github.com/pydantic/pydantic/pull/8906)\n\n#### Fixes[Â¶](index.html#fixes_37 \"Permanent link\")\n\n* Fix discriminated union schema gen bug by [@sydney-runkle](https://github.com/sydney-runkle) in [#8904](https://github.com/pydantic/pydantic/pull/8904)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed37-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.6.2 (2024-02-23)[Â¶](index.html#v262-2024-02-23 \"Permanent link\")", "anchor": "v262-2024-02-23indexhtmlv262-2024-02-23-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.6.2)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v262-2024-02-23indexhtmlv262-2024-02-23-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_38 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed38-permanent-link", "md_text": "#### Packaging[Â¶](index.html#packaging_22 \"Permanent link\")\n\n* Upgrade to `pydantic-core` 2.16.3 by [@sydney-runkle](https://github.com/sydney-runkle) in [#8879](https://github.com/pydantic/pydantic/pull/8879)\n\n#### Fixes[Â¶](index.html#fixes_38 \"Permanent link\")\n\n* 'YYYY-MM-DD' date string coerced to datetime shouldn't infer timezone by [@sydney-runkle](https://github.com/sydney-runkle) in [pydantic/pydantic-core#1193](https://github.com/pydantic/pydantic-core/pull/1193)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed38-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.6.1 (2024-02-05)[Â¶](index.html#v261-2024-02-05 \"Permanent link\")", "anchor": "v261-2024-02-05indexhtmlv261-2024-02-05-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.6.1)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v261-2024-02-05indexhtmlv261-2024-02-05-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_39 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed39-permanent-link", "md_text": "#### Packaging[Â¶](index.html#packaging_23 \"Permanent link\")\n\n* Upgrade to `pydantic-core` 2.16.2 by [@sydney-runkle](https://github.com/sydney-runkle) in [#8717](https://github.com/pydantic/pydantic/pull/8717)\n\n#### Fixes[Â¶](index.html#fixes_39 \"Permanent link\")\n\n* Fix bug with `mypy` plugin and `no_strict_optional = True` by [@dmontagu](https://github.com/dmontagu) in [#8666](https://github.com/pydantic/pydantic/pull/8666)\n* Fix `ByteSize` error `type` change by [@sydney-runkle](https://github.com/sydney-runkle) in [#8681](https://github.com/pydantic/pydantic/pull/8681)\n* Fix inheriting `Field` annotations in dataclasses by [@sydney-runkle](https://github.com/sydney-runkle) in [#8679](https://github.com/pydantic/pydantic/pull/8679)\n* Fix regression in core schema generation for indirect definition references by [@dmontagu](https://github.com/dmontagu) in [#8702](https://github.com/pydantic/pydantic/pull/8702)\n* Fix unsupported types bug with `PlainValidator` by [@sydney-runkle](https://github.com/sydney-runkle) in [#8710](https://github.com/pydantic/pydantic/pull/8710)\n* Reverting problematic fix from 2.6 release, fixing schema building bug by [@sydney-runkle](https://github.com/sydney-runkle) in [#8718](https://github.com/pydantic/pydantic/pull/8718)\n* Fix warning for tuple of wrong size in `Union` by [@davidhewitt](https://github.com/davidhewitt) in [pydantic/pydantic-core#1174](https://github.com/pydantic/pydantic-core/pull/1174)\n* Fix `computed_field` JSON serializer `exclude_none` behavior by [@sydney-runkle](https://github.com/sydney-runkle) in [pydantic/pydantic-core#1187](https://github.com/pydantic/pydantic-core/pull/1187)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed39-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.6.0 (2024-01-23)[Â¶](index.html#v260-2024-01-23 \"Permanent link\")", "anchor": "v260-2024-01-23indexhtmlv260-2024-01-23-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.6.0)\n\nThe code released in v2.6.0 is practically identical to that of v2.6.0b1.", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v260-2024-01-23indexhtmlv260-2024-01-23-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_40 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed40-permanent-link", "md_text": "#### Packaging[Â¶](index.html#packaging_24 \"Permanent link\")\n\n* Check for `email-validator` version >= 2.0 by [@commonism](https://github.com/commonism) in [#6033](https://github.com/pydantic/pydantic/pull/6033)\n* Upgrade `ruff`` target version to Python 3.8 by [@Elkiwa](https://github.com/Elkiwa) in [#8341](https://github.com/pydantic/pydantic/pull/8341)\n* Update to `pydantic-extra-types==2.4.1` by [@yezz123](https://github.com/yezz123) in [#8478](https://github.com/pydantic/pydantic/pull/8478)\n* Update to `pyright==1.1.345` by [@Viicos](https://github.com/Viicos) in [#8453](https://github.com/pydantic/pydantic/pull/8453)\n* Update pydantic-core from 2.14.6 to 2.16.1, significant changes from these updates are described below, full changelog [here](https://github.com/pydantic/pydantic-core/compare/v2.14.6...v2.16.1)\n\n#### New Features[Â¶](index.html#new-features_12 \"Permanent link\")\n\n* Add `NatsDsn` by [@ekeew](https://github.com/ekeew) in [#6874](https://github.com/pydantic/pydantic/pull/6874)\n* Add `ConfigDict.ser_json_inf_nan` by [@davidhewitt](https://github.com/davidhewitt) in [#8159](https://github.com/pydantic/pydantic/pull/8159)\n* Add `types.OnErrorOmit` by [@adriangb](https://github.com/adriangb) in [#8222](https://github.com/pydantic/pydantic/pull/8222)\n* Support `AliasGenerator` usage by [@sydney-runkle](https://github.com/sydney-runkle) in [#8282](https://github.com/pydantic/pydantic/pull/8282)\n* Add Pydantic People Page to docs by [@sydney-runkle](https://github.com/sydney-runkle) in [#8345](https://github.com/pydantic/pydantic/pull/8345)\n* Support `yyyy-MM-DD` datetime parsing by [@sydney-runkle](https://github.com/sydney-runkle) in [#8404](https://github.com/pydantic/pydantic/pull/8404)\n* Added bits conversions to the `ByteSize` class #8415 by [@luca-matei](https://github.com/luca-matei) in [#8507](https://github.com/pydantic/pydantic/pull/8507)\n* Enable json schema creation with type `ByteSize` by [@geospackle](https://github.com/geospackle) in [#8537](https://github.com/pydantic/pydantic/pull/8537)\n* Add `eval_type_backport` to handle union operator and builtin generic subscripting in older Pythons by [@alexmojaki](https://github.com/alexmojaki) in [#8209](https://github.com/pydantic/pydantic/pull/8209)\n* Add support for `dataclass` fields `init` by [@dmontagu](https://github.com/dmontagu) in [#8552](https://github.com/pydantic/pydantic/pull/8552)\n* Implement pickling for `ValidationError` by [@davidhewitt](https://github.com/davidhewitt) in [pydantic/pydantic-core#1119](https://github.com/pydantic/pydantic-core/pull/1119)\n* Add unified tuple validator that can handle \"variadic\" tuples via PEP-646 by [@dmontagu](https://github.com/dmontagu) in [pydantic/pydantic-core#865](https://github.com/pydantic/pydantic-core/pull/865)\n\n#### Changes[Â¶](index.html#changes_10 \"Permanent link\")", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed40-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_40 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed40-permanent-link", "md_text": "* Drop Python3.7 support by [@hramezani](https://github.com/hramezani) in [#7188](https://github.com/pydantic/pydantic/pull/7188)\n* Drop Python 3.7, and PyPy 3.7 and 3.8 by [@davidhewitt](https://github.com/davidhewitt) in [pydantic/pydantic-core#1129](https://github.com/pydantic/pydantic-core/pull/1129)\n* Use positional-only `self` in `BaseModel` constructor, so no field name can ever conflict with it by [@ariebovenberg](https://github.com/ariebovenberg) in [#8072](https://github.com/pydantic/pydantic/pull/8072)\n* Make `@validate_call` return a function instead of a custom descriptor - fixes binding issue with inheritance and adds `self/cls` argument to validation errors by [@alexmojaki](https://github.com/alexmojaki) in [#8268](https://github.com/pydantic/pydantic/pull/8268)\n* Exclude `BaseModel` docstring from JSON schema description by [@sydney-runkle](https://github.com/sydney-runkle) in [#8352](https://github.com/pydantic/pydantic/pull/8352)\n* Introducing `classproperty` decorator for `model_computed_fields` by [@Jocelyn-Gas](https://github.com/Jocelyn-Gas) in [#8437](https://github.com/pydantic/pydantic/pull/8437)\n* Explicitly raise an error if field names clashes with types by [@Viicos](https://github.com/Viicos) in [#8243](https://github.com/pydantic/pydantic/pull/8243)\n* Use stricter serializer for unions of simple types by [@alexdrydew](https://github.com/alexdrydew) [pydantic/pydantic-core#1132](https://github.com/pydantic/pydantic-core/pull/1132)\n\n#### Performance[Â¶](index.html#performance_7 \"Permanent link\")\n\n* Add Codspeed profiling Actions workflow by [@lambertsbennett](https://github.com/lambertsbennett) in [#8054](https://github.com/pydantic/pydantic/pull/8054)\n* Improve `int` extraction by [@samuelcolvin](https://github.com/samuelcolvin) in [pydantic/pydantic-core#1155](https://github.com/pydantic/pydantic-core/pull/1155)\n* Improve performance of recursion guard by [@samuelcolvin](https://github.com/samuelcolvin) in [pydantic/pydantic-core#1156](https://github.com/pydantic/pydantic-core/pull/1156)\n* `dataclass` serialization speedups by [@samuelcolvin](https://github.com/samuelcolvin) in [pydantic/pydantic-core#1162](https://github.com/pydantic/pydantic-core/pull/1162)\n* Avoid `HashMap` creation when looking up small JSON objects in `LazyIndexMaps` by [@samuelcolvin](https://github.com/samuelcolvin) in [pydantic/jiter#55](https://github.com/pydantic/jiter/pull/55)\n* use hashbrown to speedup python string caching by [@davidhewitt](https://github.com/davidhewitt) in [pydantic/jiter#51](https://github.com/pydantic/jiter/pull/51)\n* Replace `Peak` with more efficient `Peek` by [@davidhewitt](https://github.com/davidhewitt) in [pydantic/jiter#48](https://github.com/pydantic/jiter/pull/48)\n\n#### Fixes[Â¶](index.html#fixes_40 \"Permanent link\")", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed40-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_40 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed40-permanent-link", "md_text": "* Move `getattr` warning in deprecated `BaseConfig` by [@tlambert03](https://github.com/tlambert03) in [#7183](https://github.com/pydantic/pydantic/pull/7183)\n* Only hash `model_fields`, not whole `__dict__` by [@alexmojaki](https://github.com/alexmojaki) in [#7786](https://github.com/pydantic/pydantic/pull/7786)\n* Fix mishandling of unions while freezing types in the `mypy` plugin by [@dmontagu](https://github.com/dmontagu) in [#7411](https://github.com/pydantic/pydantic/pull/7411)\n* Fix `mypy` error on untyped `ClassVar` by [@vincent-hachin-wmx](https://github.com/vincent-hachin-wmx) in [#8138](https://github.com/pydantic/pydantic/pull/8138)\n* Only compare pydantic fields in `BaseModel.__eq__` instead of whole `__dict__` by [@QuentinSoubeyranAqemia](https://github.com/QuentinSoubeyranAqemia) in [#7825](https://github.com/pydantic/pydantic/pull/7825)\n* Update `strict` docstring in `model_validate` method. by [@LukeTonin](https://github.com/LukeTonin) in [#8223](https://github.com/pydantic/pydantic/pull/8223)\n* Fix overload position of `computed_field` by [@Viicos](https://github.com/Viicos) in [#8227](https://github.com/pydantic/pydantic/pull/8227)\n* Fix custom type type casting used in multiple attributes by [@ianhfc](https://github.com/ianhfc) in [#8066](https://github.com/pydantic/pydantic/pull/8066)\n* Fix issue not allowing `validate_call` decorator to be dynamically assigned to a class method by [@jusexton](https://github.com/jusexton) in [#8249](https://github.com/pydantic/pydantic/pull/8249)\n* Fix issue `unittest.mock` deprecation warnings by [@ibleedicare](https://github.com/ibleedicare) in [#8262](https://github.com/pydantic/pydantic/pull/8262)\n* Added tests for the case `JsonValue` contains subclassed primitive values by [@jusexton](https://github.com/jusexton) in [#8286](https://github.com/pydantic/pydantic/pull/8286)\n* Fix `mypy` error on free before validator (classmethod) by [@sydney-runkle](https://github.com/sydney-runkle) in [#8285](https://github.com/pydantic/pydantic/pull/8285)\n* Fix `to_snake` conversion by [@jevins09](https://github.com/jevins09) in [#8316](https://github.com/pydantic/pydantic/pull/8316)\n* Fix type annotation of `ModelMetaclass.__prepare__` by [@slanzmich](https://github.com/slanzmich) in [#8305](https://github.com/pydantic/pydantic/pull/8305)\n* Disallow `config` specification when initializing a `TypeAdapter` when the annotated type has config already by [@sydney-runkle](https://github.com/sydney-runkle) in [#8365](https://github.com/pydantic/pydantic/pull/8365)\n* Fix a naming issue with JSON schema for generics parametrized by recursive type aliases by [@dmontagu](https://github.com/dmontagu) in [#8389](https://github.com/pydantic/pydantic/pull/8389)\n* Fix type annotation in pydantic people script by [@shenxiangzhuang](https://github.com/shenxiangzhuang) in [#8402](https://github.com/pydantic/pydantic/pull/8402)\n* Add support for field `alias` in `dataclass` signature by [@NeevCohen](https://github.com/NeevCohen) in [#8387](https://github.com/pydantic/pydantic/pull/8387)\n* Fix bug with schema generation with `Field(...)` in a forward ref by [@dmontagu](https://github.com/dmontagu) in [#8494](https://github.com/pydantic/pydantic/pull/8494)\n* Fix ordering of keys in `__dict__` with `model_construct` call by [@sydney-runkle](https://github.com/sydney-runkle) in [#8500](https://github.com/pydantic/pydantic/pull/8500)\n* Fix module `path_type` creation when globals does not contain `__name__` by [@hramezani](https://github.com/hramezani) in [#8470](https://github.com/pydantic/pydantic/pull/8470)\n* Fix for namespace issue with dataclasses with `from __future__ import annotations` by [@sydney-runkle](https://github.com/sydney-runkle) in [#8513](https://github.com/pydantic/pydantic/pull/8513)\n* Fix: make function validator types positional-only by [@pmmmwh](https://github.com/pmmmwh) in [#8479](https://github.com/pydantic/pydantic/pull/8479)\n* Fix usage of `@deprecated` by [@Viicos](https://github.com/Viicos) in [#8294](https://github.com/pydantic/pydantic/pull/8294)\n* Add more support for private attributes in `model_construct` call by [@sydney-runkle](https://github.com/sydney-runkle) in [#8525](https://github.com/pydantic/pydantic/pull/8525)\n* Use a stack for the types namespace by [@dmontagu](https://github.com/dmontagu) in [#8378](https://github.com/pydantic/pydantic/pull/8378)\n* Fix schema-building bug with `TypeAliasType` for types with refs by [@dmontagu](https://github.com/dmontagu) in [#8526](https://github.com/pydantic/pydantic/pull/8526)\n* Support `pydantic.Field(repr=False)` in dataclasses by [@tigeryy2](https://github.com/tigeryy2) in [#8511](https://github.com/pydantic/pydantic/pull/8511)\n* Override `dataclass_transform` behavior for `RootModel` by [@Viicos](https://github.com/Viicos) in [#8163](https://github.com/pydantic/pydantic/pull/8163)\n* Refactor signature generation for simplicity by [@sydney-runkle](https://github.com/sydney-runkle) in [#8572](https://github.com/pydantic/pydantic/pull/8572)\n* Fix ordering bug of PlainValidator annotation by [@Anvil](https://github.com/Anvil) in [#8567](https://github.com/pydantic/pydantic/pull/8567)\n* Fix `exclude_none` for json serialization of `computed_field`s by [@sydney-runkle](https://github.com/sydney-runkle) in [pydantic/pydantic-core#1098](https://github.com/pydantic/pydantic-core/pull/1098)\n* Support yyyy-MM-DD string for datetimes by [@sydney-runkle](https://github.com/sydney-runkle) in [pydantic/pydantic-core#1124](https://github.com/pydantic/pydantic-core/pull/1124)\n* Tweak ordering of definitions in generated schemas by [@StrawHatDrag0n](https://github.com/StrawHatDrag0n) in [#8583](https://github.com/pydantic/pydantic/pull/8583)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed40-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "New Contributors[Â¶](index.html#new-contributors_16 \"Permanent link\")", "anchor": "new-contributorsindexhtmlnew-contributors16-permanent-link", "md_text": "#### `pydantic`[Â¶](index.html#pydantic_1 \"Permanent link\")", "url": "https://docs.pydantic.dev/latest/changelog/index.html#new-contributorsindexhtmlnew-contributors16-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "New Contributors[Â¶](index.html#new-contributors_16 \"Permanent link\")", "anchor": "new-contributorsindexhtmlnew-contributors16-permanent-link", "md_text": "* [@ekeew](https://github.com/ekeew) made their first contribution in [#6874](https://github.com/pydantic/pydantic/pull/6874)\n* [@lambertsbennett](https://github.com/lambertsbennett) made their first contribution in [#8054](https://github.com/pydantic/pydantic/pull/8054)\n* [@vincent-hachin-wmx](https://github.com/vincent-hachin-wmx) made their first contribution in [#8138](https://github.com/pydantic/pydantic/pull/8138)\n* [@QuentinSoubeyranAqemia](https://github.com/QuentinSoubeyranAqemia) made their first contribution in [#7825](https://github.com/pydantic/pydantic/pull/7825)\n* [@ariebovenberg](https://github.com/ariebovenberg) made their first contribution in [#8072](https://github.com/pydantic/pydantic/pull/8072)\n* [@LukeTonin](https://github.com/LukeTonin) made their first contribution in [#8223](https://github.com/pydantic/pydantic/pull/8223)\n* [@denisart](https://github.com/denisart) made their first contribution in [#8231](https://github.com/pydantic/pydantic/pull/8231)\n* [@ianhfc](https://github.com/ianhfc) made their first contribution in [#8066](https://github.com/pydantic/pydantic/pull/8066)\n* [@eonu](https://github.com/eonu) made their first contribution in [#8255](https://github.com/pydantic/pydantic/pull/8255)\n* [@amandahla](https://github.com/amandahla) made their first contribution in [#8263](https://github.com/pydantic/pydantic/pull/8263)\n* [@ibleedicare](https://github.com/ibleedicare) made their first contribution in [#8262](https://github.com/pydantic/pydantic/pull/8262)\n* [@jevins09](https://github.com/jevins09) made their first contribution in [#8316](https://github.com/pydantic/pydantic/pull/8316)\n* [@cuu508](https://github.com/cuu508) made their first contribution in [#8322](https://github.com/pydantic/pydantic/pull/8322)\n* [@slanzmich](https://github.com/slanzmich) made their first contribution in [#8305](https://github.com/pydantic/pydantic/pull/8305)\n* [@jensenbox](https://github.com/jensenbox) made their first contribution in [#8331](https://github.com/pydantic/pydantic/pull/8331)\n* [@szepeviktor](https://github.com/szepeviktor) made their first contribution in [#8356](https://github.com/pydantic/pydantic/pull/8356)\n* [@Elkiwa](https://github.com/Elkiwa) made their first contribution in [#8341](https://github.com/pydantic/pydantic/pull/8341)\n* [@parhamfh](https://github.com/parhamfh) made their first contribution in [#8395](https://github.com/pydantic/pydantic/pull/8395)\n* [@shenxiangzhuang](https://github.com/shenxiangzhuang) made their first contribution in [#8402](https://github.com/pydantic/pydantic/pull/8402)\n* [@NeevCohen](https://github.com/NeevCohen) made their first contribution in [#8387](https://github.com/pydantic/pydantic/pull/8387)\n* [@zby](https://github.com/zby) made their first contribution in [#8497](https://github.com/pydantic/pydantic/pull/8497)\n* [@patelnets](https://github.com/patelnets) made their first contribution in [#8491](https://github.com/pydantic/pydantic/pull/8491)\n* [@edwardwli](https://github.com/edwardwli) made their first contribution in [#8503](https://github.com/pydantic/pydantic/pull/8503)\n* [@luca-matei](https://github.com/luca-matei) made their first contribution in [#8507](https://github.com/pydantic/pydantic/pull/8507)\n* [@Jocelyn-Gas](https://github.com/Jocelyn-Gas) made their first contribution in [#8437](https://github.com/pydantic/pydantic/pull/8437)\n* [@bL34cHig0](https://github.com/bL34cHig0) made their first contribution in [#8501](https://github.com/pydantic/pydantic/pull/8501)\n* [@tigeryy2](https://github.com/tigeryy2) made their first contribution in [#8511](https://github.com/pydantic/pydantic/pull/8511)\n* [@geospackle](https://github.com/geospackle) made their first contribution in [#8537](https://github.com/pydantic/pydantic/pull/8537)\n* [@Anvil](https://github.com/Anvil) made their first contribution in [#8567](https://github.com/pydantic/pydantic/pull/8567)\n* [@hungtsetse](https://github.com/hungtsetse) made their first contribution in [#8546](https://github.com/pydantic/pydantic/pull/8546)\n* [@StrawHatDrag0n](https://github.com/StrawHatDrag0n) made their first contribution in [#8583](https://github.com/pydantic/pydantic/pull/8583)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#new-contributorsindexhtmlnew-contributors16-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "New Contributors[Â¶](index.html#new-contributors_16 \"Permanent link\")", "anchor": "new-contributorsindexhtmlnew-contributors16-permanent-link", "md_text": "#### `pydantic-core`[Â¶](index.html#pydantic-core_1 \"Permanent link\")\n\n* [@mariuswinger](https://github.com/mariuswinger) made their first contribution in [pydantic/pydantic-core#1087](https://github.com/pydantic/pydantic-core/pull/1087)\n* [@adamchainz](https://github.com/adamchainz) made their first contribution in [pydantic/pydantic-core#1090](https://github.com/pydantic/pydantic-core/pull/1090)\n* [@akx](https://github.com/akx) made their first contribution in [pydantic/pydantic-core#1123](https://github.com/pydantic/pydantic-core/pull/1123)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#new-contributorsindexhtmlnew-contributors16-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.6.0b1 (2024-01-19)[Â¶](index.html#v260b1-2024-01-19 \"Permanent link\")", "anchor": "v260b1-2024-01-19indexhtmlv260b1-2024-01-19-permanent-link", "md_text": "Pre-release, see [the GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.6.0b1) for details.", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v260b1-2024-01-19indexhtmlv260b1-2024-01-19-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.5.3 (2023-12-22)[Â¶](index.html#v253-2023-12-22 \"Permanent link\")", "anchor": "v253-2023-12-22indexhtmlv253-2023-12-22-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.5.3)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v253-2023-12-22indexhtmlv253-2023-12-22-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_41 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed41-permanent-link", "md_text": "#### Packaging[Â¶](index.html#packaging_25 \"Permanent link\")\n\n* uprev `pydantic-core` to 2.14.6\n\n#### Fixes[Â¶](index.html#fixes_41 \"Permanent link\")\n\n* Fix memory leak with recursive definitions creating reference cycles by [@davidhewitt](https://github.com/davidhewitt) in [pydantic/pydantic-core#1125](https://github.com/pydantic/pydantic-core/pull/1125)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed41-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.5.2 (2023-11-22)[Â¶](index.html#v252-2023-11-22 \"Permanent link\")", "anchor": "v252-2023-11-22indexhtmlv252-2023-11-22-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.5.2)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v252-2023-11-22indexhtmlv252-2023-11-22-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_42 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed42-permanent-link", "md_text": "#### Packaging[Â¶](index.html#packaging_26 \"Permanent link\")\n\n* uprev `pydantic-core` to 2.14.5\n\n#### New Features[Â¶](index.html#new-features_13 \"Permanent link\")\n\n* Add `ConfigDict.ser_json_inf_nan` by [@davidhewitt](https://github.com/davidhewitt) in [#8159](https://github.com/pydantic/pydantic/pull/8159)\n\n#### Fixes[Â¶](index.html#fixes_42 \"Permanent link\")\n\n* Fix validation of `Literal` from JSON keys when used as `dict` key by [@sydney-runkle](https://github.com/sydney-runkle) in [pydantic/pydantic-core#1075](https://github.com/pydantic/pydantic-core/pull/1075)\n* Fix bug re `custom_init` on members of `Union` by [@sydney-runkle](https://github.com/sydney-runkle) in [pydantic/pydantic-core#1076](https://github.com/pydantic/pydantic-core/pull/1076)\n* Fix `JsonValue` `bool` serialization by [@sydney-runkle](https://github.com/sydney-runkle) in [#8190](https://github.com/pydantic/pydantic/pull/8159)\n* Fix handling of unhashable inputs with `Literal` in `Union`s by [@sydney-runkle](https://github.com/sydney-runkle) in [pydantic/pydantic-core#1089](https://github.com/pydantic/pydantic-core/pull/1089)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed42-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.5.1 (2023-11-15)[Â¶](index.html#v251-2023-11-15 \"Permanent link\")", "anchor": "v251-2023-11-15indexhtmlv251-2023-11-15-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.5.1)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v251-2023-11-15indexhtmlv251-2023-11-15-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_43 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed43-permanent-link", "md_text": "#### Packaging[Â¶](index.html#packaging_27 \"Permanent link\")\n\n* uprev pydantic-core to 2.14.3 by [@samuelcolvin](https://github.com/samuelcolvin) in [#8120](https://github.com/pydantic/pydantic/pull/8120)\n\n#### Fixes[Â¶](index.html#fixes_43 \"Permanent link\")\n\n* Fix package description limit by [@dmontagu](https://github.com/dmontagu) in [#8097](https://github.com/pydantic/pydantic/pull/8097)\n* Fix `ValidateCallWrapper` error when creating a model which has a [@validate\\_call](https://github.com/validate_call) wrapped field annotation by [@sydney-runkle](https://github.com/sydney-runkle) in [#8110](https://github.com/pydantic/pydantic/pull/8110)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed43-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.5.0 (2023-11-13)[Â¶](index.html#v250-2023-11-13 \"Permanent link\")", "anchor": "v250-2023-11-13indexhtmlv250-2023-11-13-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.5.0)\n\nThe code released in v2.5.0 is functionally identical to that of v2.5.0b1.", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v250-2023-11-13indexhtmlv250-2023-11-13-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_44 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed44-permanent-link", "md_text": "#### Packaging[Â¶](index.html#packaging_28 \"Permanent link\")\n\n* Update pydantic-core from 2.10.1 to 2.14.1, significant changes from these updates are described below, full changelog [here](https://github.com/pydantic/pydantic-core/compare/v2.10.1...v2.14.1)\n* Update to `pyright==1.1.335` by [@Viicos](https://github.com/Viicos) in [#8075](https://github.com/pydantic/pydantic/pull/8075)\n\n#### New Features[Â¶](index.html#new-features_14 \"Permanent link\")\n\n* Allow plugins to catch non `ValidationError` errors by [@adriangb](https://github.com/adriangb) in [#7806](https://github.com/pydantic/pydantic/pull/7806)\n* Support `__doc__` argument in `create_model()` by [@chris-spann](https://github.com/chris-spann) in [#7863](https://github.com/pydantic/pydantic/pull/7863)\n* Expose `regex_engine` flag - meaning you can use with the Rust or Python regex libraries in constraints by [@utkini](https://github.com/utkini) in [#7768](https://github.com/pydantic/pydantic/pull/7768)\n* Save return type generated from type annotation in `ComputedFieldInfo` by [@alexmojaki](https://github.com/alexmojaki) in [#7889](https://github.com/pydantic/pydantic/pull/7889)\n* Adopting `ruff` formatter by [@Luca-Blight](https://github.com/Luca-Blight) in [#7930](https://github.com/pydantic/pydantic/pull/7930)\n* Added `validation_error_cause` to config by [@zakstucke](https://github.com/zakstucke) in [#7626](https://github.com/pydantic/pydantic/pull/7626)\n* Make path of the item to validate available in plugin by [@hramezani](https://github.com/hramezani) in [#7861](https://github.com/pydantic/pydantic/pull/7861)\n* Add `CallableDiscriminator` and `Tag` by [@dmontagu](https://github.com/dmontagu) in [#7983](https://github.com/pydantic/pydantic/pull/7983)\n  + `CallableDiscriminator` renamed to `Discriminator` by [@dmontagu](https://github.com/dmontagu) in [#8047](https://github.com/pydantic/pydantic/pull/8047)\n* Make union case tags affect union error messages by [@dmontagu](https://github.com/dmontagu) in [#8001](https://github.com/pydantic/pydantic/pull/8001)\n* Add `examples` and `json_schema_extra` to `@computed_field` by [@alexmojaki](https://github.com/alexmojaki) in [#8013](https://github.com/pydantic/pydantic/pull/8013)\n* Add `JsonValue` type by [@dmontagu](https://github.com/dmontagu) in [#7998](https://github.com/pydantic/pydantic/pull/7998)\n* Allow `str` as argument to `Discriminator` by [@dmontagu](https://github.com/dmontagu) in [#8047](https://github.com/pydantic/pydantic/pull/8047)\n* Add `SchemaSerializer.__reduce__` method to enable pickle serialization by [@edoakes](https://github.com/edoakes) in [pydantic/pydantic-core#1006](https://github.com/pydantic/pydantic-core/pull/1006)\n\n#### Changes[Â¶](index.html#changes_11 \"Permanent link\")\n\n* **Significant Change:** replace `ultra_strict` with new smart union implementation, the way unions are validated has changed significantly to improve performance and correctness, we have worked hard to absolutely minimise the number of cases where behaviour has changed, see the PR for details - by [@davidhewitt](https://github.com/davidhewitt) in [pydantic/pydantic-core#867](https://github.com/pydantic/pydantic-core/pull/867)\n* Add support for instance method reassignment when `extra='allow'` by [@sydney-runkle](https://github.com/sydney-runkle) in [#7683](https://github.com/pydantic/pydantic/pull/7683)\n* Support JSON schema generation for `Enum` types with no cases by [@sydney-runkle](https://github.com/sydney-runkle) in [#7927](https://github.com/pydantic/pydantic/pull/7927)\n* Warn if a class inherits from `Generic` before `BaseModel` by [@alexmojaki](https://github.com/alexmojaki) in [#7891](https://github.com/pydantic/pydantic/pull/7891)\n\n#### Performance[Â¶](index.html#performance_8 \"Permanent link\")", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed44-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_44 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed44-permanent-link", "md_text": "* New custom JSON parser, `jiter` by [@samuelcolvin](https://github.com/samuelcolvin) in [pydantic/pydantic-core#974](https://github.com/pydantic/pydantic-core/pull/974)\n* PGO build for MacOS M1 by [@samuelcolvin](https://github.com/samuelcolvin) in [pydantic/pydantic-core#1063](https://github.com/pydantic/pydantic-core/pull/1063)\n* Use `__getattr__` for all package imports, improve import time by [@samuelcolvin](https://github.com/samuelcolvin) in [#7947](https://github.com/pydantic/pydantic/pull/7947)\n\n#### Fixes[Â¶](index.html#fixes_44 \"Permanent link\")", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed44-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_44 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed44-permanent-link", "md_text": "* Fix `mypy` issue with subclasses of `RootModel` by [@sydney-runkle](https://github.com/sydney-runkle) in [#7677](https://github.com/pydantic/pydantic/pull/7677)\n* Properly rebuild the `FieldInfo` when a forward ref gets evaluated by [@dmontagu](https://github.com/dmontagu) in [#7698](https://github.com/pydantic/pydantic/pull/7698)\n* Fix failure to load `SecretStr` from JSON (regression in v2.4) by [@sydney-runkle](https://github.com/sydney-runkle) in [#7729](https://github.com/pydantic/pydantic/pull/7729)\n* Fix `defer_build` behavior with `TypeAdapter` by [@sydney-runkle](https://github.com/sydney-runkle) in [#7736](https://github.com/pydantic/pydantic/pull/7736)\n* Improve compatibility with legacy `mypy` versions by [@dmontagu](https://github.com/dmontagu) in [#7742](https://github.com/pydantic/pydantic/pull/7742)\n* Fix: update `TypeVar` handling when default is not set by [@pmmmwh](https://github.com/pmmmwh) in [#7719](https://github.com/pydantic/pydantic/pull/7719)\n* Support specification of `strict` on `Enum` type fields by [@sydney-runkle](https://github.com/sydney-runkle) in [#7761](https://github.com/pydantic/pydantic/pull/7761)\n* Wrap `weakref.ref` instead of subclassing to fix `cloudpickle` serialization by [@edoakes](https://github.com/edoakes) in [#7780](https://github.com/pydantic/pydantic/pull/7780)\n* Keep values of private attributes set within `model_post_init` in subclasses by [@alexmojaki](https://github.com/alexmojaki) in [#7775](https://github.com/pydantic/pydantic/pull/7775)\n* Add more specific type for non-callable `json_schema_extra` by [@alexmojaki](https://github.com/alexmojaki) in [#7803](https://github.com/pydantic/pydantic/pull/7803)\n* Raise an error when deleting frozen (model) fields by [@alexmojaki](https://github.com/alexmojaki) in [#7800](https://github.com/pydantic/pydantic/pull/7800)\n* Fix schema sorting bug with default values by [@sydney-runkle](https://github.com/sydney-runkle) in [#7817](https://github.com/pydantic/pydantic/pull/7817)\n* Use generated alias for aliases that are not specified otherwise by [@alexmojaki](https://github.com/alexmojaki) in [#7802](https://github.com/pydantic/pydantic/pull/7802)\n* Support `strict` specification for `UUID` types by [@sydney-runkle](https://github.com/sydney-runkle) in [#7865](https://github.com/pydantic/pydantic/pull/7865)\n* JSON schema: fix extra parameter handling by [@me-and](https://github.com/me-and) in [#7810](https://github.com/pydantic/pydantic/pull/7810)\n* Fix: support `pydantic.Field(kw_only=True)` with inherited dataclasses by [@PrettyWood](https://github.com/PrettyWood) in [#7827](https://github.com/pydantic/pydantic/pull/7827)\n* Support `validate_call` decorator for methods in classes with `__slots__` by [@sydney-runkle](https://github.com/sydney-runkle) in [#7883](https://github.com/pydantic/pydantic/pull/7883)\n* Fix pydantic dataclass problem with `dataclasses.field` default by [@hramezani](https://github.com/hramezani) in [#7898](https://github.com/pydantic/pydantic/pull/7898)\n* Fix schema generation for generics with union type bounds by [@sydney-runkle](https://github.com/sydney-runkle) in [#7899](https://github.com/pydantic/pydantic/pull/7899)\n* Fix version for `importlib_metadata` on python 3.7 by [@sydney-runkle](https://github.com/sydney-runkle) in [#7904](https://github.com/pydantic/pydantic/pull/7904)\n* Support `|` operator (Union) in PydanticRecursiveRef by [@alexmojaki](https://github.com/alexmojaki) in [#7892](https://github.com/pydantic/pydantic/pull/7892)\n* Fix `display_as_type` for `TypeAliasType` in python 3.12 by [@dmontagu](https://github.com/dmontagu) in [#7929](https://github.com/pydantic/pydantic/pull/7929)\n* Add support for `NotRequired` generics in `TypedDict` by [@sydney-runkle](https://github.com/sydney-runkle) in [#7932](https://github.com/pydantic/pydantic/pull/7932)\n* Make generic `TypeAliasType` specifications produce different schema definitions by [@alexdrydew](https://github.com/alexdrydew) in [#7893](https://github.com/pydantic/pydantic/pull/7893)\n* Added fix for signature of inherited dataclass by [@howsunjow](https://github.com/howsunjow) in [#7925](https://github.com/pydantic/pydantic/pull/7925)\n* Make the model name generation more robust in JSON schema by [@joakimnordling](https://github.com/joakimnordling) in [#7881](https://github.com/pydantic/pydantic/pull/7881)\n* Fix plurals in validation error messages (in tests) by [@Iipin](https://github.com/Iipin) in [#7972](https://github.com/pydantic/pydantic/pull/7972)\n* `PrivateAttr` is passed from `Annotated` default position by [@tabassco](https://github.com/tabassco) in [#8004](https://github.com/pydantic/pydantic/pull/8004)\n* Don't decode bytes (which may not be UTF8) when displaying SecretBytes by [@alexmojaki](https://github.com/alexmojaki) in [#8012](https://github.com/pydantic/pydantic/pull/8012)\n* Use `classmethod` instead of `classmethod[Any, Any, Any]` by [@Mr-Pepe](https://github.com/Mr-Pepe) in [#7979](https://github.com/pydantic/pydantic/pull/7979)\n* Clearer error on invalid Plugin by [@samuelcolvin](https://github.com/samuelcolvin) in [#8023](https://github.com/pydantic/pydantic/pull/8023)\n* Correct pydantic dataclasses import by [@samuelcolvin](https://github.com/samuelcolvin) in [#8027](https://github.com/pydantic/pydantic/pull/8027)\n* Fix misbehavior for models referencing redefined type aliases by [@dmontagu](https://github.com/dmontagu) in [#8050](https://github.com/pydantic/pydantic/pull/8050)\n* Fix `Optional` field with `validate_default` only performing one field validation by [@sydney-runkle](https://github.com/sydney-runkle) in [pydantic/pydantic-core#1002](https://github.com/pydantic/pydantic-core/pull/1002)\n* Fix `definition-ref` bug with `Dict` keys by [@sydney-runkle](https://github.com/sydney-runkle) in [pydantic/pydantic-core#1014](https://github.com/pydantic/pydantic-core/pull/1014)\n* Fix bug allowing validation of `bool` types with `coerce_numbers_to_str=True` by [@sydney-runkle](https://github.com/sydney-runkle) in [pydantic/pydantic-core#1017](https://github.com/pydantic/pydantic-core/pull/1017)\n* Don't accept `NaN` in float and decimal constraints by [@davidhewitt](https://github.com/davidhewitt) in [pydantic/pydantic-core#1037](https://github.com/pydantic/pydantic-core/pull/1037)\n* Add `lax_str` and `lax_int` support for enum values not inherited from str/int by [@michaelhly](https://github.com/michaelhly) in [pydantic/pydantic-core#1015](https://github.com/pydantic/pydantic-core/pull/1015)\n* Support subclasses in lists in `Union` of `List` types by [@sydney-runkle](https://github.com/sydney-runkle) in [pydantic/pydantic-core#1039](https://github.com/pydantic/pydantic-core/pull/1039)\n* Allow validation against `max_digits` and `decimals` to pass if normalized or non-normalized input is valid by [@sydney-runkle](https://github.com/sydney-runkle) in [pydantic/pydantic-core#1049](https://github.com/pydantic/pydantic-core/pull/1049)\n* Fix: proper pluralization in `ValidationError` messages by [@Iipin](https://github.com/Iipin) in [pydantic/pydantic-core#1050](https://github.com/pydantic/pydantic-core/pull/1050)\n* Disallow the string `'-'` as `datetime` input by [@davidhewitt](https://github.com/davidhewitt) in [pydantic/speedate#52](https://github.com/pydantic/speedate/pull/52) & [pydantic/pydantic-core#1060](https://github.com/pydantic/pydantic-core/pull/1060)\n* Fix: NaN and Inf float serialization by [@davidhewitt](https://github.com/davidhewitt) in [pydantic/pydantic-core#1062](https://github.com/pydantic/pydantic-core/pull/1062)\n* Restore manylinux-compatible PGO builds by [@davidhewitt](https://github.com/davidhewitt) in [pydantic/pydantic-core#1068](https://github.com/pydantic/pydantic-core/pull/1068)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed44-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "New Contributors[Â¶](index.html#new-contributors_17 \"Permanent link\")", "anchor": "new-contributorsindexhtmlnew-contributors17-permanent-link", "md_text": "#### `pydantic`[Â¶](index.html#pydantic_2 \"Permanent link\")\n\n* [@schneebuzz](https://github.com/schneebuzz) made their first contribution in [#7699](https://github.com/pydantic/pydantic/pull/7699)\n* [@edoakes](https://github.com/edoakes) made their first contribution in [#7780](https://github.com/pydantic/pydantic/pull/7780)\n* [@alexmojaki](https://github.com/alexmojaki) made their first contribution in [#7775](https://github.com/pydantic/pydantic/pull/7775)\n* [@NickG123](https://github.com/NickG123) made their first contribution in [#7751](https://github.com/pydantic/pydantic/pull/7751)\n* [@gowthamgts](https://github.com/gowthamgts) made their first contribution in [#7830](https://github.com/pydantic/pydantic/pull/7830)\n* [@jamesbraza](https://github.com/jamesbraza) made their first contribution in [#7848](https://github.com/pydantic/pydantic/pull/7848)\n* [@laundmo](https://github.com/laundmo) made their first contribution in [#7850](https://github.com/pydantic/pydantic/pull/7850)\n* [@rahmatnazali](https://github.com/rahmatnazali) made their first contribution in [#7870](https://github.com/pydantic/pydantic/pull/7870)\n* [@waterfountain1996](https://github.com/waterfountain1996) made their first contribution in [#7878](https://github.com/pydantic/pydantic/pull/7878)\n* [@chris-spann](https://github.com/chris-spann) made their first contribution in [#7863](https://github.com/pydantic/pydantic/pull/7863)\n* [@me-and](https://github.com/me-and) made their first contribution in [#7810](https://github.com/pydantic/pydantic/pull/7810)\n* [@utkini](https://github.com/utkini) made their first contribution in [#7768](https://github.com/pydantic/pydantic/pull/7768)\n* [@bn-l](https://github.com/bn-l) made their first contribution in [#7744](https://github.com/pydantic/pydantic/pull/7744)\n* [@alexdrydew](https://github.com/alexdrydew) made their first contribution in [#7893](https://github.com/pydantic/pydantic/pull/7893)\n* [@Luca-Blight](https://github.com/Luca-Blight) made their first contribution in [#7930](https://github.com/pydantic/pydantic/pull/7930)\n* [@howsunjow](https://github.com/howsunjow) made their first contribution in [#7925](https://github.com/pydantic/pydantic/pull/7925)\n* [@joakimnordling](https://github.com/joakimnordling) made their first contribution in [#7881](https://github.com/pydantic/pydantic/pull/7881)\n* [@icfly2](https://github.com/icfly2) made their first contribution in [#7976](https://github.com/pydantic/pydantic/pull/7976)\n* [@Yummy-Yums](https://github.com/Yummy-Yums) made their first contribution in [#8003](https://github.com/pydantic/pydantic/pull/8003)\n* [@Iipin](https://github.com/Iipin) made their first contribution in [#7972](https://github.com/pydantic/pydantic/pull/7972)\n* [@tabassco](https://github.com/tabassco) made their first contribution in [#8004](https://github.com/pydantic/pydantic/pull/8004)\n* [@Mr-Pepe](https://github.com/Mr-Pepe) made their first contribution in [#7979](https://github.com/pydantic/pydantic/pull/7979)\n* [@0x00cl](https://github.com/0x00cl) made their first contribution in [#8010](https://github.com/pydantic/pydantic/pull/8010)\n* [@barraponto](https://github.com/barraponto) made their first contribution in [#8032](https://github.com/pydantic/pydantic/pull/8032)\n\n#### `pydantic-core`[Â¶](index.html#pydantic-core_2 \"Permanent link\")\n\n* [@sisp](https://github.com/sisp) made their first contribution in [pydantic/pydantic-core#995](https://github.com/pydantic/pydantic-core/pull/995)\n* [@michaelhly](https://github.com/michaelhly) made their first contribution in [pydantic/pydantic-core#1015](https://github.com/pydantic/pydantic-core/pull/1015)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#new-contributorsindexhtmlnew-contributors17-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.5.0b1 (2023-11-09)[Â¶](index.html#v250b1-2023-11-09 \"Permanent link\")", "anchor": "v250b1-2023-11-09indexhtmlv250b1-2023-11-09-permanent-link", "md_text": "Pre-release, see [the GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.5.0b1) for details.", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v250b1-2023-11-09indexhtmlv250b1-2023-11-09-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.4.2 (2023-09-27)[Â¶](index.html#v242-2023-09-27 \"Permanent link\")", "anchor": "v242-2023-09-27indexhtmlv242-2023-09-27-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.4.2)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v242-2023-09-27indexhtmlv242-2023-09-27-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_45 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed45-permanent-link", "md_text": "#### Fixes[Â¶](index.html#fixes_45 \"Permanent link\")\n\n* Fix bug with JSON schema for sequence of discriminated union by [@dmontagu](https://github.com/dmontagu) in [#7647](https://github.com/pydantic/pydantic/pull/7647)\n* Fix schema references in discriminated unions by [@adriangb](https://github.com/adriangb) in [#7646](https://github.com/pydantic/pydantic/pull/7646)\n* Fix json schema generation for recursive models by [@adriangb](https://github.com/adriangb) in [#7653](https://github.com/pydantic/pydantic/pull/7653)\n* Fix `models_json_schema` for generic models by [@adriangb](https://github.com/adriangb) in [#7654](https://github.com/pydantic/pydantic/pull/7654)\n* Fix xfailed test for generic model signatures by [@adriangb](https://github.com/adriangb) in [#7658](https://github.com/pydantic/pydantic/pull/7658)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed45-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "New Contributors[Â¶](index.html#new-contributors_18 \"Permanent link\")", "anchor": "new-contributorsindexhtmlnew-contributors18-permanent-link", "md_text": "* [@austinorr](https://github.com/austinorr) made their first contribution in [#7657](https://github.com/pydantic/pydantic/pull/7657)\n* [@peterHoburg](https://github.com/peterHoburg) made their first contribution in [#7670](https://github.com/pydantic/pydantic/pull/7670)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#new-contributorsindexhtmlnew-contributors18-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.4.1 (2023-09-26)[Â¶](index.html#v241-2023-09-26 \"Permanent link\")", "anchor": "v241-2023-09-26indexhtmlv241-2023-09-26-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.4.1)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v241-2023-09-26indexhtmlv241-2023-09-26-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_46 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed46-permanent-link", "md_text": "#### Packaging[Â¶](index.html#packaging_29 \"Permanent link\")\n\n* Update pydantic-core to 2.10.1 by [@davidhewitt](https://github.com/davidhewitt) in [#7633](https://github.com/pydantic/pydantic/pull/7633)\n\n#### Fixes[Â¶](index.html#fixes_46 \"Permanent link\")\n\n* Serialize unsubstituted type vars as `Any` by [@adriangb](https://github.com/adriangb) in [#7606](https://github.com/pydantic/pydantic/pull/7606)\n* Remove schema building caches by [@adriangb](https://github.com/adriangb) in [#7624](https://github.com/pydantic/pydantic/pull/7624)\n* Fix an issue where JSON schema extras weren't JSON encoded by [@dmontagu](https://github.com/dmontagu) in [#7625](https://github.com/pydantic/pydantic/pull/7625)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed46-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.4.0 (2023-09-22)[Â¶](index.html#v240-2023-09-22 \"Permanent link\")", "anchor": "v240-2023-09-22indexhtmlv240-2023-09-22-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.4.0)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v240-2023-09-22indexhtmlv240-2023-09-22-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_47 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed47-permanent-link", "md_text": "#### Packaging[Â¶](index.html#packaging_30 \"Permanent link\")\n\n* Update pydantic-core to 2.10.0 by [@samuelcolvin](https://github.com/samuelcolvin) in [#7542](https://github.com/pydantic/pydantic/pull/7542)\n\n#### New Features[Â¶](index.html#new-features_15 \"Permanent link\")\n\n* Add `Base64Url` types by [@dmontagu](https://github.com/dmontagu) in [#7286](https://github.com/pydantic/pydantic/pull/7286)\n* Implement optional `number` to `str` coercion by [@lig](https://github.com/lig) in [#7508](https://github.com/pydantic/pydantic/pull/7508)\n* Allow access to `field_name` and `data` in all validators if there is data and a field name by [@samuelcolvin](https://github.com/samuelcolvin) in [#7542](https://github.com/pydantic/pydantic/pull/7542)\n* Add `BaseModel.model_validate_strings` and `TypeAdapter.validate_strings` by [@hramezani](https://github.com/hramezani) in [#7552](https://github.com/pydantic/pydantic/pull/7552)\n* Add Pydantic `plugins` experimental implementation by [@lig](https://github.com/lig) [@samuelcolvin](https://github.com/samuelcolvin) and [@Kludex](https://github.com/Kludex) in [#6820](https://github.com/pydantic/pydantic/pull/6820)\n\n#### Changes[Â¶](index.html#changes_12 \"Permanent link\")\n\n* Do not override `model_post_init` in subclass with private attrs by [@Viicos](https://github.com/Viicos) in [#7302](https://github.com/pydantic/pydantic/pull/7302)\n* Make fields with defaults not required in the serialization schema by default by [@dmontagu](https://github.com/dmontagu) in [#7275](https://github.com/pydantic/pydantic/pull/7275)\n* Mark `Extra` as deprecated by [@disrupted](https://github.com/disrupted) in [#7299](https://github.com/pydantic/pydantic/pull/7299)\n* Make `EncodedStr` a dataclass by [@Kludex](https://github.com/Kludex) in [#7396](https://github.com/pydantic/pydantic/pull/7396)\n* Move `annotated_handlers` to be public by [@samuelcolvin](https://github.com/samuelcolvin) in [#7569](https://github.com/pydantic/pydantic/pull/7569)\n\n#### Performance[Â¶](index.html#performance_9 \"Permanent link\")\n\n* Simplify flattening and inlining of `CoreSchema` by [@adriangb](https://github.com/adriangb) in [#7523](https://github.com/pydantic/pydantic/pull/7523)\n* Remove unused copies in `CoreSchema` walking by [@adriangb](https://github.com/adriangb) in [#7528](https://github.com/pydantic/pydantic/pull/7528)\n* Add caches for collecting definitions and invalid schemas from a CoreSchema by [@adriangb](https://github.com/adriangb) in [#7527](https://github.com/pydantic/pydantic/pull/7527)\n* Eagerly resolve discriminated unions and cache cases where we can't by [@adriangb](https://github.com/adriangb) in [#7529](https://github.com/pydantic/pydantic/pull/7529)\n* Replace `dict.get` and `dict.setdefault` with more verbose versions in `CoreSchema` building hot paths by [@adriangb](https://github.com/adriangb) in [#7536](https://github.com/pydantic/pydantic/pull/7536)\n* Cache invalid `CoreSchema` discovery by [@adriangb](https://github.com/adriangb) in [#7535](https://github.com/pydantic/pydantic/pull/7535)\n* Allow disabling `CoreSchema` validation for faster startup times by [@adriangb](https://github.com/adriangb) in [#7565](https://github.com/pydantic/pydantic/pull/7565)\n\n#### Fixes[Â¶](index.html#fixes_47 \"Permanent link\")", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed47-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "What's Changed[Â¶](index.html#whats-changed_47 \"Permanent link\")", "anchor": "whats-changedindexhtmlwhats-changed47-permanent-link", "md_text": "* Fix config detection for `TypedDict` from grandparent classes by [@dmontagu](https://github.com/dmontagu) in [#7272](https://github.com/pydantic/pydantic/pull/7272)\n* Fix hash function generation for frozen models with unusual MRO by [@dmontagu](https://github.com/dmontagu) in [#7274](https://github.com/pydantic/pydantic/pull/7274)\n* Make `strict` config overridable in field for Path by [@hramezani](https://github.com/hramezani) in [#7281](https://github.com/pydantic/pydantic/pull/7281)\n* Use `ser_json_<timedelta|bytes>` on default in `GenerateJsonSchema` by [@Kludex](https://github.com/Kludex) in [#7269](https://github.com/pydantic/pydantic/pull/7269)\n* Adding a check that alias is validated as an identifier for Python by [@andree0](https://github.com/andree0) in [#7319](https://github.com/pydantic/pydantic/pull/7319)\n* Raise an error when computed field overrides field by [@sydney-runkle](https://github.com/sydney-runkle) in [#7346](https://github.com/pydantic/pydantic/pull/7346)\n* Fix applying `SkipValidation` to referenced schemas by [@adriangb](https://github.com/adriangb) in [#7381](https://github.com/pydantic/pydantic/pull/7381)\n* Enforce behavior of private attributes having double leading underscore by [@lig](https://github.com/lig) in [#7265](https://github.com/pydantic/pydantic/pull/7265)\n* Standardize `__get_pydantic_core_schema__` signature by [@hramezani](https://github.com/hramezani) in [#7415](https://github.com/pydantic/pydantic/pull/7415)\n* Fix generic dataclass fields mutation bug (when using `TypeAdapter`) by [@sydney-runkle](https://github.com/sydney-runkle) in [#7435](https://github.com/pydantic/pydantic/pull/7435)\n* Fix `TypeError` on `model_validator` in `wrap` mode by [@pmmmwh](https://github.com/pmmmwh) in [#7496](https://github.com/pydantic/pydantic/pull/7496)\n* Improve enum error message by [@hramezani](https://github.com/hramezani) in [#7506](https://github.com/pydantic/pydantic/pull/7506)\n* Make `repr` work for instances that failed initialization when handling `ValidationError`s by [@dmontagu](https://github.com/dmontagu) in [#7439](https://github.com/pydantic/pydantic/pull/7439)\n* Fixed a regular expression denial of service issue by limiting whitespaces by [@prodigysml](https://github.com/prodigysml) in [#7360](https://github.com/pydantic/pydantic/pull/7360)\n* Fix handling of `UUID` values having `UUID.version=None` by [@lig](https://github.com/lig) in [#7566](https://github.com/pydantic/pydantic/pull/7566)\n* Fix `__iter__` returning private `cached_property` info by [@sydney-runkle](https://github.com/sydney-runkle) in [#7570](https://github.com/pydantic/pydantic/pull/7570)\n* Improvements to version info message by [@samuelcolvin](https://github.com/samuelcolvin) in [#7594](https://github.com/pydantic/pydantic/pull/7594)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#whats-changedindexhtmlwhats-changed47-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "New Contributors[Â¶](index.html#new-contributors_19 \"Permanent link\")", "anchor": "new-contributorsindexhtmlnew-contributors19-permanent-link", "md_text": "* [@15498th](https://github.com/15498th) made their first contribution in [#7238](https://github.com/pydantic/pydantic/pull/7238)\n* [@GabrielCappelli](https://github.com/GabrielCappelli) made their first contribution in [#7213](https://github.com/pydantic/pydantic/pull/7213)\n* [@tobni](https://github.com/tobni) made their first contribution in [#7184](https://github.com/pydantic/pydantic/pull/7184)\n* [@redruin1](https://github.com/redruin1) made their first contribution in [#7282](https://github.com/pydantic/pydantic/pull/7282)\n* [@FacerAin](https://github.com/FacerAin) made their first contribution in [#7288](https://github.com/pydantic/pydantic/pull/7288)\n* [@acdha](https://github.com/acdha) made their first contribution in [#7297](https://github.com/pydantic/pydantic/pull/7297)\n* [@andree0](https://github.com/andree0) made their first contribution in [#7319](https://github.com/pydantic/pydantic/pull/7319)\n* [@gordonhart](https://github.com/gordonhart) made their first contribution in [#7375](https://github.com/pydantic/pydantic/pull/7375)\n* [@pmmmwh](https://github.com/pmmmwh) made their first contribution in [#7496](https://github.com/pydantic/pydantic/pull/7496)\n* [@disrupted](https://github.com/disrupted) made their first contribution in [#7299](https://github.com/pydantic/pydantic/pull/7299)\n* [@prodigysml](https://github.com/prodigysml) made their first contribution in [#7360](https://github.com/pydantic/pydantic/pull/7360)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#new-contributorsindexhtmlnew-contributors19-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.3.0 (2023-08-23)[Â¶](index.html#v230-2023-08-23 \"Permanent link\")", "anchor": "v230-2023-08-23indexhtmlv230-2023-08-23-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.3.0)\n\n* ðŸ”¥ Remove orphaned changes file from repo by [@lig](https://github.com/lig) in [#7168](https://github.com/pydantic/pydantic/pull/7168)\n* Add copy button on documentation by [@Kludex](https://github.com/Kludex) in [#7190](https://github.com/pydantic/pydantic/pull/7190)\n* Fix docs on JSON type by [@Kludex](https://github.com/Kludex) in [#7189](https://github.com/pydantic/pydantic/pull/7189)\n* Update mypy 1.5.0 to 1.5.1 in CI by [@hramezani](https://github.com/hramezani) in [#7191](https://github.com/pydantic/pydantic/pull/7191)\n* fix download links badge by [@samuelcolvin](https://github.com/samuelcolvin) in [#7200](https://github.com/pydantic/pydantic/pull/7200)\n* add 2.2.1 to changelog by [@samuelcolvin](https://github.com/samuelcolvin) in [#7212](https://github.com/pydantic/pydantic/pull/7212)\n* Make ModelWrapValidator protocols generic by [@dmontagu](https://github.com/dmontagu) in [#7154](https://github.com/pydantic/pydantic/pull/7154)\n* Correct `Field(..., exclude: bool)` docs by [@samuelcolvin](https://github.com/samuelcolvin) in [#7214](https://github.com/pydantic/pydantic/pull/7214)\n* Make shadowing attributes a warning instead of an error by [@adriangb](https://github.com/adriangb) in [#7193](https://github.com/pydantic/pydantic/pull/7193)\n* Document `Base64Str` and `Base64Bytes` by [@Kludex](https://github.com/Kludex) in [#7192](https://github.com/pydantic/pydantic/pull/7192)\n* Fix `config.defer_build` for serialization first cases by [@samuelcolvin](https://github.com/samuelcolvin) in [#7024](https://github.com/pydantic/pydantic/pull/7024)\n* clean Model docstrings in JSON Schema by [@samuelcolvin](https://github.com/samuelcolvin) in [#7210](https://github.com/pydantic/pydantic/pull/7210)\n* fix [#7228](https://github.com/pydantic/pydantic/pull/7228) (typo): docs in `validators.md` to correct `validate_default` kwarg by [@lmmx](https://github.com/lmmx) in [#7229](https://github.com/pydantic/pydantic/pull/7229)\n* âœ… Implement `tzinfo.fromutc` method for `TzInfo` in `pydantic-core` by [@lig](https://github.com/lig) in [#7019](https://github.com/pydantic/pydantic/pull/7019)\n* Support `__get_validators__` by [@hramezani](https://github.com/hramezani) in [#7197](https://github.com/pydantic/pydantic/pull/7197)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v230-2023-08-23indexhtmlv230-2023-08-23-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.2.1 (2023-08-18)[Â¶](index.html#v221-2023-08-18 \"Permanent link\")", "anchor": "v221-2023-08-18indexhtmlv221-2023-08-18-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.2.1)\n\n* Make `xfail`ing test for root model extra stop `xfail`ing by [@dmontagu](https://github.com/dmontagu) in [#6937](https://github.com/pydantic/pydantic/pull/6937)\n* Optimize recursion detection by stopping on the second visit for the same object by [@mciucu](https://github.com/mciucu) in [#7160](https://github.com/pydantic/pydantic/pull/7160)\n* fix link in docs by [@tlambert03](https://github.com/tlambert03) in [#7166](https://github.com/pydantic/pydantic/pull/7166)\n* Replace MiMalloc w/ default allocator by [@adriangb](https://github.com/adriangb) in [pydantic/pydantic-core#900](https://github.com/pydantic/pydantic-core/pull/900)\n* Bump pydantic-core to 2.6.1 and prepare 2.2.1 release by [@adriangb](https://github.com/adriangb) in [#7176](https://github.com/pydantic/pydantic/pull/7176)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v221-2023-08-18indexhtmlv221-2023-08-18-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.2.0 (2023-08-17)[Â¶](index.html#v220-2023-08-17 \"Permanent link\")", "anchor": "v220-2023-08-17indexhtmlv220-2023-08-17-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.2.0)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v220-2023-08-17indexhtmlv220-2023-08-17-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.2.0 (2023-08-17)[Â¶](index.html#v220-2023-08-17 \"Permanent link\")", "anchor": "v220-2023-08-17indexhtmlv220-2023-08-17-permanent-link", "md_text": "* Split \"pipx install\" setup command into two commands on the documentation site by [@nomadmtb](https://github.com/nomadmtb) in [#6869](https://github.com/pydantic/pydantic/pull/6869)\n* Deprecate `Field.include` by [@hramezani](https://github.com/hramezani) in [#6852](https://github.com/pydantic/pydantic/pull/6852)\n* Fix typo in default factory error msg by [@hramezani](https://github.com/hramezani) in [#6880](https://github.com/pydantic/pydantic/pull/6880)\n* Simplify handling of typing.Annotated in GenerateSchema by [@dmontagu](https://github.com/dmontagu) in [#6887](https://github.com/pydantic/pydantic/pull/6887)\n* Re-enable fastapi tests in CI by [@dmontagu](https://github.com/dmontagu) in [#6883](https://github.com/pydantic/pydantic/pull/6883)\n* Make it harder to hit collisions with json schema defrefs by [@dmontagu](https://github.com/dmontagu) in [#6566](https://github.com/pydantic/pydantic/pull/6566)\n* Cleaner error for invalid input to `Path` fields by [@samuelcolvin](https://github.com/samuelcolvin) in [#6903](https://github.com/pydantic/pydantic/pull/6903)\n* ![ðŸ“](https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.1.0/assets/svg/1f4dd.svg \":memo:\") support Coordinate Type by [@yezz123](https://github.com/yezz123) in [#6906](https://github.com/pydantic/pydantic/pull/6906)\n* Fix `ForwardRef` wrapper for py 3.10.0 (shim until bpo-45166) by [@randomir](https://github.com/randomir) in [#6919](https://github.com/pydantic/pydantic/pull/6919)\n* Fix misbehavior related to copying of RootModel by [@dmontagu](https://github.com/dmontagu) in [#6918](https://github.com/pydantic/pydantic/pull/6918)\n* Fix issue with recursion error caused by ParamSpec by [@dmontagu](https://github.com/dmontagu) in [#6923](https://github.com/pydantic/pydantic/pull/6923)\n* Add section about Constrained classes to the Migration Guide by [@Kludex](https://github.com/Kludex) in [#6924](https://github.com/pydantic/pydantic/pull/6924)\n* Use `main` branch for badge links by [@Viicos](https://github.com/Viicos) in [#6925](https://github.com/pydantic/pydantic/pull/6925)\n* Add test for v1/v2 Annotated discrepancy by [@carlbordum](https://github.com/carlbordum) in [#6926](https://github.com/pydantic/pydantic/pull/6926)\n* Make the v1 mypy plugin work with both v1 and v2 by [@dmontagu](https://github.com/dmontagu) in [#6921](https://github.com/pydantic/pydantic/pull/6921)\n* Fix issue where generic models couldn't be parametrized with BaseModel by [@dmontagu](https://github.com/dmontagu) in [#6933](https://github.com/pydantic/pydantic/pull/6933)\n* Remove xfail for discriminated union with alias by [@dmontagu](https://github.com/dmontagu) in [#6938](https://github.com/pydantic/pydantic/pull/6938)\n* add field\\_serializer to computed\\_field by [@andresliszt](https://github.com/andresliszt) in [#6965](https://github.com/pydantic/pydantic/pull/6965)\n* Use union\\_schema with Type[Union[...]] by [@JeanArhancet](https://github.com/JeanArhancet) in [#6952](https://github.com/pydantic/pydantic/pull/6952)\n* Fix inherited typeddict attributes / config by [@adriangb](https://github.com/adriangb) in [#6981](https://github.com/pydantic/pydantic/pull/6981)\n* fix dataclass annotated before validator called twice by [@davidhewitt](https://github.com/davidhewitt) in [#6998](https://github.com/pydantic/pydantic/pull/6998)\n* Update test-fastapi deselected tests by [@hramezani](https://github.com/hramezani) in [#7014](https://github.com/pydantic/pydantic/pull/7014)\n* Fix validator doc format by [@hramezani](https://github.com/hramezani) in [#7015](https://github.com/pydantic/pydantic/pull/7015)\n* Fix typo in docstring of model\\_json\\_schema by [@AdamVinch-Federated](https://github.com/AdamVinch-Federated) in [#7032](https://github.com/pydantic/pydantic/pull/7032)\n* remove unused \"type ignores\" with pyright by [@samuelcolvin](https://github.com/samuelcolvin) in [#7026](https://github.com/pydantic/pydantic/pull/7026)\n* Add benchmark representing FastAPI startup time by [@adriangb](https://github.com/adriangb) in [#7030](https://github.com/pydantic/pydantic/pull/7030)\n* Fix json\\_encoders for Enum subclasses by [@adriangb](https://github.com/adriangb) in [#7029](https://github.com/pydantic/pydantic/pull/7029)\n* Update docstring of `ser_json_bytes` regarding base64 encoding by [@Viicos](https://github.com/Viicos) in [#7052](https://github.com/pydantic/pydantic/pull/7052)\n* Allow `@validate_call` to work on async methods by [@adriangb](https://github.com/adriangb) in [#7046](https://github.com/pydantic/pydantic/pull/7046)\n* Fix: mypy error with `Settings` and `SettingsConfigDict` by [@JeanArhancet](https://github.com/JeanArhancet) in [#7002](https://github.com/pydantic/pydantic/pull/7002)\n* Fix some typos (repeated words and it's/its) by [@eumiro](https://github.com/eumiro) in [#7063](https://github.com/pydantic/pydantic/pull/7063)\n* Fix the typo in docstring by [@harunyasar](https://github.com/harunyasar) in [#7062](https://github.com/pydantic/pydantic/pull/7062)\n* Docs: Fix broken URL in the pydantic-settings package recommendation by [@swetjen](https://github.com/swetjen) in [#6995](https://github.com/pydantic/pydantic/pull/6995)\n* Handle constraints being applied to schemas that don't accept it by [@adriangb](https://github.com/adriangb) in [#6951](https://github.com/pydantic/pydantic/pull/6951)\n* Replace almost\\_equal\\_floats with math.isclose by [@eumiro](https://github.com/eumiro) in [#7082](https://github.com/pydantic/pydantic/pull/7082)\n* bump pydantic-core to 2.5.0 by [@davidhewitt](https://github.com/davidhewitt) in [#7077](https://github.com/pydantic/pydantic/pull/7077)\n* Add `short_version` and use it in links by [@hramezani](https://github.com/hramezani) in [#7115](https://github.com/pydantic/pydantic/pull/7115)\n* ðŸ“ Add usage link to `RootModel` by [@Kludex](https://github.com/Kludex) in [#7113](https://github.com/pydantic/pydantic/pull/7113)\n* Revert \"Fix default port for mongosrv DSNs (#6827)\" by [@Kludex](https://github.com/Kludex) in [#7116](https://github.com/pydantic/pydantic/pull/7116)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v220-2023-08-17indexhtmlv220-2023-08-17-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.2.0 (2023-08-17)[Â¶](index.html#v220-2023-08-17 \"Permanent link\")", "anchor": "v220-2023-08-17indexhtmlv220-2023-08-17-permanent-link", "md_text": "* Clarify validate\\_default and \\_Unset handling in usage docs and migration guide by [@benbenbang](https://github.com/benbenbang) in [#6950](https://github.com/pydantic/pydantic/pull/6950)\n* Tweak documentation of `Field.exclude` by [@Viicos](https://github.com/Viicos) in [#7086](https://github.com/pydantic/pydantic/pull/7086)\n* Do not require `validate_assignment` to use `Field.frozen` by [@Viicos](https://github.com/Viicos) in [#7103](https://github.com/pydantic/pydantic/pull/7103)\n* tweaks to `_core_utils` by [@samuelcolvin](https://github.com/samuelcolvin) in [#7040](https://github.com/pydantic/pydantic/pull/7040)\n* Make DefaultDict working with set by [@hramezani](https://github.com/hramezani) in [#7126](https://github.com/pydantic/pydantic/pull/7126)\n* Don't always require typing.Generic as a base for partially parametrized models by [@dmontagu](https://github.com/dmontagu) in [#7119](https://github.com/pydantic/pydantic/pull/7119)\n* Fix issue with JSON schema incorrectly using parent class core schema by [@dmontagu](https://github.com/dmontagu) in [#7020](https://github.com/pydantic/pydantic/pull/7020)\n* Fix xfailed test related to TypedDict and alias\\_generator by [@dmontagu](https://github.com/dmontagu) in [#6940](https://github.com/pydantic/pydantic/pull/6940)\n* Improve error message for NameEmail by [@dmontagu](https://github.com/dmontagu) in [#6939](https://github.com/pydantic/pydantic/pull/6939)\n* Fix generic computed fields by [@dmontagu](https://github.com/dmontagu) in [#6988](https://github.com/pydantic/pydantic/pull/6988)\n* Reflect namedtuple default values during validation by [@dmontagu](https://github.com/dmontagu) in [#7144](https://github.com/pydantic/pydantic/pull/7144)\n* Update dependencies, fix pydantic-core usage, fix CI issues by [@dmontagu](https://github.com/dmontagu) in [#7150](https://github.com/pydantic/pydantic/pull/7150)\n* Add mypy 1.5.0 by [@hramezani](https://github.com/hramezani) in [#7118](https://github.com/pydantic/pydantic/pull/7118)\n* Handle non-json native enum values by [@adriangb](https://github.com/adriangb) in [#7056](https://github.com/pydantic/pydantic/pull/7056)\n* document `round_trip` in Json type documentation by [@jc-louis](https://github.com/jc-louis) in [#7137](https://github.com/pydantic/pydantic/pull/7137)\n* Relax signature checks to better support builtins and C extension functions as validators by [@adriangb](https://github.com/adriangb) in [#7101](https://github.com/pydantic/pydantic/pull/7101)\n* add union\\_mode='left\\_to\\_right' by [@davidhewitt](https://github.com/davidhewitt) in [#7151](https://github.com/pydantic/pydantic/pull/7151)\n* Include an error message hint for inherited ordering by [@yvalencia91](https://github.com/yvalencia91) in [#7124](https://github.com/pydantic/pydantic/pull/7124)\n* Fix one docs link and resolve some warnings for two others by [@dmontagu](https://github.com/dmontagu) in [#7153](https://github.com/pydantic/pydantic/pull/7153)\n* Include Field extra keys name in warning by [@hramezani](https://github.com/hramezani) in [#7136](https://github.com/pydantic/pydantic/pull/7136)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v220-2023-08-17indexhtmlv220-2023-08-17-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.1.1 (2023-07-25)[Â¶](index.html#v211-2023-07-25 \"Permanent link\")", "anchor": "v211-2023-07-25indexhtmlv211-2023-07-25-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.1.1)\n\n* Skip FieldInfo merging when unnecessary by [@dmontagu](https://github.com/dmontagu) in [#6862](https://github.com/pydantic/pydantic/pull/6862)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v211-2023-07-25indexhtmlv211-2023-07-25-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.1.0 (2023-07-25)[Â¶](index.html#v210-2023-07-25 \"Permanent link\")", "anchor": "v210-2023-07-25indexhtmlv210-2023-07-25-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.1.0)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v210-2023-07-25indexhtmlv210-2023-07-25-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.1.0 (2023-07-25)[Â¶](index.html#v210-2023-07-25 \"Permanent link\")", "anchor": "v210-2023-07-25indexhtmlv210-2023-07-25-permanent-link", "md_text": "* Add `StringConstraints` for use as Annotated metadata by [@adriangb](https://github.com/adriangb) in [#6605](https://github.com/pydantic/pydantic/pull/6605)\n* Try to fix intermittently failing CI by [@adriangb](https://github.com/adriangb) in [#6683](https://github.com/pydantic/pydantic/pull/6683)\n* Remove redundant example of optional vs default. by [@ehiggs-deliverect](https://github.com/ehiggs-deliverect) in [#6676](https://github.com/pydantic/pydantic/pull/6676)\n* Docs update by [@samuelcolvin](https://github.com/samuelcolvin) in [#6692](https://github.com/pydantic/pydantic/pull/6692)\n* Remove the Validate always section in validator docs by [@adriangb](https://github.com/adriangb) in [#6679](https://github.com/pydantic/pydantic/pull/6679)\n* Fix recursion error in json schema generation by [@adriangb](https://github.com/adriangb) in [#6720](https://github.com/pydantic/pydantic/pull/6720)\n* Fix incorrect subclass check for secretstr by [@AlexVndnblcke](https://github.com/AlexVndnblcke) in [#6730](https://github.com/pydantic/pydantic/pull/6730)\n* update pdm / pdm lockfile to 2.8.0 by [@davidhewitt](https://github.com/davidhewitt) in [#6714](https://github.com/pydantic/pydantic/pull/6714)\n* unpin pdm on more CI jobs by [@davidhewitt](https://github.com/davidhewitt) in [#6755](https://github.com/pydantic/pydantic/pull/6755)\n* improve source locations for auxiliary packages in docs by [@davidhewitt](https://github.com/davidhewitt) in [#6749](https://github.com/pydantic/pydantic/pull/6749)\n* Assume builtins don't accept an info argument by [@adriangb](https://github.com/adriangb) in [#6754](https://github.com/pydantic/pydantic/pull/6754)\n* Fix bug where calling `help(BaseModelSubclass)` raises errors by [@hramezani](https://github.com/hramezani) in [#6758](https://github.com/pydantic/pydantic/pull/6758)\n* Fix mypy plugin handling of `@model_validator(mode=\"after\")` by [@ljodal](https://github.com/ljodal) in [#6753](https://github.com/pydantic/pydantic/pull/6753)\n* update pydantic-core to 2.3.1 by [@davidhewitt](https://github.com/davidhewitt) in [#6756](https://github.com/pydantic/pydantic/pull/6756)\n* Mypy plugin for settings by [@hramezani](https://github.com/hramezani) in [#6760](https://github.com/pydantic/pydantic/pull/6760)\n* Use `contentSchema` keyword for JSON schema by [@dmontagu](https://github.com/dmontagu) in [#6715](https://github.com/pydantic/pydantic/pull/6715)\n* fast-path checking finite decimals by [@davidhewitt](https://github.com/davidhewitt) in [#6769](https://github.com/pydantic/pydantic/pull/6769)\n* Docs update by [@samuelcolvin](https://github.com/samuelcolvin) in [#6771](https://github.com/pydantic/pydantic/pull/6771)\n* Improve json schema doc by [@hramezani](https://github.com/hramezani) in [#6772](https://github.com/pydantic/pydantic/pull/6772)\n* Update validator docs by [@adriangb](https://github.com/adriangb) in [#6695](https://github.com/pydantic/pydantic/pull/6695)\n* Fix typehint for wrap validator by [@dmontagu](https://github.com/dmontagu) in [#6788](https://github.com/pydantic/pydantic/pull/6788)\n* ðŸ› Fix validation warning for unions of Literal and other type by [@lig](https://github.com/lig) in [#6628](https://github.com/pydantic/pydantic/pull/6628)\n* Update documentation for generics support in V2 by [@tpdorsey](https://github.com/tpdorsey) in [#6685](https://github.com/pydantic/pydantic/pull/6685)\n* add pydantic-core build info to `version_info()` by [@samuelcolvin](https://github.com/samuelcolvin) in [#6785](https://github.com/pydantic/pydantic/pull/6785)\n* Fix pydantic dataclasses that use slots with default values by [@dmontagu](https://github.com/dmontagu) in [#6796](https://github.com/pydantic/pydantic/pull/6796)\n* Fix inheritance of hash function for frozen models by [@dmontagu](https://github.com/dmontagu) in [#6789](https://github.com/pydantic/pydantic/pull/6789)\n* âœ¨ Add `SkipJsonSchema` annotation by [@Kludex](https://github.com/Kludex) in [#6653](https://github.com/pydantic/pydantic/pull/6653)\n* Error if an invalid field name is used with Field by [@dmontagu](https://github.com/dmontagu) in [#6797](https://github.com/pydantic/pydantic/pull/6797)\n* Add `GenericModel` to `MOVED_IN_V2` by [@adriangb](https://github.com/adriangb) in [#6776](https://github.com/pydantic/pydantic/pull/6776)\n* Remove unused code from `docs/usage/types/custom.md` by [@hramezani](https://github.com/hramezani) in [#6803](https://github.com/pydantic/pydantic/pull/6803)\n* Fix `float` -> `Decimal` coercion precision loss by [@adriangb](https://github.com/adriangb) in [#6810](https://github.com/pydantic/pydantic/pull/6810)\n* remove email validation from the north star benchmark by [@davidhewitt](https://github.com/davidhewitt) in [#6816](https://github.com/pydantic/pydantic/pull/6816)\n* Fix link to mypy by [@progsmile](https://github.com/progsmile) in [#6824](https://github.com/pydantic/pydantic/pull/6824)\n* Improve initialization hooks example by [@hramezani](https://github.com/hramezani) in [#6822](https://github.com/pydantic/pydantic/pull/6822)\n* Fix default port for mongosrv DSNs by [@dmontagu](https://github.com/dmontagu) in [#6827](https://github.com/pydantic/pydantic/pull/6827)\n* Improve API documentation, in particular more links between usage and API docs by [@samuelcolvin](https://github.com/samuelcolvin) in [#6780](https://github.com/pydantic/pydantic/pull/6780)\n* update pydantic-core to 2.4.0 by [@davidhewitt](https://github.com/davidhewitt) in [#6831](https://github.com/pydantic/pydantic/pull/6831)\n* Fix `annotated_types.MaxLen` validator for custom sequence types by [@ImogenBits](https://github.com/ImogenBits) in [#6809](https://github.com/pydantic/pydantic/pull/6809)\n* Update V1 by [@hramezani](https://github.com/hramezani) in [#6833](https://github.com/pydantic/pydantic/pull/6833)\n* Make it so callable JSON schema extra works by [@dmontagu](https://github.com/dmontagu) in [#6798](https://github.com/pydantic/pydantic/pull/6798)\n* Fix serialization issue with `InstanceOf` by [@dmontagu](https://github.com/dmontagu) in [#6829](https://github.com/pydantic/pydantic/pull/6829)\n* Add back support for `json_encoders` by [@adriangb](https://github.com/adriangb) in [#6811](https://github.com/pydantic/pydantic/pull/6811)\n* Update field annotations when building the schema by [@dmontagu](https://github.com/dmontagu) in [#6838](https://github.com/pydantic/pydantic/pull/6838)\n* Use `WeakValueDictionary` to fix generic memory leak by [@dmontagu](https://github.com/dmontagu) in [#6681](https://github.com/pydantic/pydantic/pull/6681)\n* Add `config.defer_build` to optionally make model building lazy by [@samuelcolvin](https://github.com/samuelcolvin) in [#6823](https://github.com/pydantic/pydantic/pull/6823)\n* delegate `UUID` serialization to pydantic-core by [@davidhewitt](https://github.com/davidhewitt) in [#6850](https://github.com/pydantic/pydantic/pull/6850)\n* Update `json_encoders` docs by [@adriangb](https://github.com/adriangb) in [#6848](https://github.com/pydantic/pydantic/pull/6848)\n* Fix error message for `staticmethod`/`classmethod` order with validate\\_call by [@dmontagu](https://github.com/dmontagu) in [#6686](https://github.com/pydantic/pydantic/pull/6686)\n* Improve documentation for `Config` by [@samuelcolvin](https://github.com/samuelcolvin) in [#6847](https://github.com/pydantic/pydantic/pull/6847)\n* Update serialization doc to mention `Field.exclude` takes priority over call-time `include/exclude` by [@hramezani](https://github.com/hramezani) in [#6851](https://github.com/pydantic/pydantic/pull/6851)\n* Allow customizing core schema generation by making `GenerateSchema` public by [@adriangb](https://github.com/adriangb) in [#6737](https://github.com/pydantic/pydantic/pull/6737)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v210-2023-07-25indexhtmlv210-2023-07-25-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.0.3 (2023-07-05)[Â¶](index.html#v203-2023-07-05 \"Permanent link\")", "anchor": "v203-2023-07-05indexhtmlv203-2023-07-05-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.0.3)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v203-2023-07-05indexhtmlv203-2023-07-05-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.0.3 (2023-07-05)[Â¶](index.html#v203-2023-07-05 \"Permanent link\")", "anchor": "v203-2023-07-05indexhtmlv203-2023-07-05-permanent-link", "md_text": "* Mention PyObject (v1) moving to ImportString (v2) in migration doc by [@slafs](https://github.com/slafs) in [#6456](https://github.com/pydantic/pydantic/pull/6456)\n* Fix release-tweet CI by [@Kludex](https://github.com/Kludex) in [#6461](https://github.com/pydantic/pydantic/pull/6461)\n* Revise the section on required / optional / nullable fields. by [@ybressler](https://github.com/ybressler) in [#6468](https://github.com/pydantic/pydantic/pull/6468)\n* Warn if a type hint is not in fact a type by [@adriangb](https://github.com/adriangb) in [#6479](https://github.com/pydantic/pydantic/pull/6479)\n* Replace TransformSchema with GetPydanticSchema by [@dmontagu](https://github.com/dmontagu) in [#6484](https://github.com/pydantic/pydantic/pull/6484)\n* Fix the un-hashability of various annotation types, for use in caching generic containers by [@dmontagu](https://github.com/dmontagu) in [#6480](https://github.com/pydantic/pydantic/pull/6480)\n* PYD-164: Rework custom types docs by [@adriangb](https://github.com/adriangb) in [#6490](https://github.com/pydantic/pydantic/pull/6490)\n* Fix ci by [@adriangb](https://github.com/adriangb) in [#6507](https://github.com/pydantic/pydantic/pull/6507)\n* Fix forward ref in generic by [@adriangb](https://github.com/adriangb) in [#6511](https://github.com/pydantic/pydantic/pull/6511)\n* Fix generation of serialization JSON schemas for core\\_schema.ChainSchema by [@dmontagu](https://github.com/dmontagu) in [#6515](https://github.com/pydantic/pydantic/pull/6515)\n* Document the change in `Field.alias` behavior in Pydantic V2 by [@hramezani](https://github.com/hramezani) in [#6508](https://github.com/pydantic/pydantic/pull/6508)\n* Give better error message attempting to compute the json schema of a model with undefined fields by [@dmontagu](https://github.com/dmontagu) in [#6519](https://github.com/pydantic/pydantic/pull/6519)\n* Document `alias_priority` by [@tpdorsey](https://github.com/tpdorsey) in [#6520](https://github.com/pydantic/pydantic/pull/6520)\n* Add redirect for types documentation by [@tpdorsey](https://github.com/tpdorsey) in [#6513](https://github.com/pydantic/pydantic/pull/6513)\n* Allow updating docs without release by [@samuelcolvin](https://github.com/samuelcolvin) in [#6551](https://github.com/pydantic/pydantic/pull/6551)\n* Ensure docs tests always run in the right folder by [@dmontagu](https://github.com/dmontagu) in [#6487](https://github.com/pydantic/pydantic/pull/6487)\n* Defer evaluation of return type hints for serializer functions by [@dmontagu](https://github.com/dmontagu) in [#6516](https://github.com/pydantic/pydantic/pull/6516)\n* Disable E501 from Ruff and rely on just Black by [@adriangb](https://github.com/adriangb) in [#6552](https://github.com/pydantic/pydantic/pull/6552)\n* Update JSON Schema documentation for V2 by [@tpdorsey](https://github.com/tpdorsey) in [#6492](https://github.com/pydantic/pydantic/pull/6492)\n* Add documentation of cyclic reference handling by [@dmontagu](https://github.com/dmontagu) in [#6493](https://github.com/pydantic/pydantic/pull/6493)\n* Remove the need for change files by [@samuelcolvin](https://github.com/samuelcolvin) in [#6556](https://github.com/pydantic/pydantic/pull/6556)\n* add \"north star\" benchmark by [@davidhewitt](https://github.com/davidhewitt) in [#6547](https://github.com/pydantic/pydantic/pull/6547)\n* Update Dataclasses docs by [@tpdorsey](https://github.com/tpdorsey) in [#6470](https://github.com/pydantic/pydantic/pull/6470)\n* â™»ï¸ Use different error message on v1 redirects by [@Kludex](https://github.com/Kludex) in [#6595](https://github.com/pydantic/pydantic/pull/6595)\n* â¬† Upgrade `pydantic-core` to v2.2.0 by [@lig](https://github.com/lig) in [#6589](https://github.com/pydantic/pydantic/pull/6589)\n* Fix serialization for IPvAny by [@dmontagu](https://github.com/dmontagu) in [#6572](https://github.com/pydantic/pydantic/pull/6572)\n* Improve CI by using PDM instead of pip to install typing-extensions by [@adriangb](https://github.com/adriangb) in [#6602](https://github.com/pydantic/pydantic/pull/6602)\n* Add `enum` error type docs by [@lig](https://github.com/lig) in [#6603](https://github.com/pydantic/pydantic/pull/6603)\n* ðŸ› Fix `max_length` for unicode strings by [@lig](https://github.com/lig) in [#6559](https://github.com/pydantic/pydantic/pull/6559)\n* Add documentation for accessing features via `pydantic.v1` by [@tpdorsey](https://github.com/tpdorsey) in [#6604](https://github.com/pydantic/pydantic/pull/6604)\n* Include extra when iterating over a model by [@adriangb](https://github.com/adriangb) in [#6562](https://github.com/pydantic/pydantic/pull/6562)\n* Fix typing of model\\_validator by [@adriangb](https://github.com/adriangb) in [#6514](https://github.com/pydantic/pydantic/pull/6514)\n* Touch up Decimal validator by [@adriangb](https://github.com/adriangb) in [#6327](https://github.com/pydantic/pydantic/pull/6327)\n* Fix various docstrings using fixed pytest-examples by [@dmontagu](https://github.com/dmontagu) in [#6607](https://github.com/pydantic/pydantic/pull/6607)\n* Handle function validators in a discriminated union by [@dmontagu](https://github.com/dmontagu) in [#6570](https://github.com/pydantic/pydantic/pull/6570)\n* Review json\\_schema.md by [@tpdorsey](https://github.com/tpdorsey) in [#6608](https://github.com/pydantic/pydantic/pull/6608)\n* Make validate\\_call work on basemodel methods by [@dmontagu](https://github.com/dmontagu) in [#6569](https://github.com/pydantic/pydantic/pull/6569)\n* add test for big int json serde by [@davidhewitt](https://github.com/davidhewitt) in [#6614](https://github.com/pydantic/pydantic/pull/6614)\n* Fix pydantic dataclass problem with dataclasses.field default\\_factory by [@hramezani](https://github.com/hramezani) in [#6616](https://github.com/pydantic/pydantic/pull/6616)\n* Fixed mypy type inference for TypeAdapter by [@zakstucke](https://github.com/zakstucke) in [#6617](https://github.com/pydantic/pydantic/pull/6617)\n* Make it work to use None as a generic parameter by [@dmontagu](https://github.com/dmontagu) in [#6609](https://github.com/pydantic/pydantic/pull/6609)\n* Make it work to use `$ref` as an alias by [@dmontagu](https://github.com/dmontagu) in [#6568](https://github.com/pydantic/pydantic/pull/6568)\n* add note to migration guide about changes to `AnyUrl` etc by [@davidhewitt](https://github.com/davidhewitt) in [#6618](https://github.com/pydantic/pydantic/pull/6618)\n* ðŸ› Support defining `json_schema_extra` on `RootModel` using `Field` by [@lig](https://github.com/lig) in [#6622](https://github.com/pydantic/pydantic/pull/6622)\n* Update pre-commit to prevent commits to main branch on accident by [@dmontagu](https://github.com/dmontagu) in [#6636](https://github.com/pydantic/pydantic/pull/6636)\n* Fix PDM CI for python 3.7 on MacOS/windows by [@dmontagu](https://github.com/dmontagu) in [#6627](https://github.com/pydantic/pydantic/pull/6627)\n* Produce more accurate signatures for pydantic dataclasses by [@dmontagu](https://github.com/dmontagu) in [#6633](https://github.com/pydantic/pydantic/pull/6633)\n* Updates to Url types for Pydantic V2 by [@tpdorsey](https://github.com/tpdorsey) in [#6638](https://github.com/pydantic/pydantic/pull/6638)\n* Fix list markdown in `transform` docstring by [@StefanBRas](https://github.com/StefanBRas) in [#6649](https://github.com/pydantic/pydantic/pull/6649)\n* simplify slots\\_dataclass construction to appease mypy by [@davidhewitt](https://github.com/davidhewitt) in [#6639](https://github.com/pydantic/pydantic/pull/6639)\n* Update TypedDict schema generation docstring by [@adriangb](https://github.com/adriangb) in [#6651](https://github.com/pydantic/pydantic/pull/6651)\n* Detect and lint-error for prints by [@dmontagu](https://github.com/dmontagu) in [#6655](https://github.com/pydantic/pydantic/pull/6655)\n* Add xfailing test for pydantic-core PR 766 by [@dmontagu](https://github.com/dmontagu) in [#6641](https://github.com/pydantic/pydantic/pull/6641)\n* Ignore unrecognized fields from dataclasses metadata by [@dmontagu](https://github.com/dmontagu) in [#6634](https://github.com/pydantic/pydantic/pull/6634)\n* Make non-existent class getattr a mypy error by [@dmontagu](https://github.com/dmontagu) in [#6658](https://github.com/pydantic/pydantic/pull/6658)\n* Update pydantic-core to 2.3.0 by [@hramezani](https://github.com/hramezani) in [#6648](https://github.com/pydantic/pydantic/pull/6648)\n* Use OrderedDict from typing\\_extensions by [@dmontagu](https://github.com/dmontagu) in [#6664](https://github.com/pydantic/pydantic/pull/6664)\n* Fix typehint for JSON schema extra callable by [@dmontagu](https://github.com/dmontagu) in [#6659](https://github.com/pydantic/pydantic/pull/6659)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v203-2023-07-05indexhtmlv203-2023-07-05-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.0.2 (2023-07-05)[Â¶](index.html#v202-2023-07-05 \"Permanent link\")", "anchor": "v202-2023-07-05indexhtmlv202-2023-07-05-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.0.2)\n\n* Fix bug where round-trip pickling/unpickling a `RootModel` would change the value of `__dict__`, [#6457](https://github.com/pydantic/pydantic/pull/6457) by [@dmontagu](https://github.com/dmontagu)\n* Allow single-item discriminated unions, [#6405](https://github.com/pydantic/pydantic/pull/6405) by [@dmontagu](https://github.com/dmontagu)\n* Fix issue with union parsing of enums, [#6440](https://github.com/pydantic/pydantic/pull/6440) by [@dmontagu](https://github.com/dmontagu)\n* Docs: Fixed `constr` documentation, renamed old `regex` to new `pattern`, [#6452](https://github.com/pydantic/pydantic/pull/6452) by [@miili](https://github.com/miili)\n* Change `GenerateJsonSchema.generate_definitions` signature, [#6436](https://github.com/pydantic/pydantic/pull/6436) by [@dmontagu](https://github.com/dmontagu)\n\nSee the full changelog [here](https://github.com/pydantic/pydantic/releases/tag/v2.0.2)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v202-2023-07-05indexhtmlv202-2023-07-05-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.0.1 (2023-07-04)[Â¶](index.html#v201-2023-07-04 \"Permanent link\")", "anchor": "v201-2023-07-04indexhtmlv201-2023-07-04-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.0.1)\n\nFirst patch release of Pydantic V2\n\n* Extra fields added via `setattr` (i.e. `m.some_extra_field = 'extra_value'`)\n  are added to `.model_extra` if `model_config` `extra='allowed'`. Fixed [#6333](https://github.com/pydantic/pydantic/pull/6333), [#6365](https://github.com/pydantic/pydantic/pull/6365) by [@aaraney](https://github.com/aaraney)\n* Automatically unpack JSON schema '$ref' for custom types, [#6343](https://github.com/pydantic/pydantic/pull/6343) by [@adriangb](https://github.com/adriangb)\n* Fix tagged unions multiple processing in submodels, [#6340](https://github.com/pydantic/pydantic/pull/6340) by [@suharnikov](https://github.com/suharnikov)\n\nSee the full changelog [here](https://github.com/pydantic/pydantic/releases/tag/v2.0.1)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v201-2023-07-04indexhtmlv201-2023-07-04-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.0 (2023-06-30)[Â¶](index.html#v20-2023-06-30 \"Permanent link\")", "anchor": "v20-2023-06-30indexhtmlv20-2023-06-30-permanent-link", "md_text": "[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v2.0)\n\nPydantic V2 is here! ![ðŸŽ‰](https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.1.0/assets/svg/1f389.svg \":tada:\")\n\nSee [this post](https://docs.pydantic.dev/2.0/blog/pydantic-v2-final/) for more details.", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v20-2023-06-30indexhtmlv20-2023-06-30-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.0b3 (2023-06-16)[Â¶](index.html#v20b3-2023-06-16 \"Permanent link\")", "anchor": "v20b3-2023-06-16indexhtmlv20b3-2023-06-16-permanent-link", "md_text": "Third beta pre-release of Pydantic V2\n\nSee the full changelog [here](https://github.com/pydantic/pydantic/releases/tag/v2.0b3)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v20b3-2023-06-16indexhtmlv20b3-2023-06-16-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.0b2 (2023-06-03)[Â¶](index.html#v20b2-2023-06-03 \"Permanent link\")", "anchor": "v20b2-2023-06-03indexhtmlv20b2-2023-06-03-permanent-link", "md_text": "Add `from_attributes` runtime flag to `TypeAdapter.validate_python` and `BaseModel.model_validate`.\n\nSee the full changelog [here](https://github.com/pydantic/pydantic/releases/tag/v2.0b2)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v20b2-2023-06-03indexhtmlv20b2-2023-06-03-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.0b1 (2023-06-01)[Â¶](index.html#v20b1-2023-06-01 \"Permanent link\")", "anchor": "v20b1-2023-06-01indexhtmlv20b1-2023-06-01-permanent-link", "md_text": "First beta pre-release of Pydantic V2\n\nSee the full changelog [here](https://github.com/pydantic/pydantic/releases/tag/v2.0b1)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v20b1-2023-06-01indexhtmlv20b1-2023-06-01-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.0a4 (2023-05-05)[Â¶](index.html#v20a4-2023-05-05 \"Permanent link\")", "anchor": "v20a4-2023-05-05indexhtmlv20a4-2023-05-05-permanent-link", "md_text": "Fourth pre-release of Pydantic V2\n\nSee the full changelog [here](https://github.com/pydantic/pydantic/releases/tag/v2.0a4)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v20a4-2023-05-05indexhtmlv20a4-2023-05-05-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.0a3 (2023-04-20)[Â¶](index.html#v20a3-2023-04-20 \"Permanent link\")", "anchor": "v20a3-2023-04-20indexhtmlv20a3-2023-04-20-permanent-link", "md_text": "Third pre-release of Pydantic V2\n\nSee the full changelog [here](https://github.com/pydantic/pydantic/releases/tag/v2.0a3)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v20a3-2023-04-20indexhtmlv20a3-2023-04-20-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.0a2 (2023-04-12)[Â¶](index.html#v20a2-2023-04-12 \"Permanent link\")", "anchor": "v20a2-2023-04-12indexhtmlv20a2-2023-04-12-permanent-link", "md_text": "Second pre-release of Pydantic V2\n\nSee the full changelog [here](https://github.com/pydantic/pydantic/releases/tag/v2.0a2)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v20a2-2023-04-12indexhtmlv20a2-2023-04-12-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v2.0a1 (2023-04-03)[Â¶](index.html#v20a1-2023-04-03 \"Permanent link\")", "anchor": "v20a1-2023-04-03indexhtmlv20a1-2023-04-03-permanent-link", "md_text": "First pre-release of Pydantic V2!\n\nSee [this post](https://docs.pydantic.dev/blog/pydantic-v2-alpha/) for more details.", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v20a1-2023-04-03indexhtmlv20a1-2023-04-03-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.10.21 (2025-01-10)[Â¶](index.html#v11021-2025-01-10 \"Permanent link\")", "anchor": "v11021-2025-01-10indexhtmlv11021-2025-01-10-permanent-link", "md_text": "* Fix compatibility with ForwardRef.\\_evaluate and Python < 3.12.4 by [@griels](https://github.com/griels) in https://github.com/pydantic/pydantic/pull/11232", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v11021-2025-01-10indexhtmlv11021-2025-01-10-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.10.20 (2025-01-07)[Â¶](index.html#v11020-2025-01-07 \"Permanent link\")", "anchor": "v11020-2025-01-07indexhtmlv11020-2025-01-07-permanent-link", "md_text": "This release provides proper support for Python 3.13, with (Cythonized) wheels published for this version.\nAs a consequence, Cython was updated from `0.29.x` to `3.0.x`.\n\n* General maintenance of CI and build ecosystem by [@Viicos](https://github.com/Viicos) in https://github.com/pydantic/pydantic/pull/10847\n  + Update Cython to `3.0.x`.\n  + Properly address Python 3.13 deprecation warnings.\n  + Migrate packaging to `pyproject.toml`, make use of PEP 517 build options.\n  + Use [`build`](https://pypi.org/project/build/) instead of direct `setup.py` invocations.\n  + Update various Github Actions versions.\n* Replace outdated stpmex link in documentation by [@jaredenorris](https://github.com/jaredenorris) in https://github.com/pydantic/pydantic/pull/10997", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v11020-2025-01-07indexhtmlv11020-2025-01-07-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.10.19 (2024-11-06)[Â¶](index.html#v11019-2024-11-06 \"Permanent link\")", "anchor": "v11019-2024-11-06indexhtmlv11019-2024-11-06-permanent-link", "md_text": "* Add warning when v2 model is nested in v1 model by [@sydney-runkle](https://github.com/sydney-runkle) in https://github.com/pydantic/pydantic/pull/10432\n* Fix deprecation warning in V1 `isinstance` check by [@alicederyn](https://github.com/alicederyn) in https://github.com/pydantic/pydantic/pull/10645", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v11019-2024-11-06indexhtmlv11019-2024-11-06-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.10.18 (2024-08-22)[Â¶](index.html#v11018-2024-08-22 \"Permanent link\")", "anchor": "v11018-2024-08-22indexhtmlv11018-2024-08-22-permanent-link", "md_text": "* Eval type fix in V1 by [@sydney-runkle](https://github.com/sydney-runkle) in https://github.com/pydantic/pydantic/pull/9751\n* Add `to_lower_camel` to `__all__` in `utils.py` by [@sydney-runkle](https://github.com/sydney-runkle) (direct commit)\n* Fix `mypy` v1 plugin for mypy 1.11 release by [@flaeppe](https://github.com/flaeppe) in https://github.com/pydantic/pydantic/pull/10139\n* Fix discriminator key used when discriminator has alias and `.schema(by_alias=False)` by [@exs-dwoodward](https://github.com/exs-dwoodward) in https://github.com/pydantic/pydantic/pull/10146", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v11018-2024-08-22indexhtmlv11018-2024-08-22-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.10.17 (2024-06-20)[Â¶](index.html#v11017-2024-06-20 \"Permanent link\")", "anchor": "v11017-2024-06-20indexhtmlv11017-2024-06-20-permanent-link", "md_text": "* Advertise Python 3.12 for 1.10.x! Part Deux by [@vfazio](https://github.com/vfazio) in https://github.com/pydantic/pydantic/pull/9644\n* Mirrored modules in `v1` namespace to fix typing and object resolution in python>3.11 by [@exs-dwoodward](https://github.com/exs-dwoodward) in https://github.com/pydantic/pydantic/pull/9660\n* setup: remove upper bound from python\\_requires by [@vfazio](https://github.com/vfazio) in https://github.com/pydantic/pydantic/pull/9685", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v11017-2024-06-20indexhtmlv11017-2024-06-20-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.10.16 (2024-06-11)[Â¶](index.html#v11016-2024-06-11 \"Permanent link\")", "anchor": "v11016-2024-06-11indexhtmlv11016-2024-06-11-permanent-link", "md_text": "* Specify recursive\\_guard as kwarg in FutureRef.\\_evaluate by [@vfazio](https://github.com/vfazio) in https://github.com/pydantic/pydantic/pull/9612\n* Fix mypy v1 plugin for upcoming mypy release by @ cdce8p in https://github.com/pydantic/pydantic/pull/9586\n* Import modules/objects directly from v1 namespace by [@exs-dwoodward](https://github.com/exs-dwoodward) in https://github.com/pydantic/pydantic/pull/9162", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v11016-2024-06-11indexhtmlv11016-2024-06-11-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.10.15 (2024-04-03)[Â¶](index.html#v11015-2024-04-03 \"Permanent link\")", "anchor": "v11015-2024-04-03indexhtmlv11015-2024-04-03-permanent-link", "md_text": "* Add pydantic.v1 namespace to Pydantic v1 by [@exs-dmiketa](https://github.com/exs-dmiketa) in https://github.com/pydantic/pydantic/pull/9042\n* Relax version of typing-extensions for V1 by [@SonOfLilit](https://github.com/SonOfLilit) in https://github.com/pydantic/pydantic/pull/8819\n* patch fix for mypy by [@sydney-runkle](https://github.com/sydney-runkle) in https://github.com/pydantic/pydantic/pull/8765", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v11015-2024-04-03indexhtmlv11015-2024-04-03-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.10.14 (2024-01-19)[Â¶](index.html#v11014-2024-01-19 \"Permanent link\")", "anchor": "v11014-2024-01-19indexhtmlv11014-2024-01-19-permanent-link", "md_text": "* Update install.md by [@dmontagu](https://github.com/dmontagu) in #7690\n* Fix ci to only deploy docs on release by [@sydney-runkle](https://github.com/sydney-runkle) in #7740\n* Ubuntu fixes for V1 by [@sydney-runkle](https://github.com/sydney-runkle) in #8540 and #8587\n* Fix cached\\_property handling in dataclasses when copied by [@rdbisme](https://github.com/rdbisme) in #8407", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v11014-2024-01-19indexhtmlv11014-2024-01-19-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.10.13 (2023-09-27)[Â¶](index.html#v11013-2023-09-27 \"Permanent link\")", "anchor": "v11013-2023-09-27indexhtmlv11013-2023-09-27-permanent-link", "md_text": "* Fix: Add max length check to `pydantic.validate_email`, #7673 by [@hramezani](https://github.com/hramezani)\n* Docs: Fix pip commands to install v1, #6930 by [@chbndrhnns](https://github.com/chbndrhnns)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v11013-2023-09-27indexhtmlv11013-2023-09-27-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.10.12 (2023-07-24)[Â¶](index.html#v11012-2023-07-24 \"Permanent link\")", "anchor": "v11012-2023-07-24indexhtmlv11012-2023-07-24-permanent-link", "md_text": "* Fixes the `maxlen` property being dropped on `deque` validation. Happened only if the deque item has been typed. Changes the `_validate_sequence_like` func, [#6581](https://github.com/pydantic/pydantic/pull/6581) by [@maciekglowka](https://github.com/maciekglowka)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v11012-2023-07-24indexhtmlv11012-2023-07-24-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.10.11 (2023-07-04)[Â¶](index.html#v11011-2023-07-04 \"Permanent link\")", "anchor": "v11011-2023-07-04indexhtmlv11011-2023-07-04-permanent-link", "md_text": "* Importing create\\_model in tools.py through relative path instead of absolute path - so that it doesn't import V2 code when copied over to V2 branch, [#6361](https://github.com/pydantic/pydantic/pull/6361) by [@SharathHuddar](https://github.com/SharathHuddar)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v11011-2023-07-04indexhtmlv11011-2023-07-04-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.10.10 (2023-06-30)[Â¶](index.html#v11010-2023-06-30 \"Permanent link\")", "anchor": "v11010-2023-06-30indexhtmlv11010-2023-06-30-permanent-link", "md_text": "* Add Pydantic `Json` field support to settings management, [#6250](https://github.com/pydantic/pydantic/pull/6250) by [@hramezani](https://github.com/hramezani)\n* Fixed literal validator errors for unhashable values, [#6188](https://github.com/pydantic/pydantic/pull/6188) by [@markus1978](https://github.com/markus1978)\n* Fixed bug with generics receiving forward refs, [#6130](https://github.com/pydantic/pydantic/pull/6130) by [@mark-todd](https://github.com/mark-todd)\n* Update install method of FastAPI for internal tests in CI, [#6117](https://github.com/pydantic/pydantic/pull/6117) by [@Kludex](https://github.com/Kludex)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v11010-2023-06-30indexhtmlv11010-2023-06-30-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.10.9 (2023-06-07)[Â¶](index.html#v1109-2023-06-07 \"Permanent link\")", "anchor": "v1109-2023-06-07indexhtmlv1109-2023-06-07-permanent-link", "md_text": "* Fix trailing zeros not ignored in Decimal validation, [#5968](https://github.com/pydantic/pydantic/pull/5968) by [@hramezani](https://github.com/hramezani)\n* Fix mypy plugin for v1.4.0, [#5928](https://github.com/pydantic/pydantic/pull/5928) by [@cdce8p](https://github.com/cdce8p)\n* Add future and past date hypothesis strategies, [#5850](https://github.com/pydantic/pydantic/pull/5850) by [@bschoenmaeckers](https://github.com/bschoenmaeckers)\n* Discourage usage of Cython 3 with Pydantic 1.x, [#5845](https://github.com/pydantic/pydantic/pull/5845) by [@lig](https://github.com/lig)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v1109-2023-06-07indexhtmlv1109-2023-06-07-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.10.8 (2023-05-23)[Â¶](index.html#v1108-2023-05-23 \"Permanent link\")", "anchor": "v1108-2023-05-23indexhtmlv1108-2023-05-23-permanent-link", "md_text": "* Fix a bug in `Literal` usage with `typing-extension==4.6.0`, [#5826](https://github.com/pydantic/pydantic/pull/5826) by [@hramezani](https://github.com/hramezani)\n* This solves the (closed) issue [#3849](https://github.com/pydantic/pydantic/pull/3849) where aliased fields that use discriminated union fail to validate when the data contains the non-aliased field name, [#5736](https://github.com/pydantic/pydantic/pull/5736) by [@benwah](https://github.com/benwah)\n* Update email-validator dependency to >=2.0.0post2, [#5627](https://github.com/pydantic/pydantic/pull/5627) by [@adriangb](https://github.com/adriangb)\n* update `AnyClassMethod` for changes in [python/typeshed#9771](https://github.com/python/typeshed/issues/9771), [#5505](https://github.com/pydantic/pydantic/pull/5505) by [@ITProKyle](https://github.com/ITProKyle)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v1108-2023-05-23indexhtmlv1108-2023-05-23-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.10.7 (2023-03-22)[Â¶](index.html#v1107-2023-03-22 \"Permanent link\")", "anchor": "v1107-2023-03-22indexhtmlv1107-2023-03-22-permanent-link", "md_text": "* Fix creating schema from model using `ConstrainedStr` with `regex` as dict key, [#5223](https://github.com/pydantic/pydantic/pull/5223) by [@matejetz](https://github.com/matejetz)\n* Address bug in mypy plugin caused by explicit\\_package\\_bases=True, [#5191](https://github.com/pydantic/pydantic/pull/5191) by [@dmontagu](https://github.com/dmontagu)\n* Add implicit defaults in the mypy plugin for Field with no default argument, [#5190](https://github.com/pydantic/pydantic/pull/5190) by [@dmontagu](https://github.com/dmontagu)\n* Fix schema generated for Enum values used as Literals in discriminated unions, [#5188](https://github.com/pydantic/pydantic/pull/5188) by [@javibookline](https://github.com/javibookline)\n* Fix mypy failures caused by the pydantic mypy plugin when users define `from_orm` in their own classes, [#5187](https://github.com/pydantic/pydantic/pull/5187) by [@dmontagu](https://github.com/dmontagu)\n* Fix `InitVar` usage with pydantic dataclasses, mypy version `1.1.1` and the custom mypy plugin, [#5162](https://github.com/pydantic/pydantic/pull/5162) by [@cdce8p](https://github.com/cdce8p)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v1107-2023-03-22indexhtmlv1107-2023-03-22-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.10.6 (2023-03-08)[Â¶](index.html#v1106-2023-03-08 \"Permanent link\")", "anchor": "v1106-2023-03-08indexhtmlv1106-2023-03-08-permanent-link", "md_text": "* Implement logic to support creating validators from non standard callables by using defaults to identify them and unwrapping `functools.partial` and `functools.partialmethod` when checking the signature, [#5126](https://github.com/pydantic/pydantic/pull/5126) by [@JensHeinrich](https://github.com/JensHeinrich)\n* Fix mypy plugin for v1.1.1, and fix `dataclass_transform` decorator for pydantic dataclasses, [#5111](https://github.com/pydantic/pydantic/pull/5111) by [@cdce8p](https://github.com/cdce8p)\n* Raise `ValidationError`, not `ConfigError`, when a discriminator value is unhashable, [#4773](https://github.com/pydantic/pydantic/pull/4773) by [@kurtmckee](https://github.com/kurtmckee)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v1106-2023-03-08indexhtmlv1106-2023-03-08-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.10.5 (2023-02-15)[Â¶](index.html#v1105-2023-02-15 \"Permanent link\")", "anchor": "v1105-2023-02-15indexhtmlv1105-2023-02-15-permanent-link", "md_text": "* Fix broken parametrized bases handling with `GenericModel`s with complex sets of models, [#5052](https://github.com/pydantic/pydantic/pull/5052) by [@MarkusSintonen](https://github.com/MarkusSintonen)\n* Invalidate mypy cache if plugin config changes, [#5007](https://github.com/pydantic/pydantic/pull/5007) by [@cdce8p](https://github.com/cdce8p)\n* Fix `RecursionError` when deep-copying dataclass types wrapped by pydantic, [#4949](https://github.com/pydantic/pydantic/pull/4949) by [@mbillingr](https://github.com/mbillingr)\n* Fix `X | Y` union syntax breaking `GenericModel`, [#4146](https://github.com/pydantic/pydantic/pull/4146) by [@thenx](https://github.com/thenx)\n* Switch coverage badge to show coverage for this branch/release, [#5060](https://github.com/pydantic/pydantic/pull/5060) by [@samuelcolvin](https://github.com/samuelcolvin)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v1105-2023-02-15indexhtmlv1105-2023-02-15-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.10.4 (2022-12-30)[Â¶](index.html#v1104-2022-12-30 \"Permanent link\")", "anchor": "v1104-2022-12-30indexhtmlv1104-2022-12-30-permanent-link", "md_text": "* Change dependency to `typing-extensions>=4.2.0`, [#4885](https://github.com/pydantic/pydantic/pull/4885) by [@samuelcolvin](https://github.com/samuelcolvin)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v1104-2022-12-30indexhtmlv1104-2022-12-30-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.10.3 (2022-12-29)[Â¶](index.html#v1103-2022-12-29 \"Permanent link\")", "anchor": "v1103-2022-12-29indexhtmlv1103-2022-12-29-permanent-link", "md_text": "**NOTE: v1.10.3 was [\"yanked\"](https://pypi.org/help/#yanked) from PyPI due to [#4885](https://github.com/pydantic/pydantic/pull/4885) which is fixed in v1.10.4**\n\n* fix parsing of custom root models, [#4883](https://github.com/pydantic/pydantic/pull/4883) by [@gou177](https://github.com/gou177)\n* fix: use dataclass proxy for frozen or empty dataclasses, [#4878](https://github.com/pydantic/pydantic/pull/4878) by [@PrettyWood](https://github.com/PrettyWood)\n* Fix `schema` and `schema_json` on models where a model instance is a one of default values, [#4781](https://github.com/pydantic/pydantic/pull/4781) by [@Bobronium](https://github.com/Bobronium)\n* Add Jina AI to sponsors on docs index page, [#4767](https://github.com/pydantic/pydantic/pull/4767) by [@samuelcolvin](https://github.com/samuelcolvin)\n* fix: support assignment on `DataclassProxy`, [#4695](https://github.com/pydantic/pydantic/pull/4695) by [@PrettyWood](https://github.com/PrettyWood)\n* Add `postgresql+psycopg` as allowed scheme for `PostgreDsn` to make it usable with SQLAlchemy 2, [#4689](https://github.com/pydantic/pydantic/pull/4689) by [@morian](https://github.com/morian)\n* Allow dict schemas to have both `patternProperties` and `additionalProperties`, [#4641](https://github.com/pydantic/pydantic/pull/4641) by [@jparise](https://github.com/jparise)\n* Fixes error passing None for optional lists with `unique_items`, [#4568](https://github.com/pydantic/pydantic/pull/4568) by [@mfulgo](https://github.com/mfulgo)\n* Fix `GenericModel` with `Callable` param raising a `TypeError`, [#4551](https://github.com/pydantic/pydantic/pull/4551) by [@mfulgo](https://github.com/mfulgo)\n* Fix field regex with `StrictStr` type annotation, [#4538](https://github.com/pydantic/pydantic/pull/4538) by [@sisp](https://github.com/sisp)\n* Correct `dataclass_transform` keyword argument name from `field_descriptors` to `field_specifiers`, [#4500](https://github.com/pydantic/pydantic/pull/4500) by [@samuelcolvin](https://github.com/samuelcolvin)\n* fix: avoid multiple calls of `__post_init__` when dataclasses are inherited, [#4487](https://github.com/pydantic/pydantic/pull/4487) by [@PrettyWood](https://github.com/PrettyWood)\n* Reduce the size of binary wheels, [#2276](https://github.com/pydantic/pydantic/pull/2276) by [@samuelcolvin](https://github.com/samuelcolvin)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v1103-2022-12-29indexhtmlv1103-2022-12-29-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.10.2 (2022-09-05)[Â¶](index.html#v1102-2022-09-05 \"Permanent link\")", "anchor": "v1102-2022-09-05indexhtmlv1102-2022-09-05-permanent-link", "md_text": "* **Revert Change:** Revert percent encoding of URL parts which was originally added in [#4224](https://github.com/pydantic/pydantic/pull/4224), [#4470](https://github.com/pydantic/pydantic/pull/4470) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Prevent long (length > `4_300`) strings/bytes as input to int fields, see\n  [python/cpython#95778](https://github.com/python/cpython/issues/95778) and\n  [CVE-2020-10735](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-10735), [#1477](https://github.com/pydantic/pydantic/pull/1477) by [@samuelcolvin](https://github.com/samuelcolvin)\n* fix: dataclass wrapper was not always called, [#4477](https://github.com/pydantic/pydantic/pull/4477) by [@PrettyWood](https://github.com/PrettyWood)\n* Use `tomllib` on Python 3.11 when parsing `mypy` configuration, [#4476](https://github.com/pydantic/pydantic/pull/4476) by [@hauntsaninja](https://github.com/hauntsaninja)\n* Basic fix of `GenericModel` cache to detect order of arguments in `Union` models, [#4474](https://github.com/pydantic/pydantic/pull/4474) by [@sveinugu](https://github.com/sveinugu)\n* Fix mypy plugin when using bare types like `list` and `dict` as `default_factory`, [#4457](https://github.com/pydantic/pydantic/pull/4457) by [@samuelcolvin](https://github.com/samuelcolvin)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v1102-2022-09-05indexhtmlv1102-2022-09-05-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.10.1 (2022-08-31)[Â¶](index.html#v1101-2022-08-31 \"Permanent link\")", "anchor": "v1101-2022-08-31indexhtmlv1101-2022-08-31-permanent-link", "md_text": "* Add `__hash__` method to `pydantic.color.Color` class, [#4454](https://github.com/pydantic/pydantic/pull/4454) by [@czaki](https://github.com/czaki)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v1101-2022-08-31indexhtmlv1101-2022-08-31-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.10.0 (2022-08-30)[Â¶](index.html#v1100-2022-08-30 \"Permanent link\")", "anchor": "v1100-2022-08-30indexhtmlv1100-2022-08-30-permanent-link", "md_text": "* Refactor the whole *pydantic* `dataclass` decorator to really act like its standard lib equivalent.\n  It hence keeps `__eq__`, `__hash__`, ... and makes comparison with its non-validated version possible.\n  It also fixes usage of `frozen` dataclasses in fields and usage of `default_factory` in nested dataclasses.\n  The support of `Config.extra` has been added.\n  Finally, config customization directly via a `dict` is now possible, [#2557](https://github.com/pydantic/pydantic/pull/2557) by [@PrettyWood](https://github.com/PrettyWood)\n    \n    \n  **BREAKING CHANGES:**\n  + The `compiled` boolean (whether *pydantic* is compiled with cython) has been moved from `main.py` to `version.py`\n  + Now that `Config.extra` is supported, `dataclass` ignores by default extra arguments (like `BaseModel`)\n* Fix PEP487 `__set_name__` protocol in `BaseModel` for PrivateAttrs, [#4407](https://github.com/pydantic/pydantic/pull/4407) by [@tlambert03](https://github.com/tlambert03)\n* Allow for custom parsing of environment variables via `parse_env_var` in `Config`, [#4406](https://github.com/pydantic/pydantic/pull/4406) by [@acmiyaguchi](https://github.com/acmiyaguchi)\n* Rename `master` to `main`, [#4405](https://github.com/pydantic/pydantic/pull/4405) by [@hramezani](https://github.com/hramezani)\n* Fix `StrictStr` does not raise `ValidationError` when `max_length` is present in `Field`, [#4388](https://github.com/pydantic/pydantic/pull/4388) by [@hramezani](https://github.com/hramezani)\n* Make `SecretStr` and `SecretBytes` hashable, [#4387](https://github.com/pydantic/pydantic/pull/4387) by [@chbndrhnns](https://github.com/chbndrhnns)\n* Fix `StrictBytes` does not raise `ValidationError` when `max_length` is present in `Field`, [#4380](https://github.com/pydantic/pydantic/pull/4380) by [@JeanArhancet](https://github.com/JeanArhancet)\n* Add support for bare `type`, [#4375](https://github.com/pydantic/pydantic/pull/4375) by [@hramezani](https://github.com/hramezani)\n* Support Python 3.11, including binaries for 3.11 in PyPI, [#4374](https://github.com/pydantic/pydantic/pull/4374) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Add support for `re.Pattern`, [#4366](https://github.com/pydantic/pydantic/pull/4366) by [@hramezani](https://github.com/hramezani)\n* Fix `__post_init_post_parse__` is incorrectly passed keyword arguments when no `__post_init__` is defined, [#4361](https://github.com/pydantic/pydantic/pull/4361) by [@hramezani](https://github.com/hramezani)\n* Fix implicitly importing `ForwardRef` and `Callable` from `pydantic.typing` instead of `typing` and also expose `MappingIntStrAny`, [#4358](https://github.com/pydantic/pydantic/pull/4358) by [@aminalaee](https://github.com/aminalaee)\n* remove `Any` types from the `dataclass` decorator so it can be used with the `disallow_any_expr` mypy option, [#4356](https://github.com/pydantic/pydantic/pull/4356) by [@DetachHead](https://github.com/DetachHead)\n* moved repo to `pydantic/pydantic`, [#4348](https://github.com/pydantic/pydantic/pull/4348) by [@yezz123](https://github.com/yezz123)\n* fix \"extra fields not permitted\" error when dataclass with `Extra.forbid` is validated multiple times, [#4343](https://github.com/pydantic/pydantic/pull/4343) by [@detachhead](https://github.com/detachhead)\n* Add Python 3.9 and 3.10 examples to docs, [#4339](https://github.com/pydantic/pydantic/pull/4339) by [@Bobronium](https://github.com/Bobronium)\n* Discriminated union models now use `oneOf` instead of `anyOf` when generating OpenAPI schema definitions, [#4335](https://github.com/pydantic/pydantic/pull/4335) by [@MaxwellPayne](https://github.com/MaxwellPayne)\n* Allow type checkers to infer inner type of `Json` type. `Json[list[str]]` will be now inferred as `list[str]`,\n  `Json[Any]` should be used instead of plain `Json`.\n  Runtime behaviour is not changed, [#4332](https://github.com/pydantic/pydantic/pull/4332) by [@Bobronium](https://github.com/Bobronium)\n* Allow empty string aliases by using a `alias is not None` check, rather than `bool(alias)`, [#4253](https://github.com/pydantic/pydantic/pull/4253) by [@sergeytsaplin](https://github.com/sergeytsaplin)\n* Update `ForwardRef`s in `Field.outer_type_`, [#4249](https://github.com/pydantic/pydantic/pull/4249) by [@JacobHayes](https://github.com/JacobHayes)\n* The use of `__dataclass_transform__` has been replaced by `typing_extensions.dataclass_transform`, which is the preferred way to mark pydantic models as a dataclass under [PEP 681](https://peps.python.org/pep-0681/), [#4241](https://github.com/pydantic/pydantic/pull/4241) by [@multimeric](https://github.com/multimeric)\n* Use parent model's `Config` when validating nested `NamedTuple` fields, [#4219](https://github.com/pydantic/pydantic/pull/4219) by [@synek](https://github.com/synek)\n* Update `BaseModel.construct` to work with aliased Fields, [#4192](https://github.com/pydantic/pydantic/pull/4192) by [@kylebamos](https://github.com/kylebamos)\n* Catch certain raised errors in `smart_deepcopy` and revert to `deepcopy` if so, [#4184](https://github.com/pydantic/pydantic/pull/4184) by [@coneybeare](https://github.com/coneybeare)\n* Add `Config.anystr_upper` and `to_upper` kwarg to constr and conbytes, [#4165](https://github.com/pydantic/pydantic/pull/4165) by [@satheler](https://github.com/satheler)\n* Fix JSON schema for `set` and `frozenset` when they include default values, [#4155](https://github.com/pydantic/pydantic/pull/4155) by [@aminalaee](https://github.com/aminalaee)\n* Teach the mypy plugin that methods decorated by `@validator` are classmethods, [#4102](https://github.com/pydantic/pydantic/pull/4102) by [@DMRobertson](https://github.com/DMRobertson)\n* Improve mypy plugin's ability to detect required fields, [#4086](https://github.com/pydantic/pydantic/pull/4086) by [@richardxia](https://github.com/richardxia)\n* Support fields of type `Type[]` in schema, [#4051](https://github.com/pydantic/pydantic/pull/4051) by [@aminalaee](https://github.com/aminalaee)\n* Add `default` value in JSON Schema when `const=True`, [#4031](https://github.com/pydantic/pydantic/pull/4031) by [@aminalaee](https://github.com/aminalaee)\n* Adds reserved word check to signature generation logic, [#4011](https://github.com/pydantic/pydantic/pull/4011) by [@strue36](https://github.com/strue36)\n* Fix Json strategy failure for the complex nested field, [#4005](https://github.com/pydantic/pydantic/pull/4005) by [@sergiosim](https://github.com/sergiosim)\n* Add JSON-compatible float constraint `allow_inf_nan`, [#3994](https://github.com/pydantic/pydantic/pull/3994) by [@tiangolo](https://github.com/tiangolo)\n* Remove undefined behaviour when `env_prefix` had characters in common with `env_nested_delimiter`, [#3975](https://github.com/pydantic/pydantic/pull/3975) by [@arsenron](https://github.com/arsenron)\n* Support generics model with `create_model`, [#3945](https://github.com/pydantic/pydantic/pull/3945) by [@hot123s](https://github.com/hot123s)\n* allow submodels to overwrite extra field info, [#3934](https://github.com/pydantic/pydantic/pull/3934) by [@PrettyWood](https://github.com/PrettyWood)\n* Document and test structural pattern matching ([PEP 636](https://peps.python.org/pep-0636/)) on `BaseModel`, [#3920](https://github.com/pydantic/pydantic/pull/3920) by [@irgolic](https://github.com/irgolic)\n* Fix incorrect deserialization of python timedelta object to ISO 8601 for negative time deltas.\n  Minus was serialized in incorrect place (\"P-1DT23H59M59.888735S\" instead of correct \"-P1DT23H59M59.888735S\"), [#3899](https://github.com/pydantic/pydantic/pull/3899) by [@07pepa](https://github.com/07pepa)\n* Fix validation of discriminated union fields with an alias when passing a model instance, [#3846](https://github.com/pydantic/pydantic/pull/3846) by [@chornsby](https://github.com/chornsby)\n* Add a CockroachDsn type to validate CockroachDB connection strings. The type\n  supports the following schemes: `cockroachdb`, `cockroachdb+psycopg2` and `cockroachdb+asyncpg`, [#3839](https://github.com/pydantic/pydantic/pull/3839) by [@blubber](https://github.com/blubber)\n* Fix MyPy plugin to not override pre-existing `__init__` method in models, [#3824](https://github.com/pydantic/pydantic/pull/3824) by [@patrick91](https://github.com/patrick91)\n* Fix mypy version checking, [#3783](https://github.com/pydantic/pydantic/pull/3783) by [@KotlinIsland](https://github.com/KotlinIsland)\n* support overwriting dunder attributes of `BaseModel` instances, [#3777](https://github.com/pydantic/pydantic/pull/3777) by [@PrettyWood](https://github.com/PrettyWood)\n* Added `ConstrainedDate` and `condate`, [#3740](https://github.com/pydantic/pydantic/pull/3740) by [@hottwaj](https://github.com/hottwaj)\n* Support `kw_only` in dataclasses, [#3670](https://github.com/pydantic/pydantic/pull/3670) by [@detachhead](https://github.com/detachhead)\n* Add comparison method for `Color` class, [#3646](https://github.com/pydantic/pydantic/pull/3646) by [@aminalaee](https://github.com/aminalaee)\n* Drop support for python3.6, associated cleanup, [#3605](https://github.com/pydantic/pydantic/pull/3605) by [@samuelcolvin](https://github.com/samuelcolvin)\n* created new function `to_lower_camel()` for \"non pascal case\" camel case, [#3463](https://github.com/pydantic/pydantic/pull/3463) by [@schlerp](https://github.com/schlerp)\n* Add checks to `default` and `default_factory` arguments in Mypy plugin, [#3430](https://github.com/pydantic/pydantic/pull/3430) by [@klaa97](https://github.com/klaa97)\n* fix mangling of `inspect.signature` for `BaseModel`, [#3413](https://github.com/pydantic/pydantic/pull/3413) by [@fix-inspect-signature](https://github.com/fix-inspect-signature)\n* Adds the `SecretField` abstract class so that all the current and future secret fields like `SecretStr` and `SecretBytes` will derive from it, [#3409](https://github.com/pydantic/pydantic/pull/3409) by [@expobrain](https://github.com/expobrain)\n* Support multi hosts validation in `PostgresDsn`, [#3337](https://github.com/pydantic/pydantic/pull/3337) by [@rglsk](https://github.com/rglsk)\n* Fix parsing of very small numeric timedelta values, [#3315](https://github.com/pydantic/pydantic/pull/3315) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Update `SecretsSettingsSource` to respect `config.case_sensitive`, [#3273](https://github.com/pydantic/pydantic/pull/3273) by [@JeanArhancet](https://github.com/JeanArhancet)\n* Add MongoDB network data source name (DSN) schema, [#3229](https://github.com/pydantic/pydantic/pull/3229) by [@snosratiershad](https://github.com/snosratiershad)\n* Add support for multiple dotenv files, [#3222](https://github.com/pydantic/pydantic/pull/3222) by [@rekyungmin](https://github.com/rekyungmin)\n* Raise an explicit `ConfigError` when multiple fields are incorrectly set for a single validator, [#3215](https://github.com/pydantic/pydantic/pull/3215) by [@SunsetOrange](https://github.com/SunsetOrange)\n* Allow ellipsis on `Field`s inside `Annotated` for `TypedDicts` required, [#3133](https://github.com/pydantic/pydantic/pull/3133) by [@ezegomez](https://github.com/ezegomez)\n* Catch overflow errors in `int_validator`, [#3112](https://github.com/pydantic/pydantic/pull/3112) by [@ojii](https://github.com/ojii)\n* Adds a `__rich_repr__` method to `Representation` class which enables pretty printing with [Rich](https://github.com/willmcgugan/rich), [#3099](https://github.com/pydantic/pydantic/pull/3099) by [@willmcgugan](https://github.com/willmcgugan)\n* Add percent encoding in `AnyUrl` and descendent types, [#3061](https://github.com/pydantic/pydantic/pull/3061) by [@FaresAhmedb](https://github.com/FaresAhmedb)\n* `validate_arguments` decorator now supports `alias`, [#3019](https://github.com/pydantic/pydantic/pull/3019) by [@MAD-py](https://github.com/MAD-py)\n* Avoid `__dict__` and `__weakref__` attributes in `AnyUrl` and IP address fields, [#2890](https://github.com/pydantic/pydantic/pull/2890) by [@nuno-andre](https://github.com/nuno-andre)\n* Add ability to use `Final` in a field type annotation, [#2766](https://github.com/pydantic/pydantic/pull/2766) by [@uriyyo](https://github.com/uriyyo)\n* Update requirement to `typing_extensions>=4.1.0` to guarantee `dataclass_transform` is available, [#4424](https://github.com/pydantic/pydantic/pull/4424) by [@commonism](https://github.com/commonism)\n* Add Explosion and AWS to main sponsors, [#4413](https://github.com/pydantic/pydantic/pull/4413) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Update documentation for `copy_on_model_validation` to reflect recent changes, [#4369](https://github.com/pydantic/pydantic/pull/4369) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Runtime warning if `__slots__` is passed to `create_model`, `__slots__` is then ignored, [#4432](https://github.com/pydantic/pydantic/pull/4432) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Add type hints to `BaseSettings.Config` to avoid mypy errors, also correct mypy version compatibility notice in docs, [#4450](https://github.com/pydantic/pydantic/pull/4450) by [@samuelcolvin](https://github.com/samuelcolvin)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v1100-2022-08-30indexhtmlv1100-2022-08-30-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.10.0b1 (2022-08-24)[Â¶](index.html#v1100b1-2022-08-24 \"Permanent link\")", "anchor": "v1100b1-2022-08-24indexhtmlv1100b1-2022-08-24-permanent-link", "md_text": "Pre-release, see [the GitHub release](https://github.com/pydantic/pydantic/releases/tag/v1.10.0b1) for details.", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v1100b1-2022-08-24indexhtmlv1100b1-2022-08-24-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.10.0a2 (2022-08-24)[Â¶](index.html#v1100a2-2022-08-24 \"Permanent link\")", "anchor": "v1100a2-2022-08-24indexhtmlv1100a2-2022-08-24-permanent-link", "md_text": "Pre-release, see [the GitHub release](https://github.com/pydantic/pydantic/releases/tag/v1.10.0a2) for details.", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v1100a2-2022-08-24indexhtmlv1100a2-2022-08-24-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.10.0a1 (2022-08-22)[Â¶](index.html#v1100a1-2022-08-22 \"Permanent link\")", "anchor": "v1100a1-2022-08-22indexhtmlv1100a1-2022-08-22-permanent-link", "md_text": "Pre-release, see [the GitHub release](https://github.com/pydantic/pydantic/releases/tag/v1.10.0a1) for details.", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v1100a1-2022-08-22indexhtmlv1100a1-2022-08-22-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.9.2 (2022-08-11)[Â¶](index.html#v192-2022-08-11 \"Permanent link\")", "anchor": "v192-2022-08-11indexhtmlv192-2022-08-11-permanent-link", "md_text": "**Revert Breaking Change**: *v1.9.1* introduced a breaking change where model fields were\ndeep copied by default, this release reverts the default behaviour to match *v1.9.0* and before,\nwhile also allow deep-copy behaviour via `copy_on_model_validation = 'deep'`. See [#4092](https://github.com/pydantic/pydantic/pull/4092) for more information.\n\n* Allow for shallow copies of model fields, `Config.copy_on_model_validation` is now a str which must be\n  `'none'`, `'deep'`, or `'shallow'` corresponding to not copying, deep copy & shallow copy; default `'shallow'`,\n  [#4093](https://github.com/pydantic/pydantic/pull/4093) by [@timkpaine](https://github.com/timkpaine)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v192-2022-08-11indexhtmlv192-2022-08-11-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.9.1 (2022-05-19)[Â¶](index.html#v191-2022-05-19 \"Permanent link\")", "anchor": "v191-2022-05-19indexhtmlv191-2022-05-19-permanent-link", "md_text": "Thank you to pydantic's sponsors:\n[@tiangolo](https://github.com/tiangolo), [@stellargraph](https://github.com/stellargraph), [@JonasKs](https://github.com/JonasKs), [@grillazz](https://github.com/grillazz), [@Mazyod](https://github.com/Mazyod), [@kevinalh](https://github.com/kevinalh), [@chdsbd](https://github.com/chdsbd), [@povilasb](https://github.com/povilasb), [@povilasb](https://github.com/povilasb), [@jina-ai](https://github.com/jina-ai),\n[@mainframeindustries](https://github.com/mainframeindustries), [@robusta-dev](https://github.com/robusta-dev), [@SendCloud](https://github.com/SendCloud), [@rszamszur](https://github.com/rszamszur), [@jodal](https://github.com/jodal), [@hardbyte](https://github.com/hardbyte), [@corleyma](https://github.com/corleyma), [@daddycocoaman](https://github.com/daddycocoaman),\n[@Rehket](https://github.com/Rehket), [@jokull](https://github.com/jokull), [@reillysiemens](https://github.com/reillysiemens), [@westonsteimel](https://github.com/westonsteimel), [@primer-io](https://github.com/primer-io), [@koxudaxi](https://github.com/koxudaxi), [@browniebroke](https://github.com/browniebroke), [@stradivari96](https://github.com/stradivari96),\n[@adriangb](https://github.com/adriangb), [@kamalgill](https://github.com/kamalgill), [@jqueguiner](https://github.com/jqueguiner), [@dev-zero](https://github.com/dev-zero), [@datarootsio](https://github.com/datarootsio), [@RedCarpetUp](https://github.com/RedCarpetUp)\nfor their kind support.", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v191-2022-05-19indexhtmlv191-2022-05-19-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.9.1 (2022-05-19)[Â¶](index.html#v191-2022-05-19 \"Permanent link\")", "anchor": "v191-2022-05-19indexhtmlv191-2022-05-19-permanent-link", "md_text": "* Limit the size of `generics._generic_types_cache` and `generics._assigned_parameters`\n  to avoid unlimited increase in memory usage, [#4083](https://github.com/pydantic/pydantic/pull/4083) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Add Jupyverse and FPS as Jupyter projects using pydantic, [#4082](https://github.com/pydantic/pydantic/pull/4082) by [@davidbrochart](https://github.com/davidbrochart)\n* Speedup `__isinstancecheck__` on pydantic models when the type is not a model, may also avoid memory \"leaks\", [#4081](https://github.com/pydantic/pydantic/pull/4081) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Fix in-place modification of `FieldInfo` that caused problems with PEP 593 type aliases, [#4067](https://github.com/pydantic/pydantic/pull/4067) by [@adriangb](https://github.com/adriangb)\n* Add support for autocomplete in VS Code via `__dataclass_transform__` when using `pydantic.dataclasses.dataclass`, [#4006](https://github.com/pydantic/pydantic/pull/4006) by [@giuliano-oliveira](https://github.com/giuliano-oliveira)\n* Remove benchmarks from codebase and docs, [#3973](https://github.com/pydantic/pydantic/pull/3973) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Typing checking with pyright in CI, improve docs on vscode/pylance/pyright, [#3972](https://github.com/pydantic/pydantic/pull/3972) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Fix nested Python dataclass schema regression, [#3819](https://github.com/pydantic/pydantic/pull/3819) by [@himbeles](https://github.com/himbeles)\n* Update documentation about lazy evaluation of sources for Settings, [#3806](https://github.com/pydantic/pydantic/pull/3806) by [@garyd203](https://github.com/garyd203)\n* Prevent subclasses of bytes being converted to bytes, [#3706](https://github.com/pydantic/pydantic/pull/3706) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Fixed \"error checking inheritance of\" when using PEP585 and PEP604 type hints, [#3681](https://github.com/pydantic/pydantic/pull/3681) by [@aleksul](https://github.com/aleksul)\n* Allow self referencing `ClassVar`s in models, [#3679](https://github.com/pydantic/pydantic/pull/3679) by [@samuelcolvin](https://github.com/samuelcolvin)\n* **Breaking Change, see [#4106](https://github.com/pydantic/pydantic/pull/4106)**: Fix issue with self-referencing dataclass, [#3675](https://github.com/pydantic/pydantic/pull/3675) by [@uriyyo](https://github.com/uriyyo)\n* Include non-standard port numbers in rendered URLs, [#3652](https://github.com/pydantic/pydantic/pull/3652) by [@dolfinus](https://github.com/dolfinus)\n* `Config.copy_on_model_validation` does a deep copy and not a shallow one, [#3641](https://github.com/pydantic/pydantic/pull/3641) by [@PrettyWood](https://github.com/PrettyWood)\n* fix: clarify that discriminated unions do not support singletons, [#3636](https://github.com/pydantic/pydantic/pull/3636) by [@tommilligan](https://github.com/tommilligan)\n* Add `read_text(encoding='utf-8')` for `setup.py`, [#3625](https://github.com/pydantic/pydantic/pull/3625) by [@hswong3i](https://github.com/hswong3i)\n* Fix JSON Schema generation for Discriminated Unions within lists, [#3608](https://github.com/pydantic/pydantic/pull/3608) by [@samuelcolvin](https://github.com/samuelcolvin)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v191-2022-05-19indexhtmlv191-2022-05-19-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.9.0 (2021-12-31)[Â¶](index.html#v190-2021-12-31 \"Permanent link\")", "anchor": "v190-2021-12-31indexhtmlv190-2021-12-31-permanent-link", "md_text": "Thank you to pydantic's sponsors:\n[@sthagen](https://github.com/sthagen), [@timdrijvers](https://github.com/timdrijvers), [@toinbis](https://github.com/toinbis), [@koxudaxi](https://github.com/koxudaxi), [@ginomempin](https://github.com/ginomempin), [@primer-io](https://github.com/primer-io), [@and-semakin](https://github.com/and-semakin), [@westonsteimel](https://github.com/westonsteimel), [@reillysiemens](https://github.com/reillysiemens),\n[@es3n1n](https://github.com/es3n1n), [@jokull](https://github.com/jokull), [@JonasKs](https://github.com/JonasKs), [@Rehket](https://github.com/Rehket), [@corleyma](https://github.com/corleyma), [@daddycocoaman](https://github.com/daddycocoaman), [@hardbyte](https://github.com/hardbyte), [@datarootsio](https://github.com/datarootsio), [@jodal](https://github.com/jodal), [@aminalaee](https://github.com/aminalaee), [@rafsaf](https://github.com/rafsaf),\n[@jqueguiner](https://github.com/jqueguiner), [@chdsbd](https://github.com/chdsbd), [@kevinalh](https://github.com/kevinalh), [@Mazyod](https://github.com/Mazyod), [@grillazz](https://github.com/grillazz), [@JonasKs](https://github.com/JonasKs), [@simw](https://github.com/simw), [@leynier](https://github.com/leynier), [@xfenix](https://github.com/xfenix)\nfor their kind support.", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v190-2021-12-31indexhtmlv190-2021-12-31-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "Highlights[Â¶](index.html#highlights \"Permanent link\")", "anchor": "highlightsindexhtmlhighlights-permanent-link", "md_text": "* add Python 3.10 support, [#2885](https://github.com/pydantic/pydantic/pull/2885) by [@PrettyWood](https://github.com/PrettyWood)\n* [Discriminated unions](https://docs.pydantic.dev/usage/types/#discriminated-unions-aka-tagged-unions), [#619](https://github.com/pydantic/pydantic/pull/619) by [@PrettyWood](https://github.com/PrettyWood)\n* [`Config.smart_union` for better union logic](https://docs.pydantic.dev/usage/model_config/#smart-union), [#2092](https://github.com/pydantic/pydantic/pull/2092) by [@PrettyWood](https://github.com/PrettyWood)\n* Binaries for Macos M1 CPUs, [#3498](https://github.com/pydantic/pydantic/pull/3498) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Complex types can be set via [nested environment variables](https://docs.pydantic.dev/usage/settings/#parsing-environment-variable-values), e.g. `foo___bar`, [#3159](https://github.com/pydantic/pydantic/pull/3159) by [@Air-Mark](https://github.com/Air-Mark)\n* add a dark mode to *pydantic* documentation, [#2913](https://github.com/pydantic/pydantic/pull/2913) by [@gbdlin](https://github.com/gbdlin)\n* Add support for autocomplete in VS Code via `__dataclass_transform__`, [#2721](https://github.com/pydantic/pydantic/pull/2721) by [@tiangolo](https://github.com/tiangolo)\n* Add \"exclude\" as a field parameter so that it can be configured using model config, [#660](https://github.com/pydantic/pydantic/pull/660) by [@daviskirk](https://github.com/daviskirk)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#highlightsindexhtmlhighlights-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.9.0 (2021-12-31) Changes[Â¶](index.html#v190-2021-12-31-changes \"Permanent link\")", "anchor": "v190-2021-12-31-changesindexhtmlv190-2021-12-31-changes-permanent-link", "md_text": "* Apply `update_forward_refs` to `Config.json_encodes` prevent name clashes in types defined via strings, [#3583](https://github.com/pydantic/pydantic/pull/3583) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Extend pydantic's mypy plugin to support mypy versions `0.910`, `0.920`, `0.921` & `0.930`, [#3573](https://github.com/pydantic/pydantic/pull/3573) & [#3594](https://github.com/pydantic/pydantic/pull/3594) by [@PrettyWood](https://github.com/PrettyWood), [@christianbundy](https://github.com/christianbundy), [@samuelcolvin](https://github.com/samuelcolvin)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v190-2021-12-31-changesindexhtmlv190-2021-12-31-changes-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.9.0a2 (2021-12-24) Changes[Â¶](index.html#v190a2-2021-12-24-changes \"Permanent link\")", "anchor": "v190a2-2021-12-24-changesindexhtmlv190a2-2021-12-24-changes-permanent-link", "md_text": "* support generic models with discriminated union, [#3551](https://github.com/pydantic/pydantic/pull/3551) by [@PrettyWood](https://github.com/PrettyWood)\n* keep old behaviour of `json()` by default, [#3542](https://github.com/pydantic/pydantic/pull/3542) by [@PrettyWood](https://github.com/PrettyWood)\n* Removed typing-only `__root__` attribute from `BaseModel`, [#3540](https://github.com/pydantic/pydantic/pull/3540) by [@layday](https://github.com/layday)\n* Build Python 3.10 wheels, [#3539](https://github.com/pydantic/pydantic/pull/3539) by [@mbachry](https://github.com/mbachry)\n* Fix display of `extra` fields with model `__repr__`, [#3234](https://github.com/pydantic/pydantic/pull/3234) by [@cocolman](https://github.com/cocolman)\n* models copied via `Config.copy_on_model_validation` always have all fields, [#3201](https://github.com/pydantic/pydantic/pull/3201) by [@PrettyWood](https://github.com/PrettyWood)\n* nested ORM from nested dictionaries, [#3182](https://github.com/pydantic/pydantic/pull/3182) by [@PrettyWood](https://github.com/PrettyWood)\n* fix link to discriminated union section by [@PrettyWood](https://github.com/PrettyWood)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v190a2-2021-12-24-changesindexhtmlv190a2-2021-12-24-changes-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.9.0a1 (2021-12-18) Changes[Â¶](index.html#v190a1-2021-12-18-changes \"Permanent link\")", "anchor": "v190a1-2021-12-18-changesindexhtmlv190a1-2021-12-18-changes-permanent-link", "md_text": "* Add support for `Decimal`-specific validation configurations in `Field()`, additionally to using `condecimal()`,\n  to allow better support from editors and tooling, [#3507](https://github.com/pydantic/pydantic/pull/3507) by [@tiangolo](https://github.com/tiangolo)\n* Add `arm64` binaries suitable for MacOS with an M1 CPU to PyPI, [#3498](https://github.com/pydantic/pydantic/pull/3498) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Fix issue where `None` was considered invalid when using a `Union` type containing `Any` or `object`, [#3444](https://github.com/pydantic/pydantic/pull/3444) by [@tharradine](https://github.com/tharradine)\n* When generating field schema, pass optional `field` argument (of type\n  `pydantic.fields.ModelField`) to `__modify_schema__()` if present, [#3434](https://github.com/pydantic/pydantic/pull/3434) by [@jasujm](https://github.com/jasujm)\n* Fix issue when pydantic fail to parse `typing.ClassVar` string type annotation, [#3401](https://github.com/pydantic/pydantic/pull/3401) by [@uriyyo](https://github.com/uriyyo)\n* Mention Python >= 3.9.2 as an alternative to `typing_extensions.TypedDict`, [#3374](https://github.com/pydantic/pydantic/pull/3374) by [@BvB93](https://github.com/BvB93)\n* Changed the validator method name in the [Custom Errors example](https://docs.pydantic.dev/usage/models/#custom-errors)\n  to more accurately describe what the validator is doing; changed from `name_must_contain_space` to `value_must_equal_bar`, [#3327](https://github.com/pydantic/pydantic/pull/3327) by [@michaelrios28](https://github.com/michaelrios28)\n* Add `AmqpDsn` class, [#3254](https://github.com/pydantic/pydantic/pull/3254) by [@kludex](https://github.com/kludex)\n* Always use `Enum` value as default in generated JSON schema, [#3190](https://github.com/pydantic/pydantic/pull/3190) by [@joaommartins](https://github.com/joaommartins)\n* Add support for Mypy 0.920, [#3175](https://github.com/pydantic/pydantic/pull/3175) by [@christianbundy](https://github.com/christianbundy)\n* `validate_arguments` now supports `extra` customization (used to always be `Extra.forbid`), [#3161](https://github.com/pydantic/pydantic/pull/3161) by [@PrettyWood](https://github.com/PrettyWood)\n* Complex types can be set by nested environment variables, [#3159](https://github.com/pydantic/pydantic/pull/3159) by [@Air-Mark](https://github.com/Air-Mark)\n* Fix mypy plugin to collect fields based on `pydantic.utils.is_valid_field` so that it ignores untyped private variables, [#3146](https://github.com/pydantic/pydantic/pull/3146) by [@hi-ogawa](https://github.com/hi-ogawa)\n* fix `validate_arguments` issue with `Config.validate_all`, [#3135](https://github.com/pydantic/pydantic/pull/3135) by [@PrettyWood](https://github.com/PrettyWood)\n* avoid dict coercion when using dict subclasses as field type, [#3122](https://github.com/pydantic/pydantic/pull/3122) by [@PrettyWood](https://github.com/PrettyWood)\n* add support for `object` type, [#3062](https://github.com/pydantic/pydantic/pull/3062) by [@PrettyWood](https://github.com/PrettyWood)\n* Updates pydantic dataclasses to keep `_special` properties on parent classes, [#3043](https://github.com/pydantic/pydantic/pull/3043) by [@zulrang](https://github.com/zulrang)\n* Add a `TypedDict` class for error objects, [#3038](https://github.com/pydantic/pydantic/pull/3038) by [@matthewhughes934](https://github.com/matthewhughes934)\n* Fix support for using a subclass of an annotation as a default, [#3018](https://github.com/pydantic/pydantic/pull/3018) by [@JacobHayes](https://github.com/JacobHayes)\n* make `create_model_from_typeddict` mypy compliant, [#3008](https://github.com/pydantic/pydantic/pull/3008) by [@PrettyWood](https://github.com/PrettyWood)\n* Make multiple inheritance work when using `PrivateAttr`, [#2989](https://github.com/pydantic/pydantic/pull/2989) by [@hmvp](https://github.com/hmvp)\n* Parse environment variables as JSON, if they have a `Union` type with a complex subfield, [#2936](https://github.com/pydantic/pydantic/pull/2936) by [@cbartz](https://github.com/cbartz)\n* Prevent `StrictStr` permitting `Enum` values where the enum inherits from `str`, [#2929](https://github.com/pydantic/pydantic/pull/2929) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Make `SecretsSettingsSource` parse values being assigned to fields of complex types when sourced from a secrets file,\n  just as when sourced from environment variables, [#2917](https://github.com/pydantic/pydantic/pull/2917) by [@davidmreed](https://github.com/davidmreed)\n* add a dark mode to *pydantic* documentation, [#2913](https://github.com/pydantic/pydantic/pull/2913) by [@gbdlin](https://github.com/gbdlin)\n* Make `pydantic-mypy` plugin compatible with `pyproject.toml` configuration, consistent with `mypy` changes.\n  See the [doc](https://docs.pydantic.dev/mypy_plugin/#configuring-the-plugin) for more information, [#2908](https://github.com/pydantic/pydantic/pull/2908) by [@jrwalk](https://github.com/jrwalk)\n* add Python 3.10 support, [#2885](https://github.com/pydantic/pydantic/pull/2885) by [@PrettyWood](https://github.com/PrettyWood)\n* Correctly parse generic models with `Json[T]`, [#2860](https://github.com/pydantic/pydantic/pull/2860) by [@geekingfrog](https://github.com/geekingfrog)\n* Update contrib docs re: Python version to use for building docs, [#2856](https://github.com/pydantic/pydantic/pull/2856) by [@paxcodes](https://github.com/paxcodes)\n* Clarify documentation about *pydantic*'s support for custom validation and strict type checking,\n  despite *pydantic* being primarily a parsing library, [#2855](https://github.com/pydantic/pydantic/pull/2855) by [@paxcodes](https://github.com/paxcodes)\n* Fix schema generation for `Deque` fields, [#2810](https://github.com/pydantic/pydantic/pull/2810) by [@sergejkozin](https://github.com/sergejkozin)\n* fix an edge case when mixing constraints and `Literal`, [#2794](https://github.com/pydantic/pydantic/pull/2794) by [@PrettyWood](https://github.com/PrettyWood)\n* Fix postponed annotation resolution for `NamedTuple` and `TypedDict` when they're used directly as the type of fields\n  within Pydantic models, [#2760](https://github.com/pydantic/pydantic/pull/2760) by [@jameysharp](https://github.com/jameysharp)\n* Fix bug when `mypy` plugin fails on `construct` method call for `BaseSettings` derived classes, [#2753](https://github.com/pydantic/pydantic/pull/2753) by [@uriyyo](https://github.com/uriyyo)\n* Add function overloading for a `pydantic.create_model` function, [#2748](https://github.com/pydantic/pydantic/pull/2748) by [@uriyyo](https://github.com/uriyyo)\n* Fix mypy plugin issue with self field declaration, [#2743](https://github.com/pydantic/pydantic/pull/2743) by [@uriyyo](https://github.com/uriyyo)\n* The colon at the end of the line \"The fields which were supplied when user was initialised:\" suggests that the code following it is related.\n  Changed it to a period, [#2733](https://github.com/pydantic/pydantic/pull/2733) by [@krisaoe](https://github.com/krisaoe)\n* Renamed variable `schema` to `schema_` to avoid shadowing of global variable name, [#2724](https://github.com/pydantic/pydantic/pull/2724) by [@shahriyarr](https://github.com/shahriyarr)\n* Add support for autocomplete in VS Code via `__dataclass_transform__`, [#2721](https://github.com/pydantic/pydantic/pull/2721) by [@tiangolo](https://github.com/tiangolo)\n* add missing type annotations in `BaseConfig` and handle `max_length = 0`, [#2719](https://github.com/pydantic/pydantic/pull/2719) by [@PrettyWood](https://github.com/PrettyWood)\n* Change `orm_mode` checking to allow recursive ORM mode parsing with dicts, [#2718](https://github.com/pydantic/pydantic/pull/2718) by [@nuno-andre](https://github.com/nuno-andre)\n* Add episode 313 of the *Talk Python To Me* podcast, where Michael Kennedy and Samuel Colvin discuss Pydantic, to the docs, [#2712](https://github.com/pydantic/pydantic/pull/2712) by [@RatulMaharaj](https://github.com/RatulMaharaj)\n* fix JSON schema generation when a field is of type `NamedTuple` and has a default value, [#2707](https://github.com/pydantic/pydantic/pull/2707) by [@PrettyWood](https://github.com/PrettyWood)\n* `Enum` fields now properly support extra kwargs in schema generation, [#2697](https://github.com/pydantic/pydantic/pull/2697) by [@sammchardy](https://github.com/sammchardy)\n* **Breaking Change, see [#3780](https://github.com/pydantic/pydantic/pull/3780)**: Make serialization of referenced pydantic models possible, [#2650](https://github.com/pydantic/pydantic/pull/2650) by [@PrettyWood](https://github.com/PrettyWood)\n* Add `uniqueItems` option to `ConstrainedList`, [#2618](https://github.com/pydantic/pydantic/pull/2618) by [@nuno-andre](https://github.com/nuno-andre)\n* Try to evaluate forward refs automatically at model creation, [#2588](https://github.com/pydantic/pydantic/pull/2588) by [@uriyyo](https://github.com/uriyyo)\n* Switch docs preview and coverage display to use [smokeshow](https://smokeshow.helpmanual.io/), [#2580](https://github.com/pydantic/pydantic/pull/2580) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Add `__version__` attribute to pydantic module, [#2572](https://github.com/pydantic/pydantic/pull/2572) by [@paxcodes](https://github.com/paxcodes)\n* Add `postgresql+asyncpg`, `postgresql+pg8000`, `postgresql+psycopg2`, `postgresql+psycopg2cffi`, `postgresql+py-postgresql`\n  and `postgresql+pygresql` schemes for `PostgresDsn`, [#2567](https://github.com/pydantic/pydantic/pull/2567) by [@postgres-asyncpg](https://github.com/postgres-asyncpg)\n* Enable the Hypothesis plugin to generate a constrained decimal when the `decimal_places` argument is specified, [#2524](https://github.com/pydantic/pydantic/pull/2524) by [@cwe5590](https://github.com/cwe5590)\n* Allow `collections.abc.Callable` to be used as type in Python 3.9, [#2519](https://github.com/pydantic/pydantic/pull/2519) by [@daviskirk](https://github.com/daviskirk)\n* Documentation update how to custom compile pydantic when using pip install, small change in `setup.py`\n  to allow for custom CFLAGS when compiling, [#2517](https://github.com/pydantic/pydantic/pull/2517) by [@peterroelants](https://github.com/peterroelants)\n* remove side effect of `default_factory` to run it only once even if `Config.validate_all` is set, [#2515](https://github.com/pydantic/pydantic/pull/2515) by [@PrettyWood](https://github.com/PrettyWood)\n* Add lookahead to ip regexes for `AnyUrl` hosts. This allows urls with DNS labels\n  looking like IPs to validate as they are perfectly valid host names, [#2512](https://github.com/pydantic/pydantic/pull/2512) by [@sbv-csis](https://github.com/sbv-csis)\n* Set `minItems` and `maxItems` in generated JSON schema for fixed-length tuples, [#2497](https://github.com/pydantic/pydantic/pull/2497) by [@PrettyWood](https://github.com/PrettyWood)\n* Add `strict` argument to `conbytes`, [#2489](https://github.com/pydantic/pydantic/pull/2489) by [@koxudaxi](https://github.com/koxudaxi)\n* Support user defined generic field types in generic models, [#2465](https://github.com/pydantic/pydantic/pull/2465) by [@daviskirk](https://github.com/daviskirk)\n* Add an example and a short explanation of subclassing `GetterDict` to docs, [#2463](https://github.com/pydantic/pydantic/pull/2463) by [@nuno-andre](https://github.com/nuno-andre)\n* add `KafkaDsn` type, `HttpUrl` now has default port 80 for http and 443 for https, [#2447](https://github.com/pydantic/pydantic/pull/2447) by [@MihanixA](https://github.com/MihanixA)\n* Add `PastDate` and `FutureDate` types, [#2425](https://github.com/pydantic/pydantic/pull/2425) by [@Kludex](https://github.com/Kludex)\n* Support generating schema for `Generic` fields with subtypes, [#2375](https://github.com/pydantic/pydantic/pull/2375) by [@maximberg](https://github.com/maximberg)\n* fix(encoder): serialize `NameEmail` to str, [#2341](https://github.com/pydantic/pydantic/pull/2341) by [@alecgerona](https://github.com/alecgerona)\n* add `Config.smart_union` to prevent coercion in `Union` if possible, see\n  [the doc](https://docs.pydantic.dev/usage/model_config/#smart-union) for more information, [#2092](https://github.com/pydantic/pydantic/pull/2092) by [@PrettyWood](https://github.com/PrettyWood)\n* Add ability to use `typing.Counter` as a model field type, [#2060](https://github.com/pydantic/pydantic/pull/2060) by [@uriyyo](https://github.com/uriyyo)\n* Add parameterised subclasses to `__bases__` when constructing new parameterised classes, so that `A <: B => A[int] <: B[int]`, [#2007](https://github.com/pydantic/pydantic/pull/2007) by [@diabolo-dan](https://github.com/diabolo-dan)\n* Create `FileUrl` type that allows URLs that conform to [RFC 8089](https://tools.ietf.org/html/rfc8089#section-2).\n  Add `host_required` parameter, which is `True` by default (`AnyUrl` and subclasses), `False` in `RedisDsn`, `FileUrl`, [#1983](https://github.com/pydantic/pydantic/pull/1983) by [@vgerak](https://github.com/vgerak)\n* add `confrozenset()`, analogous to `conset()` and `conlist()`, [#1897](https://github.com/pydantic/pydantic/pull/1897) by [@PrettyWood](https://github.com/PrettyWood)\n* stop calling parent class `root_validator` if overridden, [#1895](https://github.com/pydantic/pydantic/pull/1895) by [@PrettyWood](https://github.com/PrettyWood)\n* Add `repr` (defaults to `True`) parameter to `Field`, to hide it from the default representation of the `BaseModel`, [#1831](https://github.com/pydantic/pydantic/pull/1831) by [@fnep](https://github.com/fnep)\n* Accept empty query/fragment URL parts, [#1807](https://github.com/pydantic/pydantic/pull/1807) by [@xavier](https://github.com/xavier)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v190a1-2021-12-18-changesindexhtmlv190a1-2021-12-18-changes-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.8.2 (2021-05-11)[Â¶](index.html#v182-2021-05-11 \"Permanent link\")", "anchor": "v182-2021-05-11indexhtmlv182-2021-05-11-permanent-link", "md_text": "A security vulnerability, level \"moderate\" is fixed in v1.8.2. Please upgrade **ASAP**.\nSee security advisory [CVE-2021-29510](https://github.com/pydantic/pydantic/security/advisories/GHSA-5jqp-qgf6-3pvh)\n\n* **Security fix:** Fix `date` and `datetime` parsing so passing either `'infinity'` or `float('inf')`\n  (or their negative values) does not cause an infinite loop,\n  see security advisory [CVE-2021-29510](https://github.com/pydantic/pydantic/security/advisories/GHSA-5jqp-qgf6-3pvh)\n* fix schema generation with Enum by generating a valid name, [#2575](https://github.com/pydantic/pydantic/pull/2575) by [@PrettyWood](https://github.com/PrettyWood)\n* fix JSON schema generation with a `Literal` of an enum member, [#2536](https://github.com/pydantic/pydantic/pull/2536) by [@PrettyWood](https://github.com/PrettyWood)\n* Fix bug with configurations declarations that are passed as\n  keyword arguments during class creation, [#2532](https://github.com/pydantic/pydantic/pull/2532) by [@uriyyo](https://github.com/uriyyo)\n* Allow passing `json_encoders` in class kwargs, [#2521](https://github.com/pydantic/pydantic/pull/2521) by [@layday](https://github.com/layday)\n* support arbitrary types with custom `__eq__`, [#2483](https://github.com/pydantic/pydantic/pull/2483) by [@PrettyWood](https://github.com/PrettyWood)\n* support `Annotated` in `validate_arguments` and in generic models with Python 3.9, [#2483](https://github.com/pydantic/pydantic/pull/2483) by [@PrettyWood](https://github.com/PrettyWood)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v182-2021-05-11indexhtmlv182-2021-05-11-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.8.1 (2021-03-03)[Â¶](index.html#v181-2021-03-03 \"Permanent link\")", "anchor": "v181-2021-03-03indexhtmlv181-2021-03-03-permanent-link", "md_text": "Bug fixes for regressions and new features from `v1.8`\n\n* allow elements of `Config.field` to update elements of a `Field`, [#2461](https://github.com/pydantic/pydantic/pull/2461) by [@samuelcolvin](https://github.com/samuelcolvin)\n* fix validation with a `BaseModel` field and a custom root type, [#2449](https://github.com/pydantic/pydantic/pull/2449) by [@PrettyWood](https://github.com/PrettyWood)\n* expose `Pattern` encoder to `fastapi`, [#2444](https://github.com/pydantic/pydantic/pull/2444) by [@PrettyWood](https://github.com/PrettyWood)\n* enable the Hypothesis plugin to generate a constrained float when the `multiple_of` argument is specified, [#2442](https://github.com/pydantic/pydantic/pull/2442) by [@tobi-lipede-oodle](https://github.com/tobi-lipede-oodle)\n* Avoid `RecursionError` when using some types like `Enum` or `Literal` with generic models, [#2436](https://github.com/pydantic/pydantic/pull/2436) by [@PrettyWood](https://github.com/PrettyWood)\n* do not overwrite declared `__hash__` in subclasses of a model, [#2422](https://github.com/pydantic/pydantic/pull/2422) by [@PrettyWood](https://github.com/PrettyWood)\n* fix `mypy` complaints on `Path` and `UUID` related custom types, [#2418](https://github.com/pydantic/pydantic/pull/2418) by [@PrettyWood](https://github.com/PrettyWood)\n* Support properly variable length tuples of compound types, [#2416](https://github.com/pydantic/pydantic/pull/2416) by [@PrettyWood](https://github.com/PrettyWood)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v181-2021-03-03indexhtmlv181-2021-03-03-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.8 (2021-02-26)[Â¶](index.html#v18-2021-02-26 \"Permanent link\")", "anchor": "v18-2021-02-26indexhtmlv18-2021-02-26-permanent-link", "md_text": "Thank you to pydantic's sponsors:\n[@jorgecarleitao](https://github.com/jorgecarleitao), [@BCarley](https://github.com/BCarley), [@chdsbd](https://github.com/chdsbd), [@tiangolo](https://github.com/tiangolo), [@matin](https://github.com/matin), [@linusg](https://github.com/linusg), [@kevinalh](https://github.com/kevinalh), [@koxudaxi](https://github.com/koxudaxi), [@timdrijvers](https://github.com/timdrijvers), [@mkeen](https://github.com/mkeen), [@meadsteve](https://github.com/meadsteve),\n[@ginomempin](https://github.com/ginomempin), [@primer-io](https://github.com/primer-io), [@and-semakin](https://github.com/and-semakin), [@tomthorogood](https://github.com/tomthorogood), [@AjitZK](https://github.com/AjitZK), [@westonsteimel](https://github.com/westonsteimel), [@Mazyod](https://github.com/Mazyod), [@christippett](https://github.com/christippett), [@CarlosDomingues](https://github.com/CarlosDomingues),\n[@Kludex](https://github.com/Kludex), [@r-m-n](https://github.com/r-m-n)\nfor their kind support.", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v18-2021-02-26indexhtmlv18-2021-02-26-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "Highlights[Â¶](index.html#highlights_1 \"Permanent link\")", "anchor": "highlightsindexhtmlhighlights1-permanent-link", "md_text": "* [Hypothesis plugin](https://docs.pydantic.dev/hypothesis_plugin/) for testing, [#2097](https://github.com/pydantic/pydantic/pull/2097) by [@Zac-HD](https://github.com/Zac-HD)\n* support for [`NamedTuple` and `TypedDict`](https://docs.pydantic.dev/usage/types/#annotated-types), [#2216](https://github.com/pydantic/pydantic/pull/2216) by [@PrettyWood](https://github.com/PrettyWood)\n* Support [`Annotated` hints on model fields](https://docs.pydantic.dev/usage/schema/#typingannotated-fields), [#2147](https://github.com/pydantic/pydantic/pull/2147) by [@JacobHayes](https://github.com/JacobHayes)\n* [`frozen` parameter on `Config`](https://docs.pydantic.dev/usage/model_config/) to allow models to be hashed, [#1880](https://github.com/pydantic/pydantic/pull/1880) by [@rhuille](https://github.com/rhuille)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#highlightsindexhtmlhighlights1-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "Changes[Â¶](index.html#changes_13 \"Permanent link\")", "anchor": "changesindexhtmlchanges13-permanent-link", "md_text": "* **Breaking Change**, remove old deprecation aliases from v1, [#2415](https://github.com/pydantic/pydantic/pull/2415) by [@samuelcolvin](https://github.com/samuelcolvin):\n  + remove notes on migrating to v1 in docs\n  + remove `Schema` which was replaced by `Field`\n  + remove `Config.case_insensitive` which was replaced by `Config.case_sensitive` (default `False`)\n  + remove `Config.allow_population_by_alias` which was replaced by `Config.allow_population_by_field_name`\n  + remove `model.fields` which was replaced by `model.__fields__`\n  + remove `model.to_string()` which was replaced by `str(model)`\n  + remove `model.__values__` which was replaced by `model.__dict__`\n* **Breaking Change:** always validate only first sublevel items with `each_item`.\n  There were indeed some edge cases with some compound types where the validated items were the last sublevel ones, [#1933](https://github.com/pydantic/pydantic/pull/1933) by [@PrettyWood](https://github.com/PrettyWood)\n* Update docs extensions to fix local syntax highlighting, [#2400](https://github.com/pydantic/pydantic/pull/2400) by [@daviskirk](https://github.com/daviskirk)\n* fix: allow `utils.lenient_issubclass` to handle `typing.GenericAlias` objects like `list[str]` in Python >= 3.9, [#2399](https://github.com/pydantic/pydantic/pull/2399) by [@daviskirk](https://github.com/daviskirk)\n* Improve field declaration for *pydantic* `dataclass` by allowing the usage of *pydantic* `Field` or `'metadata'` kwarg of `dataclasses.field`, [#2384](https://github.com/pydantic/pydantic/pull/2384) by [@PrettyWood](https://github.com/PrettyWood)\n* Making `typing-extensions` a required dependency, [#2368](https://github.com/pydantic/pydantic/pull/2368) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Make `resolve_annotations` more lenient, allowing for missing modules, [#2363](https://github.com/pydantic/pydantic/pull/2363) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Allow configuring models through class kwargs, [#2356](https://github.com/pydantic/pydantic/pull/2356) by [@Bobronium](https://github.com/Bobronium)\n* Prevent `Mapping` subclasses from always being coerced to `dict`, [#2325](https://github.com/pydantic/pydantic/pull/2325) by [@ofek](https://github.com/ofek)\n* fix: allow `None` for type `Optional[conset / conlist]`, [#2320](https://github.com/pydantic/pydantic/pull/2320) by [@PrettyWood](https://github.com/PrettyWood)\n* Support empty tuple type, [#2318](https://github.com/pydantic/pydantic/pull/2318) by [@PrettyWood](https://github.com/PrettyWood)\n* fix: `python_requires` metadata to require >=3.6.1, [#2306](https://github.com/pydantic/pydantic/pull/2306) by [@hukkinj1](https://github.com/hukkinj1)\n* Properly encode `Decimal` with, or without any decimal places, [#2293](https://github.com/pydantic/pydantic/pull/2293) by [@hultner](https://github.com/hultner)\n* fix: update `__fields_set__` in `BaseModel.copy(update=â€¦)`, [#2290](https://github.com/pydantic/pydantic/pull/2290) by [@PrettyWood](https://github.com/PrettyWood)\n* fix: keep order of fields with `BaseModel.construct()`, [#2281](https://github.com/pydantic/pydantic/pull/2281) by [@PrettyWood](https://github.com/PrettyWood)\n* Support generating schema for Generic fields, [#2262](https://github.com/pydantic/pydantic/pull/2262) by [@maximberg](https://github.com/maximberg)\n* Fix `validate_decorator` so `**kwargs` doesn't exclude values when the keyword\n  has the same name as the `*args` or `**kwargs` names, [#2251](https://github.com/pydantic/pydantic/pull/2251) by [@cybojenix](https://github.com/cybojenix)\n* Prevent overriding positional arguments with keyword arguments in\n  `validate_arguments`, as per behaviour with native functions, [#2249](https://github.com/pydantic/pydantic/pull/2249) by [@cybojenix](https://github.com/cybojenix)\n* add documentation for `con*` type functions, [#2242](https://github.com/pydantic/pydantic/pull/2242) by [@tayoogunbiyi](https://github.com/tayoogunbiyi)\n* Support custom root type (aka `__root__`) when using `parse_obj()` with nested models, [#2238](https://github.com/pydantic/pydantic/pull/2238) by [@PrettyWood](https://github.com/PrettyWood)\n* Support custom root type (aka `__root__`) with `from_orm()`, [#2237](https://github.com/pydantic/pydantic/pull/2237) by [@PrettyWood](https://github.com/PrettyWood)\n* ensure cythonized functions are left untouched when creating models, based on [#1944](https://github.com/pydantic/pydantic/pull/1944) by [@kollmats](https://github.com/kollmats), [#2228](https://github.com/pydantic/pydantic/pull/2228) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Resolve forward refs for stdlib dataclasses converted into *pydantic* ones, [#2220](https://github.com/pydantic/pydantic/pull/2220) by [@PrettyWood](https://github.com/PrettyWood)\n* Add support for `NamedTuple` and `TypedDict` types.\n  Those two types are now handled and validated when used inside `BaseModel` or *pydantic* `dataclass`.\n  Two utils are also added `create_model_from_namedtuple` and `create_model_from_typeddict`, [#2216](https://github.com/pydantic/pydantic/pull/2216) by [@PrettyWood](https://github.com/PrettyWood)\n* Do not ignore annotated fields when type is `Union[Type[...], ...]`, [#2213](https://github.com/pydantic/pydantic/pull/2213) by [@PrettyWood](https://github.com/PrettyWood)\n* Raise a user-friendly `TypeError` when a `root_validator` does not return a `dict` (e.g. `None`), [#2209](https://github.com/pydantic/pydantic/pull/2209) by [@masalim2](https://github.com/masalim2)\n* Add a `FrozenSet[str]` type annotation to the `allowed_schemes` argument on the `strict_url` field type, [#2198](https://github.com/pydantic/pydantic/pull/2198) by [@Midnighter](https://github.com/Midnighter)\n* add `allow_mutation` constraint to `Field`, [#2195](https://github.com/pydantic/pydantic/pull/2195) by [@sblack-usu](https://github.com/sblack-usu)\n* Allow `Field` with a `default_factory` to be used as an argument to a function\n  decorated with `validate_arguments`, [#2176](https://github.com/pydantic/pydantic/pull/2176) by [@thomascobb](https://github.com/thomascobb)\n* Allow non-existent secrets directory by only issuing a warning, [#2175](https://github.com/pydantic/pydantic/pull/2175) by [@davidolrik](https://github.com/davidolrik)\n* fix URL regex to parse fragment without query string, [#2168](https://github.com/pydantic/pydantic/pull/2168) by [@andrewmwhite](https://github.com/andrewmwhite)\n* fix: ensure to always return one of the values in `Literal` field type, [#2166](https://github.com/pydantic/pydantic/pull/2166) by [@PrettyWood](https://github.com/PrettyWood)\n* Support `typing.Annotated` hints on model fields. A `Field` may now be set in the type hint with `Annotated[..., Field(...)`; all other annotations are ignored but still visible with `get_type_hints(..., include_extras=True)`, [#2147](https://github.com/pydantic/pydantic/pull/2147) by [@JacobHayes](https://github.com/JacobHayes)\n* Added `StrictBytes` type as well as `strict=False` option to `ConstrainedBytes`, [#2136](https://github.com/pydantic/pydantic/pull/2136) by [@rlizzo](https://github.com/rlizzo)\n* added `Config.anystr_lower` and `to_lower` kwarg to `constr` and `conbytes`, [#2134](https://github.com/pydantic/pydantic/pull/2134) by [@tayoogunbiyi](https://github.com/tayoogunbiyi)\n* Support plain `typing.Tuple` type, [#2132](https://github.com/pydantic/pydantic/pull/2132) by [@PrettyWood](https://github.com/PrettyWood)\n* Add a bound method `validate` to functions decorated with `validate_arguments`\n  to validate parameters without actually calling the function, [#2127](https://github.com/pydantic/pydantic/pull/2127) by [@PrettyWood](https://github.com/PrettyWood)\n* Add the ability to customize settings sources (add / disable / change priority order), [#2107](https://github.com/pydantic/pydantic/pull/2107) by [@kozlek](https://github.com/kozlek)\n* Fix mypy complaints about most custom *pydantic* types, [#2098](https://github.com/pydantic/pydantic/pull/2098) by [@PrettyWood](https://github.com/PrettyWood)\n* Add a [Hypothesis](https://hypothesis.readthedocs.io/) plugin for easier [property-based testing](https://increment.com/testing/in-praise-of-property-based-testing/) with Pydantic's custom types - [usage details here](https://docs.pydantic.dev/hypothesis_plugin/), [#2097](https://github.com/pydantic/pydantic/pull/2097) by [@Zac-HD](https://github.com/Zac-HD)\n* add validator for `None`, `NoneType` or `Literal[None]`, [#2095](https://github.com/pydantic/pydantic/pull/2095) by [@PrettyWood](https://github.com/PrettyWood)\n* Handle properly fields of type `Callable` with a default value, [#2094](https://github.com/pydantic/pydantic/pull/2094) by [@PrettyWood](https://github.com/PrettyWood)\n* Updated `create_model` return type annotation to return type which inherits from `__base__` argument, [#2071](https://github.com/pydantic/pydantic/pull/2071) by [@uriyyo](https://github.com/uriyyo)\n* Add merged `json_encoders` inheritance, [#2064](https://github.com/pydantic/pydantic/pull/2064) by [@art049](https://github.com/art049)\n* allow overwriting `ClassVar`s in sub-models without having to re-annotate them, [#2061](https://github.com/pydantic/pydantic/pull/2061) by [@layday](https://github.com/layday)\n* add default encoder for `Pattern` type, [#2045](https://github.com/pydantic/pydantic/pull/2045) by [@PrettyWood](https://github.com/PrettyWood)\n* Add `NonNegativeInt`, `NonPositiveInt`, `NonNegativeFloat`, `NonPositiveFloat`, [#1975](https://github.com/pydantic/pydantic/pull/1975) by [@mdavis-xyz](https://github.com/mdavis-xyz)\n* Use % for percentage in string format of colors, [#1960](https://github.com/pydantic/pydantic/pull/1960) by [@EdwardBetts](https://github.com/EdwardBetts)\n* Fixed issue causing `KeyError` to be raised when building schema from multiple `BaseModel` with the same names declared in separate classes, [#1912](https://github.com/pydantic/pydantic/pull/1912) by [@JSextonn](https://github.com/JSextonn)\n* Add `rediss` (Redis over SSL) protocol to `RedisDsn`\n  Allow URLs without `user` part (e.g., `rediss://:pass@localhost`), [#1911](https://github.com/pydantic/pydantic/pull/1911) by [@TrDex](https://github.com/TrDex)\n* Add a new `frozen` boolean parameter to `Config` (default: `False`).\n  Setting `frozen=True` does everything that `allow_mutation=False` does, and also generates a `__hash__()` method for the model. This makes instances of the model potentially hashable if all the attributes are hashable, [#1880](https://github.com/pydantic/pydantic/pull/1880) by [@rhuille](https://github.com/rhuille)\n* fix schema generation with multiple Enums having the same name, [#1857](https://github.com/pydantic/pydantic/pull/1857) by [@PrettyWood](https://github.com/PrettyWood)\n* Added support for 13/19 digits VISA credit cards in `PaymentCardNumber` type, [#1416](https://github.com/pydantic/pydantic/pull/1416) by [@AlexanderSov](https://github.com/AlexanderSov)\n* fix: prevent `RecursionError` while using recursive `GenericModel`s, [#1370](https://github.com/pydantic/pydantic/pull/1370) by [@xppt](https://github.com/xppt)\n* use `enum` for `typing.Literal` in JSON schema, [#1350](https://github.com/pydantic/pydantic/pull/1350) by [@PrettyWood](https://github.com/PrettyWood)\n* Fix: some recursive models did not require `update_forward_refs` and silently behaved incorrectly, [#1201](https://github.com/pydantic/pydantic/pull/1201) by [@PrettyWood](https://github.com/PrettyWood)\n* Fix bug where generic models with fields where the typevar is nested in another type `a: List[T]` are considered to be concrete. This allows these models to be subclassed and composed as expected, [#947](https://github.com/pydantic/pydantic/pull/947) by [@daviskirk](https://github.com/daviskirk)\n* Add `Config.copy_on_model_validation` flag. When set to `False`, *pydantic* will keep models used as fields\n  untouched on validation instead of reconstructing (copying) them, [#265](https://github.com/pydantic/pydantic/pull/265) by [@PrettyWood](https://github.com/PrettyWood)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#changesindexhtmlchanges13-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.7.4 (2021-05-11)[Â¶](index.html#v174-2021-05-11 \"Permanent link\")", "anchor": "v174-2021-05-11indexhtmlv174-2021-05-11-permanent-link", "md_text": "* **Security fix:** Fix `date` and `datetime` parsing so passing either `'infinity'` or `float('inf')`\n  (or their negative values) does not cause an infinite loop,\n  See security advisory [CVE-2021-29510](https://github.com/pydantic/pydantic/security/advisories/GHSA-5jqp-qgf6-3pvh)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v174-2021-05-11indexhtmlv174-2021-05-11-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.7.3 (2020-11-30)[Â¶](index.html#v173-2020-11-30 \"Permanent link\")", "anchor": "v173-2020-11-30indexhtmlv173-2020-11-30-permanent-link", "md_text": "Thank you to pydantic's sponsors:\n[@timdrijvers](https://github.com/timdrijvers), [@BCarley](https://github.com/BCarley), [@chdsbd](https://github.com/chdsbd), [@tiangolo](https://github.com/tiangolo), [@matin](https://github.com/matin), [@linusg](https://github.com/linusg), [@kevinalh](https://github.com/kevinalh), [@jorgecarleitao](https://github.com/jorgecarleitao), [@koxudaxi](https://github.com/koxudaxi), [@primer-api](https://github.com/primer-api),\n[@mkeen](https://github.com/mkeen), [@meadsteve](https://github.com/meadsteve) for their kind support.\n\n* fix: set right default value for required (optional) fields, [#2142](https://github.com/pydantic/pydantic/pull/2142) by [@PrettyWood](https://github.com/PrettyWood)\n* fix: support `underscore_attrs_are_private` with generic models, [#2138](https://github.com/pydantic/pydantic/pull/2138) by [@PrettyWood](https://github.com/PrettyWood)\n* fix: update all modified field values in `root_validator` when `validate_assignment` is on, [#2116](https://github.com/pydantic/pydantic/pull/2116) by [@PrettyWood](https://github.com/PrettyWood)\n* Allow pickling of `pydantic.dataclasses.dataclass` dynamically created from a built-in `dataclasses.dataclass`, [#2111](https://github.com/pydantic/pydantic/pull/2111) by [@aimestereo](https://github.com/aimestereo)\n* Fix a regression where Enum fields would not propagate keyword arguments to the schema, [#2109](https://github.com/pydantic/pydantic/pull/2109) by [@bm424](https://github.com/bm424)\n* Ignore `__doc__` as private attribute when `Config.underscore_attrs_are_private` is set, [#2090](https://github.com/pydantic/pydantic/pull/2090) by [@PrettyWood](https://github.com/PrettyWood)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v173-2020-11-30indexhtmlv173-2020-11-30-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.7.2 (2020-11-01)[Â¶](index.html#v172-2020-11-01 \"Permanent link\")", "anchor": "v172-2020-11-01indexhtmlv172-2020-11-01-permanent-link", "md_text": "* fix slow `GenericModel` concrete model creation, allow `GenericModel` concrete name reusing in module, [#2078](https://github.com/pydantic/pydantic/pull/2078) by [@Bobronium](https://github.com/Bobronium)\n* keep the order of the fields when `validate_assignment` is set, [#2073](https://github.com/pydantic/pydantic/pull/2073) by [@PrettyWood](https://github.com/PrettyWood)\n* forward all the params of the stdlib `dataclass` when converted into *pydantic* `dataclass`, [#2065](https://github.com/pydantic/pydantic/pull/2065) by [@PrettyWood](https://github.com/PrettyWood)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v172-2020-11-01indexhtmlv172-2020-11-01-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.7.1 (2020-10-28)[Â¶](index.html#v171-2020-10-28 \"Permanent link\")", "anchor": "v171-2020-10-28indexhtmlv171-2020-10-28-permanent-link", "md_text": "Thank you to pydantic's sponsors:\n[@timdrijvers](https://github.com/timdrijvers), [@BCarley](https://github.com/BCarley), [@chdsbd](https://github.com/chdsbd), [@tiangolo](https://github.com/tiangolo), [@matin](https://github.com/matin), [@linusg](https://github.com/linusg), [@kevinalh](https://github.com/kevinalh), [@jorgecarleitao](https://github.com/jorgecarleitao), [@koxudaxi](https://github.com/koxudaxi), [@primer-api](https://github.com/primer-api), [@mkeen](https://github.com/mkeen)\nfor their kind support.\n\n* fix annotation of `validate_arguments` when passing configuration as argument, [#2055](https://github.com/pydantic/pydantic/pull/2055) by [@layday](https://github.com/layday)\n* Fix mypy assignment error when using `PrivateAttr`, [#2048](https://github.com/pydantic/pydantic/pull/2048) by [@aphedges](https://github.com/aphedges)\n* fix `underscore_attrs_are_private` causing `TypeError` when overriding `__init__`, [#2047](https://github.com/pydantic/pydantic/pull/2047) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Fixed regression introduced in v1.7 involving exception handling in field validators when `validate_assignment=True`, [#2044](https://github.com/pydantic/pydantic/pull/2044) by [@johnsabath](https://github.com/johnsabath)\n* fix: *pydantic* `dataclass` can inherit from stdlib `dataclass`\n  and `Config.arbitrary_types_allowed` is supported, [#2042](https://github.com/pydantic/pydantic/pull/2042) by [@PrettyWood](https://github.com/PrettyWood)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v171-2020-10-28indexhtmlv171-2020-10-28-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.7 (2020-10-26)[Â¶](index.html#v17-2020-10-26 \"Permanent link\")", "anchor": "v17-2020-10-26indexhtmlv17-2020-10-26-permanent-link", "md_text": "Thank you to pydantic's sponsors:\n[@timdrijvers](https://github.com/timdrijvers), [@BCarley](https://github.com/BCarley), [@chdsbd](https://github.com/chdsbd), [@tiangolo](https://github.com/tiangolo), [@matin](https://github.com/matin), [@linusg](https://github.com/linusg), [@kevinalh](https://github.com/kevinalh), [@jorgecarleitao](https://github.com/jorgecarleitao), [@koxudaxi](https://github.com/koxudaxi), [@primer-api](https://github.com/primer-api)\nfor their kind support.", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v17-2020-10-26indexhtmlv17-2020-10-26-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "Highlights[Â¶](index.html#highlights_2 \"Permanent link\")", "anchor": "highlightsindexhtmlhighlights2-permanent-link", "md_text": "* Python 3.9 support, thanks [@PrettyWood](https://github.com/PrettyWood)\n* [Private model attributes](https://docs.pydantic.dev/usage/models/#private-model-attributes), thanks [@Bobronium](https://github.com/Bobronium)\n* [\"secrets files\" support in `BaseSettings`](https://docs.pydantic.dev/usage/settings/#secret-support), thanks [@mdgilene](https://github.com/mdgilene)\n* [convert stdlib dataclasses to pydantic dataclasses and use stdlib dataclasses in models](https://docs.pydantic.dev/usage/dataclasses/#stdlib-dataclasses-and-pydantic-dataclasses), thanks [@PrettyWood](https://github.com/PrettyWood)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#highlightsindexhtmlhighlights2-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "Changes[Â¶](index.html#changes_14 \"Permanent link\")", "anchor": "changesindexhtmlchanges14-permanent-link", "md_text": "* **Breaking Change:** remove `__field_defaults__`, add `default_factory` support with `BaseModel.construct`.\n  Use `.get_default()` method on fields in `__fields__` attribute instead, [#1732](https://github.com/pydantic/pydantic/pull/1732) by [@PrettyWood](https://github.com/PrettyWood)\n* Rearrange CI to run linting as a separate job, split install recipes for different tasks, [#2020](https://github.com/pydantic/pydantic/pull/2020) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Allows subclasses of generic models to make some, or all, of the superclass's type parameters concrete, while\n  also defining new type parameters in the subclass, [#2005](https://github.com/pydantic/pydantic/pull/2005) by [@choogeboom](https://github.com/choogeboom)\n* Call validator with the correct `values` parameter type in `BaseModel.__setattr__`,\n  when `validate_assignment = True` in model config, [#1999](https://github.com/pydantic/pydantic/pull/1999) by [@me-ransh](https://github.com/me-ransh)\n* Force `fields.Undefined` to be a singleton object, fixing inherited generic model schemas, [#1981](https://github.com/pydantic/pydantic/pull/1981) by [@daviskirk](https://github.com/daviskirk)\n* Include tests in source distributions, [#1976](https://github.com/pydantic/pydantic/pull/1976) by [@sbraz](https://github.com/sbraz)\n* Add ability to use `min_length/max_length` constraints with secret types, [#1974](https://github.com/pydantic/pydantic/pull/1974) by [@uriyyo](https://github.com/uriyyo)\n* Also check `root_validators` when `validate_assignment` is on, [#1971](https://github.com/pydantic/pydantic/pull/1971) by [@PrettyWood](https://github.com/PrettyWood)\n* Fix const validators not running when custom validators are present, [#1957](https://github.com/pydantic/pydantic/pull/1957) by [@hmvp](https://github.com/hmvp)\n* add `deque` to field types, [#1935](https://github.com/pydantic/pydantic/pull/1935) by [@wozniakty](https://github.com/wozniakty)\n* add basic support for Python 3.9, [#1832](https://github.com/pydantic/pydantic/pull/1832) by [@PrettyWood](https://github.com/PrettyWood)\n* Fix typo in the anchor of exporting\\_models.md#modelcopy and incorrect description, [#1821](https://github.com/pydantic/pydantic/pull/1821) by [@KimMachineGun](https://github.com/KimMachineGun)\n* Added ability for `BaseSettings` to read \"secret files\", [#1820](https://github.com/pydantic/pydantic/pull/1820) by [@mdgilene](https://github.com/mdgilene)\n* add `parse_raw_as` utility function, [#1812](https://github.com/pydantic/pydantic/pull/1812) by [@PrettyWood](https://github.com/PrettyWood)\n* Support home directory relative paths for `dotenv` files (e.g. `~/.env`), [#1803](https://github.com/pydantic/pydantic/pull/1803) by [@PrettyWood](https://github.com/PrettyWood)\n* Clarify documentation for `parse_file` to show that the argument\n  should be a file *path* not a file-like object, [#1794](https://github.com/pydantic/pydantic/pull/1794) by [@mdavis-xyz](https://github.com/mdavis-xyz)\n* Fix false positive from mypy plugin when a class nested within a `BaseModel` is named `Model`, [#1770](https://github.com/pydantic/pydantic/pull/1770) by [@selimb](https://github.com/selimb)\n* add basic support of Pattern type in schema generation, [#1767](https://github.com/pydantic/pydantic/pull/1767) by [@PrettyWood](https://github.com/PrettyWood)\n* Support custom title, description and default in schema of enums, [#1748](https://github.com/pydantic/pydantic/pull/1748) by [@PrettyWood](https://github.com/PrettyWood)\n* Properly represent `Literal` Enums when `use_enum_values` is True, [#1747](https://github.com/pydantic/pydantic/pull/1747) by [@noelevans](https://github.com/noelevans)\n* Allows timezone information to be added to strings to be formatted as time objects. Permitted formats are `Z` for UTC\n  or an offset for absolute positive or negative time shifts. Or the timezone data can be omitted, [#1744](https://github.com/pydantic/pydantic/pull/1744) by [@noelevans](https://github.com/noelevans)\n* Add stub `__init__` with Python 3.6 signature for `ForwardRef`, [#1738](https://github.com/pydantic/pydantic/pull/1738) by [@sirtelemak](https://github.com/sirtelemak)\n* Fix behaviour with forward refs and optional fields in nested models, [#1736](https://github.com/pydantic/pydantic/pull/1736) by [@PrettyWood](https://github.com/PrettyWood)\n* add `Enum` and `IntEnum` as valid types for fields, [#1735](https://github.com/pydantic/pydantic/pull/1735) by [@PrettyWood](https://github.com/PrettyWood)\n* Change default value of `__module__` argument of `create_model` from `None` to `'pydantic.main'`.\n  Set reference of created concrete model to it's module to allow pickling (not applied to models created in\n  functions), [#1686](https://github.com/pydantic/pydantic/pull/1686) by [@Bobronium](https://github.com/Bobronium)\n* Add private attributes support, [#1679](https://github.com/pydantic/pydantic/pull/1679) by [@Bobronium](https://github.com/Bobronium)\n* add `config` to `@validate_arguments`, [#1663](https://github.com/pydantic/pydantic/pull/1663) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Allow descendant Settings models to override env variable names for the fields defined in parent Settings models with\n  `env` in their `Config`. Previously only `env_prefix` configuration option was applicable, [#1561](https://github.com/pydantic/pydantic/pull/1561) by [@ojomio](https://github.com/ojomio)\n* Support `ref_template` when creating schema `$ref`s, [#1479](https://github.com/pydantic/pydantic/pull/1479) by [@kilo59](https://github.com/kilo59)\n* Add a `__call__` stub to `PyObject` so that mypy will know that it is callable, [#1352](https://github.com/pydantic/pydantic/pull/1352) by [@brianmaissy](https://github.com/brianmaissy)\n* `pydantic.dataclasses.dataclass` decorator now supports built-in `dataclasses.dataclass`.\n  It is hence possible to convert an existing `dataclass` easily to add Pydantic validation.\n  Moreover nested dataclasses are also supported, [#744](https://github.com/pydantic/pydantic/pull/744) by [@PrettyWood](https://github.com/PrettyWood)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#changesindexhtmlchanges14-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.6.2 (2021-05-11)[Â¶](index.html#v162-2021-05-11 \"Permanent link\")", "anchor": "v162-2021-05-11indexhtmlv162-2021-05-11-permanent-link", "md_text": "* **Security fix:** Fix `date` and `datetime` parsing so passing either `'infinity'` or `float('inf')`\n  (or their negative values) does not cause an infinite loop,\n  See security advisory [CVE-2021-29510](https://github.com/pydantic/pydantic/security/advisories/GHSA-5jqp-qgf6-3pvh)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v162-2021-05-11indexhtmlv162-2021-05-11-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.6.1 (2020-07-15)[Â¶](index.html#v161-2020-07-15 \"Permanent link\")", "anchor": "v161-2020-07-15indexhtmlv161-2020-07-15-permanent-link", "md_text": "* fix validation and parsing of nested models with `default_factory`, [#1710](https://github.com/pydantic/pydantic/pull/1710) by [@PrettyWood](https://github.com/PrettyWood)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v161-2020-07-15indexhtmlv161-2020-07-15-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.6 (2020-07-11)[Â¶](index.html#v16-2020-07-11 \"Permanent link\")", "anchor": "v16-2020-07-11indexhtmlv16-2020-07-11-permanent-link", "md_text": "Thank you to pydantic's sponsors: [@matin](https://github.com/matin), [@tiangolo](https://github.com/tiangolo), [@chdsbd](https://github.com/chdsbd), [@jorgecarleitao](https://github.com/jorgecarleitao), and 1 anonymous sponsor for their kind support.", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v16-2020-07-11indexhtmlv16-2020-07-11-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.6 (2020-07-11)[Â¶](index.html#v16-2020-07-11 \"Permanent link\")", "anchor": "v16-2020-07-11indexhtmlv16-2020-07-11-permanent-link", "md_text": "* Modify validators for `conlist` and `conset` to not have `always=True`, [#1682](https://github.com/pydantic/pydantic/pull/1682) by [@samuelcolvin](https://github.com/samuelcolvin)\n* add port check to `AnyUrl` (can't exceed 65536) ports are 16 unsigned bits: `0 <= port <= 2**16-1` src: [rfc793 header format](https://tools.ietf.org/html/rfc793#section-3.1), [#1654](https://github.com/pydantic/pydantic/pull/1654) by [@flapili](https://github.com/flapili)\n* Document default `regex` anchoring semantics, [#1648](https://github.com/pydantic/pydantic/pull/1648) by [@yurikhan](https://github.com/yurikhan)\n* Use `chain.from_iterable` in class\\_validators.py. This is a faster and more idiomatic way of using `itertools.chain`.\n  Instead of computing all the items in the iterable and storing them in memory, they are computed one-by-one and never\n  stored as a huge list. This can save on both runtime and memory space, [#1642](https://github.com/pydantic/pydantic/pull/1642) by [@cool-RR](https://github.com/cool-RR)\n* Add `conset()`, analogous to `conlist()`, [#1623](https://github.com/pydantic/pydantic/pull/1623) by [@patrickkwang](https://github.com/patrickkwang)\n* make Pydantic errors (un)pickable, [#1616](https://github.com/pydantic/pydantic/pull/1616) by [@PrettyWood](https://github.com/PrettyWood)\n* Allow custom encoding for `dotenv` files, [#1615](https://github.com/pydantic/pydantic/pull/1615) by [@PrettyWood](https://github.com/PrettyWood)\n* Ensure `SchemaExtraCallable` is always defined to get type hints on BaseConfig, [#1614](https://github.com/pydantic/pydantic/pull/1614) by [@PrettyWood](https://github.com/PrettyWood)\n* Update datetime parser to support negative timestamps, [#1600](https://github.com/pydantic/pydantic/pull/1600) by [@mlbiche](https://github.com/mlbiche)\n* Update mypy, remove `AnyType` alias for `Type[Any]`, [#1598](https://github.com/pydantic/pydantic/pull/1598) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Adjust handling of root validators so that errors are aggregated from *all* failing root validators, instead of reporting on only the first root validator to fail, [#1586](https://github.com/pydantic/pydantic/pull/1586) by [@beezee](https://github.com/beezee)\n* Make `__modify_schema__` on Enums apply to the enum schema rather than fields that use the enum, [#1581](https://github.com/pydantic/pydantic/pull/1581) by [@therefromhere](https://github.com/therefromhere)\n* Fix behavior of `__all__` key when used in conjunction with index keys in advanced include/exclude of fields that are sequences, [#1579](https://github.com/pydantic/pydantic/pull/1579) by [@xspirus](https://github.com/xspirus)\n* Subclass validators do not run when referencing a `List` field defined in a parent class when `each_item=True`. Added an example to the docs illustrating this, [#1566](https://github.com/pydantic/pydantic/pull/1566) by [@samueldeklund](https://github.com/samueldeklund)\n* change `schema.field_class_to_schema` to support `frozenset` in schema, [#1557](https://github.com/pydantic/pydantic/pull/1557) by [@wangpeibao](https://github.com/wangpeibao)\n* Call `__modify_schema__` only for the field schema, [#1552](https://github.com/pydantic/pydantic/pull/1552) by [@PrettyWood](https://github.com/PrettyWood)\n* Move the assignment of `field.validate_always` in `fields.py` so the `always` parameter of validators work on inheritance, [#1545](https://github.com/pydantic/pydantic/pull/1545) by [@dcHHH](https://github.com/dcHHH)\n* Added support for UUID instantiation through 16 byte strings such as `b'\\x12\\x34\\x56\\x78' * 4`. This was done to support `BINARY(16)` columns in sqlalchemy, [#1541](https://github.com/pydantic/pydantic/pull/1541) by [@shawnwall](https://github.com/shawnwall)\n* Add a test assertion that `default_factory` can return a singleton, [#1523](https://github.com/pydantic/pydantic/pull/1523) by [@therefromhere](https://github.com/therefromhere)\n* Add `NameEmail.__eq__` so duplicate `NameEmail` instances are evaluated as equal, [#1514](https://github.com/pydantic/pydantic/pull/1514) by [@stephen-bunn](https://github.com/stephen-bunn)\n* Add datamodel-code-generator link in pydantic document site, [#1500](https://github.com/pydantic/pydantic/pull/1500) by [@koxudaxi](https://github.com/koxudaxi)\n* Added a \"Discussion of Pydantic\" section to the documentation, with a link to \"Pydantic Introduction\" video by Alexander HultnÃ©r, [#1499](https://github.com/pydantic/pydantic/pull/1499) by [@hultner](https://github.com/hultner)\n* Avoid some side effects of `default_factory` by calling it only once\n  if possible and by not setting a default value in the schema, [#1491](https://github.com/pydantic/pydantic/pull/1491) by [@PrettyWood](https://github.com/PrettyWood)\n* Added docs about dumping dataclasses to JSON, [#1487](https://github.com/pydantic/pydantic/pull/1487) by [@mikegrima](https://github.com/mikegrima)\n* Make `BaseModel.__signature__` class-only, so getting `__signature__` from model instance will raise `AttributeError`, [#1466](https://github.com/pydantic/pydantic/pull/1466) by [@Bobronium](https://github.com/Bobronium)\n* include `'format': 'password'` in the schema for secret types, [#1424](https://github.com/pydantic/pydantic/pull/1424) by [@atheuz](https://github.com/atheuz)\n* Modify schema constraints on `ConstrainedFloat` so that `exclusiveMinimum` and\n  minimum are not included in the schema if they are equal to `-math.inf` and\n  `exclusiveMaximum` and `maximum` are not included if they are equal to `math.inf`, [#1417](https://github.com/pydantic/pydantic/pull/1417) by [@vdwees](https://github.com/vdwees)\n* Squash internal `__root__` dicts in `.dict()` (and, by extension, in `.json()`), [#1414](https://github.com/pydantic/pydantic/pull/1414) by [@patrickkwang](https://github.com/patrickkwang)\n* Move `const` validator to post-validators so it validates the parsed value, [#1410](https://github.com/pydantic/pydantic/pull/1410) by [@selimb](https://github.com/selimb)\n* Fix model validation to handle nested literals, e.g. `Literal['foo', Literal['bar']]`, [#1364](https://github.com/pydantic/pydantic/pull/1364) by [@DBCerigo](https://github.com/DBCerigo)\n* Remove `user_required = True` from `RedisDsn`, neither user nor password are required, [#1275](https://github.com/pydantic/pydantic/pull/1275) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Remove extra `allOf` from schema for fields with `Union` and custom `Field`, [#1209](https://github.com/pydantic/pydantic/pull/1209) by [@mostaphaRoudsari](https://github.com/mostaphaRoudsari)\n* Updates OpenAPI schema generation to output all enums as separate models.\n  Instead of inlining the enum values in the model schema, models now use a `$ref`\n  property to point to the enum definition, [#1173](https://github.com/pydantic/pydantic/pull/1173) by [@calvinwyoung](https://github.com/calvinwyoung)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v16-2020-07-11indexhtmlv16-2020-07-11-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.5.1 (2020-04-23)[Â¶](index.html#v151-2020-04-23 \"Permanent link\")", "anchor": "v151-2020-04-23indexhtmlv151-2020-04-23-permanent-link", "md_text": "* Signature generation with `extra: allow` never uses a field name, [#1418](https://github.com/pydantic/pydantic/pull/1418) by [@prettywood](https://github.com/prettywood)\n* Avoid mutating `Field` default value, [#1412](https://github.com/pydantic/pydantic/pull/1412) by [@prettywood](https://github.com/prettywood)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v151-2020-04-23indexhtmlv151-2020-04-23-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.5 (2020-04-18)[Â¶](index.html#v15-2020-04-18 \"Permanent link\")", "anchor": "v15-2020-04-18indexhtmlv15-2020-04-18-permanent-link", "md_text": "* Make includes/excludes arguments for `.dict()`, `._iter()`, ..., immutable, [#1404](https://github.com/pydantic/pydantic/pull/1404) by [@AlexECX](https://github.com/AlexECX)\n* Always use a field's real name with includes/excludes in `model._iter()`, regardless of `by_alias`, [#1397](https://github.com/pydantic/pydantic/pull/1397) by [@AlexECX](https://github.com/AlexECX)\n* Update constr regex example to include start and end lines, [#1396](https://github.com/pydantic/pydantic/pull/1396) by [@lmcnearney](https://github.com/lmcnearney)\n* Confirm that shallow `model.copy()` does make a shallow copy of attributes, [#1383](https://github.com/pydantic/pydantic/pull/1383) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Renaming `model_name` argument of `main.create_model()` to `__model_name` to allow using `model_name` as a field name, [#1367](https://github.com/pydantic/pydantic/pull/1367) by [@kittipatv](https://github.com/kittipatv)\n* Replace raising of exception to silent passing for non-Var attributes in mypy plugin, [#1345](https://github.com/pydantic/pydantic/pull/1345) by [@b0g3r](https://github.com/b0g3r)\n* Remove `typing_extensions` dependency for Python 3.8, [#1342](https://github.com/pydantic/pydantic/pull/1342) by [@prettywood](https://github.com/prettywood)\n* Make `SecretStr` and `SecretBytes` initialization idempotent, [#1330](https://github.com/pydantic/pydantic/pull/1330) by [@atheuz](https://github.com/atheuz)\n* document making secret types dumpable using the json method, [#1328](https://github.com/pydantic/pydantic/pull/1328) by [@atheuz](https://github.com/atheuz)\n* Move all testing and build to github actions, add windows and macos binaries,\n  thank you [@StephenBrown2](https://github.com/StephenBrown2) for much help, [#1326](https://github.com/pydantic/pydantic/pull/1326) by [@samuelcolvin](https://github.com/samuelcolvin)\n* fix card number length check in `PaymentCardNumber`, `PaymentCardBrand` now inherits from `str`, [#1317](https://github.com/pydantic/pydantic/pull/1317) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Have `BaseModel` inherit from `Representation` to make mypy happy when overriding `__str__`, [#1310](https://github.com/pydantic/pydantic/pull/1310) by [@FuegoFro](https://github.com/FuegoFro)\n* Allow `None` as input to all optional list fields, [#1307](https://github.com/pydantic/pydantic/pull/1307) by [@prettywood](https://github.com/prettywood)\n* Add `datetime` field to `default_factory` example, [#1301](https://github.com/pydantic/pydantic/pull/1301) by [@StephenBrown2](https://github.com/StephenBrown2)\n* Allow subclasses of known types to be encoded with superclass encoder, [#1291](https://github.com/pydantic/pydantic/pull/1291) by [@StephenBrown2](https://github.com/StephenBrown2)\n* Exclude exported fields from all elements of a list/tuple of submodels/dicts with `'__all__'`, [#1286](https://github.com/pydantic/pydantic/pull/1286) by [@masalim2](https://github.com/masalim2)\n* Add pydantic.color.Color objects as available input for Color fields, [#1258](https://github.com/pydantic/pydantic/pull/1258) by [@leosussan](https://github.com/leosussan)\n* In examples, type nullable fields as `Optional`, so that these are valid mypy annotations, [#1248](https://github.com/pydantic/pydantic/pull/1248) by [@kokes](https://github.com/kokes)\n* Make `pattern_validator()` accept pre-compiled `Pattern` objects. Fix `str_validator()` return type to `str`, [#1237](https://github.com/pydantic/pydantic/pull/1237) by [@adamgreg](https://github.com/adamgreg)\n* Document how to manage Generics and inheritance, [#1229](https://github.com/pydantic/pydantic/pull/1229) by [@esadruhn](https://github.com/esadruhn)\n* `update_forward_refs()` method of BaseModel now copies `__dict__` of class module instead of modifying it, [#1228](https://github.com/pydantic/pydantic/pull/1228) by [@paul-ilyin](https://github.com/paul-ilyin)\n* Support instance methods and class methods with `@validate_arguments`, [#1222](https://github.com/pydantic/pydantic/pull/1222) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Add `default_factory` argument to `Field` to create a dynamic default value by passing a zero-argument callable, [#1210](https://github.com/pydantic/pydantic/pull/1210) by [@prettywood](https://github.com/prettywood)\n* add support for `NewType` of `List`, `Optional`, etc, [#1207](https://github.com/pydantic/pydantic/pull/1207) by [@Kazy](https://github.com/Kazy)\n* fix mypy signature for `root_validator`, [#1192](https://github.com/pydantic/pydantic/pull/1192) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Fixed parsing of nested 'custom root type' models, [#1190](https://github.com/pydantic/pydantic/pull/1190) by [@Shados](https://github.com/Shados)\n* Add `validate_arguments` function decorator which checks the arguments to a function matches type annotations, [#1179](https://github.com/pydantic/pydantic/pull/1179) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Add `__signature__` to models, [#1034](https://github.com/pydantic/pydantic/pull/1034) by [@Bobronium](https://github.com/Bobronium)\n* Refactor `._iter()` method, 10x speed boost for `dict(model)`, [#1017](https://github.com/pydantic/pydantic/pull/1017) by [@Bobronium](https://github.com/Bobronium)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v15-2020-04-18indexhtmlv15-2020-04-18-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.4 (2020-01-24)[Â¶](index.html#v14-2020-01-24 \"Permanent link\")", "anchor": "v14-2020-01-24indexhtmlv14-2020-01-24-permanent-link", "md_text": "* **Breaking Change:** alias precedence logic changed so aliases on a field always take priority over\n  an alias from `alias_generator` to avoid buggy/unexpected behaviour,\n  see [here](https://docs.pydantic.dev/usage/model_config/#alias-precedence) for details, [#1178](https://github.com/pydantic/pydantic/pull/1178) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Add support for unicode and punycode in TLDs, [#1182](https://github.com/pydantic/pydantic/pull/1182) by [@jamescurtin](https://github.com/jamescurtin)\n* Fix `cls` argument in validators during assignment, [#1172](https://github.com/pydantic/pydantic/pull/1172) by [@samuelcolvin](https://github.com/samuelcolvin)\n* completing Luhn algorithm for `PaymentCardNumber`, [#1166](https://github.com/pydantic/pydantic/pull/1166) by [@cuencandres](https://github.com/cuencandres)\n* add support for generics that implement `__get_validators__` like a custom data type, [#1159](https://github.com/pydantic/pydantic/pull/1159) by [@tiangolo](https://github.com/tiangolo)\n* add support for infinite generators with `Iterable`, [#1152](https://github.com/pydantic/pydantic/pull/1152) by [@tiangolo](https://github.com/tiangolo)\n* fix `url_regex` to accept schemas with `+`, `-` and `.` after the first character, [#1142](https://github.com/pydantic/pydantic/pull/1142) by [@samuelcolvin](https://github.com/samuelcolvin)\n* move `version_info()` to `version.py`, suggest its use in issues, [#1138](https://github.com/pydantic/pydantic/pull/1138) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Improve pydantic import time by roughly 50% by deferring some module loading and regex compilation, [#1127](https://github.com/pydantic/pydantic/pull/1127) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Fix `EmailStr` and `NameEmail` to accept instances of themselves in cython, [#1126](https://github.com/pydantic/pydantic/pull/1126) by [@koxudaxi](https://github.com/koxudaxi)\n* Pass model class to the `Config.schema_extra` callable, [#1125](https://github.com/pydantic/pydantic/pull/1125) by [@therefromhere](https://github.com/therefromhere)\n* Fix regex for username and password in URLs, [#1115](https://github.com/pydantic/pydantic/pull/1115) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Add support for nested generic models, [#1104](https://github.com/pydantic/pydantic/pull/1104) by [@dmontagu](https://github.com/dmontagu)\n* add `__all__` to `__init__.py` to prevent \"implicit reexport\" errors from mypy, [#1072](https://github.com/pydantic/pydantic/pull/1072) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Add support for using \"dotenv\" files with `BaseSettings`, [#1011](https://github.com/pydantic/pydantic/pull/1011) by [@acnebs](https://github.com/acnebs)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v14-2020-01-24indexhtmlv14-2020-01-24-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.3 (2019-12-21)[Â¶](index.html#v13-2019-12-21 \"Permanent link\")", "anchor": "v13-2019-12-21indexhtmlv13-2019-12-21-permanent-link", "md_text": "* Change `schema` and `schema_model` to handle dataclasses by using their `__pydantic_model__` feature, [#792](https://github.com/pydantic/pydantic/pull/792) by [@aviramha](https://github.com/aviramha)\n* Added option for `root_validator` to be skipped if values validation fails using keyword `skip_on_failure=True`, [#1049](https://github.com/pydantic/pydantic/pull/1049) by [@aviramha](https://github.com/aviramha)\n* Allow `Config.schema_extra` to be a callable so that the generated schema can be post-processed, [#1054](https://github.com/pydantic/pydantic/pull/1054) by [@selimb](https://github.com/selimb)\n* Update mypy to version 0.750, [#1057](https://github.com/pydantic/pydantic/pull/1057) by [@dmontagu](https://github.com/dmontagu)\n* Trick Cython into allowing str subclassing, [#1061](https://github.com/pydantic/pydantic/pull/1061) by [@skewty](https://github.com/skewty)\n* Prevent type attributes being added to schema unless the attribute `__schema_attributes__` is `True`, [#1064](https://github.com/pydantic/pydantic/pull/1064) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Change `BaseModel.parse_file` to use `Config.json_loads`, [#1067](https://github.com/pydantic/pydantic/pull/1067) by [@kierandarcy](https://github.com/kierandarcy)\n* Fix for optional `Json` fields, [#1073](https://github.com/pydantic/pydantic/pull/1073) by [@volker48](https://github.com/volker48)\n* Change the default number of threads used when compiling with cython to one,\n  allow override via the `CYTHON_NTHREADS` environment variable, [#1074](https://github.com/pydantic/pydantic/pull/1074) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Run FastAPI tests during Pydantic's CI tests, [#1075](https://github.com/pydantic/pydantic/pull/1075) by [@tiangolo](https://github.com/tiangolo)\n* My mypy strictness constraints, and associated tweaks to type annotations, [#1077](https://github.com/pydantic/pydantic/pull/1077) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Add `__eq__` to SecretStr and SecretBytes to allow \"value equals\", [#1079](https://github.com/pydantic/pydantic/pull/1079) by [@sbv-trueenergy](https://github.com/sbv-trueenergy)\n* Fix schema generation for nested None case, [#1088](https://github.com/pydantic/pydantic/pull/1088) by [@lutostag](https://github.com/lutostag)\n* Consistent checks for sequence like objects, [#1090](https://github.com/pydantic/pydantic/pull/1090) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Fix `Config` inheritance on `BaseSettings` when used with `env_prefix`, [#1091](https://github.com/pydantic/pydantic/pull/1091) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Fix for `__modify_schema__` when it conflicted with `field_class_to_schema*`, [#1102](https://github.com/pydantic/pydantic/pull/1102) by [@samuelcolvin](https://github.com/samuelcolvin)\n* docs: Fix explanation of case sensitive environment variable names when populating `BaseSettings` subclass attributes, [#1105](https://github.com/pydantic/pydantic/pull/1105) by [@tribals](https://github.com/tribals)\n* Rename django-rest-framework benchmark in documentation, [#1119](https://github.com/pydantic/pydantic/pull/1119) by [@frankie567](https://github.com/frankie567)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v13-2019-12-21indexhtmlv13-2019-12-21-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.2 (2019-11-28)[Â¶](index.html#v12-2019-11-28 \"Permanent link\")", "anchor": "v12-2019-11-28indexhtmlv12-2019-11-28-permanent-link", "md_text": "* **Possible Breaking Change:** Add support for required `Optional` with `name: Optional[AnyType] = Field(...)`\n  and refactor `ModelField` creation to preserve `required` parameter value, [#1031](https://github.com/pydantic/pydantic/pull/1031) by [@tiangolo](https://github.com/tiangolo);\n  see [here](https://docs.pydantic.dev/usage/models/#required-optional-fields) for details\n* Add benchmarks for `cattrs`, [#513](https://github.com/pydantic/pydantic/pull/513) by [@sebastianmika](https://github.com/sebastianmika)\n* Add `exclude_none` option to `dict()` and friends, [#587](https://github.com/pydantic/pydantic/pull/587) by [@niknetniko](https://github.com/niknetniko)\n* Add benchmarks for `valideer`, [#670](https://github.com/pydantic/pydantic/pull/670) by [@gsakkis](https://github.com/gsakkis)\n* Add `parse_obj_as` and `parse_file_as` functions for ad-hoc parsing of data into arbitrary pydantic-compatible types, [#934](https://github.com/pydantic/pydantic/pull/934) by [@dmontagu](https://github.com/dmontagu)\n* Add `allow_reuse` argument to validators, thus allowing validator reuse, [#940](https://github.com/pydantic/pydantic/pull/940) by [@dmontagu](https://github.com/dmontagu)\n* Add support for mapping types for custom root models, [#958](https://github.com/pydantic/pydantic/pull/958) by [@dmontagu](https://github.com/dmontagu)\n* Mypy plugin support for dataclasses, [#966](https://github.com/pydantic/pydantic/pull/966) by [@koxudaxi](https://github.com/koxudaxi)\n* Add support for dataclasses default factory, [#968](https://github.com/pydantic/pydantic/pull/968) by [@ahirner](https://github.com/ahirner)\n* Add a `ByteSize` type for converting byte string (`1GB`) to plain bytes, [#977](https://github.com/pydantic/pydantic/pull/977) by [@dgasmith](https://github.com/dgasmith)\n* Fix mypy complaint about `@root_validator(pre=True)`, [#984](https://github.com/pydantic/pydantic/pull/984) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Add manylinux binaries for Python 3.8 to pypi, also support manylinux2010, [#994](https://github.com/pydantic/pydantic/pull/994) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Adds ByteSize conversion to another unit, [#995](https://github.com/pydantic/pydantic/pull/995) by [@dgasmith](https://github.com/dgasmith)\n* Fix `__str__` and `__repr__` inheritance for models, [#1022](https://github.com/pydantic/pydantic/pull/1022) by [@samuelcolvin](https://github.com/samuelcolvin)\n* add testimonials section to docs, [#1025](https://github.com/pydantic/pydantic/pull/1025) by [@sullivancolin](https://github.com/sullivancolin)\n* Add support for `typing.Literal` for Python 3.8, [#1026](https://github.com/pydantic/pydantic/pull/1026) by [@dmontagu](https://github.com/dmontagu)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v12-2019-11-28indexhtmlv12-2019-11-28-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.1.1 (2019-11-20)[Â¶](index.html#v111-2019-11-20 \"Permanent link\")", "anchor": "v111-2019-11-20indexhtmlv111-2019-11-20-permanent-link", "md_text": "* Fix bug where use of complex fields on sub-models could cause fields to be incorrectly configured, [#1015](https://github.com/pydantic/pydantic/pull/1015) by [@samuelcolvin](https://github.com/samuelcolvin)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v111-2019-11-20indexhtmlv111-2019-11-20-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.1 (2019-11-07)[Â¶](index.html#v11-2019-11-07 \"Permanent link\")", "anchor": "v11-2019-11-07indexhtmlv11-2019-11-07-permanent-link", "md_text": "* Add a mypy plugin for type checking `BaseModel.__init__` and more, [#722](https://github.com/pydantic/pydantic/pull/722) by [@dmontagu](https://github.com/dmontagu)\n* Change return type typehint for `GenericModel.__class_getitem__` to prevent PyCharm warnings, [#936](https://github.com/pydantic/pydantic/pull/936) by [@dmontagu](https://github.com/dmontagu)\n* Fix usage of `Any` to allow `None`, also support `TypeVar` thus allowing use of un-parameterised collection types\n  e.g. `Dict` and `List`, [#962](https://github.com/pydantic/pydantic/pull/962) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Set `FieldInfo` on subfields to fix schema generation for complex nested types, [#965](https://github.com/pydantic/pydantic/pull/965) by [@samuelcolvin](https://github.com/samuelcolvin)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v11-2019-11-07indexhtmlv11-2019-11-07-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.0 (2019-10-23)[Â¶](index.html#v10-2019-10-23 \"Permanent link\")", "anchor": "v10-2019-10-23indexhtmlv10-2019-10-23-permanent-link", "md_text": "* **Breaking Change:** deprecate the `Model.fields` property, use `Model.__fields__` instead, [#883](https://github.com/pydantic/pydantic/pull/883) by [@samuelcolvin](https://github.com/samuelcolvin)\n* **Breaking Change:** Change the precedence of aliases so child model aliases override parent aliases,\n  including using `alias_generator`, [#904](https://github.com/pydantic/pydantic/pull/904) by [@samuelcolvin](https://github.com/samuelcolvin)\n* **Breaking change:** Rename `skip_defaults` to `exclude_unset`, and add ability to exclude actual defaults, [#915](https://github.com/pydantic/pydantic/pull/915) by [@dmontagu](https://github.com/dmontagu)\n* Add `**kwargs` to `pydantic.main.ModelMetaclass.__new__` so `__init_subclass__` can take custom parameters on extended\n  `BaseModel` classes, [#867](https://github.com/pydantic/pydantic/pull/867) by [@retnikt](https://github.com/retnikt)\n* Fix field of a type that has a default value, [#880](https://github.com/pydantic/pydantic/pull/880) by [@koxudaxi](https://github.com/koxudaxi)\n* Use `FutureWarning` instead of `DeprecationWarning` when `alias` instead of `env` is used for settings models, [#881](https://github.com/pydantic/pydantic/pull/881) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Fix issue with `BaseSettings` inheritance and `alias` getting set to `None`, [#882](https://github.com/pydantic/pydantic/pull/882) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Modify `__repr__` and `__str__` methods to be consistent across all public classes, add `__pretty__` to support\n  python-devtools, [#884](https://github.com/pydantic/pydantic/pull/884) by [@samuelcolvin](https://github.com/samuelcolvin)\n* deprecation warning for `case_insensitive` on `BaseSettings` config, [#885](https://github.com/pydantic/pydantic/pull/885) by [@samuelcolvin](https://github.com/samuelcolvin)\n* For `BaseSettings` merge environment variables and in-code values recursively, as long as they create a valid object\n  when merged together, to allow splitting init arguments, [#888](https://github.com/pydantic/pydantic/pull/888) by [@idmitrievsky](https://github.com/idmitrievsky)\n* change secret types example, [#890](https://github.com/pydantic/pydantic/pull/890) by [@ashears](https://github.com/ashears)\n* Change the signature of `Model.construct()` to be more user-friendly, document `construct()` usage, [#898](https://github.com/pydantic/pydantic/pull/898) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Add example for the `construct()` method, [#907](https://github.com/pydantic/pydantic/pull/907) by [@ashears](https://github.com/ashears)\n* Improve use of `Field` constraints on complex types, raise an error if constraints are not enforceable,\n  also support tuples with an ellipsis `Tuple[X, ...]`, `Sequence` and `FrozenSet` in schema, [#909](https://github.com/pydantic/pydantic/pull/909) by [@samuelcolvin](https://github.com/samuelcolvin)\n* update docs for bool missing valid value, [#911](https://github.com/pydantic/pydantic/pull/911) by [@trim21](https://github.com/trim21)\n* Better `str`/`repr` logic for `ModelField`, [#912](https://github.com/pydantic/pydantic/pull/912) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Fix `ConstrainedList`, update schema generation to reflect `min_items` and `max_items` `Field()` arguments, [#917](https://github.com/pydantic/pydantic/pull/917) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Allow abstracts sets (eg. dict keys) in the `include` and `exclude` arguments of `dict()`, [#921](https://github.com/pydantic/pydantic/pull/921) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Fix JSON serialization errors on `ValidationError.json()` by using `pydantic_encoder`, [#922](https://github.com/pydantic/pydantic/pull/922) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Clarify usage of `remove_untouched`, improve error message for types with no validators, [#926](https://github.com/pydantic/pydantic/pull/926) by [@retnikt](https://github.com/retnikt)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v10-2019-10-23indexhtmlv10-2019-10-23-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.0b2 (2019-10-07)[Â¶](index.html#v10b2-2019-10-07 \"Permanent link\")", "anchor": "v10b2-2019-10-07indexhtmlv10b2-2019-10-07-permanent-link", "md_text": "* Mark `StrictBool` typecheck as `bool` to allow for default values without mypy errors, [#690](https://github.com/pydantic/pydantic/pull/690) by [@dmontagu](https://github.com/dmontagu)\n* Transfer the documentation build from sphinx to mkdocs, re-write much of the documentation, [#856](https://github.com/pydantic/pydantic/pull/856) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Add support for custom naming schemes for `GenericModel` subclasses, [#859](https://github.com/pydantic/pydantic/pull/859) by [@dmontagu](https://github.com/dmontagu)\n* Add `if TYPE_CHECKING:` to the excluded lines for test coverage, [#874](https://github.com/pydantic/pydantic/pull/874) by [@dmontagu](https://github.com/dmontagu)\n* Rename `allow_population_by_alias` to `allow_population_by_field_name`, remove unnecessary warning about it, [#875](https://github.com/pydantic/pydantic/pull/875) by [@samuelcolvin](https://github.com/samuelcolvin)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v10b2-2019-10-07indexhtmlv10b2-2019-10-07-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v1.0b1 (2019-10-01)[Â¶](index.html#v10b1-2019-10-01 \"Permanent link\")", "anchor": "v10b1-2019-10-01indexhtmlv10b1-2019-10-01-permanent-link", "md_text": "* **Breaking Change:** rename `Schema` to `Field`, make it a function to placate mypy, [#577](https://github.com/pydantic/pydantic/pull/577) by [@samuelcolvin](https://github.com/samuelcolvin)\n* **Breaking Change:** modify parsing behavior for `bool`, [#617](https://github.com/pydantic/pydantic/pull/617) by [@dmontagu](https://github.com/dmontagu)\n* **Breaking Change:** `get_validators` is no longer recognised, use `__get_validators__`.\n  `Config.ignore_extra` and `Config.allow_extra` are no longer recognised, use `Config.extra`, [#720](https://github.com/pydantic/pydantic/pull/720) by [@samuelcolvin](https://github.com/samuelcolvin)\n* **Breaking Change:** modify default config settings for `BaseSettings`; `case_insensitive` renamed to `case_sensitive`,\n  default changed to `case_sensitive = False`, `env_prefix` default changed to `''` - e.g. no prefix, [#721](https://github.com/pydantic/pydantic/pull/721) by [@dmontagu](https://github.com/dmontagu)\n* **Breaking change:** Implement `root_validator` and rename root errors from `__obj__` to `__root__`, [#729](https://github.com/pydantic/pydantic/pull/729) by [@samuelcolvin](https://github.com/samuelcolvin)\n* **Breaking Change:** alter the behaviour of `dict(model)` so that sub-models are nolonger\n  converted to dictionaries, [#733](https://github.com/pydantic/pydantic/pull/733) by [@samuelcolvin](https://github.com/samuelcolvin)\n* **Breaking change:** Added `initvars` support to `post_init_post_parse`, [#748](https://github.com/pydantic/pydantic/pull/748) by [@Raphael-C-Almeida](https://github.com/Raphael-C-Almeida)\n* **Breaking Change:** Make `BaseModel.json()` only serialize the `__root__` key for models with custom root, [#752](https://github.com/pydantic/pydantic/pull/752) by [@dmontagu](https://github.com/dmontagu)\n* **Breaking Change:** complete rewrite of `URL` parsing logic, [#755](https://github.com/pydantic/pydantic/pull/755) by [@samuelcolvin](https://github.com/samuelcolvin)\n* **Breaking Change:** preserve superclass annotations for field-determination when not provided in subclass, [#757](https://github.com/pydantic/pydantic/pull/757) by [@dmontagu](https://github.com/dmontagu)\n* **Breaking Change:** `BaseSettings` now uses the special `env` settings to define which environment variables to\n  read, not aliases, [#847](https://github.com/pydantic/pydantic/pull/847) by [@samuelcolvin](https://github.com/samuelcolvin)\n* add support for `assert` statements inside validators, [#653](https://github.com/pydantic/pydantic/pull/653) by [@abdusco](https://github.com/abdusco)\n* Update documentation to specify the use of `pydantic.dataclasses.dataclass` and subclassing `pydantic.BaseModel`, [#710](https://github.com/pydantic/pydantic/pull/710) by [@maddosaurus](https://github.com/maddosaurus)\n* Allow custom JSON decoding and encoding via `json_loads` and `json_dumps` `Config` properties, [#714](https://github.com/pydantic/pydantic/pull/714) by [@samuelcolvin](https://github.com/samuelcolvin)\n* make all annotated fields occur in the order declared, [#715](https://github.com/pydantic/pydantic/pull/715) by [@dmontagu](https://github.com/dmontagu)\n* use pytest to test `mypy` integration, [#735](https://github.com/pydantic/pydantic/pull/735) by [@dmontagu](https://github.com/dmontagu)\n* add `__repr__` method to `ErrorWrapper`, [#738](https://github.com/pydantic/pydantic/pull/738) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Added support for `FrozenSet` members in dataclasses, and a better error when attempting to use types from the `typing` module that are not supported by Pydantic, [#745](https://github.com/pydantic/pydantic/pull/745) by [@djpetti](https://github.com/djpetti)\n* add documentation for Pycharm Plugin, [#750](https://github.com/pydantic/pydantic/pull/750) by [@koxudaxi](https://github.com/koxudaxi)\n* fix broken examples in the docs, [#753](https://github.com/pydantic/pydantic/pull/753) by [@dmontagu](https://github.com/dmontagu)\n* moving typing related objects into `pydantic.typing`, [#761](https://github.com/pydantic/pydantic/pull/761) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Minor performance improvements to `ErrorWrapper`, `ValidationError` and datetime parsing, [#763](https://github.com/pydantic/pydantic/pull/763) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Improvements to `datetime`/`date`/`time`/`timedelta` types: more descriptive errors,\n  change errors to `value_error` not `type_error`, support bytes, [#766](https://github.com/pydantic/pydantic/pull/766) by [@samuelcolvin](https://github.com/samuelcolvin)\n* fix error messages for `Literal` types with multiple allowed values, [#770](https://github.com/pydantic/pydantic/pull/770) by [@dmontagu](https://github.com/dmontagu)\n* Improved auto-generated `title` field in JSON schema by converting underscore to space, [#772](https://github.com/pydantic/pydantic/pull/772) by [@skewty](https://github.com/skewty)\n* support `mypy --no-implicit-reexport` for dataclasses, also respect `--no-implicit-reexport` in pydantic itself, [#783](https://github.com/pydantic/pydantic/pull/783) by [@samuelcolvin](https://github.com/samuelcolvin)\n* add the `PaymentCardNumber` type, [#790](https://github.com/pydantic/pydantic/pull/790) by [@matin](https://github.com/matin)\n* Fix const validations for lists, [#794](https://github.com/pydantic/pydantic/pull/794) by [@hmvp](https://github.com/hmvp)\n* Set `additionalProperties` to false in schema for models with extra fields disallowed, [#796](https://github.com/pydantic/pydantic/pull/796) by [@Code0x58](https://github.com/Code0x58)\n* `EmailStr` validation method now returns local part case-sensitive per RFC 5321, [#798](https://github.com/pydantic/pydantic/pull/798) by [@henriklindgren](https://github.com/henriklindgren)\n* Added ability to validate strictness to `ConstrainedFloat`, `ConstrainedInt` and `ConstrainedStr` and added\n  `StrictFloat` and `StrictInt` classes, [#799](https://github.com/pydantic/pydantic/pull/799) by [@DerRidda](https://github.com/DerRidda)\n* Improve handling of `None` and `Optional`, replace `whole` with `each_item` (inverse meaning, default `False`)\n  on validators, [#803](https://github.com/pydantic/pydantic/pull/803) by [@samuelcolvin](https://github.com/samuelcolvin)\n* add support for `Type[T]` type hints, [#807](https://github.com/pydantic/pydantic/pull/807) by [@timonbimon](https://github.com/timonbimon)\n* Performance improvements from removing `change_exceptions`, change how pydantic error are constructed, [#819](https://github.com/pydantic/pydantic/pull/819) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Fix the error message arising when a `BaseModel`-type model field causes a `ValidationError` during parsing, [#820](https://github.com/pydantic/pydantic/pull/820) by [@dmontagu](https://github.com/dmontagu)\n* allow `getter_dict` on `Config`, modify `GetterDict` to be more like a `Mapping` object and thus easier to work with, [#821](https://github.com/pydantic/pydantic/pull/821) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Only check `TypeVar` param on base `GenericModel` class, [#842](https://github.com/pydantic/pydantic/pull/842) by [@zpencerq](https://github.com/zpencerq)\n* rename `Model._schema_cache` -> `Model.__schema_cache__`, `Model._json_encoder` -> `Model.__json_encoder__`,\n  `Model._custom_root_type` -> `Model.__custom_root_type__`, [#851](https://github.com/pydantic/pydantic/pull/851) by [@samuelcolvin](https://github.com/samuelcolvin)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v10b1-2019-10-01indexhtmlv10b1-2019-10-01-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.32.2 (2019-08-17)[Â¶](index.html#v0322-2019-08-17 \"Permanent link\")", "anchor": "v0322-2019-08-17indexhtmlv0322-2019-08-17-permanent-link", "md_text": "(Docs are available [here](https://5d584fcca7c9b70007d1c997--pydantic-docs.netlify.com))\n\n* fix `__post_init__` usage with dataclass inheritance, fix [#739](https://github.com/pydantic/pydantic/pull/739) by [@samuelcolvin](https://github.com/samuelcolvin)\n* fix required fields validation on GenericModels classes, [#742](https://github.com/pydantic/pydantic/pull/742) by [@amitbl](https://github.com/amitbl)\n* fix defining custom `Schema` on `GenericModel` fields, [#754](https://github.com/pydantic/pydantic/pull/754) by [@amitbl](https://github.com/amitbl)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v0322-2019-08-17indexhtmlv0322-2019-08-17-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.32.1 (2019-08-08)[Â¶](index.html#v0321-2019-08-08 \"Permanent link\")", "anchor": "v0321-2019-08-08indexhtmlv0321-2019-08-08-permanent-link", "md_text": "* do not validate extra fields when `validate_assignment` is on, [#724](https://github.com/pydantic/pydantic/pull/724) by [@YaraslauZhylko](https://github.com/YaraslauZhylko)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v0321-2019-08-08indexhtmlv0321-2019-08-08-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.32 (2019-08-06)[Â¶](index.html#v032-2019-08-06 \"Permanent link\")", "anchor": "v032-2019-08-06indexhtmlv032-2019-08-06-permanent-link", "md_text": "* add model name to `ValidationError` error message, [#676](https://github.com/pydantic/pydantic/pull/676) by [@dmontagu](https://github.com/dmontagu)\n* **breaking change**: remove `__getattr__` and rename `__values__` to `__dict__` on `BaseModel`,\n  deprecation warning on use `__values__` attr, attributes access speed increased up to 14 times, [#712](https://github.com/pydantic/pydantic/pull/712) by [@Bobronium](https://github.com/Bobronium)\n* support `ForwardRef` (without self-referencing annotations) in Python 3.6, [#706](https://github.com/pydantic/pydantic/pull/706) by [@koxudaxi](https://github.com/koxudaxi)\n* implement `schema_extra` in `Config` sub-class, [#663](https://github.com/pydantic/pydantic/pull/663) by [@tiangolo](https://github.com/tiangolo)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v032-2019-08-06indexhtmlv032-2019-08-06-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.31.1 (2019-07-31)[Â¶](index.html#v0311-2019-07-31 \"Permanent link\")", "anchor": "v0311-2019-07-31indexhtmlv0311-2019-07-31-permanent-link", "md_text": "* fix json generation for `EnumError`, [#697](https://github.com/pydantic/pydantic/pull/697) by [@dmontagu](https://github.com/dmontagu)\n* update numerous dependencies", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v0311-2019-07-31indexhtmlv0311-2019-07-31-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.31 (2019-07-24)[Â¶](index.html#v031-2019-07-24 \"Permanent link\")", "anchor": "v031-2019-07-24indexhtmlv031-2019-07-24-permanent-link", "md_text": "* better support for floating point `multiple_of` values, [#652](https://github.com/pydantic/pydantic/pull/652) by [@justindujardin](https://github.com/justindujardin)\n* fix schema generation for `NewType` and `Literal`, [#649](https://github.com/pydantic/pydantic/pull/649) by [@dmontagu](https://github.com/dmontagu)\n* fix `alias_generator` and field config conflict, [#645](https://github.com/pydantic/pydantic/pull/645) by [@gmetzker](https://github.com/gmetzker) and [#658](https://github.com/pydantic/pydantic/pull/658) by [@Bobronium](https://github.com/Bobronium)\n* more detailed message for `EnumError`, [#673](https://github.com/pydantic/pydantic/pull/673) by [@dmontagu](https://github.com/dmontagu)\n* add advanced exclude support for `dict`, `json` and `copy`, [#648](https://github.com/pydantic/pydantic/pull/648) by [@Bobronium](https://github.com/Bobronium)\n* fix bug in `GenericModel` for models with concrete parameterized fields, [#672](https://github.com/pydantic/pydantic/pull/672) by [@dmontagu](https://github.com/dmontagu)\n* add documentation for `Literal` type, [#651](https://github.com/pydantic/pydantic/pull/651) by [@dmontagu](https://github.com/dmontagu)\n* add `Config.keep_untouched` for custom descriptors support, [#679](https://github.com/pydantic/pydantic/pull/679) by [@Bobronium](https://github.com/Bobronium)\n* use `inspect.cleandoc` internally to get model description, [#657](https://github.com/pydantic/pydantic/pull/657) by [@tiangolo](https://github.com/tiangolo)\n* add `Color` to schema generation, by [@euri10](https://github.com/euri10)\n* add documentation for Literal type, [#651](https://github.com/pydantic/pydantic/pull/651) by [@dmontagu](https://github.com/dmontagu)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v031-2019-07-24indexhtmlv031-2019-07-24-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.30.1 (2019-07-15)[Â¶](index.html#v0301-2019-07-15 \"Permanent link\")", "anchor": "v0301-2019-07-15indexhtmlv0301-2019-07-15-permanent-link", "md_text": "* fix so nested classes which inherit and change `__init__` are correctly processed while still allowing `self` as a\n  parameter, [#644](https://github.com/pydantic/pydantic/pull/644) by [@lnaden](https://github.com/lnaden) and [@dgasmith](https://github.com/dgasmith)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v0301-2019-07-15indexhtmlv0301-2019-07-15-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.30 (2019-07-07)[Â¶](index.html#v030-2019-07-07 \"Permanent link\")", "anchor": "v030-2019-07-07indexhtmlv030-2019-07-07-permanent-link", "md_text": "* enforce single quotes in code, [#612](https://github.com/pydantic/pydantic/pull/612) by [@samuelcolvin](https://github.com/samuelcolvin)\n* fix infinite recursion with dataclass inheritance and `__post_init__`, [#606](https://github.com/pydantic/pydantic/pull/606) by [@Hanaasagi](https://github.com/Hanaasagi)\n* fix default values for `GenericModel`, [#610](https://github.com/pydantic/pydantic/pull/610) by [@dmontagu](https://github.com/dmontagu)\n* clarify that self-referencing models require Python 3.7+, [#616](https://github.com/pydantic/pydantic/pull/616) by [@vlcinsky](https://github.com/vlcinsky)\n* fix truncate for types, [#611](https://github.com/pydantic/pydantic/pull/611) by [@dmontagu](https://github.com/dmontagu)\n* add `alias_generator` support, [#622](https://github.com/pydantic/pydantic/pull/622) by [@Bobronium](https://github.com/Bobronium)\n* fix unparameterized generic type schema generation, [#625](https://github.com/pydantic/pydantic/pull/625) by [@dmontagu](https://github.com/dmontagu)\n* fix schema generation with multiple/circular references to the same model, [#621](https://github.com/pydantic/pydantic/pull/621) by [@tiangolo](https://github.com/tiangolo) and [@wongpat](https://github.com/wongpat)\n* support custom root types, [#628](https://github.com/pydantic/pydantic/pull/628) by [@koxudaxi](https://github.com/koxudaxi)\n* support `self` as a field name in `parse_obj`, [#632](https://github.com/pydantic/pydantic/pull/632) by [@samuelcolvin](https://github.com/samuelcolvin)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v030-2019-07-07indexhtmlv030-2019-07-07-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.29 (2019-06-19)[Â¶](index.html#v029-2019-06-19 \"Permanent link\")", "anchor": "v029-2019-06-19indexhtmlv029-2019-06-19-permanent-link", "md_text": "* support dataclasses.InitVar, [#592](https://github.com/pydantic/pydantic/pull/592) by [@pfrederiks](https://github.com/pfrederiks)\n* Updated documentation to elucidate the usage of `Union` when defining multiple types under an attribute's\n  annotation and showcase how the type-order can affect marshalling of provided values, [#594](https://github.com/pydantic/pydantic/pull/594) by [@somada141](https://github.com/somada141)\n* add `conlist` type, [#583](https://github.com/pydantic/pydantic/pull/583) by [@hmvp](https://github.com/hmvp)\n* add support for generics, [#595](https://github.com/pydantic/pydantic/pull/595) by [@dmontagu](https://github.com/dmontagu)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v029-2019-06-19indexhtmlv029-2019-06-19-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.28 (2019-06-06)[Â¶](index.html#v028-2019-06-06 \"Permanent link\")", "anchor": "v028-2019-06-06indexhtmlv028-2019-06-06-permanent-link", "md_text": "* fix support for JSON Schema generation when using models with circular references in Python 3.7, [#572](https://github.com/pydantic/pydantic/pull/572) by [@tiangolo](https://github.com/tiangolo)\n* support `__post_init_post_parse__` on dataclasses, [#567](https://github.com/pydantic/pydantic/pull/567) by [@sevaho](https://github.com/sevaho)\n* allow dumping dataclasses to JSON, [#575](https://github.com/pydantic/pydantic/pull/575) by [@samuelcolvin](https://github.com/samuelcolvin) and [@DanielOberg](https://github.com/DanielOberg)\n* ORM mode, [#562](https://github.com/pydantic/pydantic/pull/562) by [@samuelcolvin](https://github.com/samuelcolvin)\n* fix `pydantic.compiled` on ipython, [#573](https://github.com/pydantic/pydantic/pull/573) by [@dmontagu](https://github.com/dmontagu) and [@samuelcolvin](https://github.com/samuelcolvin)\n* add `StrictBool` type, [#579](https://github.com/pydantic/pydantic/pull/579) by [@cazgp](https://github.com/cazgp)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v028-2019-06-06indexhtmlv028-2019-06-06-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.27 (2019-05-30)[Â¶](index.html#v027-2019-05-30 \"Permanent link\")", "anchor": "v027-2019-05-30indexhtmlv027-2019-05-30-permanent-link", "md_text": "* **breaking change** `_pydantic_post_init` to execute dataclass' original `__post_init__` before\n  validation, [#560](https://github.com/pydantic/pydantic/pull/560) by [@HeavenVolkoff](https://github.com/HeavenVolkoff)\n* fix handling of generic types without specified parameters, [#550](https://github.com/pydantic/pydantic/pull/550) by [@dmontagu](https://github.com/dmontagu)\n* **breaking change** (maybe): this is the first release compiled with **cython**, see the docs and please\n  submit an issue if you run into problems", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v027-2019-05-30indexhtmlv027-2019-05-30-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.27.0a1 (2019-05-26)[Â¶](index.html#v0270a1-2019-05-26 \"Permanent link\")", "anchor": "v0270a1-2019-05-26indexhtmlv0270a1-2019-05-26-permanent-link", "md_text": "* fix JSON Schema for `list`, `tuple`, and `set`, [#540](https://github.com/pydantic/pydantic/pull/540) by [@tiangolo](https://github.com/tiangolo)\n* compiling with cython, `manylinux` binaries, some other performance improvements, [#548](https://github.com/pydantic/pydantic/pull/548) by [@samuelcolvin](https://github.com/samuelcolvin)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v0270a1-2019-05-26indexhtmlv0270a1-2019-05-26-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.26 (2019-05-22)[Â¶](index.html#v026-2019-05-22 \"Permanent link\")", "anchor": "v026-2019-05-22indexhtmlv026-2019-05-22-permanent-link", "md_text": "* fix to schema generation for `IPvAnyAddress`, `IPvAnyInterface`, `IPvAnyNetwork` [#498](https://github.com/pydantic/pydantic/pull/498) by [@pilosus](https://github.com/pilosus)\n* fix variable length tuples support, [#495](https://github.com/pydantic/pydantic/pull/495) by [@pilosus](https://github.com/pilosus)\n* fix return type hint for `create_model`, [#526](https://github.com/pydantic/pydantic/pull/526) by [@dmontagu](https://github.com/dmontagu)\n* **Breaking Change:** fix `.dict(skip_keys=True)` skipping values set via alias (this involves changing\n  `validate_model()` to always returns `Tuple[Dict[str, Any], Set[str], Optional[ValidationError]]`), [#517](https://github.com/pydantic/pydantic/pull/517) by [@sommd](https://github.com/sommd)\n* fix to schema generation for `IPv4Address`, `IPv6Address`, `IPv4Interface`,\n  `IPv6Interface`, `IPv4Network`, `IPv6Network` [#532](https://github.com/pydantic/pydantic/pull/532) by [@euri10](https://github.com/euri10)\n* add `Color` type, [#504](https://github.com/pydantic/pydantic/pull/504) by [@pilosus](https://github.com/pilosus) and [@samuelcolvin](https://github.com/samuelcolvin)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v026-2019-05-22indexhtmlv026-2019-05-22-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.25 (2019-05-05)[Â¶](index.html#v025-2019-05-05 \"Permanent link\")", "anchor": "v025-2019-05-05indexhtmlv025-2019-05-05-permanent-link", "md_text": "* Improve documentation on self-referencing models and annotations, [#487](https://github.com/pydantic/pydantic/pull/487) by [@theenglishway](https://github.com/theenglishway)\n* fix `.dict()` with extra keys, [#490](https://github.com/pydantic/pydantic/pull/490) by [@JaewonKim](https://github.com/JaewonKim)\n* support `const` keyword in `Schema`, [#434](https://github.com/pydantic/pydantic/pull/434) by [@Sean1708](https://github.com/Sean1708)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v025-2019-05-05indexhtmlv025-2019-05-05-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.24 (2019-04-23)[Â¶](index.html#v024-2019-04-23 \"Permanent link\")", "anchor": "v024-2019-04-23indexhtmlv024-2019-04-23-permanent-link", "md_text": "* fix handling `ForwardRef` in sub-types, like `Union`, [#464](https://github.com/pydantic/pydantic/pull/464) by [@tiangolo](https://github.com/tiangolo)\n* fix secret serialization, [#465](https://github.com/pydantic/pydantic/pull/465) by [@atheuz](https://github.com/atheuz)\n* Support custom validators for dataclasses, [#454](https://github.com/pydantic/pydantic/pull/454) by [@primal100](https://github.com/primal100)\n* fix `parse_obj` to cope with dict-like objects, [#472](https://github.com/pydantic/pydantic/pull/472) by [@samuelcolvin](https://github.com/samuelcolvin)\n* fix to schema generation in nested dataclass-based models, [#474](https://github.com/pydantic/pydantic/pull/474) by [@NoAnyLove](https://github.com/NoAnyLove)\n* fix `json` for `Path`, `FilePath`, and `DirectoryPath` objects, [#473](https://github.com/pydantic/pydantic/pull/473) by [@mikegoodspeed](https://github.com/mikegoodspeed)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v024-2019-04-23indexhtmlv024-2019-04-23-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.23 (2019-04-04)[Â¶](index.html#v023-2019-04-04 \"Permanent link\")", "anchor": "v023-2019-04-04indexhtmlv023-2019-04-04-permanent-link", "md_text": "* improve documentation for contributing section, [#441](https://github.com/pydantic/pydantic/pull/441) by [@pilosus](https://github.com/pilosus)\n* improve README.rst to include essential information about the package, [#446](https://github.com/pydantic/pydantic/pull/446) by [@pilosus](https://github.com/pilosus)\n* `IntEnum` support, [#444](https://github.com/pydantic/pydantic/pull/444) by [@potykion](https://github.com/potykion)\n* fix PyObject callable value, [#409](https://github.com/pydantic/pydantic/pull/409) by [@pilosus](https://github.com/pilosus)\n* fix `black` deprecation warnings after update, [#451](https://github.com/pydantic/pydantic/pull/451) by [@pilosus](https://github.com/pilosus)\n* fix `ForwardRef` collection bug, [#450](https://github.com/pydantic/pydantic/pull/450) by [@tigerwings](https://github.com/tigerwings)\n* Support specialized `ClassVars`, [#455](https://github.com/pydantic/pydantic/pull/455) by [@tyrylu](https://github.com/tyrylu)\n* fix JSON serialization for `ipaddress` types, [#333](https://github.com/pydantic/pydantic/pull/333) by [@pilosus](https://github.com/pilosus)\n* add `SecretStr` and `SecretBytes` types, [#452](https://github.com/pydantic/pydantic/pull/452) by [@atheuz](https://github.com/atheuz)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v023-2019-04-04indexhtmlv023-2019-04-04-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.22 (2019-03-29)[Â¶](index.html#v022-2019-03-29 \"Permanent link\")", "anchor": "v022-2019-03-29indexhtmlv022-2019-03-29-permanent-link", "md_text": "* add `IPv{4,6,Any}Network` and `IPv{4,6,Any}Interface` types from `ipaddress` stdlib, [#333](https://github.com/pydantic/pydantic/pull/333) by [@pilosus](https://github.com/pilosus)\n* add docs for `datetime` types, [#386](https://github.com/pydantic/pydantic/pull/386) by [@pilosus](https://github.com/pilosus)\n* fix to schema generation in dataclass-based models, [#408](https://github.com/pydantic/pydantic/pull/408) by [@pilosus](https://github.com/pilosus)\n* fix path in nested models, [#437](https://github.com/pydantic/pydantic/pull/437) by [@kataev](https://github.com/kataev)\n* add `Sequence` support, [#304](https://github.com/pydantic/pydantic/pull/304) by [@pilosus](https://github.com/pilosus)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v022-2019-03-29indexhtmlv022-2019-03-29-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.21.0 (2019-03-15)[Â¶](index.html#v0210-2019-03-15 \"Permanent link\")", "anchor": "v0210-2019-03-15indexhtmlv0210-2019-03-15-permanent-link", "md_text": "* fix typo in `NoneIsNotAllowedError` message, [#414](https://github.com/pydantic/pydantic/pull/414) by [@YaraslauZhylko](https://github.com/YaraslauZhylko)\n* add `IPvAnyAddress`, `IPv4Address` and `IPv6Address` types, [#333](https://github.com/pydantic/pydantic/pull/333) by [@pilosus](https://github.com/pilosus)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v0210-2019-03-15indexhtmlv0210-2019-03-15-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.20.1 (2019-02-26)[Â¶](index.html#v0201-2019-02-26 \"Permanent link\")", "anchor": "v0201-2019-02-26indexhtmlv0201-2019-02-26-permanent-link", "md_text": "* fix type hints of `parse_obj` and similar methods, [#405](https://github.com/pydantic/pydantic/pull/405) by [@erosennin](https://github.com/erosennin)\n* fix submodel validation, [#403](https://github.com/pydantic/pydantic/pull/403) by [@samuelcolvin](https://github.com/samuelcolvin)\n* correct type hints for `ValidationError.json`, [#406](https://github.com/pydantic/pydantic/pull/406) by [@layday](https://github.com/layday)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v0201-2019-02-26indexhtmlv0201-2019-02-26-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.20.0 (2019-02-18)[Â¶](index.html#v0200-2019-02-18 \"Permanent link\")", "anchor": "v0200-2019-02-18indexhtmlv0200-2019-02-18-permanent-link", "md_text": "* fix tests for Python 3.8, [#396](https://github.com/pydantic/pydantic/pull/396) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Adds fields to the `dir` method for autocompletion in interactive sessions, [#398](https://github.com/pydantic/pydantic/pull/398) by [@dgasmith](https://github.com/dgasmith)\n* support `ForwardRef` (and therefore `from __future__ import annotations`) with dataclasses, [#397](https://github.com/pydantic/pydantic/pull/397) by [@samuelcolvin](https://github.com/samuelcolvin)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v0200-2019-02-18indexhtmlv0200-2019-02-18-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.20.0a1 (2019-02-13)[Â¶](index.html#v0200a1-2019-02-13 \"Permanent link\")", "anchor": "v0200a1-2019-02-13indexhtmlv0200a1-2019-02-13-permanent-link", "md_text": "* **breaking change** (maybe): more sophisticated argument parsing for validators, any subset of\n  `values`, `config` and `field` is now permitted, eg. `(cls, value, field)`,\n  however the variadic key word argument (\"`**kwargs`\") **must** be called `kwargs`, [#388](https://github.com/pydantic/pydantic/pull/388) by [@samuelcolvin](https://github.com/samuelcolvin)\n* **breaking change**: Adds `skip_defaults` argument to `BaseModel.dict()` to allow skipping of fields that\n  were not explicitly set, signature of `Model.construct()` changed, [#389](https://github.com/pydantic/pydantic/pull/389) by [@dgasmith](https://github.com/dgasmith)\n* add `py.typed` marker file for PEP-561 support, [#391](https://github.com/pydantic/pydantic/pull/391) by [@je-l](https://github.com/je-l)\n* Fix `extra` behaviour for multiple inheritance/mix-ins, [#394](https://github.com/pydantic/pydantic/pull/394) by [@YaraslauZhylko](https://github.com/YaraslauZhylko)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v0200a1-2019-02-13indexhtmlv0200a1-2019-02-13-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.19.0 (2019-02-04)[Â¶](index.html#v0190-2019-02-04 \"Permanent link\")", "anchor": "v0190-2019-02-04indexhtmlv0190-2019-02-04-permanent-link", "md_text": "* Support `Callable` type hint, fix [#279](https://github.com/pydantic/pydantic/pull/279) by [@proofit404](https://github.com/proofit404)\n* Fix schema for fields with `validator` decorator, fix [#375](https://github.com/pydantic/pydantic/pull/375) by [@tiangolo](https://github.com/tiangolo)\n* Add `multiple_of` constraint to `ConstrainedDecimal`, `ConstrainedFloat`, `ConstrainedInt`\n  and their related types `condecimal`, `confloat`, and `conint` [#371](https://github.com/pydantic/pydantic/pull/371), thanks [@StephenBrown2](https://github.com/StephenBrown2)\n* Deprecated `ignore_extra` and `allow_extra` Config fields in favor of `extra`, [#352](https://github.com/pydantic/pydantic/pull/352) by [@liiight](https://github.com/liiight)\n* Add type annotations to all functions, test fully with mypy, [#373](https://github.com/pydantic/pydantic/pull/373) by [@samuelcolvin](https://github.com/samuelcolvin)\n* fix for 'missing' error with `validate_all` or `validate_always`, [#381](https://github.com/pydantic/pydantic/pull/381) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Change the second/millisecond watershed for date/datetime parsing to `2e10`, [#385](https://github.com/pydantic/pydantic/pull/385) by [@samuelcolvin](https://github.com/samuelcolvin)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v0190-2019-02-04indexhtmlv0190-2019-02-04-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.18.2 (2019-01-22)[Â¶](index.html#v0182-2019-01-22 \"Permanent link\")", "anchor": "v0182-2019-01-22indexhtmlv0182-2019-01-22-permanent-link", "md_text": "* Fix to schema generation with `Optional` fields, fix [#361](https://github.com/pydantic/pydantic/pull/361) by [@samuelcolvin](https://github.com/samuelcolvin)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v0182-2019-01-22indexhtmlv0182-2019-01-22-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.18.1 (2019-01-17)[Â¶](index.html#v0181-2019-01-17 \"Permanent link\")", "anchor": "v0181-2019-01-17indexhtmlv0181-2019-01-17-permanent-link", "md_text": "* add `ConstrainedBytes` and `conbytes` types, [#315](https://github.com/pydantic/pydantic/pull/315) [@Gr1N](https://github.com/Gr1N)\n* adding `MANIFEST.in` to include license in package `.tar.gz`, [#358](https://github.com/pydantic/pydantic/pull/358) by [@samuelcolvin](https://github.com/samuelcolvin)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v0181-2019-01-17indexhtmlv0181-2019-01-17-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.18.0 (2019-01-13)[Â¶](index.html#v0180-2019-01-13 \"Permanent link\")", "anchor": "v0180-2019-01-13indexhtmlv0180-2019-01-13-permanent-link", "md_text": "* **breaking change**: don't call validators on keys of dictionaries, [#254](https://github.com/pydantic/pydantic/pull/254) by [@samuelcolvin](https://github.com/samuelcolvin)\n* Fix validators with `always=True` when the default is `None` or the type is optional, also prevent\n  `whole` validators being called for sub-fields, fix [#132](https://github.com/pydantic/pydantic/pull/132) by [@samuelcolvin](https://github.com/samuelcolvin)\n* improve documentation for settings priority and allow it to be easily changed, [#343](https://github.com/pydantic/pydantic/pull/343) by [@samuelcolvin](https://github.com/samuelcolvin)\n* fix `ignore_extra=False` and `allow_population_by_alias=True`, fix [#257](https://github.com/pydantic/pydantic/pull/257) by [@samuelcolvin](https://github.com/samuelcolvin)\n* **breaking change**: Set `BaseConfig` attributes `min_anystr_length` and `max_anystr_length` to\n  `None` by default, fix [#349](https://github.com/pydantic/pydantic/pull/349) in [#350](https://github.com/pydantic/pydantic/pull/350) by [@tiangolo](https://github.com/tiangolo)\n* add support for postponed annotations, [#348](https://github.com/pydantic/pydantic/pull/348) by [@samuelcolvin](https://github.com/samuelcolvin)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v0180-2019-01-13indexhtmlv0180-2019-01-13-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.17.0 (2018-12-27)[Â¶](index.html#v0170-2018-12-27 \"Permanent link\")", "anchor": "v0170-2018-12-27indexhtmlv0170-2018-12-27-permanent-link", "md_text": "* fix schema for `timedelta` as number, [#325](https://github.com/pydantic/pydantic/pull/325) by [@tiangolo](https://github.com/tiangolo)\n* prevent validators being called repeatedly after inheritance, [#327](https://github.com/pydantic/pydantic/pull/327) by [@samuelcolvin](https://github.com/samuelcolvin)\n* prevent duplicate validator check in ipython, fix [#312](https://github.com/pydantic/pydantic/pull/312) by [@samuelcolvin](https://github.com/samuelcolvin)\n* add \"Using Pydantic\" section to docs, [#323](https://github.com/pydantic/pydantic/pull/323) by [@tiangolo](https://github.com/tiangolo) & [#326](https://github.com/pydantic/pydantic/pull/326) by [@samuelcolvin](https://github.com/samuelcolvin)\n* fix schema generation for fields annotated as `: dict`, `: list`,\n  `: tuple` and `: set`, [#330](https://github.com/pydantic/pydantic/pull/330) & [#335](https://github.com/pydantic/pydantic/pull/335) by [@nkonin](https://github.com/nkonin)\n* add support for constrained strings as dict keys in schema, [#332](https://github.com/pydantic/pydantic/pull/332) by [@tiangolo](https://github.com/tiangolo)\n* support for passing Config class in dataclasses decorator, [#276](https://github.com/pydantic/pydantic/pull/276) by [@jarekkar](https://github.com/jarekkar)\n  (**breaking change**: this supersedes the `validate_assignment` argument with `config`)\n* support for nested dataclasses, [#334](https://github.com/pydantic/pydantic/pull/334) by [@samuelcolvin](https://github.com/samuelcolvin)\n* better errors when getting an `ImportError` with `PyObject`, [#309](https://github.com/pydantic/pydantic/pull/309) by [@samuelcolvin](https://github.com/samuelcolvin)\n* rename `get_validators` to `__get_validators__`, deprecation warning on use of old name, [#338](https://github.com/pydantic/pydantic/pull/338) by [@samuelcolvin](https://github.com/samuelcolvin)\n* support `ClassVar` by excluding such attributes from fields, [#184](https://github.com/pydantic/pydantic/pull/184) by [@samuelcolvin](https://github.com/samuelcolvin)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v0170-2018-12-27indexhtmlv0170-2018-12-27-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.16.1 (2018-12-10)[Â¶](index.html#v0161-2018-12-10 \"Permanent link\")", "anchor": "v0161-2018-12-10indexhtmlv0161-2018-12-10-permanent-link", "md_text": "* fix `create_model` to correctly use the passed `__config__`, [#320](https://github.com/pydantic/pydantic/pull/320) by [@hugoduncan](https://github.com/hugoduncan)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v0161-2018-12-10indexhtmlv0161-2018-12-10-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.16.0 (2018-12-03)[Â¶](index.html#v0160-2018-12-03 \"Permanent link\")", "anchor": "v0160-2018-12-03indexhtmlv0160-2018-12-03-permanent-link", "md_text": "* **breaking change**: refactor schema generation to be compatible with JSON Schema and OpenAPI specs, [#308](https://github.com/pydantic/pydantic/pull/308) by [@tiangolo](https://github.com/tiangolo)\n* add `schema` to `schema` module to generate top-level schemas from base models, [#308](https://github.com/pydantic/pydantic/pull/308) by [@tiangolo](https://github.com/tiangolo)\n* add additional fields to `Schema` class to declare validation for `str` and numeric values, [#311](https://github.com/pydantic/pydantic/pull/311) by [@tiangolo](https://github.com/tiangolo)\n* rename `_schema` to `schema` on fields, [#318](https://github.com/pydantic/pydantic/pull/318) by [@samuelcolvin](https://github.com/samuelcolvin)\n* add `case_insensitive` option to `BaseSettings` `Config`, [#277](https://github.com/pydantic/pydantic/pull/277) by [@jasonkuhrt](https://github.com/jasonkuhrt)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v0160-2018-12-03indexhtmlv0160-2018-12-03-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.15.0 (2018-11-18)[Â¶](index.html#v0150-2018-11-18 \"Permanent link\")", "anchor": "v0150-2018-11-18indexhtmlv0150-2018-11-18-permanent-link", "md_text": "* move codebase to use black, [#287](https://github.com/pydantic/pydantic/pull/287) by [@samuelcolvin](https://github.com/samuelcolvin)\n* fix alias use in settings, [#286](https://github.com/pydantic/pydantic/pull/286) by [@jasonkuhrt](https://github.com/jasonkuhrt) and [@samuelcolvin](https://github.com/samuelcolvin)\n* fix datetime parsing in `parse_date`, [#298](https://github.com/pydantic/pydantic/pull/298) by [@samuelcolvin](https://github.com/samuelcolvin)\n* allow dataclass inheritance, fix [#293](https://github.com/pydantic/pydantic/pull/293) by [@samuelcolvin](https://github.com/samuelcolvin)\n* fix `PyObject = None`, fix [#305](https://github.com/pydantic/pydantic/pull/305) by [@samuelcolvin](https://github.com/samuelcolvin)\n* allow `Pattern` type, fix [#303](https://github.com/pydantic/pydantic/pull/303) by [@samuelcolvin](https://github.com/samuelcolvin)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v0150-2018-11-18indexhtmlv0150-2018-11-18-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.14.0 (2018-10-02)[Â¶](index.html#v0140-2018-10-02 \"Permanent link\")", "anchor": "v0140-2018-10-02indexhtmlv0140-2018-10-02-permanent-link", "md_text": "* dataclasses decorator, [#269](https://github.com/pydantic/pydantic/pull/269) by [@Gaunt](https://github.com/Gaunt) and [@samuelcolvin](https://github.com/samuelcolvin)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v0140-2018-10-02indexhtmlv0140-2018-10-02-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.13.1 (2018-09-21)[Â¶](index.html#v0131-2018-09-21 \"Permanent link\")", "anchor": "v0131-2018-09-21indexhtmlv0131-2018-09-21-permanent-link", "md_text": "* fix issue where int\\_validator doesn't cast a `bool` to an `int` [#264](https://github.com/pydantic/pydantic/pull/264) by [@nphyatt](https://github.com/nphyatt)\n* add deep copy support for `BaseModel.copy()` [#249](https://github.com/pydantic/pydantic/pull/249), [@gangefors](https://github.com/gangefors)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v0131-2018-09-21indexhtmlv0131-2018-09-21-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.13.0 (2018-08-25)[Â¶](index.html#v0130-2018-08-25 \"Permanent link\")", "anchor": "v0130-2018-08-25indexhtmlv0130-2018-08-25-permanent-link", "md_text": "* raise an exception if a field's name shadows an existing `BaseModel` attribute [#242](https://github.com/pydantic/pydantic/pull/242)\n* add `UrlStr` and `urlstr` types [#236](https://github.com/pydantic/pydantic/pull/236)\n* timedelta json encoding ISO8601 and total seconds, custom json encoders [#247](https://github.com/pydantic/pydantic/pull/247), by [@cfkanesan](https://github.com/cfkanesan) and [@samuelcolvin](https://github.com/samuelcolvin)\n* allow `timedelta` objects as values for properties of type `timedelta` (matches `datetime` etc. behavior) [#247](https://github.com/pydantic/pydantic/pull/247)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v0130-2018-08-25indexhtmlv0130-2018-08-25-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.12.1 (2018-07-31)[Â¶](index.html#v0121-2018-07-31 \"Permanent link\")", "anchor": "v0121-2018-07-31indexhtmlv0121-2018-07-31-permanent-link", "md_text": "* fix schema generation for fields defined using `typing.Any` [#237](https://github.com/pydantic/pydantic/pull/237)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v0121-2018-07-31indexhtmlv0121-2018-07-31-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.12.0 (2018-07-31)[Â¶](index.html#v0120-2018-07-31 \"Permanent link\")", "anchor": "v0120-2018-07-31indexhtmlv0120-2018-07-31-permanent-link", "md_text": "* add `by_alias` argument in `.dict()` and `.json()` model methods [#205](https://github.com/pydantic/pydantic/pull/205)\n* add Json type support [#214](https://github.com/pydantic/pydantic/pull/214)\n* support tuples [#227](https://github.com/pydantic/pydantic/pull/227)\n* major improvements and changes to schema [#213](https://github.com/pydantic/pydantic/pull/213)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v0120-2018-07-31indexhtmlv0120-2018-07-31-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.11.2 (2018-07-05)[Â¶](index.html#v0112-2018-07-05 \"Permanent link\")", "anchor": "v0112-2018-07-05indexhtmlv0112-2018-07-05-permanent-link", "md_text": "* add `NewType` support [#115](https://github.com/pydantic/pydantic/pull/115)\n* fix `list`, `set` & `tuple` validation [#225](https://github.com/pydantic/pydantic/pull/225)\n* separate out `validate_model` method, allow errors to be returned along with valid values [#221](https://github.com/pydantic/pydantic/pull/221)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v0112-2018-07-05indexhtmlv0112-2018-07-05-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.11.1 (2018-07-02)[Â¶](index.html#v0111-2018-07-02 \"Permanent link\")", "anchor": "v0111-2018-07-02indexhtmlv0111-2018-07-02-permanent-link", "md_text": "* support Python 3.7 [#216](https://github.com/pydantic/pydantic/pull/216), thanks [@layday](https://github.com/layday)\n* Allow arbitrary types in model [#209](https://github.com/pydantic/pydantic/pull/209), thanks [@oldPadavan](https://github.com/oldPadavan)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v0111-2018-07-02indexhtmlv0111-2018-07-02-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.11.0 (2018-06-28)[Â¶](index.html#v0110-2018-06-28 \"Permanent link\")", "anchor": "v0110-2018-06-28indexhtmlv0110-2018-06-28-permanent-link", "md_text": "* make `list`, `tuple` and `set` types stricter [#86](https://github.com/pydantic/pydantic/pull/86)\n* **breaking change**: remove msgpack parsing [#201](https://github.com/pydantic/pydantic/pull/201)\n* add `FilePath` and `DirectoryPath` types [#10](https://github.com/pydantic/pydantic/pull/10)\n* model schema generation [#190](https://github.com/pydantic/pydantic/pull/190)\n* JSON serialization of models and schemas [#133](https://github.com/pydantic/pydantic/pull/133)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v0110-2018-06-28indexhtmlv0110-2018-06-28-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.10.0 (2018-06-11)[Â¶](index.html#v0100-2018-06-11 \"Permanent link\")", "anchor": "v0100-2018-06-11indexhtmlv0100-2018-06-11-permanent-link", "md_text": "* add `Config.allow_population_by_alias` [#160](https://github.com/pydantic/pydantic/pull/160), thanks [@bendemaree](https://github.com/bendemaree)\n* **breaking change**: new errors format [#179](https://github.com/pydantic/pydantic/pull/179), thanks [@Gr1N](https://github.com/Gr1N)\n* **breaking change**: removed `Config.min_number_size` and `Config.max_number_size` [#183](https://github.com/pydantic/pydantic/pull/183), thanks [@Gr1N](https://github.com/Gr1N)\n* **breaking change**: correct behaviour of `lt` and `gt` arguments to `conint` etc. [#188](https://github.com/pydantic/pydantic/pull/188)\n  for the old behaviour use `le` and `ge` [#194](https://github.com/pydantic/pydantic/pull/194), thanks [@jaheba](https://github.com/jaheba)\n* added error context and ability to redefine error message templates using `Config.error_msg_templates` [#183](https://github.com/pydantic/pydantic/pull/183),\n  thanks [@Gr1N](https://github.com/Gr1N)\n* fix typo in validator exception [#150](https://github.com/pydantic/pydantic/pull/150)\n* copy defaults to model values, so different models don't share objects [#154](https://github.com/pydantic/pydantic/pull/154)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v0100-2018-06-11indexhtmlv0100-2018-06-11-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.9.1 (2018-05-10)[Â¶](index.html#v091-2018-05-10 \"Permanent link\")", "anchor": "v091-2018-05-10indexhtmlv091-2018-05-10-permanent-link", "md_text": "* allow custom `get_field_config` on config classes [#159](https://github.com/pydantic/pydantic/pull/159)\n* add `UUID1`, `UUID3`, `UUID4` and `UUID5` types [#167](https://github.com/pydantic/pydantic/pull/167), thanks [@Gr1N](https://github.com/Gr1N)\n* modify some inconsistent docstrings and annotations [#173](https://github.com/pydantic/pydantic/pull/173), thanks [@YannLuo](https://github.com/YannLuo)\n* fix type annotations for exotic types [#171](https://github.com/pydantic/pydantic/pull/171), thanks [@Gr1N](https://github.com/Gr1N)\n* Reuse type validators in exotic types [#171](https://github.com/pydantic/pydantic/pull/171)\n* scheduled monthly requirements updates [#168](https://github.com/pydantic/pydantic/pull/168)\n* add `Decimal`, `ConstrainedDecimal` and `condecimal` types [#170](https://github.com/pydantic/pydantic/pull/170), thanks [@Gr1N](https://github.com/Gr1N)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v091-2018-05-10indexhtmlv091-2018-05-10-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.9.0 (2018-04-28)[Â¶](index.html#v090-2018-04-28 \"Permanent link\")", "anchor": "v090-2018-04-28indexhtmlv090-2018-04-28-permanent-link", "md_text": "* tweak email-validator import error message [#145](https://github.com/pydantic/pydantic/pull/145)\n* fix parse error of `parse_date()` and `parse_datetime()` when input is 0 [#144](https://github.com/pydantic/pydantic/pull/144), thanks [@YannLuo](https://github.com/YannLuo)\n* add `Config.anystr_strip_whitespace` and `strip_whitespace` kwarg to `constr`,\n  by default values is `False` [#163](https://github.com/pydantic/pydantic/pull/163), thanks [@Gr1N](https://github.com/Gr1N)\n* add `ConstrainedFloat`, `confloat`, `PositiveFloat` and `NegativeFloat` types [#166](https://github.com/pydantic/pydantic/pull/166), thanks [@Gr1N](https://github.com/Gr1N)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v090-2018-04-28indexhtmlv090-2018-04-28-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.8.0 (2018-03-25)[Â¶](index.html#v080-2018-03-25 \"Permanent link\")", "anchor": "v080-2018-03-25indexhtmlv080-2018-03-25-permanent-link", "md_text": "* fix type annotation for `inherit_config` [#139](https://github.com/pydantic/pydantic/pull/139)\n* **breaking change**: check for invalid field names in validators [#140](https://github.com/pydantic/pydantic/pull/140)\n* validate attributes of parent models [#141](https://github.com/pydantic/pydantic/pull/141)\n* **breaking change**: email validation now uses\n  [email-validator](https://github.com/JoshData/python-email-validator) [#142](https://github.com/pydantic/pydantic/pull/142)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v080-2018-03-25indexhtmlv080-2018-03-25-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.7.1 (2018-02-07)[Â¶](index.html#v071-2018-02-07 \"Permanent link\")", "anchor": "v071-2018-02-07indexhtmlv071-2018-02-07-permanent-link", "md_text": "* fix bug with `create_model` modifying the base class", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v071-2018-02-07indexhtmlv071-2018-02-07-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.7.0 (2018-02-06)[Â¶](index.html#v070-2018-02-06 \"Permanent link\")", "anchor": "v070-2018-02-06indexhtmlv070-2018-02-06-permanent-link", "md_text": "* added compatibility with abstract base classes (ABCs) [#123](https://github.com/pydantic/pydantic/pull/123)\n* add `create_model` method [#113](https://github.com/pydantic/pydantic/pull/113) [#125](https://github.com/pydantic/pydantic/pull/125)\n* **breaking change**: rename `.config` to `.__config__` on a model\n* **breaking change**: remove deprecated `.values()` on a model, use `.dict()` instead\n* remove use of `OrderedDict` and use simple dict [#126](https://github.com/pydantic/pydantic/pull/126)\n* add `Config.use_enum_values` [#127](https://github.com/pydantic/pydantic/pull/127)\n* add wildcard validators of the form `@validate('*')` [#128](https://github.com/pydantic/pydantic/pull/128)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v070-2018-02-06indexhtmlv070-2018-02-06-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.6.4 (2018-02-01)[Â¶](index.html#v064-2018-02-01 \"Permanent link\")", "anchor": "v064-2018-02-01indexhtmlv064-2018-02-01-permanent-link", "md_text": "* allow Python date and times objects [#122](https://github.com/pydantic/pydantic/pull/122)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v064-2018-02-01indexhtmlv064-2018-02-01-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.6.3 (2017-11-26)[Â¶](index.html#v063-2017-11-26 \"Permanent link\")", "anchor": "v063-2017-11-26indexhtmlv063-2017-11-26-permanent-link", "md_text": "* fix direct install without `README.rst` present", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v063-2017-11-26indexhtmlv063-2017-11-26-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.6.2 (2017-11-13)[Â¶](index.html#v062-2017-11-13 \"Permanent link\")", "anchor": "v062-2017-11-13indexhtmlv062-2017-11-13-permanent-link", "md_text": "* errors for invalid validator use\n* safer check for complex models in `Settings`", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v062-2017-11-13indexhtmlv062-2017-11-13-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.6.1 (2017-11-08)[Â¶](index.html#v061-2017-11-08 \"Permanent link\")", "anchor": "v061-2017-11-08indexhtmlv061-2017-11-08-permanent-link", "md_text": "* prevent duplicate validators, [#101](https://github.com/pydantic/pydantic/pull/101)\n* add `always` kwarg to validators, [#102](https://github.com/pydantic/pydantic/pull/102)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v061-2017-11-08indexhtmlv061-2017-11-08-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.6.0 (2017-11-07)[Â¶](index.html#v060-2017-11-07 \"Permanent link\")", "anchor": "v060-2017-11-07indexhtmlv060-2017-11-07-permanent-link", "md_text": "* assignment validation [#94](https://github.com/pydantic/pydantic/pull/94), thanks petroswork!\n* JSON in environment variables for complex types, [#96](https://github.com/pydantic/pydantic/pull/96)\n* add `validator` decorators for complex validation, [#97](https://github.com/pydantic/pydantic/pull/97)\n* depreciate `values(...)` and replace with `.dict(...)`, [#99](https://github.com/pydantic/pydantic/pull/99)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v060-2017-11-07indexhtmlv060-2017-11-07-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.5.0 (2017-10-23)[Â¶](index.html#v050-2017-10-23 \"Permanent link\")", "anchor": "v050-2017-10-23indexhtmlv050-2017-10-23-permanent-link", "md_text": "* add `UUID` validation [#89](https://github.com/pydantic/pydantic/pull/89)\n* remove `index` and `track` from error object (json) if they're null [#90](https://github.com/pydantic/pydantic/pull/90)\n* improve the error text when a list is provided rather than a dict [#90](https://github.com/pydantic/pydantic/pull/90)\n* add benchmarks table to docs [#91](https://github.com/pydantic/pydantic/pull/91)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v050-2017-10-23indexhtmlv050-2017-10-23-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.4.0 (2017-07-08)[Â¶](index.html#v040-2017-07-08 \"Permanent link\")", "anchor": "v040-2017-07-08indexhtmlv040-2017-07-08-permanent-link", "md_text": "* show length in string validation error\n* fix aliases in config during inheritance [#55](https://github.com/pydantic/pydantic/pull/55)\n* simplify error display\n* use unicode ellipsis in `truncate`\n* add `parse_obj`, `parse_raw` and `parse_file` helper functions [#58](https://github.com/pydantic/pydantic/pull/58)\n* switch annotation only fields to come first in fields list not last", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v040-2017-07-08indexhtmlv040-2017-07-08-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.3.0 (2017-06-21)[Â¶](index.html#v030-2017-06-21 \"Permanent link\")", "anchor": "v030-2017-06-21indexhtmlv030-2017-06-21-permanent-link", "md_text": "* immutable models via `config.allow_mutation = False`, associated cleanup and performance improvement [#44](https://github.com/pydantic/pydantic/pull/44)\n* immutable helper methods `construct()` and `copy()` [#53](https://github.com/pydantic/pydantic/pull/53)\n* allow pickling of models [#53](https://github.com/pydantic/pydantic/pull/53)\n* `setattr` is removed as `__setattr__` is now intelligent [#44](https://github.com/pydantic/pydantic/pull/44)\n* `raise_exception` removed, Models now always raise exceptions [#44](https://github.com/pydantic/pydantic/pull/44)\n* instance method validators removed\n* django-restful-framework benchmarks added [#47](https://github.com/pydantic/pydantic/pull/47)\n* fix inheritance bug [#49](https://github.com/pydantic/pydantic/pull/49)\n* make str type stricter so list, dict etc are not coerced to strings. [#52](https://github.com/pydantic/pydantic/pull/52)\n* add `StrictStr` which only always strings as input [#52](https://github.com/pydantic/pydantic/pull/52)", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v030-2017-06-21indexhtmlv030-2017-06-21-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.2.1 (2017-06-07)[Â¶](index.html#v021-2017-06-07 \"Permanent link\")", "anchor": "v021-2017-06-07indexhtmlv021-2017-06-07-permanent-link", "md_text": "* pypi and travis together messed up the deploy of `v0.2` this should fix it", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v021-2017-06-07indexhtmlv021-2017-06-07-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.2.0 (2017-06-07)[Â¶](index.html#v020-2017-06-07 \"Permanent link\")", "anchor": "v020-2017-06-07indexhtmlv020-2017-06-07-permanent-link", "md_text": "* **breaking change**: `values()` on a model is now a method not a property,\n  takes `include` and `exclude` arguments\n* allow annotation only fields to support mypy\n* add pretty `to_string(pretty=True)` method for models", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v020-2017-06-07indexhtmlv020-2017-06-07-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "v0.1.0 (2017-06-03)[Â¶](index.html#v010-2017-06-03 \"Permanent link\")", "anchor": "v010-2017-06-03indexhtmlv010-2017-06-03-permanent-link", "md_text": "* add docs\n* add history\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/changelog/index.html#v010-2017-06-03indexhtmlv010-2017-06-03-permanent-link", "page": "changelog/index.html", "source_site": "pydantic"}
{"title": "Install Pydantic V2[Â¶](index.html#install-pydantic-v2 \"Permanent link\")", "anchor": "install-pydantic-v2indexhtmlinstall-pydantic-v2-permanent-link", "md_text": "Pydantic V2 is now the current production release of Pydantic.\nYou can install Pydantic V2 from PyPI:\n\n```\npip install -U pydantic\n```\n\nIf you encounter any issues, please [create an issue in GitHub](https://github.com/pydantic/pydantic/issues) using\nthe `bug V2` label. This will help us to actively monitor and track errors, and to continue to improve the library's\nperformance.\n\nIf you need to use latest Pydantic V1 for any reason, see the [Continue using Pydantic V1 features](index.html#continue-using-pydantic-v1-features) section below for details on installation and imports from `pydantic.v1`.", "url": "https://docs.pydantic.dev/latest/migration/index.html#install-pydantic-v2indexhtmlinstall-pydantic-v2-permanent-link", "page": "migration/index.html", "source_site": "pydantic"}
{"title": "Code transformation tool[Â¶](index.html#code-transformation-tool \"Permanent link\")", "anchor": "code-transformation-toolindexhtmlcode-transformation-tool-permanent-link", "md_text": "We have created a tool to help you migrate your code. This tool is still in beta, but we hope it will help you to\nmigrate your code more quickly.\n\nYou can install the tool from PyPI:\n\n```\npip install bump-pydantic\n```\n\nThe usage is simple. If your project structure is:\n\n```\n* repo_folder\n    * my_package\n        * <python source files> ...\n```\n\nThen you'll want to do:\n\n```\ncd /path/to/repo_folder\nbump-pydantic my_package\n```\n\nSee more about it on the [Bump Pydantic](https://github.com/pydantic/bump-pydantic) repository.", "url": "https://docs.pydantic.dev/latest/migration/index.html#code-transformation-toolindexhtmlcode-transformation-tool-permanent-link", "page": "migration/index.html", "source_site": "pydantic"}
{"title": "Continue using Pydantic V1 features[Â¶](index.html#continue-using-pydantic-v1-features \"Permanent link\")", "anchor": "continue-using-pydantic-v1-featuresindexhtmlcontinue-using-pydantic-v1-features-permanent-link", "md_text": "Pydantic V1 is still available when you need it, though we recommend migrating to\nPydantic V2 for its improvements and new features.\n\nIf you need to use latest Pydantic V1, you can install it with:\n\n```\npip install \"pydantic==1.*\"\n```\n\nThe Pydantic V2 package also continues to provide access to the Pydantic V1 API\nby importing through `pydantic.v1`.\n\nFor example, you can use the `BaseModel` class from Pydantic V1 instead of the\nPydantic V2 `pydantic.BaseModel` class:\n\n```\nfrom pydantic.v1 import BaseModel\n```\n\nYou can also import functions that have been removed from Pydantic V2, such as `lenient_isinstance`:\n\n```\nfrom pydantic.v1.utils import lenient_isinstance\n```\n\nPydantic V1 documentation is available at <https://docs.pydantic.dev/1.10/>.", "url": "https://docs.pydantic.dev/latest/migration/index.html#continue-using-pydantic-v1-featuresindexhtmlcontinue-using-pydantic-v1-features-permanent-link", "page": "migration/index.html", "source_site": "pydantic"}
{"title": "Using Pydantic v1 features in a v1/v2 environment[Â¶](index.html#using-pydantic-v1-features-in-a-v1v2-environment \"Permanent link\")", "anchor": "using-pydantic-v1-features-in-a-v1v2-environmentindexhtmlusing-pydantic-v1-features-in-a-v1v2-environment-permanent-link", "md_text": "As of `pydantic>=1.10.17`, the `pydantic.v1` namespace can be used within V1.\nThis makes it easier to migrate to V2, which also supports the `pydantic.v1`\nnamespace. In order to unpin a `pydantic<2` dependency and continue using V1\nfeatures, take the following steps:\n\n1. Replace `pydantic<2` with `pydantic>=1.10.17`\n2. Find and replace all occurrences of:\n\n```\nfrom pydantic.<module> import <object>\n```\n\nwith:\n\n```\nfrom pydantic.v1.<module> import <object>\n```\n\nHere's how you can import `pydantic`'s v1 features based on your version of `pydantic`:\n\n`pydantic>=1.10.17,<3``pydantic<3`\n\nAs of `v1.10.17` the `.v1` namespace is available in V1, allowing imports as below:\n\n```\nfrom pydantic.v1.fields import ModelField\n```\n\nAll versions of Pydantic V1 and V2 support the following import pattern, in case you don't\nknow which version of Pydantic you are using:\n\n```\ntry:\n    from pydantic.v1.fields import ModelField\nexcept ImportError:\n    from pydantic.fields import ModelField\n```\n\nWhen importing modules using `pydantic>=1.10.17,<2` with the `.v1` namespace\nthese modules will *not* be the **same** module as the same import without the `.v1`\nnamespace, but the symbols imported *will* be. For example `pydantic.v1.fields is not pydantic.fields`\nbut `pydantic.v1.fields.ModelField is pydantic.fields.ModelField`. Luckily, this is not likely to be relevant\nin the vast majority of cases. It's just an unfortunate consequence of providing a smoother migration experience.", "url": "https://docs.pydantic.dev/latest/migration/index.html#using-pydantic-v1-features-in-a-v1v2-environmentindexhtmlusing-pydantic-v1-features-in-a-v1v2-environment-permanent-link", "page": "migration/index.html", "source_site": "pydantic"}
{"title": "Migration guide[Â¶](index.html#migration-guide \"Permanent link\")", "anchor": "migration-guideindexhtmlmigration-guide-permanent-link", "md_text": "The following sections provide details on the most important changes in Pydantic V2.", "url": "https://docs.pydantic.dev/latest/migration/index.html#migration-guideindexhtmlmigration-guide-permanent-link", "page": "migration/index.html", "source_site": "pydantic"}
{"title": "Changes to `pydantic.BaseModel`[Â¶](index.html#changes-to-pydanticbasemodel \"Permanent link\")", "anchor": "changes-to-pydanticbasemodelindexhtmlchanges-to-pydanticbasemodel-permanent-link", "md_text": "Various method names have been changed; all non-deprecated `BaseModel` methods now have names matching either the\nformat `model_.*` or `__.*pydantic.*__`. Where possible, we have retained the deprecated methods with their old names\nto help ease migration, but calling them will emit `DeprecationWarning`s.\n\n| Pydantic V1 | Pydantic V2 |\n| --- | --- |\n| `__fields__` | `model_fields` |\n| `__private_attributes__` | `__pydantic_private__` |\n| `__validators__` | `__pydantic_validator__` |\n| `construct()` | `model_construct()` |\n| `copy()` | `model_copy()` |\n| `dict()` | `model_dump()` |\n| `json_schema()` | `model_json_schema()` |\n| `json()` | `model_dump_json()` |\n| `parse_obj()` | `model_validate()` |\n| `update_forward_refs()` | `model_rebuild()` |\n\n* Some of the built-in data-loading functionality has been slated for removal. In particular,\n  `parse_raw` and `parse_file` are now deprecated. In Pydantic V2, `model_validate_json` works like `parse_raw`. Otherwise, you should load the data and then pass it to `model_validate`.\n* The `from_orm` method has been deprecated; you can now just use `model_validate` (equivalent to `parse_obj` from\n  Pydantic V1) to achieve something similar, as long as you've set `from_attributes=True` in the model config.\n* The `__eq__` method has changed for models.\n  + Models can only be equal to other `BaseModel` instances.\n  + For two model instances to be equal, they must have the same:\n    - Type (or, in the case of generic models, non-parametrized generic origin type)\n    - Field values\n    - Extra values (only relevant when `model_config['extra'] == 'allow'`)\n    - Private attribute values; models with different values of private attributes are no longer equal.\n    - Models are no longer equal to the dicts containing their data.\n    - Non-generic models of different types are never equal.\n    - Generic models with different origin types are never equal. We don't require *exact* type equality so that,\n      for example, instances of `MyGenericModel[Any]` could be equal to instances of `MyGenericModel[int]`.\n* We have replaced the use of the `__root__` field to specify a \"custom root model\" with a new type called\n  [`RootModel`](../concepts/models/index.html#rootmodel-and-custom-root-types) which is intended to replace the functionality of\n  using a field called `__root__` in Pydantic V1. Note, `RootModel` types no longer support the `arbitrary_types_allowed`\n  config setting. See [this issue comment](https://github.com/pydantic/pydantic/issues/6710#issuecomment-1700948167) for an explanation.\n* We have significantly expanded Pydantic's capabilities related to customizing serialization. In particular, we have\n  added the [`@field_serializer`](../api/functional_serializers/index.html#pydantic.functional_serializers.field_serializer),\n  [`@model_serializer`](../api/functional_serializers/index.html#pydantic.functional_serializers.model_serializer), and\n  [`@computed_field`](../api/fields/index.html#pydantic.fields.computed_field) decorators, which each address various\n  shortcomings from Pydantic V1.\n  + See [Custom serializers](../concepts/serialization/index.html#serializers) for the usage docs of these new decorators.\n  + Due to performance overhead and implementation complexity, we have now deprecated support for specifying\n    `json_encoders` in the model config. This functionality was originally added for the purpose of achieving custom\n    serialization logic, and we think the new serialization decorators are a better choice in most common scenarios.\n* We have changed the behavior related to serializing subclasses of models when they occur as nested fields in a parent\n  model. In V1, we would always include all fields from the subclass instance. In V2, when we dump a model, we only\n  include the fields that are defined on the annotated type of the field. This helps prevent some accidental security\n  bugs. You can read more about this (including how to opt out of this behavior) in the\n  [relevant section](../concepts/serialization/index.html#subclasses-of-model-like-types) of the model exporting docs.\n* `GetterDict` has been removed as it was just an implementation detail of `orm_mode`, which has been removed.\n* In many cases, arguments passed to the constructor will be **copied** in order to perform validation and, where necessary, coercion\n  (see the [documentation](../concepts/models/index.html#attribute-copies)).\n  This is notable in the case of passing mutable objects as arguments to a constructor.\n* The `.json()` method is deprecated, and attempting to use this deprecated method with arguments such as\n  `indent` or `ensure_ascii` may lead to confusing errors. For best results, switch to V2's equivalent, `model_dump_json()`.\n  If you'd still like to use said arguments, you can use [this workaround](https://github.com/pydantic/pydantic/issues/8825#issuecomment-1946206415).\n* JSON serialization of non-string key values is generally done with `str(key)`, leading to some changes in behavior such as the following:\n\n```\nfrom typing import Optional", "url": "https://docs.pydantic.dev/latest/migration/index.html#changes-to-pydanticbasemodelindexhtmlchanges-to-pydanticbasemodel-permanent-link", "page": "migration/index.html", "source_site": "pydantic"}
{"title": "Changes to `pydantic.BaseModel`[Â¶](index.html#changes-to-pydanticbasemodel \"Permanent link\")", "anchor": "changes-to-pydanticbasemodelindexhtmlchanges-to-pydanticbasemodel-permanent-link", "md_text": "from pydantic import BaseModel as V2BaseModel\nfrom pydantic.v1 import BaseModel as V1BaseModel\n\n\nclass V1Model(V1BaseModel):\n    a: dict[Optional[str], int]\n\n\nclass V2Model(V2BaseModel):\n    a: dict[Optional[str], int]\n\n\nv1_model = V1Model(a={None: 123})\nv2_model = V2Model(a={None: 123})\n\n# V1\nprint(v1_model.json())\n#> {\"a\": {\"null\": 123}}\n\n# V2\nprint(v2_model.model_dump_json())\n#> {\"a\":{\"None\":123}}\n```\n\n* `model_dump_json()` results are compacted in order to save space, and don't always exactly match that of `json.dumps()` output.\n  That being said, you can easily modify the separators used in `json.dumps()` results in order to align the two outputs:\n\n```\nimport json\n\nfrom pydantic import BaseModel as V2BaseModel\nfrom pydantic.v1 import BaseModel as V1BaseModel\n\n\nclass V1Model(V1BaseModel):\n    a: list[str]\n\n\nclass V2Model(V2BaseModel):\n    a: list[str]\n\n\nv1_model = V1Model(a=['fancy', 'sushi'])\nv2_model = V2Model(a=['fancy', 'sushi'])\n\n# V1\nprint(v1_model.json())\n#> {\"a\": [\"fancy\", \"sushi\"]}\n\n# V2\nprint(v2_model.model_dump_json())\n#> {\"a\":[\"fancy\",\"sushi\"]}\n\n# Plain json.dumps\nprint(json.dumps(v2_model.model_dump()))\n#> {\"a\": [\"fancy\", \"sushi\"]}\n\n# Modified json.dumps\nprint(json.dumps(v2_model.model_dump(), separators=(',', ':')))\n#> {\"a\":[\"fancy\",\"sushi\"]}\n```", "url": "https://docs.pydantic.dev/latest/migration/index.html#changes-to-pydanticbasemodelindexhtmlchanges-to-pydanticbasemodel-permanent-link", "page": "migration/index.html", "source_site": "pydantic"}
{"title": "Changes to `pydantic.generics.GenericModel`[Â¶](index.html#changes-to-pydanticgenericsgenericmodel \"Permanent link\")", "anchor": "changes-to-pydanticgenericsgenericmodelindexhtmlchanges-to-pydanticgenericsgenericmodel-permanent-link", "md_text": "The `pydantic.generics.GenericModel` class is no longer necessary, and has been removed. Instead, you can now\ncreate generic `BaseModel` subclasses by just adding `Generic` as a parent class on a `BaseModel` subclass directly.\nThis looks like `class MyGenericModel(BaseModel, Generic[T]): ...`.\n\nMixing of V1 and V2 models is not supported which means that type parameters of such generic `BaseModel` (V2)\ncannot be V1 models.\n\nWhile it may not raise an error, we strongly advise against using *parametrized* generics in `isinstance` checks.\n\n* For example, you should not do `isinstance(my_model, MyGenericModel[int])`.\n  However, it is fine to do `isinstance(my_model, MyGenericModel)`. (Note that for standard generics, it would raise\n  an error to do a subclass check with a parameterized generic.)\n* If you need to perform `isinstance` checks against parametrized generics, you can do this by subclassing the\n  parametrized generic class. This looks like `class MyIntModel(MyGenericModel[int]): ...` and\n  `isinstance(my_model, MyIntModel)`.\n\nFind more information in the [Generic models](../concepts/models/index.html#generic-models) documentation.", "url": "https://docs.pydantic.dev/latest/migration/index.html#changes-to-pydanticgenericsgenericmodelindexhtmlchanges-to-pydanticgenericsgenericmodel-permanent-link", "page": "migration/index.html", "source_site": "pydantic"}
{"title": "Changes to `pydantic.Field`[Â¶](index.html#changes-to-pydanticfield \"Permanent link\")", "anchor": "changes-to-pydanticfieldindexhtmlchanges-to-pydanticfield-permanent-link", "md_text": "`Field` no longer supports arbitrary keyword arguments to be added to the JSON schema. Instead, any extra\ndata you want to add to the JSON schema should be passed as a dictionary to the `json_schema_extra` keyword argument.\n\nIn Pydantic V1, the `alias` property returns the field's name when no alias is set.\nIn Pydantic V2, this behavior has changed to return `None` when no alias is set.\n\nThe following properties have been removed from or changed in `Field`:\n\n* `const`\n* `min_items` (use `min_length` instead)\n* `max_items` (use `max_length` instead)\n* `unique_items`\n* `allow_mutation` (use `frozen` instead)\n* `regex` (use `pattern` instead)\n* `final` (use the [typing.Final](https://docs.python.org/3/library/typing.html#typing.Final) type hint instead)\n\nField constraints are no longer automatically pushed down to the parameters of generics. For example, you can no longer validate every element of a list matches a regex by providing `my_list: list[str] = Field(pattern=\".*\")`. Instead, use [`typing.Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated) to provide an annotation on the `str` itself: `my_list: list[Annotated[str, Field(pattern=\".*\")]]`", "url": "https://docs.pydantic.dev/latest/migration/index.html#changes-to-pydanticfieldindexhtmlchanges-to-pydanticfield-permanent-link", "page": "migration/index.html", "source_site": "pydantic"}
{"title": "Changes to dataclasses[Â¶](index.html#changes-to-dataclasses \"Permanent link\")", "anchor": "changes-to-dataclassesindexhtmlchanges-to-dataclasses-permanent-link", "md_text": "Pydantic [dataclasses](../concepts/dataclasses/index.html) continue to be useful for enabling the data validation on standard\ndataclasses without having to subclass `BaseModel`. Pydantic V2 introduces the following changes to this dataclass behavior:\n\n* When used as fields, dataclasses (Pydantic or vanilla) no longer accept tuples as validation inputs; dicts should be\n  used instead.\n* The `__post_init__` in Pydantic dataclasses will now be called *after* validation, rather than before.\n  + As a result, the `__post_init_post_parse__` method would have become redundant, so has been removed.\n* Pydantic no longer supports `extra='allow'` for Pydantic dataclasses, where extra fields passed to the initializer would be\n  stored as extra attributes on the dataclass. `extra='ignore'` is still supported for the purpose of ignoring\n  unexpected fields while parsing data, they just won't be stored on the instance.\n* Pydantic dataclasses no longer have an attribute `__pydantic_model__`, and no longer use an underlying `BaseModel`\n  to perform validation or provide other functionality.\n  + To perform validation, generate a JSON schema, or make use of\n    any other functionality that may have required `__pydantic_model__` in V1, you should now wrap the dataclass\n    with a [`TypeAdapter`](../api/type_adapter/index.html#pydantic.type_adapter.TypeAdapter) ([discussed more below](index.html#introduction-of-typeadapter)) and\n    make use of its methods.\n* In Pydantic V1, if you used a vanilla (i.e., non-Pydantic) dataclass as a field, the config of the parent type would\n  be used as though it was the config for the dataclass itself as well. In Pydantic V2, this is no longer the case.\n  + In Pydantic V2, to override the config (like you would with `model_config` on a `BaseModel`),\n    you can use the `config` parameter on the `@dataclass` decorator.\n    See [Dataclass Config](../concepts/dataclasses/index.html#dataclass-config) for examples.", "url": "https://docs.pydantic.dev/latest/migration/index.html#changes-to-dataclassesindexhtmlchanges-to-dataclasses-permanent-link", "page": "migration/index.html", "source_site": "pydantic"}
{"title": "Changes to config[Â¶](index.html#changes-to-config \"Permanent link\")", "anchor": "changes-to-configindexhtmlchanges-to-config-permanent-link", "md_text": "* In Pydantic V2, to specify config on a model, you should set a class attribute called `model_config` to be a dict\n  with the key/value pairs you want to be used as the config. The Pydantic V1 behavior to create a class called `Config`\n  in the namespace of the parent `BaseModel` subclass is now deprecated.\n* When subclassing a model, the `model_config` attribute is inherited. This is helpful in the case where you'd like to use\n  a base class with a given configuration for many models. Note, if you inherit from multiple `BaseModel` subclasses,\n  like `class MyModel(Model1, Model2)`, the non-default settings in the `model_config` attribute from the two models\n  will be merged, and for any settings defined in both, those from `Model2` will override those from `Model1`.\n* The following config settings have been removed:\n\n  + `allow_mutation` â€” this has been removed. You should be able to use [frozen](../api/config/index.html#pydantic.config.ConfigDict) equivalently (inverse of current use).\n  + `error_msg_templates`\n  + `fields` â€” this was the source of various bugs, so has been removed.\n    You should be able to use `Annotated` on fields to modify them as desired.\n  + `getter_dict` â€” `orm_mode` has been removed, and this implementation detail is no longer necessary.\n  + `smart_union` - the default `union_mode` in Pydantic V2 is `'smart'`.\n  + `underscore_attrs_are_private` â€” the Pydantic V2 behavior is now the same as if this was always set\n    to `True` in Pydantic V1.\n  + `json_loads`\n  + `json_dumps`\n  + `copy_on_model_validation`\n  + `post_init_call`\n* The following config settings have been renamed:\n\n  + `allow_population_by_field_name` â†’ `populate_by_name` (or `validate_by_name` starting in v2.11)\n  + `anystr_lower` â†’ `str_to_lower`\n  + `anystr_strip_whitespace` â†’ `str_strip_whitespace`\n  + `anystr_upper` â†’ `str_to_upper`\n  + `keep_untouched` â†’ `ignored_types`\n  + `max_anystr_length` â†’ `str_max_length`\n  + `min_anystr_length` â†’ `str_min_length`\n  + `orm_mode` â†’ `from_attributes`\n  + `schema_extra` â†’ `json_schema_extra`\n  + `validate_all` â†’ `validate_default`\n\nSee the [`ConfigDict` API reference](../api/config/index.html#pydantic.config.ConfigDict) for more details.", "url": "https://docs.pydantic.dev/latest/migration/index.html#changes-to-configindexhtmlchanges-to-config-permanent-link", "page": "migration/index.html", "source_site": "pydantic"}
{"title": "Changes to validators[Â¶](index.html#changes-to-validators \"Permanent link\")", "anchor": "changes-to-validatorsindexhtmlchanges-to-validators-permanent-link", "md_text": "#### `@validator` and `@root_validator` are deprecated[Â¶](index.html#validator-and-root_validator-are-deprecated \"Permanent link\")\n\n* `@validator` has been deprecated, and should be replaced with [`@field_validator`](../concepts/validators/index.html), which provides various new features\n  and improvements.\n  + The new `@field_validator` decorator does not have the `each_item` keyword argument; validators you want to\n    apply to items within a generic container should be added by annotating the type argument. See\n    [validators in Annotated metadata](../concepts/types/index.html#using-the-annotated-pattern) for details.\n    This looks like `list[Annotated[int, Field(ge=0)]]`\n  + Even if you keep using the deprecated `@validator` decorator, you can no longer add the `field` or\n    `config` arguments to the signature of validator functions. If you need access to these, you'll need\n    to migrate to `@field_validator` â€” see the [next section](index.html#changes-to-validators-allowed-signatures)\n    for more details.\n  + If you use the `always=True` keyword argument to a validator function, note that standard validators\n    for the annotated type will *also* be applied even to defaults, not just the custom validators. For\n    example, despite the fact that the validator below will never error, the following code raises a `ValidationError`:\n\nTo avoid this, you can use the `validate_default` argument in the `Field` function. When set to `True`, it mimics the behavior of `always=True` in Pydantic v1. However, the new way of using `validate_default` is encouraged as it provides more flexibility and control.\n\n```\nfrom pydantic import BaseModel, validator\n\n\nclass Model(BaseModel):\n    x: str = 1\n\n    @validator('x', always=True)\n    @classmethod\n    def validate_x(cls, v):\n        return v\n\n\nModel()\n```\n\n* `@root_validator` has been deprecated, and should be replaced with\n  [`@model_validator`](../api/functional_validators/index.html#pydantic.functional_validators.model_validator), which also provides new features and improvements.\n  Be aware that the allowed signatures have changed (see the [relevant documentation](../concepts/validators/index.html#model-validators)).\n  + Under some circumstances (such as assignment when `model_config['validate_assignment'] is True`),\n    the `@model_validator` decorator will receive an instance of the model, not a dict of values. You may\n    need to be careful to handle this case.\n  + Even if you keep using the deprecated `@root_validator` decorator, due to refactors in validation logic,\n    you can no longer run with `skip_on_failure=False` (which is the default value of this keyword argument,\n    so must be set explicitly to `True`).\n\n#### Changes to `@validator`'s allowed signatures[Â¶](index.html#changes-to-validators-allowed-signatures \"Permanent link\")\n\nIn Pydantic V1, functions wrapped by `@validator` could receive keyword arguments with metadata about what was\nbeing validated. Some of these arguments have been removed from `@field_validator` in Pydantic V2:\n\n* `config`: Pydantic V2's config is now a dictionary instead of a class, which means this argument is no longer\n  backwards compatible. If you need to access the configuration you should migrate to `@field_validator` and use\n  `info.config`.\n* `field`: this argument used to be a `ModelField` object, which was a quasi-internal class that no longer exists\n  in Pydantic V2. Most of this information can still be accessed by using the field name from `info.field_name`\n  to index into `cls.model_fields`\n\n```\nfrom pydantic import BaseModel, ValidationInfo, field_validator\n\n\nclass Model(BaseModel):\n    x: int\n\n    @field_validator('x')\n    def val_x(cls, v: int, info: ValidationInfo) -> int:\n        assert info.config is not None\n        print(info.config.get('title'))\n        #> Model\n        print(cls.model_fields[info.field_name].is_required())\n        #> True\n        return v\n\n\nModel(x=1)\n```\n\n#### `TypeError` is no longer converted to `ValidationError` in validators[Â¶](index.html#typeerror-is-no-longer-converted-to-validationerror-in-validators \"Permanent link\")\n\nPreviously, when raising a `TypeError` within a validator function, that error would be wrapped into a `ValidationError`\nand, in some cases (such as with FastAPI), these errors might be displayed to end users. This led to a variety of\nundesirable behavior â€” for example, calling a function with the wrong signature might produce a user-facing\n`ValidationError`.\n\nHowever, in Pydantic V2, when a `TypeError` is raised in a validator, it is no longer converted into a\n`ValidationError`:\n\n```\nimport pytest\n\nfrom pydantic import BaseModel, field_validator\n\n\nclass Model(BaseModel):\n    x: int\n\n    @field_validator('x')\n    def val_x(cls, v: int) -> int:\n        return str.lower(v)  # raises a TypeError\n\n\nwith pytest.raises(TypeError):\n    Model(x=1)\n```\n\nThis applies to all validation decorators.\n\n#### Validator behavior changes[Â¶](index.html#validator-behavior-changes \"Permanent link\")\n\nPydantic V2 includes some changes to type coercion. For example:", "url": "https://docs.pydantic.dev/latest/migration/index.html#changes-to-validatorsindexhtmlchanges-to-validators-permanent-link", "page": "migration/index.html", "source_site": "pydantic"}
{"title": "Changes to validators[Â¶](index.html#changes-to-validators \"Permanent link\")", "anchor": "changes-to-validatorsindexhtmlchanges-to-validators-permanent-link", "md_text": "* coercing `int`, `float`, and `Decimal` values to strings is now optional and disabled by default, see\n  [Coerce Numbers to Strings](../api/config/index.html#pydantic.config.ConfigDict.coerce_numbers_to_str).\n* iterable of pairs is no longer coerced to a dict.\n\nSee the [Conversion table](../concepts/conversion_table/index.html) for details on Pydantic V2 type coercion defaults.\n\n#### The `allow_reuse` keyword argument is no longer necessary[Â¶](index.html#the-allow_reuse-keyword-argument-is-no-longer-necessary \"Permanent link\")\n\nPreviously, Pydantic tracked \"reused\" functions in decorators as this was a common source of mistakes.\nWe did this by comparing the function's fully qualified name (module name + function name), which could result in false\npositives. The `allow_reuse` keyword argument could be used to disable this when it was intentional.\n\nOur approach to detecting repeatedly defined functions has been overhauled to only error for redefinition within a\nsingle class, reducing false positives and bringing the behavior more in line with the errors that type checkers\nand linters would give for defining a method with the same name multiple times in a single class definition.\n\nIn nearly all cases, if you were using `allow_reuse=True`, you should be able to simply delete that keyword argument and\nhave things keep working as expected.\n\n#### `@validate_arguments` has been renamed to `@validate_call`[Â¶](index.html#validate_arguments-has-been-renamed-to-validate_call \"Permanent link\")\n\nIn Pydantic V2, the `@validate_arguments` decorator has been renamed to `@validate_call`.\n\nIn Pydantic V1, the decorated function had various attributes added, such as `raw_function`, and `validate`\n(which could be used to validate arguments without actually calling the decorated function). Due to limited use of\nthese attributes, and performance-oriented changes in implementation, we have not preserved this functionality in\n`@validate_call`.", "url": "https://docs.pydantic.dev/latest/migration/index.html#changes-to-validatorsindexhtmlchanges-to-validators-permanent-link", "page": "migration/index.html", "source_site": "pydantic"}
{"title": "Input types are not preserved[Â¶](index.html#input-types-are-not-preserved \"Permanent link\")", "anchor": "input-types-are-not-preservedindexhtmlinput-types-are-not-preserved-permanent-link", "md_text": "In Pydantic V1 we made great efforts to preserve the types of all field inputs for generic collections when they were\nproper subtypes of the field annotations. For example, given the annotation `Mapping[str, int]` if you passed in a\n`collection.Counter()` you'd get a `collection.Counter()` as the value.\n\nSupporting this behavior in V2 would have negative performance implications for the general case\n(we'd have to check types every time) and would add a lot of complexity to validation. Further, even in V1 this behavior\nwas inconsistent and partially broken: it did not work for many types (`str`, `UUID`, etc.), and for generic\ncollections it's impossible to re-build the original input correctly without a lot of special casing\n(consider `ChainMap`; rebuilding the input is necessary because we need to replace values after validation, e.g.\nif coercing strings to ints).\n\nIn Pydantic V2 we no longer attempt to preserve the input type in all cases; instead, we only promise that the output\ntype will match the type annotations.\n\nGoing back to the `Mapping` example, we promise the output will be a valid `Mapping`, and in practice it will be a\nplain `dict`:\n\n```\nfrom collections.abc import Mapping\n\nfrom pydantic import TypeAdapter\n\n\nclass MyDict(dict):\n    pass\n\n\nta = TypeAdapter(Mapping[str, int])\nv = ta.validate_python(MyDict())\nprint(type(v))\n#> <class 'dict'>\n```\n\nIf you want the output type to be a specific type, consider annotating it as such or implementing a custom validator:\n\n```\nfrom collections.abc import Mapping\nfrom typing import Annotated, Any, TypeVar\n\nfrom pydantic import (\n    TypeAdapter,\n    ValidationInfo,\n    ValidatorFunctionWrapHandler,\n    WrapValidator,\n)\n\n\ndef restore_input_type(\n    value: Any, handler: ValidatorFunctionWrapHandler, _info: ValidationInfo\n) -> Any:\n    return type(value)(handler(value))\n\n\nT = TypeVar('T')\nPreserveType = Annotated[T, WrapValidator(restore_input_type)]\n\n\nta = TypeAdapter(PreserveType[Mapping[str, int]])\n\n\nclass MyDict(dict):\n    pass\n\n\nv = ta.validate_python(MyDict())\nassert type(v) is MyDict\n```\n\nWhile we don't promise to preserve input types everywhere, we *do* preserve them for subclasses of `BaseModel`,\nand for dataclasses:\n\n```\nimport pydantic.dataclasses\nfrom pydantic import BaseModel\n\n\nclass InnerModel(BaseModel):\n    x: int\n\n\nclass OuterModel(BaseModel):\n    inner: InnerModel\n\n\nclass SubInnerModel(InnerModel):\n    y: int\n\n\nm = OuterModel(inner=SubInnerModel(x=1, y=2))\nprint(m)\n#> inner=SubInnerModel(x=1, y=2)\n\n\n@pydantic.dataclasses.dataclass\nclass InnerDataclass:\n    x: int\n\n\n@pydantic.dataclasses.dataclass\nclass SubInnerDataclass(InnerDataclass):\n    y: int\n\n\n@pydantic.dataclasses.dataclass\nclass OuterDataclass:\n    inner: InnerDataclass\n\n\nd = OuterDataclass(inner=SubInnerDataclass(x=1, y=2))\nprint(d)\n#> OuterDataclass(inner=SubInnerDataclass(x=1, y=2))\n```", "url": "https://docs.pydantic.dev/latest/migration/index.html#input-types-are-not-preservedindexhtmlinput-types-are-not-preserved-permanent-link", "page": "migration/index.html", "source_site": "pydantic"}
{"title": "Changes to Handling of Standard Types[Â¶](index.html#changes-to-handling-of-standard-types \"Permanent link\")", "anchor": "changes-to-handling-of-standard-typesindexhtmlchanges-to-handling-of-standard-types-permanent-link", "md_text": "#### Dicts[Â¶](index.html#dicts \"Permanent link\")\n\nIterables of pairs (which include empty iterables) no longer pass validation for fields of type `dict`.\n\n#### Unions[Â¶](index.html#unions \"Permanent link\")\n\nWhile union types will still attempt validation of each choice from left to right, they now preserve the type of the\ninput whenever possible, even if the correct type is not the first choice for which the input would pass validation.\nAs a demonstration, consider the following example:\n\nPython 3.9 and abovePython 3.10 and above\n\n```\nfrom typing import Union\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    x: Union[int, str]\n\n\nprint(Model(x='1'))\n#> x='1'\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    x: int | str\n\n\nprint(Model(x='1'))\n#> x='1'\n```\n\nIn Pydantic V1, the printed result would have been `x=1`, since the value would pass validation as an `int`.\nIn Pydantic V2, we recognize that the value is an instance of one of the cases and short-circuit the standard union validation.\n\nTo revert to the non-short-circuiting left-to-right behavior of V1, annotate the union with `Field(union_mode='left_to_right')`.\nSee [Union Mode](../concepts/unions/index.html#union-modes) for more details.\n\n#### Required, optional, and nullable fields[Â¶](index.html#required-optional-and-nullable-fields \"Permanent link\")\n\nPydantic V2 changes some of the logic for specifying whether a field annotated as `Optional` is required\n(i.e., has no default value) or not (i.e., has a default value of `None` or any other value of the corresponding type), and now more closely matches the\nbehavior of `dataclasses`. Similarly, fields annotated as `Any` no longer have a default value of `None`.\n\nThe following table describes the behavior of field annotations in V2:\n\n| State | Field Definition |\n| --- | --- |\n| Required, cannot be `None` | `f1: str` |\n| Not required, cannot be `None`, is `'abc'` by default | `f2: str = 'abc'` |\n| Required, can be `None` | `f3: Optional[str]` |\n| Not required, can be `None`, is `None` by default | `f4: Optional[str] = None` |\n| Not required, can be `None`, is `'abc'` by default | `f5: Optional[str] = 'abc'` |\n| Required, can be any type (including `None`) | `f6: Any` |\n| Not required, can be any type (including `None`) | `f7: Any = None` |\n\nA field annotated as `typing.Optional[T]` will be required, and will allow for a value of `None`.\nIt does not mean that the field has a default value of `None`. *(This is a breaking change from V1.)*\n\nAny default value if provided makes a field not required.\n\nHere is a code example demonstrating the above:\n\nPython 3.9 and abovePython 3.10 and above\n\n```\nfrom typing import Optional\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Foo(BaseModel):\n    f1: str  # required, cannot be None\n    f2: Optional[str]  # required, can be None - same as str | None\n    f3: Optional[str] = None  # not required, can be None\n    f4: str = 'Foobar'  # not required, but cannot be None\n\n\ntry:\n    Foo(f1=None, f2=None, f4='b')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Foo\n    f1\n      Input should be a valid string [type=string_type, input_value=None, input_type=NoneType]\n    \"\"\"\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Foo(BaseModel):\n    f1: str  # required, cannot be None\n    f2: str | None  # required, can be None - same as str | None\n    f3: str | None = None  # not required, can be None\n    f4: str = 'Foobar'  # not required, but cannot be None\n\n\ntry:\n    Foo(f1=None, f2=None, f4='b')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Foo\n    f1\n      Input should be a valid string [type=string_type, input_value=None, input_type=NoneType]\n    \"\"\"\n```\n\n#### Patterns / regex on strings[Â¶](index.html#patterns-regex-on-strings \"Permanent link\")\n\nPydantic V1 used Python's regex library. Pydantic V2 uses the Rust [regex crate](https://github.com/rust-lang/regex).\nThis crate is not just a \"Rust version of regular expressions\", it's a completely different approach to regular expressions.\nIn particular, it promises linear time searching of strings in exchange for dropping a couple of features (namely look arounds and backreferences).\nWe believe this is a tradeoff worth making, in particular because Pydantic is used to validate untrusted input where ensuring things don't accidentally run in exponential time depending on the untrusted input is important.\nOn the flipside, for anyone not using these features complex regex validation should be orders of magnitude faster because it's done in Rust and in linear time.", "url": "https://docs.pydantic.dev/latest/migration/index.html#changes-to-handling-of-standard-typesindexhtmlchanges-to-handling-of-standard-types-permanent-link", "page": "migration/index.html", "source_site": "pydantic"}
{"title": "Changes to Handling of Standard Types[Â¶](index.html#changes-to-handling-of-standard-types \"Permanent link\")", "anchor": "changes-to-handling-of-standard-typesindexhtmlchanges-to-handling-of-standard-types-permanent-link", "md_text": "If you still want to use Python's regex library, you can use the [`regex_engine`](../api/config/index.html#pydantic.config.ConfigDict.regex_engine) config setting.", "url": "https://docs.pydantic.dev/latest/migration/index.html#changes-to-handling-of-standard-typesindexhtmlchanges-to-handling-of-standard-types-permanent-link", "page": "migration/index.html", "source_site": "pydantic"}
{"title": "Type conversion from floats to integers[Â¶](index.html#type-conversion-from-floats-to-integers \"Permanent link\")", "anchor": "type-conversion-from-floats-to-integersindexhtmltype-conversion-from-floats-to-integers-permanent-link", "md_text": "In V1, whenever a field was annotated as `int`, any float value would be accepted, which could lead to a potential data\nloss if the float value contains a non-zero decimal part. In V2, type conversion from floats to integers is only allowed\nif the decimal part is zero:\n\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: int\n\n\nprint(Model(x=10.0))\n#> x=10\ntry:\n    Model(x=10.2)\nexcept ValidationError as err:\n    print(err)\n    \"\"\"\n    1 validation error for Model\n    x\n      Input should be a valid integer, got a number with a fractional part [type=int_from_float, input_value=10.2, input_type=float]\n    \"\"\"\n```", "url": "https://docs.pydantic.dev/latest/migration/index.html#type-conversion-from-floats-to-integersindexhtmltype-conversion-from-floats-to-integers-permanent-link", "page": "migration/index.html", "source_site": "pydantic"}
{"title": "Introduction of `TypeAdapter`[Â¶](index.html#introduction-of-typeadapter \"Permanent link\")", "anchor": "introduction-of-typeadapterindexhtmlintroduction-of-typeadapter-permanent-link", "md_text": "Pydantic V1 had weak support for validating or serializing non-`BaseModel` types.\n\nTo work with them, you had to either create a \"root\" model or use the utility functions in `pydantic.tools`\n(namely, `parse_obj_as` and `schema_of`).\n\nIn Pydantic V2 this is *a lot* easier: the [`TypeAdapter`](../api/type_adapter/index.html#pydantic.type_adapter.TypeAdapter) class lets you create an object\nwith methods for validating, serializing, and producing JSON schemas for arbitrary types.\nThis serves as a complete replacement for `parse_obj_as` and `schema_of` (which are now deprecated),\nand also covers some of the use cases of \"root\" models. ([`RootModel`](../concepts/models/index.html#rootmodel-and-custom-root-types),\n[discussed above](index.html#changes-to-pydanticbasemodel), covers the others.)\n\n```\nfrom pydantic import TypeAdapter\n\nadapter = TypeAdapter(list[int])\nassert adapter.validate_python(['1', '2', '3']) == [1, 2, 3]\nprint(adapter.json_schema())\n#> {'items': {'type': 'integer'}, 'type': 'array'}\n```\n\nDue to limitations of inferring generic types with common type checkers, to get proper typing in some scenarios, you\nmay need to explicitly specify the generic parameter:\n\n```\nfrom pydantic import TypeAdapter\n\nadapter = TypeAdapter[str | int](str | int)\n...\n```\n\nSee [Type Adapter](../concepts/type_adapter/index.html) for more information.", "url": "https://docs.pydantic.dev/latest/migration/index.html#introduction-of-typeadapterindexhtmlintroduction-of-typeadapter-permanent-link", "page": "migration/index.html", "source_site": "pydantic"}
{"title": "Defining custom types[Â¶](index.html#defining-custom-types \"Permanent link\")", "anchor": "defining-custom-typesindexhtmldefining-custom-types-permanent-link", "md_text": "We have completely overhauled the way custom types are defined in pydantic.\n\nWe have exposed hooks for generating both `pydantic-core` and JSON schemas, allowing you to get all the performance\nbenefits of Pydantic V2 even when using your own custom types.\n\nWe have also introduced ways to use [`typing.Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated) to add custom validation to your own types.\n\nThe main changes are:\n\n* `__get_validators__` should be replaced with `__get_pydantic_core_schema__`.\n  See [Custom Data Types](../concepts/types/index.html#customizing_validation_with_get_pydantic_core_schema) for more information.\n* `__modify_schema__` becomes `__get_pydantic_json_schema__`.\n  See [JSON Schema Customization](../concepts/json_schema/index.html#customizing-json-schema) for more information.\n\nAdditionally, you can use [`typing.Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated) to modify or provide the `__get_pydantic_core_schema__` and\n`__get_pydantic_json_schema__` functions of a type by annotating it, rather than modifying the type itself.\nThis provides a powerful and flexible mechanism for integrating third-party types with Pydantic, and in some cases\nmay help you remove hacks from Pydantic V1 introduced to work around the limitations for custom types.\n\nSee [Custom Data Types](../concepts/types/index.html#custom-types) for more information.", "url": "https://docs.pydantic.dev/latest/migration/index.html#defining-custom-typesindexhtmldefining-custom-types-permanent-link", "page": "migration/index.html", "source_site": "pydantic"}
{"title": "Changes to JSON schema generation[Â¶](index.html#changes-to-json-schema-generation \"Permanent link\")", "anchor": "changes-to-json-schema-generationindexhtmlchanges-to-json-schema-generation-permanent-link", "md_text": "We received many requests over the years to make changes to the JSON schemas that pydantic generates.\n\nIn Pydantic V2, we have tried to address many of the common requests:\n\n* The JSON schema for `Optional` fields now indicates that the value `null` is allowed.\n* The `Decimal` type is now exposed in JSON schema (and serialized) as a string.\n* The JSON schema no longer preserves namedtuples as namedtuples.\n* The JSON schema we generate by default now targets draft 2020-12 (with some OpenAPI extensions).\n* When they differ, you can now specify if you want the JSON schema representing the inputs to validation,\n  or the outputs from serialization.\n\nHowever, there have been many reasonable requests over the years for changes which we have not chosen to implement.\n\nIn Pydantic V1, even if you were willing to implement changes yourself, it was very difficult because the JSON schema\ngeneration process involved various recursive function calls; to override one, you'd have to copy and modify the whole\nimplementation.\n\nIn Pydantic V2, one of our design goals was to make it easier to customize JSON schema generation. To this end, we have\nintroduced the class [`GenerateJsonSchema`](../api/json_schema/index.html#pydantic.json_schema.GenerateJsonSchema),\nwhich implements the translation of a type's pydantic-core schema into\na JSON schema. By design, this class breaks the JSON schema generation process into smaller methods that can be\neasily overridden in subclasses to modify the \"global\" approach to generating JSON schema.\n\nThe various methods that can be used to produce JSON schema (such as `BaseModel.model_json_schema` or\n`TypeAdapter.json_schema`) accept a keyword argument `schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema`,\nand you can pass your custom subclass to these methods in order to use your own approach to generating JSON schema.\n\nHopefully this means that if you disagree with any of the choices we've made, or if you are reliant on behaviors in\nPydantic V1 that have changed in Pydantic V2, you can use a custom `schema_generator`, modifying the\n`GenerateJsonSchema` class as necessary for your application.", "url": "https://docs.pydantic.dev/latest/migration/index.html#changes-to-json-schema-generationindexhtmlchanges-to-json-schema-generation-permanent-link", "page": "migration/index.html", "source_site": "pydantic"}
{"title": "`BaseSettings` has moved to `pydantic-settings`[Â¶](index.html#basesettings-has-moved-to-pydantic-settings \"Permanent link\")", "anchor": "basesettings-has-moved-to-pydantic-settingsindexhtmlbasesettings-has-moved-to-pydantic-settings-permanent-link", "md_text": "[`BaseSettings`](../api/pydantic_settings/index.html#pydantic_settings.BaseSettings), the base object for Pydantic\n[settings management](../concepts/pydantic_settings/index.html), has been moved to a separate package,\n[`pydantic-settings`](https://github.com/pydantic/pydantic-settings).\n\nAlso, the `parse_env_var` classmethod has been removed. So, you need to\n[customise settings sources](../concepts/pydantic_settings/index.html#customise-settings-sources)\nto have your own parsing function.", "url": "https://docs.pydantic.dev/latest/migration/index.html#basesettings-has-moved-to-pydantic-settingsindexhtmlbasesettings-has-moved-to-pydantic-settings-permanent-link", "page": "migration/index.html", "source_site": "pydantic"}
{"title": "Color and Payment Card Numbers moved to `pydantic-extra-types`[Â¶](index.html#color-and-payment-card-numbers-moved-to-pydantic-extra-types \"Permanent link\")", "anchor": "color-and-payment-card-numbers-moved-to-pydantic-extra-typesindexhtmlcolor-and-payment-card-numbers-moved-to-pydantic-extra-types-permanent-link", "md_text": "The following special-use types have been moved to the\n[Pydantic Extra Types](https://github.com/pydantic/pydantic-extra-types) package,\nwhich may be installed separately if needed.\n\n* [Color Types](../api/pydantic_extra_types_color/index.html)\n* [Payment Card Numbers](../api/pydantic_extra_types_payment/index.html)", "url": "https://docs.pydantic.dev/latest/migration/index.html#color-and-payment-card-numbers-moved-to-pydantic-extra-typesindexhtmlcolor-and-payment-card-numbers-moved-to-pydantic-extra-types-permanent-link", "page": "migration/index.html", "source_site": "pydantic"}
{"title": "Url and Dsn types in `pydantic.networks` no longer inherit from `str`[Â¶](index.html#url-and-dsn-types-in-pydanticnetworks-no-longer-inherit-from-str \"Permanent link\")", "anchor": "url-and-dsn-types-in-pydanticnetworks-no-longer-inherit-from-strindexhtmlurl-and-dsn-types-in-pydanticnetworks-no-longer-inherit-from-str-permanent-link", "md_text": "In Pydantic V1 the [`AnyUrl`](../api/networks/index.html#pydantic.networks.AnyUrl) type inherited from `str`, and all the other\n`Url` and `Dsn` types inherited from these. In Pydantic V2 these types are built on two new `Url` and `MultiHostUrl`\nclasses using `Annotated`.\n\nInheriting from `str` had upsides and downsides, and for V2 we decided it would be better to remove this. To use these\ntypes in APIs which expect `str` you'll now need to convert them (with `str(url)`).\n\nPydantic V2 uses Rust's [Url](https://crates.io/crates/url) crate for URL validation.\nSome of the URL validation differs slightly from the previous behavior in V1.\nOne notable difference is that the new `Url` types append slashes to the validated version if no path is included,\neven if a slash is not specified in the argument to a `Url` type constructor. See the example below for this behavior:\n\n```\nfrom pydantic import AnyUrl\n\nassert str(AnyUrl(url='https://google.com')) == 'https://google.com/'\nassert str(AnyUrl(url='https://google.com/')) == 'https://google.com/'\nassert str(AnyUrl(url='https://google.com/api')) == 'https://google.com/api'\nassert str(AnyUrl(url='https://google.com/api/')) == 'https://google.com/api/'\n```\n\nIf you still want to use the old behavior without the appended slash, take a look at this [solution](https://github.com/pydantic/pydantic/issues/7186#issuecomment-1690235887).", "url": "https://docs.pydantic.dev/latest/migration/index.html#url-and-dsn-types-in-pydanticnetworks-no-longer-inherit-from-strindexhtmlurl-and-dsn-types-in-pydanticnetworks-no-longer-inherit-from-str-permanent-link", "page": "migration/index.html", "source_site": "pydantic"}
{"title": "Constrained types[Â¶](index.html#constrained-types \"Permanent link\")", "anchor": "constrained-typesindexhtmlconstrained-types-permanent-link", "md_text": "The `Constrained*` classes were *removed*, and you should replace them by `Annotated[<type>, Field(...)]`, for example:\n\n```\nfrom pydantic import BaseModel, ConstrainedInt\n\n\nclass MyInt(ConstrainedInt):\n    ge = 0\n\n\nclass Model(BaseModel):\n    x: MyInt\n```\n\n...becomes:\n\n```\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Field\n\nMyInt = Annotated[int, Field(ge=0)]\n\n\nclass Model(BaseModel):\n    x: MyInt\n```\n\nRead more about it in the [Composing types via `Annotated`](../concepts/types/index.html#using-the-annotated-pattern)\ndocs.\n\nFor `ConstrainedStr` you can use [`StringConstraints`](../api/types/index.html#pydantic.types.StringConstraints) instead.", "url": "https://docs.pydantic.dev/latest/migration/index.html#constrained-typesindexhtmlconstrained-types-permanent-link", "page": "migration/index.html", "source_site": "pydantic"}
{"title": "Mypy plugins[Â¶](index.html#mypy-plugins \"Permanent link\")", "anchor": "mypy-pluginsindexhtmlmypy-plugins-permanent-link", "md_text": "Pydantic V2 contains a [mypy](https://mypy.readthedocs.io/en/stable/extending_mypy.html#configuring-mypy-to-use-plugins) plugin in\n`pydantic.mypy`.\n\nWhen using [V1 features](index.html#continue-using-pydantic-v1-features) the\n`pydantic.v1.mypy` plugin might need to also be enabled.\n\nTo configure the mypy plugins:\n\n`mypy.ini``pyproject.toml`\n\n```\n[mypy]\nplugins = pydantic.mypy, pydantic.v1.mypy  # include `.v1.mypy` if required.\n\n[tool.mypy]\nplugins = [\n    \"pydantic.mypy\",\n    \"pydantic.v1.mypy\",  # include `.v1.mypy` if required.\n]\n```", "url": "https://docs.pydantic.dev/latest/migration/index.html#mypy-pluginsindexhtmlmypy-plugins-permanent-link", "page": "migration/index.html", "source_site": "pydantic"}
{"title": "Other changes[Â¶](index.html#other-changes \"Permanent link\")", "anchor": "other-changesindexhtmlother-changes-permanent-link", "md_text": "* Dropped support for [`email-validator<2.0.0`](https://github.com/JoshData/python-email-validator). Make sure to update\n  using `pip install -U email-validator`.", "url": "https://docs.pydantic.dev/latest/migration/index.html#other-changesindexhtmlother-changes-permanent-link", "page": "migration/index.html", "source_site": "pydantic"}
{"title": "Moved in Pydantic V2[Â¶](index.html#moved-in-pydantic-v2 \"Permanent link\")", "anchor": "moved-in-pydantic-v2indexhtmlmoved-in-pydantic-v2-permanent-link", "md_text": "| Pydantic V1 | Pydantic V2 |\n| --- | --- |\n| `pydantic.BaseSettings` | [`pydantic_settings.BaseSettings`](index.html#basesettings-has-moved-to-pydantic-settings) |\n| `pydantic.color` | [`pydantic_extra_types.color`](../api/pydantic_extra_types_color/index.html#pydantic_extra_types.color) |\n| `pydantic.types.PaymentCardBrand` | [`pydantic_extra_types.PaymentCardBrand`](index.html#color-and-payment-card-numbers-moved-to-pydantic-extra-types) |\n| `pydantic.types.PaymentCardNumber` | [`pydantic_extra_types.PaymentCardNumber`](index.html#color-and-payment-card-numbers-moved-to-pydantic-extra-types) |\n| `pydantic.utils.version_info` | [`pydantic.version.version_info`](../api/version/index.html#pydantic.version.version_info) |\n| `pydantic.error_wrappers.ValidationError` | [`pydantic.ValidationError`](../api/pydantic_core/index.html#pydantic_core.ValidationError) |\n| `pydantic.utils.to_camel` | [`pydantic.alias_generators.to_pascal`](../api/config/index.html#pydantic.alias_generators.to_pascal) |\n| `pydantic.utils.to_lower_camel` | [`pydantic.alias_generators.to_camel`](../api/config/index.html#pydantic.alias_generators.to_camel) |\n| `pydantic.PyObject` | [`pydantic.ImportString`](../api/types/index.html#pydantic.types.ImportString) |", "url": "https://docs.pydantic.dev/latest/migration/index.html#moved-in-pydantic-v2indexhtmlmoved-in-pydantic-v2-permanent-link", "page": "migration/index.html", "source_site": "pydantic"}
{"title": "Deprecated and moved in Pydantic V2[Â¶](index.html#deprecated-and-moved-in-pydantic-v2 \"Permanent link\")", "anchor": "deprecated-and-moved-in-pydantic-v2indexhtmldeprecated-and-moved-in-pydantic-v2-permanent-link", "md_text": "| Pydantic V1 | Pydantic V2 |\n| --- | --- |\n| `pydantic.tools.schema_of` | `pydantic.deprecated.tools.schema_of` |\n| `pydantic.tools.parse_obj_as` | `pydantic.deprecated.tools.parse_obj_as` |\n| `pydantic.tools.schema_json_of` | `pydantic.deprecated.tools.schema_json_of` |\n| `pydantic.json.pydantic_encoder` | `pydantic.deprecated.json.pydantic_encoder` |\n| `pydantic.validate_arguments` | `pydantic.deprecated.decorator.validate_arguments` |\n| `pydantic.json.custom_pydantic_encoder` | `pydantic.deprecated.json.custom_pydantic_encoder` |\n| `pydantic.json.ENCODERS_BY_TYPE` | `pydantic.deprecated.json.ENCODERS_BY_TYPE` |\n| `pydantic.json.timedelta_isoformat` | `pydantic.deprecated.json.timedelta_isoformat` |\n| `pydantic.decorator.validate_arguments` | `pydantic.deprecated.decorator.validate_arguments` |\n| `pydantic.class_validators.validator` | `pydantic.deprecated.class_validators.validator` |\n| `pydantic.class_validators.root_validator` | `pydantic.deprecated.class_validators.root_validator` |\n| `pydantic.utils.deep_update` | `pydantic.v1.utils.deep_update` |\n| `pydantic.utils.GetterDict` | `pydantic.v1.utils.GetterDict` |\n| `pydantic.utils.lenient_issubclass` | `pydantic.v1.utils.lenient_issubclass` |\n| `pydantic.utils.lenient_isinstance` | `pydantic.v1.utils.lenient_isinstance` |\n| `pydantic.utils.is_valid_field` | `pydantic.v1.utils.is_valid_field` |\n| `pydantic.utils.update_not_none` | `pydantic.v1.utils.update_not_none` |\n| `pydantic.utils.import_string` | `pydantic.v1.utils.import_string` |\n| `pydantic.utils.Representation` | `pydantic.v1.utils.Representation` |\n| `pydantic.utils.ROOT_KEY` | `pydantic.v1.utils.ROOT_KEY` |\n| `pydantic.utils.smart_deepcopy` | `pydantic.v1.utils.smart_deepcopy` |\n| `pydantic.utils.sequence_like` | `pydantic.v1.utils.sequence_like` |", "url": "https://docs.pydantic.dev/latest/migration/index.html#deprecated-and-moved-in-pydantic-v2indexhtmldeprecated-and-moved-in-pydantic-v2-permanent-link", "page": "migration/index.html", "source_site": "pydantic"}
{"title": "Removed in Pydantic V2[Â¶](index.html#removed-in-pydantic-v2 \"Permanent link\")", "anchor": "removed-in-pydantic-v2indexhtmlremoved-in-pydantic-v2-permanent-link", "md_text": "* `pydantic.ConstrainedBytes`\n* `pydantic.ConstrainedDate`\n* `pydantic.ConstrainedDecimal`\n* `pydantic.ConstrainedFloat`\n* `pydantic.ConstrainedFrozenSet`\n* `pydantic.ConstrainedInt`\n* `pydantic.ConstrainedList`\n* `pydantic.ConstrainedSet`\n* `pydantic.ConstrainedStr`\n* `pydantic.JsonWrapper`\n* `pydantic.NoneBytes`\n  + This was an alias to `None | bytes`.\n* `pydantic.NoneStr`\n  + This was an alias to `None | str`.\n* `pydantic.NoneStrBytes`\n  + This was an alias to `None | str | bytes`.\n* `pydantic.Protocol`\n* `pydantic.Required`\n* `pydantic.StrBytes`\n  + This was an alias to `str | bytes`.\n* `pydantic.compiled`\n* `pydantic.config.get_config`\n* `pydantic.config.inherit_config`\n* `pydantic.config.prepare_config`\n* `pydantic.create_model_from_namedtuple`\n* `pydantic.create_model_from_typeddict`\n* `pydantic.dataclasses.create_pydantic_model_from_dataclass`\n* `pydantic.dataclasses.make_dataclass_validator`\n* `pydantic.dataclasses.set_validation`\n* `pydantic.datetime_parse.parse_date`\n* `pydantic.datetime_parse.parse_time`\n* `pydantic.datetime_parse.parse_datetime`\n* `pydantic.datetime_parse.parse_duration`\n* `pydantic.error_wrappers.ErrorWrapper`\n* `pydantic.errors.AnyStrMaxLengthError`\n* `pydantic.errors.AnyStrMinLengthError`\n* `pydantic.errors.ArbitraryTypeError`\n* `pydantic.errors.BoolError`\n* `pydantic.errors.BytesError`\n* `pydantic.errors.CallableError`\n* `pydantic.errors.ClassError`\n* `pydantic.errors.ColorError`\n* `pydantic.errors.ConfigError`\n* `pydantic.errors.DataclassTypeError`\n* `pydantic.errors.DateError`\n* `pydantic.errors.DateNotInTheFutureError`\n* `pydantic.errors.DateNotInThePastError`\n* `pydantic.errors.DateTimeError`\n* `pydantic.errors.DecimalError`\n* `pydantic.errors.DecimalIsNotFiniteError`\n* `pydantic.errors.DecimalMaxDigitsError`\n* `pydantic.errors.DecimalMaxPlacesError`\n* `pydantic.errors.DecimalWholeDigitsError`\n* `pydantic.errors.DictError`\n* `pydantic.errors.DurationError`\n* `pydantic.errors.EmailError`\n* `pydantic.errors.EnumError`\n* `pydantic.errors.EnumMemberError`\n* `pydantic.errors.ExtraError`\n* `pydantic.errors.FloatError`\n* `pydantic.errors.FrozenSetError`\n* `pydantic.errors.FrozenSetMaxLengthError`\n* `pydantic.errors.FrozenSetMinLengthError`\n* `pydantic.errors.HashableError`\n* `pydantic.errors.IPv4AddressError`\n* `pydantic.errors.IPv4InterfaceError`\n* `pydantic.errors.IPv4NetworkError`\n* `pydantic.errors.IPv6AddressError`\n* `pydantic.errors.IPv6InterfaceError`\n* `pydantic.errors.IPv6NetworkError`\n* `pydantic.errors.IPvAnyAddressError`\n* `pydantic.errors.IPvAnyInterfaceError`\n* `pydantic.errors.IPvAnyNetworkError`\n* `pydantic.errors.IntEnumError`\n* `pydantic.errors.IntegerError`\n* `pydantic.errors.InvalidByteSize`\n* `pydantic.errors.InvalidByteSizeUnit`\n* `pydantic.errors.InvalidDiscriminator`\n* `pydantic.errors.InvalidLengthForBrand`\n* `pydantic.errors.JsonError`\n* `pydantic.errors.JsonTypeError`\n* `pydantic.errors.ListError`\n* `pydantic.errors.ListMaxLengthError`\n* `pydantic.errors.ListMinLengthError`\n* `pydantic.errors.ListUniqueItemsError`\n* `pydantic.errors.LuhnValidationError`\n* `pydantic.errors.MissingDiscriminator`\n* `pydantic.errors.MissingError`\n* `pydantic.errors.NoneIsAllowedError`\n* `pydantic.errors.NoneIsNotAllowedError`\n* `pydantic.errors.NotDigitError`\n* `pydantic.errors.NotNoneError`\n* `pydantic.errors.NumberNotGeError`\n* `pydantic.errors.NumberNotGtError`\n* `pydantic.errors.NumberNotLeError`\n* `pydantic.errors.NumberNotLtError`\n* `pydantic.errors.NumberNotMultipleError`\n* `pydantic.errors.PathError`\n* `pydantic.errors.PathNotADirectoryError`\n* `pydantic.errors.PathNotAFileError`\n* `pydantic.errors.PathNotExistsError`\n* `pydantic.errors.PatternError`\n* `pydantic.errors.PyObjectError`\n* `pydantic.errors.PydanticTypeError`\n* `pydantic.errors.PydanticValueError`\n* `pydantic.errors.SequenceError`\n* `pydantic.errors.SetError`\n* `pydantic.errors.SetMaxLengthError`\n* `pydantic.errors.SetMinLengthError`\n* `pydantic.errors.StrError`\n* `pydantic.errors.StrRegexError`\n* `pydantic.errors.StrictBoolError`\n* `pydantic.errors.SubclassError`\n* `pydantic.errors.TimeError`\n* `pydantic.errors.TupleError`\n* `pydantic.errors.TupleLengthError`\n* `pydantic.errors.UUIDError`\n* `pydantic.errors.UUIDVersionError`\n* `pydantic.errors.UrlError`\n* `pydantic.errors.UrlExtraError`\n* `pydantic.errors.UrlHostError`\n* `pydantic.errors.UrlHostTldError`\n* `pydantic.errors.UrlPortError`\n* `pydantic.errors.UrlSchemeError`\n* `pydantic.errors.UrlSchemePermittedError`\n* `pydantic.errors.UrlUserInfoError`\n* `pydantic.errors.WrongConstantError`\n* `pydantic.main.validate_model`\n* `pydantic.networks.stricturl`\n* `pydantic.parse_file_as`\n* `pydantic.parse_raw_as`\n* `pydantic.stricturl`\n* `pydantic.tools.parse_file_as`\n* `pydantic.tools.parse_raw_as`\n* `pydantic.types.JsonWrapper`\n* `pydantic.types.NoneBytes`\n* `pydantic.types.NoneStr`\n* `pydantic.types.NoneStrBytes`\n* `pydantic.types.PyObject`\n* `pydantic.types.StrBytes`\n* `pydantic.typing.evaluate_forwardref`\n* `pydantic.typing.AbstractSetIntStr`\n* `pydantic.typing.AnyCallable`\n* `pydantic.typing.AnyClassMethod`\n* `pydantic.typing.CallableGenerator`\n* `pydantic.typing.DictAny`\n* `pydantic.typing.DictIntStrAny`\n* `pydantic.typing.DictStrAny`\n* `pydantic.typing.IntStr`\n* `pydantic.typing.ListStr`\n* `pydantic.typing.MappingIntStrAny`\n* `pydantic.typing.NoArgAnyCallable`\n* `pydantic.typing.NoneType`\n* `pydantic.typing.ReprArgs`\n* `pydantic.typing.SetStr`\n* `pydantic.typing.StrPath`\n* `pydantic.typing.TupleGenerator`\n* `pydantic.typing.WithArgsTypes`\n* `pydantic.typing.all_literal_values`\n* `pydantic.typing.display_as_type`\n* `pydantic.typing.get_all_type_hints`\n* `pydantic.typing.get_args`\n* `pydantic.typing.get_origin`\n* `pydantic.typing.get_sub_types`\n* `pydantic.typing.is_callable_type`\n* `pydantic.typing.is_classvar`\n* `pydantic.typing.is_finalvar`\n* `pydantic.typing.is_literal_type`\n* `pydantic.typing.is_namedtuple`\n* `pydantic.typing.is_new_type`\n* `pydantic.typing.is_none_type`\n* `pydantic.typing.is_typeddict`\n* `pydantic.typing.is_typeddict_special`\n* `pydantic.typing.is_union`\n* `pydantic.typing.new_type_supertype`\n* `pydantic.typing.resolve_annotations`\n* `pydantic.typing.typing_base`\n* `pydantic.typing.update_field_forward_refs`\n* `pydantic.typing.update_model_forward_refs`\n* `pydantic.utils.ClassAttribute`\n* `pydantic.utils.DUNDER_ATTRIBUTES`\n* `pydantic.utils.PyObjectStr`\n* `pydantic.utils.ValueItems`\n* `pydantic.utils.almost_equal_floats`\n* `pydantic.utils.get_discriminator_alias_and_values`\n* `pydantic.utils.get_model`\n* `pydantic.utils.get_unique_discriminator_alias`\n* `pydantic.utils.in_ipython`\n* `pydantic.utils.is_valid_identifier`\n* `pydantic.utils.path_type`\n* `pydantic.utils.validate_field_name`\n* `pydantic.validate_model`", "url": "https://docs.pydantic.dev/latest/migration/index.html#removed-in-pydantic-v2indexhtmlremoved-in-pydantic-v2-permanent-link", "page": "migration/index.html", "source_site": "pydantic"}
{"title": "Removed in Pydantic V2[Â¶](index.html#removed-in-pydantic-v2 \"Permanent link\")", "anchor": "removed-in-pydantic-v2indexhtmlremoved-in-pydantic-v2-permanent-link", "md_text": "Was this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/migration/index.html#removed-in-pydantic-v2indexhtmlremoved-in-pydantic-v2-permanent-link", "page": "migration/index.html", "source_site": "pydantic"}
{"title": "Usage Documentation[Â¶](index.html#usage-documentation \"Permanent link\")", "anchor": "usage-documentationindexhtmlusage-documentation-permanent-link", "md_text": "The [usage documentation](../concepts/models/index.html) is the most complete guide on how to use Pydantic.", "url": "https://docs.pydantic.dev/latest/help_with_pydantic/index.html#usage-documentationindexhtmlusage-documentation-permanent-link", "page": "help_with_pydantic/index.html", "source_site": "pydantic"}
{"title": "API Documentation[Â¶](index.html#api-documentation \"Permanent link\")", "anchor": "api-documentationindexhtmlapi-documentation-permanent-link", "md_text": "The [API documentation](../api/base_model/index.html) gives reference docs for all public Pydantic APIs.", "url": "https://docs.pydantic.dev/latest/help_with_pydantic/index.html#api-documentationindexhtmlapi-documentation-permanent-link", "page": "help_with_pydantic/index.html", "source_site": "pydantic"}
{"title": "GitHub Discussions[Â¶](index.html#github-discussions \"Permanent link\")", "anchor": "github-discussionsindexhtmlgithub-discussions-permanent-link", "md_text": "[GitHub discussions](https://github.com/pydantic/pydantic/discussions) are useful for asking questions, your question and the answer will help everyone.", "url": "https://docs.pydantic.dev/latest/help_with_pydantic/index.html#github-discussionsindexhtmlgithub-discussions-permanent-link", "page": "help_with_pydantic/index.html", "source_site": "pydantic"}
{"title": "Stack Overflow[Â¶](index.html#stack-overflow \"Permanent link\")", "anchor": "stack-overflowindexhtmlstack-overflow-permanent-link", "md_text": "Use the [`pydantic`](https://stackoverflow.com/questions/tagged/pydantic) tag on Stack Overflow to ask questions, note this is not always monitored by the core Pydantic team.", "url": "https://docs.pydantic.dev/latest/help_with_pydantic/index.html#stack-overflowindexhtmlstack-overflow-permanent-link", "page": "help_with_pydantic/index.html", "source_site": "pydantic"}
{"title": "YouTube[Â¶](index.html#youtube \"Permanent link\")", "anchor": "youtubeindexhtmlyoutube-permanent-link", "md_text": "Youtube has lots of useful [videos on Pydantic](https://www.youtube.com/results?search_query=pydantic).\n\nIn particular Marcelo Trylesinski's video [\"Pydantic V1 to V2 - The Migration\"](https://youtu.be/sD_xpYl4fPU) has helped people a lot when migrating from Pydantic V1 to V2.\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/help_with_pydantic/index.html#youtubeindexhtmlyoutube-permanent-link", "page": "help_with_pydantic/index.html", "source_site": "pydantic"}
{"title": "Type hints powering schema validation[Â¶](index.html#type-hints \"Permanent link\")", "anchor": "type-hints-powering-schema-validationindexhtmltype-hints-permanent-link", "md_text": "The schema that Pydantic validates against is generally defined by Python [type hints](https://docs.python.org/3/glossary.html#term-type-hint).\n\nType hints are great for this since, if you're writing modern Python, you already know how to use them.\nUsing type hints also means that Pydantic integrates well with static typing tools\n(like [mypy](https://www.mypy-lang.org/) and [Pyright](https://github.com/microsoft/pyright/))\nand IDEs (like [PyCharm](https://www.jetbrains.com/pycharm/) and [VSCode](https://code.visualstudio.com/)).\n\nExample - just type hints\n\n```\nfrom typing import Annotated, Literal\n\nfrom annotated_types import Gt\n\nfrom pydantic import BaseModel\n\n\nclass Fruit(BaseModel):\n    name: str  # (1)!\n    color: Literal['red', 'green']  # (2)!\n    weight: Annotated[float, Gt(0)]  # (3)!\n    bazam: dict[str, list[tuple[int, bool, float]]]  # (4)!\n\n\nprint(\n    Fruit(\n        name='Apple',\n        color='red',\n        weight=4.2,\n        bazam={'foobar': [(1, True, 0.1)]},\n    )\n)\n#> name='Apple' color='red' weight=4.2 bazam={'foobar': [(1, True, 0.1)]}\n```\n\n1. The `name` field is simply annotated with `str` â€” any string is allowed.\n2. The [`Literal`](https://docs.python.org/3/library/typing.html#typing.Literal) type is used to enforce that `color` is either `'red'` or `'green'`.\n3. Even when we want to apply constraints not encapsulated in Python types, we can use [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated)\n   and [`annotated-types`](https://github.com/annotated-types/annotated-types) to enforce constraints while still keeping typing support.\n4. I'm not claiming \"bazam\" is really an attribute of fruit, but rather to show that arbitrarily complex types can easily be validated.\n\nSee the [documentation on supported types](../concepts/types/index.html).", "url": "https://docs.pydantic.dev/latest/why/index.html#type-hints-powering-schema-validationindexhtmltype-hints-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "Performance[Â¶](index.html#performance \"Permanent link\")", "anchor": "performanceindexhtmlperformance-permanent-link", "md_text": "Pydantic's core validation logic is implemented in a separate package ([`pydantic-core`](https://github.com/pydantic/pydantic-core)),\nwhere validation for most types is implemented in Rust.\n\nAs a result, Pydantic is among the fastest data validation libraries for Python.\n\nPerformance Example - Pydantic vs. dedicated code\n\nIn general, dedicated code should be much faster than a general-purpose validator, but in this example\nPydantic is >300% faster than dedicated code when parsing JSON and validating URLs.\n\nPerformance Example\n\n```\nimport json\nimport timeit\nfrom urllib.parse import urlparse\n\nimport requests\n\nfrom pydantic import HttpUrl, TypeAdapter\n\nreps = 7\nnumber = 100\nr = requests.get('https://api.github.com/emojis')\nr.raise_for_status()\nemojis_json = r.content\n\n\ndef emojis_pure_python(raw_data):\n    data = json.loads(raw_data)\n    output = {}\n    for key, value in data.items():\n        assert isinstance(key, str)\n        url = urlparse(value)\n        assert url.scheme in ('https', 'http')\n        output[key] = url\n\n\nemojis_pure_python_times = timeit.repeat(\n    'emojis_pure_python(emojis_json)',\n    globals={\n        'emojis_pure_python': emojis_pure_python,\n        'emojis_json': emojis_json,\n    },\n    repeat=reps,\n    number=number,\n)\nprint(f'pure python: {min(emojis_pure_python_times) / number * 1000:0.2f}ms')\n#> pure python: 5.32ms\n\ntype_adapter = TypeAdapter(dict[str, HttpUrl])\nemojis_pydantic_times = timeit.repeat(\n    'type_adapter.validate_json(emojis_json)',\n    globals={\n        'type_adapter': type_adapter,\n        'HttpUrl': HttpUrl,\n        'emojis_json': emojis_json,\n    },\n    repeat=reps,\n    number=number,\n)\nprint(f'pydantic: {min(emojis_pydantic_times) / number * 1000:0.2f}ms')\n#> pydantic: 1.54ms\n\nprint(\n    f'Pydantic {min(emojis_pure_python_times) / min(emojis_pydantic_times):0.2f}x faster'\n)\n#> Pydantic 3.45x faster\n```\n\nUnlike other performance-centric libraries written in compiled languages, Pydantic also has excellent support for customizing validation via [functional validators](index.html#customisation).\n\nSamuel Colvin's [talk at PyCon 2023](https://youtu.be/pWZw7hYoRVU) explains how [`pydantic-core`](https://github.com/pydantic/pydantic-core)\nworks and how it integrates with Pydantic.", "url": "https://docs.pydantic.dev/latest/why/index.html#performanceindexhtmlperformance-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "Serialization[Â¶](index.html#serialization \"Permanent link\")", "anchor": "serializationindexhtmlserialization-permanent-link", "md_text": "Pydantic provides functionality to serialize model in three ways:\n\n1. To a Python `dict` made up of the associated Python objects.\n2. To a Python `dict` made up only of \"jsonable\" types.\n3. To a JSON string.\n\nIn all three modes, the output can be customized by excluding specific fields, excluding unset fields, excluding default values, and excluding `None` values.\n\nExample - Serialization 3 ways\n\n```\nfrom datetime import datetime\n\nfrom pydantic import BaseModel\n\n\nclass Meeting(BaseModel):\n    when: datetime\n    where: bytes\n    why: str = 'No idea'\n\n\nm = Meeting(when='2020-01-01T12:00', where='home')\nprint(m.model_dump(exclude_unset=True))\n#> {'when': datetime.datetime(2020, 1, 1, 12, 0), 'where': b'home'}\nprint(m.model_dump(exclude={'where'}, mode='json'))\n#> {'when': '2020-01-01T12:00:00', 'why': 'No idea'}\nprint(m.model_dump_json(exclude_defaults=True))\n#> {\"when\":\"2020-01-01T12:00:00\",\"where\":\"home\"}\n```\n\nSee the [documentation on serialization](../concepts/serialization/index.html).", "url": "https://docs.pydantic.dev/latest/why/index.html#serializationindexhtmlserialization-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "JSON Schema[Â¶](index.html#json-schema \"Permanent link\")", "anchor": "json-schemaindexhtmljson-schema-permanent-link", "md_text": "A [JSON Schema](https://json-schema.org/) can be generated for any Pydantic schema â€” allowing self-documenting APIs and integration with a wide variety of tools which support the JSON Schema format.\n\nExample - JSON Schema\n\n```\nfrom datetime import datetime\n\nfrom pydantic import BaseModel\n\n\nclass Address(BaseModel):\n    street: str\n    city: str\n    zipcode: str\n\n\nclass Meeting(BaseModel):\n    when: datetime\n    where: Address\n    why: str = 'No idea'\n\n\nprint(Meeting.model_json_schema())\n\"\"\"\n{\n    '$defs': {\n        'Address': {\n            'properties': {\n                'street': {'title': 'Street', 'type': 'string'},\n                'city': {'title': 'City', 'type': 'string'},\n                'zipcode': {'title': 'Zipcode', 'type': 'string'},\n            },\n            'required': ['street', 'city', 'zipcode'],\n            'title': 'Address',\n            'type': 'object',\n        }\n    },\n    'properties': {\n        'when': {'format': 'date-time', 'title': 'When', 'type': 'string'},\n        'where': {'$ref': '#/$defs/Address'},\n        'why': {'default': 'No idea', 'title': 'Why', 'type': 'string'},\n    },\n    'required': ['when', 'where'],\n    'title': 'Meeting',\n    'type': 'object',\n}\n\"\"\"\n```\n\nPydantic is compliant with the latest version of JSON Schema specification\n([2020-12](https://json-schema.org/draft/2020-12/release-notes.html)), which\nis compatible with [OpenAPI 3.1](https://spec.openapis.org/oas/v3.1.0.html).\n\nSee the [documentation on JSON Schema](../concepts/json_schema/index.html).", "url": "https://docs.pydantic.dev/latest/why/index.html#json-schemaindexhtmljson-schema-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "Strict mode and data coercion[Â¶](index.html#strict-lax \"Permanent link\")", "anchor": "strict-mode-and-data-coercionindexhtmlstrict-lax-permanent-link", "md_text": "By default, Pydantic is tolerant to common incorrect types and coerces data to the right type â€”\ne.g. a numeric string passed to an `int` field will be parsed as an `int`.\n\nPydantic also has as [strict mode](../concepts/strict_mode/index.html), where types are not coerced and a\nvalidation error is raised unless the input data exactly matches the expected schema.\n\nBut strict mode would be pretty useless when validating JSON data since JSON doesn't have types matching\nmany common Python types like [`datetime`](https://docs.python.org/3/library/datetime.html#datetime.datetime), [`UUID`](https://docs.python.org/3/library/uuid.html#uuid.UUID) or [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes).\n\nTo solve this, Pydantic can parse and validate JSON in one step. This allows sensible data conversion\n(e.g. when parsing strings into [`datetime`](https://docs.python.org/3/library/datetime.html#datetime.datetime) objects). Since the JSON parsing is\nimplemented in Rust, it's also very performant.\n\nExample - Strict mode that's actually useful\n\n```\nfrom datetime import datetime\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Meeting(BaseModel):\n    when: datetime\n    where: bytes\n\n\nm = Meeting.model_validate({'when': '2020-01-01T12:00', 'where': 'home'})\nprint(m)\n#> when=datetime.datetime(2020, 1, 1, 12, 0) where=b'home'\ntry:\n    m = Meeting.model_validate(\n        {'when': '2020-01-01T12:00', 'where': 'home'}, strict=True\n    )\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for Meeting\n    when\n      Input should be a valid datetime [type=datetime_type, input_value='2020-01-01T12:00', input_type=str]\n    where\n      Input should be a valid bytes [type=bytes_type, input_value='home', input_type=str]\n    \"\"\"\n\nm_json = Meeting.model_validate_json(\n    '{\"when\": \"2020-01-01T12:00\", \"where\": \"home\"}'\n)\nprint(m_json)\n#> when=datetime.datetime(2020, 1, 1, 12, 0) where=b'home'\n```\n\nSee the [documentation on strict mode](../concepts/strict_mode/index.html).", "url": "https://docs.pydantic.dev/latest/why/index.html#strict-mode-and-data-coercionindexhtmlstrict-lax-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "Dataclasses, TypedDicts, and more[Â¶](index.html#dataclasses-typeddict-more \"Permanent link\")", "anchor": "dataclasses-typeddicts-and-moreindexhtmldataclasses-typeddict-more-permanent-link", "md_text": "Pydantic provides four ways to create schemas and perform validation and serialization:\n\n1. [`BaseModel`](../concepts/models/index.html) â€” Pydantic's own super class with many common utilities available via instance methods.\n2. [Pydantic dataclasses](../concepts/dataclasses/index.html) â€” a wrapper around standard dataclasses with additional validation performed.\n3. [`TypeAdapter`](../api/type_adapter/index.html#pydantic.type_adapter.TypeAdapter) â€” a general way to adapt any type for validation and serialization.\n   This allows types like [`TypedDict`](../api/standard_library_types/index.html#typeddict) and [`NamedTuple`](../api/standard_library_types/index.html#named-tuples)\n   to be validated as well as simple types (like [`int`](https://docs.python.org/3/library/functions.html#int) or [`timedelta`](https://docs.python.org/3/library/datetime.html#datetime.timedelta)) â€” [all types](../concepts/types/index.html) supported\n   can be used with [`TypeAdapter`](../api/type_adapter/index.html#pydantic.type_adapter.TypeAdapter).\n4. [`validate_call`](../concepts/validation_decorator/index.html) â€” a decorator to perform validation when calling a function.\n\nExample - schema based on a [`TypedDict`](https://docs.python.org/3/library/typing.html#typing.TypedDict)\n\n```\nfrom datetime import datetime\n\nfrom typing_extensions import NotRequired, TypedDict\n\nfrom pydantic import TypeAdapter\n\n\nclass Meeting(TypedDict):\n    when: datetime\n    where: bytes\n    why: NotRequired[str]\n\n\nmeeting_adapter = TypeAdapter(Meeting)\nm = meeting_adapter.validate_python(  # (1)!\n    {'when': '2020-01-01T12:00', 'where': 'home'}\n)\nprint(m)\n#> {'when': datetime.datetime(2020, 1, 1, 12, 0), 'where': b'home'}\nmeeting_adapter.dump_python(m, exclude={'where'})  # (2)!\n\nprint(meeting_adapter.json_schema())  # (3)!\n\"\"\"\n{\n    'properties': {\n        'when': {'format': 'date-time', 'title': 'When', 'type': 'string'},\n        'where': {'format': 'binary', 'title': 'Where', 'type': 'string'},\n        'why': {'title': 'Why', 'type': 'string'},\n    },\n    'required': ['when', 'where'],\n    'title': 'Meeting',\n    'type': 'object',\n}\n\"\"\"\n```\n\n1. [`TypeAdapter`](../api/type_adapter/index.html#pydantic.type_adapter.TypeAdapter) for a [`TypedDict`](https://docs.python.org/3/library/typing.html#typing.TypedDict) performing validation,\n   it can also validate JSON data directly with [`validate_json`](../api/type_adapter/index.html#pydantic.type_adapter.TypeAdapter.validate_json).\n2. [`dump_python`](../api/type_adapter/index.html#pydantic.type_adapter.TypeAdapter.dump_python) to serialise a [`TypedDict`](https://docs.python.org/3/library/typing.html#typing.TypedDict)\n   to a python object, it can also serialise to JSON with [`dump_json`](../api/type_adapter/index.html#pydantic.type_adapter.TypeAdapter.dump_json).\n3. [`TypeAdapter`](../api/type_adapter/index.html#pydantic.type_adapter.TypeAdapter) can also generate a JSON Schema.", "url": "https://docs.pydantic.dev/latest/why/index.html#dataclasses-typeddicts-and-moreindexhtmldataclasses-typeddict-more-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "Customisation[Â¶](index.html#customisation \"Permanent link\")", "anchor": "customisationindexhtmlcustomisation-permanent-link", "md_text": "Functional validators and serializers, as well as a powerful protocol for custom types, means the way Pydantic operates can be customized on a per-field or per-type basis.\n\nCustomisation Example - wrap validators\n\n\"wrap validators\" are new in Pydantic V2 and are one of the most powerful ways to customize validation.\n\n```\nfrom datetime import datetime, timezone\nfrom typing import Any\n\nfrom pydantic_core.core_schema import ValidatorFunctionWrapHandler\n\nfrom pydantic import BaseModel, field_validator\n\n\nclass Meeting(BaseModel):\n    when: datetime\n\n    @field_validator('when', mode='wrap')\n    def when_now(\n        cls, input_value: Any, handler: ValidatorFunctionWrapHandler\n    ) -> datetime:\n        if input_value == 'now':\n            return datetime.now()\n        when = handler(input_value)\n        # in this specific application we know tz naive datetimes are in UTC\n        if when.tzinfo is None:\n            when = when.replace(tzinfo=timezone.utc)\n        return when\n\n\nprint(Meeting(when='2020-01-01T12:00+01:00'))\n#> when=datetime.datetime(2020, 1, 1, 12, 0, tzinfo=TzInfo(3600))\nprint(Meeting(when='now'))\n#> when=datetime.datetime(2032, 1, 2, 3, 4, 5, 6)\nprint(Meeting(when='2020-01-01T12:00'))\n#> when=datetime.datetime(2020, 1, 1, 12, 0, tzinfo=datetime.timezone.utc)\n```\n\nSee the documentation on [validators](../concepts/validators/index.html), [custom serializers](../concepts/serialization/index.html#serializers),\nand [custom types](../concepts/types/index.html#custom-types).", "url": "https://docs.pydantic.dev/latest/why/index.html#customisationindexhtmlcustomisation-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "Ecosystem[Â¶](index.html#ecosystem \"Permanent link\")", "anchor": "ecosystemindexhtmlecosystem-permanent-link", "md_text": "At the time of writing there are 466,400 repositories on GitHub and 8,119 packages on PyPI that depend on Pydantic.\n\nSome notable libraries that depend on Pydantic:", "url": "https://docs.pydantic.dev/latest/why/index.html#ecosystemindexhtmlecosystem-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "Ecosystem[Â¶](index.html#ecosystem \"Permanent link\")", "anchor": "ecosystemindexhtmlecosystem-permanent-link", "md_text": "* [`huggingface/transformers`](https://github.com/huggingface/transformers) 138,570 stars\n* [`hwchase17/langchain`](https://github.com/hwchase17/langchain) 99,542 stars\n* [`tiangolo/fastapi`](https://github.com/tiangolo/fastapi) 80,497 stars\n* [`apache/airflow`](https://github.com/apache/airflow) 38,577 stars\n* [`lm-sys/FastChat`](https://github.com/lm-sys/FastChat) 37,650 stars\n* [`microsoft/DeepSpeed`](https://github.com/microsoft/DeepSpeed) 36,521 stars\n* [`OpenBB-finance/OpenBBTerminal`](https://github.com/OpenBB-finance/OpenBBTerminal) 35,971 stars\n* [`gradio-app/gradio`](https://github.com/gradio-app/gradio) 35,740 stars\n* [`ray-project/ray`](https://github.com/ray-project/ray) 35,176 stars\n* [`pola-rs/polars`](https://github.com/pola-rs/polars) 31,698 stars\n* [`Lightning-AI/lightning`](https://github.com/Lightning-AI/lightning) 28,902 stars\n* [`mindsdb/mindsdb`](https://github.com/mindsdb/mindsdb) 27,141 stars\n* [`embedchain/embedchain`](https://github.com/embedchain/embedchain) 24,379 stars\n* [`pynecone-io/reflex`](https://github.com/pynecone-io/reflex) 21,558 stars\n* [`heartexlabs/label-studio`](https://github.com/heartexlabs/label-studio) 20,571 stars\n* [`Sanster/lama-cleaner`](https://github.com/Sanster/lama-cleaner) 20,313 stars\n* [`mlflow/mlflow`](https://github.com/mlflow/mlflow) 19,393 stars\n* [`RasaHQ/rasa`](https://github.com/RasaHQ/rasa) 19,337 stars\n* [`spotDL/spotify-downloader`](https://github.com/spotDL/spotify-downloader) 18,604 stars\n* [`chroma-core/chroma`](https://github.com/chroma-core/chroma) 17,393 stars\n* [`airbytehq/airbyte`](https://github.com/airbytehq/airbyte) 17,120 stars\n* [`openai/evals`](https://github.com/openai/evals) 15,437 stars\n* [`tiangolo/sqlmodel`](https://github.com/tiangolo/sqlmodel) 15,127 stars\n* [`ydataai/ydata-profiling`](https://github.com/ydataai/ydata-profiling) 12,687 stars\n* [`pyodide/pyodide`](https://github.com/pyodide/pyodide) 12,653 stars\n* [`dagster-io/dagster`](https://github.com/dagster-io/dagster) 12,440 stars\n* [`PaddlePaddle/PaddleNLP`](https://github.com/PaddlePaddle/PaddleNLP) 12,312 stars\n* [`matrix-org/synapse`](https://github.com/matrix-org/synapse) 11,857 stars\n* [`lucidrains/DALLE2-pytorch`](https://github.com/lucidrains/DALLE2-pytorch) 11,207 stars\n* [`great-expectations/great_expectations`](https://github.com/great-expectations/great_expectations) 10,164 stars\n* [`modin-project/modin`](https://github.com/modin-project/modin) 10,002 stars\n* [`aws/serverless-application-model`](https://github.com/aws/serverless-application-model) 9,402 stars\n* [`sqlfluff/sqlfluff`](https://github.com/sqlfluff/sqlfluff) 8,535 stars\n* [`replicate/cog`](https://github.com/replicate/cog) 8,344 stars\n* [`autogluon/autogluon`](https://github.com/autogluon/autogluon) 8,326 stars\n* [`lucidrains/imagen-pytorch`](https://github.com/lucidrains/imagen-pytorch) 8,164 stars\n* [`brycedrennan/imaginAIry`](https://github.com/brycedrennan/imaginAIry) 8,050 stars\n* [`vitalik/django-ninja`](https://github.com/vitalik/django-ninja) 7,685 stars\n* [`NVlabs/SPADE`](https://github.com/NVlabs/SPADE) 7,632 stars\n* [`bridgecrewio/checkov`](https://github.com/bridgecrewio/checkov) 7,340 stars\n* [`bentoml/BentoML`](https://github.com/bentoml/BentoML) 7,322 stars\n* [`skypilot-org/skypilot`](https://github.com/skypilot-org/skypilot) 7,113 stars\n* [`apache/iceberg`](https://github.com/apache/iceberg) 6,853 stars\n* [`deeppavlov/DeepPavlov`](https://github.com/deeppavlov/DeepPavlov) 6,777 stars\n* [`PrefectHQ/marvin`](https://github.com/PrefectHQ/marvin) 5,454 stars\n* [`NVIDIA/NeMo-Guardrails`](https://github.com/NVIDIA/NeMo-Guardrails) 4,383 stars\n* [`microsoft/FLAML`](https://github.com/microsoft/FLAML) 4,035 stars\n* [`jina-ai/discoart`](https://github.com/jina-ai/discoart) 3,846 stars\n* [`docarray/docarray`](https://github.com/docarray/docarray) 3,007 stars\n* [`aws-powertools/powertools-lambda-python`](https://github.com/aws-powertools/powertools-lambda-python) 2,980 stars\n* [`roman-right/beanie`](https://github.com/roman-right/beanie) 2,172 stars\n* [`art049/odmantic`](https://github.com/art049/odmantic) 1,096 stars", "url": "https://docs.pydantic.dev/latest/why/index.html#ecosystemindexhtmlecosystem-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "Ecosystem[Â¶](index.html#ecosystem \"Permanent link\")", "anchor": "ecosystemindexhtmlecosystem-permanent-link", "md_text": "More libraries using Pydantic can be found at [`Kludex/awesome-pydantic`](https://github.com/Kludex/awesome-pydantic).", "url": "https://docs.pydantic.dev/latest/why/index.html#ecosystemindexhtmlecosystem-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "Organisations using Pydantic[Â¶](index.html#using-pydantic \"Permanent link\")", "anchor": "organisations-using-pydanticindexhtmlusing-pydantic-permanent-link", "md_text": "Some notable companies and organisations using Pydantic together with comments on why/how we know they're using Pydantic.\n\nThe organisations below are included because they match one or more of the following criteria:\n\n* Using Pydantic as a dependency in a public repository.\n* Referring traffic to the Pydantic documentation site from an organization-internal domain â€” specific referrers are not included since they're generally not in the public domain.\n* Direct communication between the Pydantic team and engineers employed by the organization about usage of Pydantic within the organization.\n\nWe've included some extra detail where appropriate and already in the public domain.", "url": "https://docs.pydantic.dev/latest/why/index.html#organisations-using-pydanticindexhtmlusing-pydantic-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "Adobe[Â¶](index.html#org-adobe \"Permanent link\")", "anchor": "adobeindexhtmlorg-adobe-permanent-link", "md_text": "[`adobe/dy-sql`](https://github.com/adobe/dy-sql) uses Pydantic.", "url": "https://docs.pydantic.dev/latest/why/index.html#adobeindexhtmlorg-adobe-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "Amazon and AWS[Â¶](index.html#org-amazon \"Permanent link\")", "anchor": "amazon-and-awsindexhtmlorg-amazon-permanent-link", "md_text": "* [powertools-lambda-python](https://github.com/aws-powertools/powertools-lambda-python)\n* [awslabs/gluonts](https://github.com/awslabs/gluonts)\n* AWS [sponsored Samuel Colvin $5,000](https://twitter.com/samuel_colvin/status/1549383169006239745) to work on Pydantic in 2022", "url": "https://docs.pydantic.dev/latest/why/index.html#amazon-and-awsindexhtmlorg-amazon-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "Anthropic[Â¶](index.html#org-anthropic \"Permanent link\")", "anchor": "anthropicindexhtmlorg-anthropic-permanent-link", "md_text": "[`anthropics/anthropic-sdk-python`](https://github.com/anthropics/anthropic-sdk-python) uses Pydantic.", "url": "https://docs.pydantic.dev/latest/why/index.html#anthropicindexhtmlorg-anthropic-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "Apple[Â¶](index.html#org-apple \"Permanent link\")", "anchor": "appleindexhtmlorg-apple-permanent-link", "md_text": "*(Based on the criteria described above)*", "url": "https://docs.pydantic.dev/latest/why/index.html#appleindexhtmlorg-apple-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "ASML[Â¶](index.html#org-asml \"Permanent link\")", "anchor": "asmlindexhtmlorg-asml-permanent-link", "md_text": "*(Based on the criteria described above)*", "url": "https://docs.pydantic.dev/latest/why/index.html#asmlindexhtmlorg-asml-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "AstraZeneca[Â¶](index.html#org-astrazeneca \"Permanent link\")", "anchor": "astrazenecaindexhtmlorg-astrazeneca-permanent-link", "md_text": "[Multiple repos](https://github.com/search?q=org%3AAstraZeneca+pydantic&type=code) in the `AstraZeneca`\nGitHub org depend on Pydantic.", "url": "https://docs.pydantic.dev/latest/why/index.html#astrazenecaindexhtmlorg-astrazeneca-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "Cisco Systems[Â¶](index.html#org-cisco \"Permanent link\")", "anchor": "cisco-systemsindexhtmlorg-cisco-permanent-link", "md_text": "* Pydantic is listed in their report of [Open Source Used In RADKit](https://www.cisco.com/c/dam/en_us/about/doing_business/open_source/docs/RADKit-149-1687424532.pdf).\n* [`cisco/webex-assistant-sdk`](https://github.com/cisco/webex-assistant-sdk)", "url": "https://docs.pydantic.dev/latest/why/index.html#cisco-systemsindexhtmlorg-cisco-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "Comcast[Â¶](index.html#org-comcast \"Permanent link\")", "anchor": "comcastindexhtmlorg-comcast-permanent-link", "md_text": "*(Based on the criteria described above)*", "url": "https://docs.pydantic.dev/latest/why/index.html#comcastindexhtmlorg-comcast-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "Datadog[Â¶](index.html#org-datadog \"Permanent link\")", "anchor": "datadogindexhtmlorg-datadog-permanent-link", "md_text": "* Extensive use of Pydantic in [`DataDog/integrations-core`](https://github.com/DataDog/integrations-core) and other repos\n* Communication with engineers from Datadog about how they use Pydantic.", "url": "https://docs.pydantic.dev/latest/why/index.html#datadogindexhtmlorg-datadog-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "Facebook[Â¶](index.html#org-facebook \"Permanent link\")", "anchor": "facebookindexhtmlorg-facebook-permanent-link", "md_text": "[Multiple repos](https://github.com/search?q=org%3Afacebookresearch+pydantic&type=code) in the `facebookresearch`\nGitHub org depend on Pydantic.", "url": "https://docs.pydantic.dev/latest/why/index.html#facebookindexhtmlorg-facebook-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "GitHub[Â¶](index.html#org-github \"Permanent link\")", "anchor": "githubindexhtmlorg-github-permanent-link", "md_text": "GitHub sponsored Pydantic $750 in 2022", "url": "https://docs.pydantic.dev/latest/why/index.html#githubindexhtmlorg-github-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "Google[Â¶](index.html#org-google \"Permanent link\")", "anchor": "googleindexhtmlorg-google-permanent-link", "md_text": "Extensive use of Pydantic in [`google/turbinia`](https://github.com/google/turbinia) and other repos.", "url": "https://docs.pydantic.dev/latest/why/index.html#googleindexhtmlorg-google-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "HSBC[Â¶](index.html#org-hsbc \"Permanent link\")", "anchor": "hsbcindexhtmlorg-hsbc-permanent-link", "md_text": "*(Based on the criteria described above)*", "url": "https://docs.pydantic.dev/latest/why/index.html#hsbcindexhtmlorg-hsbc-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "IBM[Â¶](index.html#org-ibm \"Permanent link\")", "anchor": "ibmindexhtmlorg-ibm-permanent-link", "md_text": "[Multiple repos](https://github.com/search?q=org%3AIBM+pydantic&type=code) in the `IBM` GitHub org depend on Pydantic.", "url": "https://docs.pydantic.dev/latest/why/index.html#ibmindexhtmlorg-ibm-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "Intel[Â¶](index.html#org-intel \"Permanent link\")", "anchor": "intelindexhtmlorg-intel-permanent-link", "md_text": "*(Based on the criteria described above)*", "url": "https://docs.pydantic.dev/latest/why/index.html#intelindexhtmlorg-intel-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "Intuit[Â¶](index.html#org-intuit \"Permanent link\")", "anchor": "intuitindexhtmlorg-intuit-permanent-link", "md_text": "*(Based on the criteria described above)*", "url": "https://docs.pydantic.dev/latest/why/index.html#intuitindexhtmlorg-intuit-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "Intergovernmental Panel on Climate Change[Â¶](index.html#org-ipcc \"Permanent link\")", "anchor": "intergovernmental-panel-on-climate-changeindexhtmlorg-ipcc-permanent-link", "md_text": "[Tweet](https://twitter.com/daniel_huppmann/status/1563461797973110785) explaining how the IPCC use Pydantic.", "url": "https://docs.pydantic.dev/latest/why/index.html#intergovernmental-panel-on-climate-changeindexhtmlorg-ipcc-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "JPMorgan[Â¶](index.html#org-jpmorgan \"Permanent link\")", "anchor": "jpmorganindexhtmlorg-jpmorgan-permanent-link", "md_text": "*(Based on the criteria described above)*", "url": "https://docs.pydantic.dev/latest/why/index.html#jpmorganindexhtmlorg-jpmorgan-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "Jupyter[Â¶](index.html#org-jupyter \"Permanent link\")", "anchor": "jupyterindexhtmlorg-jupyter-permanent-link", "md_text": "* The developers of the Jupyter notebook are using Pydantic [for subprojects](https://github.com/pydantic/pydantic/issues/773)\n* Through the FastAPI-based Jupyter server [Jupyverse](https://github.com/jupyter-server/jupyverse)\n* [FPS](https://github.com/jupyter-server/fps)'s configuration management.", "url": "https://docs.pydantic.dev/latest/why/index.html#jupyterindexhtmlorg-jupyter-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "Microsoft[Â¶](index.html#org-microsoft \"Permanent link\")", "anchor": "microsoftindexhtmlorg-microsoft-permanent-link", "md_text": "* [DeepSpeed](https://github.com/microsoft/DeepSpeed) deep learning optimisation library uses Pydantic extensively\n* [Multiple repos](https://github.com/search?q=org%3Amicrosoft%20pydantic&type=code) in the `microsoft` GitHub org depend on Pydantic, in particular their\n* Pydantic is also [used](https://github.com/search?q=org%3AAzure%20pydantic&type=code) in the `Azure` GitHub org\n* [Comments](https://github.com/tiangolo/fastapi/pull/26) on GitHub show Microsoft engineers using Pydantic as part of Windows and Office", "url": "https://docs.pydantic.dev/latest/why/index.html#microsoftindexhtmlorg-microsoft-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "Molecular Science Software Institute[Â¶](index.html#org-molssi \"Permanent link\")", "anchor": "molecular-science-software-instituteindexhtmlorg-molssi-permanent-link", "md_text": "[Multiple repos](https://github.com/search?q=org%3AMolSSI%20pydantic&type=code) in the `MolSSI`\nGitHub org depend on Pydantic.", "url": "https://docs.pydantic.dev/latest/why/index.html#molecular-science-software-instituteindexhtmlorg-molssi-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "NASA[Â¶](index.html#org-nasa \"Permanent link\")", "anchor": "nasaindexhtmlorg-nasa-permanent-link", "md_text": "[Multiple repos](https://github.com/search?q=org%3Anasa%20pydantic&type=code) in the `NASA`\nGitHub org depend on Pydantic.\n\nNASA are also using Pydantic via FastAPI in their JWST project to process images from the James Webb Space Telescope,\nsee [this tweet](https://twitter.com/benjamin_falk/status/1546947039363305472).", "url": "https://docs.pydantic.dev/latest/why/index.html#nasaindexhtmlorg-nasa-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "Netflix[Â¶](index.html#org-netflix \"Permanent link\")", "anchor": "netflixindexhtmlorg-netflix-permanent-link", "md_text": "[Multiple repos](https://github.com/search?q=org%3Anetflix%20pydantic&type=code) in the `Netflix`\nGitHub org depend on Pydantic.", "url": "https://docs.pydantic.dev/latest/why/index.html#netflixindexhtmlorg-netflix-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "NSA[Â¶](index.html#org-nsa \"Permanent link\")", "anchor": "nsaindexhtmlorg-nsa-permanent-link", "md_text": "The [`nsacyber/WALKOFF`](https://github.com/nsacyber/WALKOFF) repo depends on Pydantic.", "url": "https://docs.pydantic.dev/latest/why/index.html#nsaindexhtmlorg-nsa-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "NVIDIA[Â¶](index.html#org-nvidia \"Permanent link\")", "anchor": "nvidiaindexhtmlorg-nvidia-permanent-link", "md_text": "[Multiple repositories](https://github.com/search?q=org%3ANVIDIA%20pydantic&type=code) in the `NVIDIA`\nGitHub org depend on Pydantic.\n\nTheir \"Omniverse Services\" depends on Pydantic according to\n[their documentation](https://web.archive.org/web/20220628161919/https://docs.omniverse.nvidia.com/prod_services/prod_services/core/index.html).", "url": "https://docs.pydantic.dev/latest/why/index.html#nvidiaindexhtmlorg-nvidia-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "OpenAI[Â¶](index.html#org-openai \"Permanent link\")", "anchor": "openaiindexhtmlorg-openai-permanent-link", "md_text": "OpenAI use Pydantic for their ChatCompletions API, as per [this](https://github.com/pydantic/pydantic/discussions/6372) discussion on GitHub.\n\nAnecdotally, OpenAI use Pydantic extensively for their internal services.", "url": "https://docs.pydantic.dev/latest/why/index.html#openaiindexhtmlorg-openai-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "Oracle[Â¶](index.html#org-oracle \"Permanent link\")", "anchor": "oracleindexhtmlorg-oracle-permanent-link", "md_text": "*(Based on the criteria described above)*", "url": "https://docs.pydantic.dev/latest/why/index.html#oracleindexhtmlorg-oracle-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "Palantir[Â¶](index.html#org-palantir \"Permanent link\")", "anchor": "palantirindexhtmlorg-palantir-permanent-link", "md_text": "*(Based on the criteria described above)*", "url": "https://docs.pydantic.dev/latest/why/index.html#palantirindexhtmlorg-palantir-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "Qualcomm[Â¶](index.html#org-qualcomm \"Permanent link\")", "anchor": "qualcommindexhtmlorg-qualcomm-permanent-link", "md_text": "*(Based on the criteria described above)*", "url": "https://docs.pydantic.dev/latest/why/index.html#qualcommindexhtmlorg-qualcomm-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "Red Hat[Â¶](index.html#org-redhat \"Permanent link\")", "anchor": "red-hatindexhtmlorg-redhat-permanent-link", "md_text": "*(Based on the criteria described above)*", "url": "https://docs.pydantic.dev/latest/why/index.html#red-hatindexhtmlorg-redhat-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "Revolut[Â¶](index.html#org-revolut \"Permanent link\")", "anchor": "revolutindexhtmlorg-revolut-permanent-link", "md_text": "Anecdotally, all internal services at Revolut are built with FastAPI and therefore Pydantic.", "url": "https://docs.pydantic.dev/latest/why/index.html#revolutindexhtmlorg-revolut-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "Robusta[Â¶](index.html#org-robusta \"Permanent link\")", "anchor": "robustaindexhtmlorg-robusta-permanent-link", "md_text": "The [`robusta-dev/robusta`](https://github.com/robusta-dev/robusta) repo depends on Pydantic.", "url": "https://docs.pydantic.dev/latest/why/index.html#robustaindexhtmlorg-robusta-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "Salesforce[Â¶](index.html#org-salesforce \"Permanent link\")", "anchor": "salesforceindexhtmlorg-salesforce-permanent-link", "md_text": "Salesforce [sponsored Samuel Colvin $10,000](https://twitter.com/samuel_colvin/status/1501288247670063104) to work on Pydantic in 2022.", "url": "https://docs.pydantic.dev/latest/why/index.html#salesforceindexhtmlorg-salesforce-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "Starbucks[Â¶](index.html#org-starbucks \"Permanent link\")", "anchor": "starbucksindexhtmlorg-starbucks-permanent-link", "md_text": "*(Based on the criteria described above)*", "url": "https://docs.pydantic.dev/latest/why/index.html#starbucksindexhtmlorg-starbucks-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "Texas Instruments[Â¶](index.html#org-ti \"Permanent link\")", "anchor": "texas-instrumentsindexhtmlorg-ti-permanent-link", "md_text": "*(Based on the criteria described above)*", "url": "https://docs.pydantic.dev/latest/why/index.html#texas-instrumentsindexhtmlorg-ti-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "Twilio[Â¶](index.html#org-twilio \"Permanent link\")", "anchor": "twilioindexhtmlorg-twilio-permanent-link", "md_text": "*(Based on the criteria described above)*", "url": "https://docs.pydantic.dev/latest/why/index.html#twilioindexhtmlorg-twilio-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "Twitter[Â¶](index.html#org-twitter \"Permanent link\")", "anchor": "twitterindexhtmlorg-twitter-permanent-link", "md_text": "Twitter's [`the-algorithm`](https://github.com/twitter/the-algorithm) repo where they\n[open sourced](https://blog.twitter.com/engineering/en_us/topics/open-source/2023/twitter-recommendation-algorithm)\ntheir recommendation engine uses Pydantic.", "url": "https://docs.pydantic.dev/latest/why/index.html#twitterindexhtmlorg-twitter-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "UK Home Office[Â¶](index.html#org-ukhomeoffice \"Permanent link\")", "anchor": "uk-home-officeindexhtmlorg-ukhomeoffice-permanent-link", "md_text": "*(Based on the criteria described above)*\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/why/index.html#uk-home-officeindexhtmlorg-ukhomeoffice-permanent-link", "page": "why/index.html", "source_site": "pydantic"}
{"title": "Optional dependencies[Â¶](index.html#optional-dependencies \"Permanent link\")", "anchor": "optional-dependenciesindexhtmloptional-dependencies-permanent-link", "md_text": "Pydantic has the following optional dependencies:\n\n* `email`: Email validation provided by the [email-validator](https://pypi.org/project/email-validator/) package.\n* `timezone`: Fallback IANA time zone database provided by the [tzdata](https://pypi.org/project/tzdata/) package.\n\nTo install optional dependencies along with Pydantic:\n\npipuv\n\n```\n# with the `email` extra:\npip install 'pydantic[email]'\n# or with `email` and `timezone` extras:\npip install 'pydantic[email,timezone]'\n\n# with the `email` extra:\nuv add 'pydantic[email]'\n# or with `email` and `timezone` extras:\nuv add 'pydantic[email,timezone]'\n```\n\nOf course, you can also install requirements manually with `pip install email-validator tzdata`.", "url": "https://docs.pydantic.dev/latest/install/index.html#optional-dependenciesindexhtmloptional-dependencies-permanent-link", "page": "install/index.html", "source_site": "pydantic"}
{"title": "Install from repository[Â¶](index.html#install-from-repository \"Permanent link\")", "anchor": "install-from-repositoryindexhtmlinstall-from-repository-permanent-link", "md_text": "And if you prefer to install Pydantic directly from the repository:\n\npipuv\n\n```\npip install 'git+https://github.com/pydantic/pydantic@main'\n# or with `email` and `timezone` extras:\npip install 'git+https://github.com/pydantic/pydantic@main#egg=pydantic[email,timezone]'\n\nuv add 'git+https://github.com/pydantic/pydantic@main'\n# or with `email` and `timezone` extras:\nuv add 'git+https://github.com/pydantic/pydantic@main#egg=pydantic[email,timezone]'\n```\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/install/index.html#install-from-repositoryindexhtmlinstall-from-repository-permanent-link", "page": "install/index.html", "source_site": "pydantic"}
{"title": "Self-referencing (or \"Recursive\") Models[Â¶](index.html#self-referencing-or-recursive-models \"Permanent link\")", "anchor": "self-referencing-or-recursive-modelsindexhtmlself-referencing-or-recursive-models-permanent-link", "md_text": "Models with self-referencing fields are also supported. These annotations will be resolved during model creation.\n\nWithin the model, you can either add the `from __future__ import annotations` import or wrap the annotation\nin a string:\n\n```\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    a: int = 123\n    sibling: 'Optional[Foo]' = None\n\n\nprint(Foo())\n#> a=123 sibling=None\nprint(Foo(sibling={'a': '321'}))\n#> a=123 sibling=Foo(a=321, sibling=None)\n```", "url": "https://docs.pydantic.dev/latest/concepts/forward_annotations/index.html#self-referencing-or-recursive-modelsindexhtmlself-referencing-or-recursive-models-permanent-link", "page": "concepts/forward_annotations/index.html", "source_site": "pydantic"}
{"title": "Cyclic references[Â¶](index.html#cyclic-references \"Permanent link\")", "anchor": "cyclic-referencesindexhtmlcyclic-references-permanent-link", "md_text": "When working with self-referencing recursive models, it is possible that you might encounter cyclic references\nin validation inputs. For example, this can happen when validating ORM instances with back-references from\nattributes.\n\nRather than raising a [`RecursionError`](https://docs.python.org/3/library/exceptions.html#RecursionError) while attempting to validate data with cyclic references, Pydantic is able\nto detect the cyclic reference and raise an appropriate [`ValidationError`](../../api/pydantic_core/index.html#pydantic_core.ValidationError):\n\nPython 3.9 and abovePython 3.10 and above\n\n```\nfrom typing import Optional\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass ModelA(BaseModel):\n    b: 'Optional[ModelB]' = None\n\n\nclass ModelB(BaseModel):\n    a: Optional[ModelA] = None\n\n\ncyclic_data = {}\ncyclic_data['a'] = {'b': cyclic_data}\nprint(cyclic_data)\n#> {'a': {'b': {...}}}\n\ntry:\n    ModelB.model_validate(cyclic_data)\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for ModelB\n    a.b\n      Recursion error - cyclic reference detected [type=recursion_loop, input_value={'a': {'b': {...}}}, input_type=dict]\n    \"\"\"\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass ModelA(BaseModel):\n    b: 'Optional[ModelB]' = None\n\n\nclass ModelB(BaseModel):\n    a: ModelA | None = None\n\n\ncyclic_data = {}\ncyclic_data['a'] = {'b': cyclic_data}\nprint(cyclic_data)\n#> {'a': {'b': {...}}}\n\ntry:\n    ModelB.model_validate(cyclic_data)\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for ModelB\n    a.b\n      Recursion error - cyclic reference detected [type=recursion_loop, input_value={'a': {'b': {...}}}, input_type=dict]\n    \"\"\"\n```\n\nBecause this error is raised without actually exceeding the maximum recursion depth, you can catch and\nhandle the raised [`ValidationError`](../../api/pydantic_core/index.html#pydantic_core.ValidationError) without needing to worry about the limited\nremaining recursion depth:\n\n```\nfrom __future__ import annotations\n\nfrom collections.abc import Generator\nfrom contextlib import contextmanager\nfrom dataclasses import field\n\nfrom pydantic import BaseModel, ValidationError, field_validator\n\n\ndef is_recursion_validation_error(exc: ValidationError) -> bool:\n    errors = exc.errors()\n    return len(errors) == 1 and errors[0]['type'] == 'recursion_loop'\n\n\n@contextmanager\ndef suppress_recursion_validation_error() -> Generator[None]:\n    try:\n        yield\n    except ValidationError as exc:\n        if not is_recursion_validation_error(exc):\n            raise exc\n\n\nclass Node(BaseModel):\n    id: int\n    children: list[Node] = field(default_factory=list)\n\n    @field_validator('children', mode='wrap')\n    @classmethod\n    def drop_cyclic_references(cls, children, h):\n        try:\n            return h(children)\n        except ValidationError as exc:\n            if not (\n                is_recursion_validation_error(exc)\n                and isinstance(children, list)\n            ):\n                raise exc\n\n            value_without_cyclic_refs = []\n            for child in children:\n                with suppress_recursion_validation_error():\n                    value_without_cyclic_refs.extend(h([child]))\n            return h(value_without_cyclic_refs)\n\n\n# Create data with cyclic references representing the graph 1 -> 2 -> 3 -> 1\nnode_data = {'id': 1, 'children': [{'id': 2, 'children': [{'id': 3}]}]}\nnode_data['children'][0]['children'][0]['children'] = [node_data]\n\nprint(Node.model_validate(node_data))\n#> id=1 children=[Node(id=2, children=[Node(id=3, children=[])])]\n```\n\nSimilarly, if Pydantic encounters a recursive reference during *serialization*, rather than waiting\nfor the maximum recursion depth to be exceeded, a [`ValueError`](https://docs.python.org/3/library/exceptions.html#ValueError) is raised immediately:\n\n```\nfrom pydantic import TypeAdapter\n\n# Create data with cyclic references representing the graph 1 -> 2 -> 3 -> 1\nnode_data = {'id': 1, 'children': [{'id': 2, 'children': [{'id': 3}]}]}\nnode_data['children'][0]['children'][0]['children'] = [node_data]\n\ntry:\n    # Try serializing the circular reference as JSON\n    TypeAdapter(dict).dump_json(node_data)\nexcept ValueError as exc:\n    print(exc)\n    \"\"\"\n    Error serializing to JSON: ValueError: Circular reference detected (id repeated)\n    \"\"\"\n```\n\nThis can also be handled if desired:\n\n```\nfrom dataclasses import field\nfrom typing import Any\n\nfrom pydantic import (\n    SerializerFunctionWrapHandler,\n    TypeAdapter,\n    field_serializer,\n)\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass NodeReference:\n    id: int\n\n\n@dataclass\nclass Node(NodeReference):\n    children: list['Node'] = field(default_factory=list)\n\n    @field_serializer('children', mode='wrap')\n    def serialize(\n        self, children: list['Node'], handler: SerializerFunctionWrapHandler\n    ) -> Any:\n        \"\"\"\n        Serialize a list of nodes, handling circular references by excluding the children.\n        \"\"\"\n        try:\n            return handler(children)\n        except ValueError as exc:\n            if not str(exc).startswith('Circular reference'):\n                raise exc", "url": "https://docs.pydantic.dev/latest/concepts/forward_annotations/index.html#cyclic-referencesindexhtmlcyclic-references-permanent-link", "page": "concepts/forward_annotations/index.html", "source_site": "pydantic"}
{"title": "Cyclic references[Â¶](index.html#cyclic-references \"Permanent link\")", "anchor": "cyclic-referencesindexhtmlcyclic-references-permanent-link", "md_text": "            result = []\n            for node in children:\n                try:\n                    serialized = handler([node])\n                except ValueError as exc:\n                    if not str(exc).startswith('Circular reference'):\n                        raise exc\n                    result.append({'id': node.id})\n                else:\n                    result.append(serialized)\n            return result\n\n\n# Create a cyclic graph:\nnodes = [Node(id=1), Node(id=2), Node(id=3)]\nnodes[0].children.append(nodes[1])\nnodes[1].children.append(nodes[2])\nnodes[2].children.append(nodes[0])\n\nprint(nodes[0])\n#> Node(id=1, children=[Node(id=2, children=[Node(id=3, children=[...])])])\n\n# Serialize the cyclic graph:\nprint(TypeAdapter(Node).dump_python(nodes[0]))\n\"\"\"\n{\n    'id': 1,\n    'children': [{'id': 2, 'children': [{'id': 3, 'children': [{'id': 1}]}]}],\n}\n\"\"\"\n```\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/concepts/forward_annotations/index.html#cyclic-referencesindexhtmlcyclic-references-permanent-link", "page": "concepts/forward_annotations/index.html", "source_site": "pydantic"}
{"title": "TL;DR", "anchor": "tldr", "md_text": "We use the term \"validation\" to refer to the process of instantiating a model (or other type) that adheres to specified types and\nconstraints. This task, which Pydantic is well known for, is most widely recognized as \"validation\" in colloquial terms,\neven though in other contexts the term \"validation\" may be more restrictive.\n\n---", "url": "https://docs.pydantic.dev/latest/concepts/models/index.html#tldr", "page": "concepts/models/index.html", "source_site": "pydantic"}
{"title": "The long version", "anchor": "the-long-version", "md_text": "The potential confusion around the term \"validation\" arises from the fact that, strictly speaking, Pydantic's\nprimary focus doesn't align precisely with the dictionary definition of \"validation\":\n\n> ### validation\n>\n> *noun*\n> the action of checking or proving the validity or accuracy of something.\n\nIn Pydantic, the term \"validation\" refers to the process of instantiating a model (or other type) that adheres to specified\ntypes and constraints. Pydantic guarantees the types and constraints of the output, not the input data.\nThis distinction becomes apparent when considering that Pydantic's `ValidationError` is raised\nwhen data cannot be successfully parsed into a model instance.\n\nWhile this distinction may initially seem subtle, it holds practical significance.\nIn some cases, \"validation\" goes beyond just model creation, and can include the copying and coercion of data.\nThis can involve copying arguments passed to the constructor in order to perform coercion to a new type\nwithout mutating the original input data. For a more in-depth understanding of the implications for your usage,\nrefer to the [Data Conversion](index.html#data-conversion) and [Attribute Copies](index.html#attribute-copies) sections below.\n\nIn essence, Pydantic's primary goal is to assure that the resulting structure post-processing (termed \"validation\")\nprecisely conforms to the applied type hints. Given the widespread adoption of \"validation\" as the colloquial term\nfor this process, we will consistently use it in our documentation.\n\nWhile the terms \"parse\" and \"validation\" were previously used interchangeably, moving forward, we aim to exclusively employ \"validate\",\nwith \"parse\" reserved specifically for discussions related to [JSON parsing](../json/index.html).", "url": "https://docs.pydantic.dev/latest/concepts/models/index.html#the-long-version", "page": "concepts/models/index.html", "source_site": "pydantic"}
{"title": "Basic model usage[Â¶](index.html#basic-model-usage \"Permanent link\")", "anchor": "basic-model-usageindexhtmlbasic-model-usage-permanent-link", "md_text": "Pydantic relies heavily on the existing Python typing constructs to define models. If you are not familiar with those, the following resources\ncan be useful:\n\n* The [Type System Guides](https://typing.readthedocs.io/en/latest/guides/index.html)\n* The [mypy documentation](https://mypy.readthedocs.io/en/latest/)\n\n```\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass User(BaseModel):\n    id: int\n    name: str = 'Jane Doe'\n\n    model_config = ConfigDict(str_max_length=10)  # (1)!\n```\n\n1. Pydantic models support a variety of [configuration values](../config/index.html)\n   (see [here](../../api/config/index.html#pydantic.config.ConfigDict) for the available configuration values).\n\nIn this example, `User` is a model with two fields:\n\n* `id`, which is an integer (defined using the [`int`](https://docs.python.org/3/library/functions.html#int) type) and is required\n* `name`, which is a string (defined using the [`str`](https://docs.python.org/3/library/stdtypes.html#str) type) and is not required (it has a default value).\n\nThe documentation on [types](../types/index.html) expands on the supported types.\n\nFields can be customized in a number of ways using the [`Field()`](../../api/fields/index.html#pydantic.fields.Field) function.\nSee the [documentation on fields](../fields/index.html) for more information.\n\nThe model can then be instantiated:\n\n```\nuser = User(id='123')\n```\n\n`user` is an instance of `User`. Initialization of the object will perform all parsing and validation.\nIf no [`ValidationError`](../../api/pydantic_core/index.html#pydantic_core.ValidationError) exception is raised,\nyou know the resulting model instance is valid.\n\nFields of a model can be accessed as normal attributes of the `user` object:\n\n```\nassert user.name == 'Jane Doe'  # (1)!\nassert user.id == 123  # (2)!\nassert isinstance(user.id, int)\n```\n\n1. `name` wasn't set when `user` was initialized, so the default value was used.\n   The [`model_fields_set`](../../api/base_model/index.html#pydantic.BaseModel.model_fields_set) attribute can be\n   inspected to check the field names explicitly set during instantiation.\n2. Note that the string `'123'` was coerced to an integer and its value is `123`.\n   More details on Pydantic's coercion logic can be found in the [data conversion](index.html#data-conversion) section.\n\nThe model instance can be serialized using the [`model_dump()`](../../api/base_model/index.html#pydantic.BaseModel.model_dump) method:\n\n```\nassert user.model_dump() == {'id': 123, 'name': 'Jane Doe'}\n```\n\nCalling [dict](https://docs.python.org/3/reference/expressions.html#dict) on the instance will also provide a dictionary, but nested fields will not be\nrecursively converted into dictionaries. [`model_dump()`](../../api/base_model/index.html#pydantic.BaseModel.model_dump) also\nprovides numerous arguments to customize the serialization result.\n\nBy default, models are mutable and field values can be changed through attribute assignment:\n\n```\nuser.id = 321\nassert user.id == 321\n```\n\nWhen defining your models, watch out for naming collisions between your field name and its type annotation.\n\nFor example, the following will not behave as expected and would yield a validation error:\n\n```\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Boo(BaseModel):\n    int: Optional[int] = None\n\n\nm = Boo(int=123)  # Will fail to validate.\n```\n\nBecause of how Python evaluates [annotated assignment statements](https://docs.python.org/3/reference/simple_stmts.html#annassign), the statement is equivalent to `int: None = None`, thus\nleading to a validation error.", "url": "https://docs.pydantic.dev/latest/concepts/models/index.html#basic-model-usageindexhtmlbasic-model-usage-permanent-link", "page": "concepts/models/index.html", "source_site": "pydantic"}
{"title": "Model methods and properties[Â¶](index.html#model-methods-and-properties \"Permanent link\")", "anchor": "model-methods-and-propertiesindexhtmlmodel-methods-and-properties-permanent-link", "md_text": "The example above only shows the tip of the iceberg of what models can do.\nModels possess the following methods and attributes:\n\n* [`model_validate()`](../../api/base_model/index.html#pydantic.BaseModel.model_validate): Validates the given object against the Pydantic model. See [Validating data](index.html#validating-data).\n* [`model_validate_json()`](../../api/base_model/index.html#pydantic.BaseModel.model_validate_json): Validates the given JSON data against the Pydantic model. See\n  [Validating data](index.html#validating-data).\n* [`model_construct()`](../../api/base_model/index.html#pydantic.BaseModel.model_construct): Creates models without running validation. See\n  [Creating models without validation](index.html#creating-models-without-validation).\n* [`model_dump()`](../../api/base_model/index.html#pydantic.BaseModel.model_dump): Returns a dictionary of the model's fields and values. See\n  [Serialization](../serialization/index.html#python-mode).\n* [`model_dump_json()`](../../api/base_model/index.html#pydantic.BaseModel.model_dump_json): Returns a JSON string representation of [`model_dump()`](../../api/base_model/index.html#pydantic.BaseModel.model_dump). See [Serialization](../serialization/index.html#json-mode).\n* [`model_copy()`](../../api/base_model/index.html#pydantic.BaseModel.model_copy): Returns a copy (by default, shallow copy) of the model. See\n  [Model copy](index.html#model-copy).\n* [`model_json_schema()`](../../api/base_model/index.html#pydantic.BaseModel.model_json_schema): Returns a jsonable dictionary representing the model's JSON Schema. See [JSON Schema](../json_schema/index.html).\n* [`model_fields`](../../api/base_model/index.html#pydantic.BaseModel.model_fields): A mapping between field names and their definitions ([`FieldInfo`](../../api/fields/index.html#pydantic.fields.FieldInfo) instances).\n* [`model_computed_fields`](../../api/base_model/index.html#pydantic.BaseModel.model_computed_fields): A mapping between computed field names and their definitions ([`ComputedFieldInfo`](../../api/fields/index.html#pydantic.fields.ComputedFieldInfo) instances).\n* [`model_extra`](../../api/base_model/index.html#pydantic.BaseModel.model_extra): The extra fields set during validation.\n* [`model_fields_set`](../../api/base_model/index.html#pydantic.BaseModel.model_fields_set): The set of fields which were explicitly provided when the model was initialized.\n* [`model_parametrized_name()`](../../api/base_model/index.html#pydantic.BaseModel.model_parametrized_name): Computes the class name for parametrizations of generic classes.\n* [`model_post_init()`](../../api/base_model/index.html#pydantic.BaseModel.model_post_init): Performs additional actions after the model is instantiated and all field validators are applied.\n* [`model_rebuild()`](../../api/base_model/index.html#pydantic.BaseModel.model_rebuild): Rebuilds the model schema, which also supports building recursive generic models.\n  See [Rebuilding model schema](index.html#rebuilding-model-schema).\n\nSee the API documentation of [`BaseModel`](../../api/base_model/index.html#pydantic.BaseModel) for the class definition including a full list of methods and attributes.\n\nSee [Changes to `pydantic.BaseModel`](../../migration/index.html#changes-to-pydanticbasemodel) in the\n[Migration Guide](../../migration/index.html) for details on changes from Pydantic V1.", "url": "https://docs.pydantic.dev/latest/concepts/models/index.html#model-methods-and-propertiesindexhtmlmodel-methods-and-properties-permanent-link", "page": "concepts/models/index.html", "source_site": "pydantic"}
{"title": "Data conversion[Â¶](index.html#data-conversion \"Permanent link\")", "anchor": "data-conversionindexhtmldata-conversion-permanent-link", "md_text": "Pydantic may cast input data to force it to conform to model field types,\nand in some cases this may result in a loss of information.\nFor example:\n\n```\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    a: int\n    b: float\n    c: str\n\n\nprint(Model(a=3.000, b='2.72', c=b'binary data').model_dump())\n#> {'a': 3, 'b': 2.72, 'c': 'binary data'}\n```\n\nThis is a deliberate decision of Pydantic, and is frequently the most useful approach. See\n[this issue](https://github.com/pydantic/pydantic/issues/578) for a longer discussion on the subject.\n\nNevertheless, Pydantic provides a [strict mode](../strict_mode/index.html), where no data conversion is performed.\nValues must be of the same type as the declared field type.\n\nThis is also the case for collections. In most cases, you shouldn't make use of abstract container classes\nand just use a concrete type, such as [`list`](https://docs.python.org/3/glossary.html#term-list):\n\n```\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    items: list[int]  # (1)!\n\n\nprint(Model(items=(1, 2, 3)))\n#> items=[1, 2, 3]\n```\n\n1. In this case, you might be tempted to use the abstract [`Sequence`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence) type\n   to allow both lists and tuples. But Pydantic takes care of converting the tuple input to a list, so\n   in most cases this isn't necessary.\n\nBesides, using these abstract types can also lead to [poor validation performance](../performance/index.html#sequence-vs-list-or-tuple-with-mapping-vs-dict), and in general using concrete container types\nwill avoid unnecessary checks.", "url": "https://docs.pydantic.dev/latest/concepts/models/index.html#data-conversionindexhtmldata-conversion-permanent-link", "page": "concepts/models/index.html", "source_site": "pydantic"}
{"title": "Extra data[Â¶](index.html#extra-data \"Permanent link\")", "anchor": "extra-dataindexhtmlextra-data-permanent-link", "md_text": "By default, Pydantic models **won't error when you provide extra data**, and these values will simply be ignored:\n\n```\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    x: int\n\n\nm = Model(x=1, y='a')\nassert m.model_dump() == {'x': 1}\n```\n\nThe [`extra`](../../api/config/index.html#pydantic.config.ConfigDict.extra) configuration value can be used to control this behavior:\n\n```\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass Model(BaseModel):\n    x: int\n\n    model_config = ConfigDict(extra='allow')\n\n\nm = Model(x=1, y='a')  # (1)!\nassert m.model_dump() == {'x': 1, 'y': 'a'}\nassert m.__pydantic_extra__ == {'y': 'a'}\n```\n\n1. If [`extra`](../../api/config/index.html#pydantic.config.ConfigDict.extra) was set to `'forbid'`, this would fail.\n\nThe configuration can take three values:\n\n* `'ignore'`: Providing extra data is ignored (the default).\n* `'forbid'`: Providing extra data is not permitted.\n* `'allow'`: Providing extra data is allowed and stored in the `__pydantic_extra__` dictionary attribute.\n  The `__pydantic_extra__` can explicitly be annotated to provide validation for extra fields.\n\nThe validation methods (e.g. [`model_validate()`](../../api/base_model/index.html#pydantic.BaseModel.model_validate)) have an optional `extra` argument\nthat will override the `extra` configuration value of the model for that validation call.\n\nFor more details, refer to the [`extra`](../../api/config/index.html#pydantic.config.ConfigDict.extra) API documentation.\n\nPydantic dataclasses also support extra data (see the [dataclass configuration](../dataclasses/index.html#dataclass-config) section).", "url": "https://docs.pydantic.dev/latest/concepts/models/index.html#extra-dataindexhtmlextra-data-permanent-link", "page": "concepts/models/index.html", "source_site": "pydantic"}
{"title": "Nested models[Â¶](index.html#nested-models \"Permanent link\")", "anchor": "nested-modelsindexhtmlnested-models-permanent-link", "md_text": "More complex hierarchical data structures can be defined using models themselves as types in annotations.\n\nPython 3.9 and abovePython 3.10 and above\n\n```\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    count: int\n    size: Optional[float] = None\n\n\nclass Bar(BaseModel):\n    apple: str = 'x'\n    banana: str = 'y'\n\n\nclass Spam(BaseModel):\n    foo: Foo\n    bars: list[Bar]\n\n\nm = Spam(foo={'count': 4}, bars=[{'apple': 'x1'}, {'apple': 'x2'}])\nprint(m)\n\"\"\"\nfoo=Foo(count=4, size=None) bars=[Bar(apple='x1', banana='y'), Bar(apple='x2', banana='y')]\n\"\"\"\nprint(m.model_dump())\n\"\"\"\n{\n    'foo': {'count': 4, 'size': None},\n    'bars': [{'apple': 'x1', 'banana': 'y'}, {'apple': 'x2', 'banana': 'y'}],\n}\n\"\"\"\n\nfrom pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    count: int\n    size: float | None = None\n\n\nclass Bar(BaseModel):\n    apple: str = 'x'\n    banana: str = 'y'\n\n\nclass Spam(BaseModel):\n    foo: Foo\n    bars: list[Bar]\n\n\nm = Spam(foo={'count': 4}, bars=[{'apple': 'x1'}, {'apple': 'x2'}])\nprint(m)\n\"\"\"\nfoo=Foo(count=4, size=None) bars=[Bar(apple='x1', banana='y'), Bar(apple='x2', banana='y')]\n\"\"\"\nprint(m.model_dump())\n\"\"\"\n{\n    'foo': {'count': 4, 'size': None},\n    'bars': [{'apple': 'x1', 'banana': 'y'}, {'apple': 'x2', 'banana': 'y'}],\n}\n\"\"\"\n```\n\nSelf-referencing models are supported. For more details, see the documentation related to\n[forward annotations](../forward_annotations/index.html#self-referencing-or-recursive-models).", "url": "https://docs.pydantic.dev/latest/concepts/models/index.html#nested-modelsindexhtmlnested-models-permanent-link", "page": "concepts/models/index.html", "source_site": "pydantic"}
{"title": "Rebuilding model schema[Â¶](index.html#rebuilding-model-schema \"Permanent link\")", "anchor": "rebuilding-model-schemaindexhtmlrebuilding-model-schema-permanent-link", "md_text": "When you define a model class in your code, Pydantic will analyze the body of the class to collect a variety of information\nrequired to perform validation and serialization, gathered in a core schema. Notably, the model's type annotations are evaluated to\nunderstand the valid types for each field (more information can be found in the [Architecture](../../internals/architecture/index.html) documentation).\nHowever, it might be the case that annotations refer to symbols not defined when the model class is being created.\nTo circumvent this issue, the [`model_rebuild()`](../../api/base_model/index.html#pydantic.BaseModel.model_rebuild) method can be used:\n\n```\nfrom pydantic import BaseModel, PydanticUserError\n\n\nclass Foo(BaseModel):\n    x: 'Bar'  # (1)!\n\n\ntry:\n    Foo.model_json_schema()\nexcept PydanticUserError as e:\n    print(e)\n    \"\"\"\n    `Foo` is not fully defined; you should define `Bar`, then call `Foo.model_rebuild()`.\n\n    For further information visit https://errors.pydantic.dev/2/u/class-not-fully-defined\n    \"\"\"\n\n\nclass Bar(BaseModel):\n    pass\n\n\nFoo.model_rebuild()\nprint(Foo.model_json_schema())\n\"\"\"\n{\n    '$defs': {'Bar': {'properties': {}, 'title': 'Bar', 'type': 'object'}},\n    'properties': {'x': {'$ref': '#/$defs/Bar'}},\n    'required': ['x'],\n    'title': 'Foo',\n    'type': 'object',\n}\n\"\"\"\n```\n\n1. `Bar` is not yet defined when the `Foo` class is being created. For this reason,\n   a [forward annotation](../forward_annotations/index.html) is being used.\n\nPydantic tries to determine when this is necessary automatically and error if it wasn't done, but you may want to\ncall [`model_rebuild()`](../../api/base_model/index.html#pydantic.BaseModel.model_rebuild) proactively when dealing with recursive models or generics.\n\nIn V2, [`model_rebuild()`](../../api/base_model/index.html#pydantic.BaseModel.model_rebuild) replaced `update_forward_refs()` from V1. There are some slight differences with the new behavior.\nThe biggest change is that when calling [`model_rebuild()`](../../api/base_model/index.html#pydantic.BaseModel.model_rebuild) on the outermost model, it builds a core schema used for validation of the\nwhole model (nested models and all), so all types at all levels need to be ready before [`model_rebuild()`](../../api/base_model/index.html#pydantic.BaseModel.model_rebuild) is called.", "url": "https://docs.pydantic.dev/latest/concepts/models/index.html#rebuilding-model-schemaindexhtmlrebuilding-model-schema-permanent-link", "page": "concepts/models/index.html", "source_site": "pydantic"}
{"title": "Arbitrary class instances[Â¶](index.html#arbitrary-class-instances \"Permanent link\")", "anchor": "arbitrary-class-instancesindexhtmlarbitrary-class-instances-permanent-link", "md_text": "(Formerly known as \"ORM Mode\"/`from_orm`).\n\nPydantic models can also be created from arbitrary class instances by reading the instance attributes corresponding\nto the model field names. One common application of this functionality is integration with object-relational mappings\n(ORMs).\n\nTo do this, set the [`from_attributes`](../../api/config/index.html#pydantic.config.ConfigDict.from_attributes) config value to `True`\n(see the documentation on [Configuration](../config/index.html) for more details).\n\nThe example here uses [SQLAlchemy](https://www.sqlalchemy.org/), but the same approach should work for any ORM.\n\n```\nfrom typing import Annotated\n\nfrom sqlalchemy import ARRAY, String\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\n\nfrom pydantic import BaseModel, ConfigDict, StringConstraints\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass CompanyOrm(Base):\n    __tablename__ = 'companies'\n\n    id: Mapped[int] = mapped_column(primary_key=True, nullable=False)\n    public_key: Mapped[str] = mapped_column(\n        String(20), index=True, nullable=False, unique=True\n    )\n    domains: Mapped[list[str]] = mapped_column(ARRAY(String(255)))\n\n\nclass CompanyModel(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n\n    id: int\n    public_key: Annotated[str, StringConstraints(max_length=20)]\n    domains: list[Annotated[str, StringConstraints(max_length=255)]]\n\n\nco_orm = CompanyOrm(\n    id=123,\n    public_key='foobar',\n    domains=['example.com', 'foobar.com'],\n)\nprint(co_orm)\n#> <__main__.CompanyOrm object at 0x0123456789ab>\nco_model = CompanyModel.model_validate(co_orm)\nprint(co_model)\n#> id=123 public_key='foobar' domains=['example.com', 'foobar.com']\n```", "url": "https://docs.pydantic.dev/latest/concepts/models/index.html#arbitrary-class-instancesindexhtmlarbitrary-class-instances-permanent-link", "page": "concepts/models/index.html", "source_site": "pydantic"}
{"title": "Nested attributes[Â¶](index.html#nested-attributes \"Permanent link\")", "anchor": "nested-attributesindexhtmlnested-attributes-permanent-link", "md_text": "When using attributes to parse models, model instances will be created from both top-level attributes and\ndeeper-nested attributes as appropriate.\n\nHere is an example demonstrating the principle:\n\n```\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass PetCls:\n    def __init__(self, *, name: str, species: str):\n        self.name = name\n        self.species = species\n\n\nclass PersonCls:\n    def __init__(self, *, name: str, age: float = None, pets: list[PetCls]):\n        self.name = name\n        self.age = age\n        self.pets = pets\n\n\nclass Pet(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n\n    name: str\n    species: str\n\n\nclass Person(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n\n    name: str\n    age: float = None\n    pets: list[Pet]\n\n\nbones = PetCls(name='Bones', species='dog')\norion = PetCls(name='Orion', species='cat')\nanna = PersonCls(name='Anna', age=20, pets=[bones, orion])\nanna_model = Person.model_validate(anna)\nprint(anna_model)\n\"\"\"\nname='Anna' age=20.0 pets=[Pet(name='Bones', species='dog'), Pet(name='Orion', species='cat')]\n\"\"\"\n```", "url": "https://docs.pydantic.dev/latest/concepts/models/index.html#nested-attributesindexhtmlnested-attributes-permanent-link", "page": "concepts/models/index.html", "source_site": "pydantic"}
{"title": "Error handling[Â¶](index.html#error-handling \"Permanent link\")", "anchor": "error-handlingindexhtmlerror-handling-permanent-link", "md_text": "Pydantic will raise a [`ValidationError`](../../api/pydantic_core/index.html#pydantic_core.ValidationError) exception whenever it finds an error in the data it's validating.\n\nA single exception will be raised regardless of the number of errors found, and that validation error\nwill contain information about all of the errors and how they happened.\n\nSee [Error Handling](../../errors/errors/index.html) for details on standard and custom errors.\n\nAs a demonstration:\n\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    list_of_ints: list[int]\n    a_float: float\n\n\ndata = dict(\n    list_of_ints=['1', 2, 'bad'],\n    a_float='not a float',\n)\n\ntry:\n    Model(**data)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for Model\n    list_of_ints.2\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='bad', input_type=str]\n    a_float\n      Input should be a valid number, unable to parse string as a number [type=float_parsing, input_value='not a float', input_type=str]\n    \"\"\"\n```", "url": "https://docs.pydantic.dev/latest/concepts/models/index.html#error-handlingindexhtmlerror-handling-permanent-link", "page": "concepts/models/index.html", "source_site": "pydantic"}
{"title": "Validating data[Â¶](index.html#validating-data \"Permanent link\")", "anchor": "validating-dataindexhtmlvalidating-data-permanent-link", "md_text": "Pydantic provides three methods on models classes for parsing data:\n\n* [`model_validate()`](../../api/base_model/index.html#pydantic.BaseModel.model_validate): this is very similar to the `__init__` method of the model,\n  except it takes a dictionary or an object rather than keyword arguments. If the object passed cannot be validated,\n  or if it's not a dictionary or instance of the model in question, a [`ValidationError`](../../api/pydantic_core/index.html#pydantic_core.ValidationError) will be raised.\n* [`model_validate_json()`](../../api/base_model/index.html#pydantic.BaseModel.model_validate_json): this validates the provided data as a JSON string or `bytes` object.\n  If your incoming data is a JSON payload, this is generally considered faster (instead of manually parsing the data as a dictionary).\n  Learn more about JSON parsing in the [JSON](../json/index.html) section of the docs.\n* [`model_validate_strings()`](../../api/base_model/index.html#pydantic.BaseModel.model_validate_strings): this takes a dictionary (can be nested) with string keys and values and validates the data in JSON mode so that said strings can be coerced into the correct types.\n\nPython 3.9 and abovePython 3.10 and above\n\n```\nfrom datetime import datetime\nfrom typing import Optional\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass User(BaseModel):\n    id: int\n    name: str = 'John Doe'\n    signup_ts: Optional[datetime] = None\n\n\nm = User.model_validate({'id': 123, 'name': 'James'})\nprint(m)\n#> id=123 name='James' signup_ts=None\n\ntry:\n    User.model_validate(['not', 'a', 'dict'])\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n      Input should be a valid dictionary or instance of User [type=model_type, input_value=['not', 'a', 'dict'], input_type=list]\n    \"\"\"\n\nm = User.model_validate_json('{\"id\": 123, \"name\": \"James\"}')\nprint(m)\n#> id=123 name='James' signup_ts=None\n\ntry:\n    m = User.model_validate_json('{\"id\": 123, \"name\": 123}')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n    name\n      Input should be a valid string [type=string_type, input_value=123, input_type=int]\n    \"\"\"\n\ntry:\n    m = User.model_validate_json('invalid JSON')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n      Invalid JSON: expected value at line 1 column 1 [type=json_invalid, input_value='invalid JSON', input_type=str]\n    \"\"\"\n\nm = User.model_validate_strings({'id': '123', 'name': 'James'})\nprint(m)\n#> id=123 name='James' signup_ts=None\n\nm = User.model_validate_strings(\n    {'id': '123', 'name': 'James', 'signup_ts': '2024-04-01T12:00:00'}\n)\nprint(m)\n#> id=123 name='James' signup_ts=datetime.datetime(2024, 4, 1, 12, 0)\n\ntry:\n    m = User.model_validate_strings(\n        {'id': '123', 'name': 'James', 'signup_ts': '2024-04-01'}, strict=True\n    )\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n    signup_ts\n      Input should be a valid datetime, invalid datetime separator, expected `T`, `t`, `_` or space [type=datetime_parsing, input_value='2024-04-01', input_type=str]\n    \"\"\"\n\nfrom datetime import datetime\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass User(BaseModel):\n    id: int\n    name: str = 'John Doe'\n    signup_ts: datetime | None = None\n\n\nm = User.model_validate({'id': 123, 'name': 'James'})\nprint(m)\n#> id=123 name='James' signup_ts=None\n\ntry:\n    User.model_validate(['not', 'a', 'dict'])\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n      Input should be a valid dictionary or instance of User [type=model_type, input_value=['not', 'a', 'dict'], input_type=list]\n    \"\"\"\n\nm = User.model_validate_json('{\"id\": 123, \"name\": \"James\"}')\nprint(m)\n#> id=123 name='James' signup_ts=None\n\ntry:\n    m = User.model_validate_json('{\"id\": 123, \"name\": 123}')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n    name\n      Input should be a valid string [type=string_type, input_value=123, input_type=int]\n    \"\"\"\n\ntry:\n    m = User.model_validate_json('invalid JSON')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n      Invalid JSON: expected value at line 1 column 1 [type=json_invalid, input_value='invalid JSON', input_type=str]\n    \"\"\"\n\nm = User.model_validate_strings({'id': '123', 'name': 'James'})\nprint(m)\n#> id=123 name='James' signup_ts=None", "url": "https://docs.pydantic.dev/latest/concepts/models/index.html#validating-dataindexhtmlvalidating-data-permanent-link", "page": "concepts/models/index.html", "source_site": "pydantic"}
{"title": "Validating data[Â¶](index.html#validating-data \"Permanent link\")", "anchor": "validating-dataindexhtmlvalidating-data-permanent-link", "md_text": "m = User.model_validate_strings(\n    {'id': '123', 'name': 'James', 'signup_ts': '2024-04-01T12:00:00'}\n)\nprint(m)\n#> id=123 name='James' signup_ts=datetime.datetime(2024, 4, 1, 12, 0)\n\ntry:\n    m = User.model_validate_strings(\n        {'id': '123', 'name': 'James', 'signup_ts': '2024-04-01'}, strict=True\n    )\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n    signup_ts\n      Input should be a valid datetime, invalid datetime separator, expected `T`, `t`, `_` or space [type=datetime_parsing, input_value='2024-04-01', input_type=str]\n    \"\"\"\n```\n\nIf you want to validate serialized data in a format other than JSON, you should load the data into a dictionary yourself and\nthen pass it to [`model_validate`](../../api/base_model/index.html#pydantic.BaseModel.model_validate).\n\nDepending on the types and model configs involved, [`model_validate`](../../api/base_model/index.html#pydantic.BaseModel.model_validate)\nand [`model_validate_json`](../../api/base_model/index.html#pydantic.BaseModel.model_validate_json) may have different validation behavior.\nIf you have data coming from a non-JSON source, but want the same validation\nbehavior and errors you'd get from [`model_validate_json`](../../api/base_model/index.html#pydantic.BaseModel.model_validate_json),\nour recommendation for now is to use either use `model_validate_json(json.dumps(data))`, or use [`model_validate_strings`](../../api/base_model/index.html#pydantic.BaseModel.model_validate_strings) if the data takes the form of a (potentially nested) dictionary with string keys and values.\n\nIf you're passing in an instance of a model to [`model_validate`](../../api/base_model/index.html#pydantic.BaseModel.model_validate), you will want to consider setting\n[`revalidate_instances`](../../api/config/index.html#pydantic.config.ConfigDict.revalidate_instances) in the model's config.\nIf you don't set this value, then validation will be skipped on model instances. See the below example:\n\n![âŒ](https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.1.0/assets/svg/274c.svg \":x:\") `revalidate_instances='never'`![âœ…](https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.1.0/assets/svg/2705.svg \":white_check_mark:\") `revalidate_instances='always'`\n\n```\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    a: int\n\n\nm = Model(a=0)\n# note: setting `validate_assignment` to `True` in the config can prevent this kind of misbehavior.\nm.a = 'not an int'\n\n# doesn't raise a validation error even though m is invalid\nm2 = Model.model_validate(m)\n\nfrom pydantic import BaseModel, ConfigDict, ValidationError\n\n\nclass Model(BaseModel):\n    a: int\n\n    model_config = ConfigDict(revalidate_instances='always')\n\n\nm = Model(a=0)\n# note: setting `validate_assignment` to `True` in the config can prevent this kind of misbehavior.\nm.a = 'not an int'\n\ntry:\n    m2 = Model.model_validate(m)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    a\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='not an int', input_type=str]\n    \"\"\"\n```", "url": "https://docs.pydantic.dev/latest/concepts/models/index.html#validating-dataindexhtmlvalidating-data-permanent-link", "page": "concepts/models/index.html", "source_site": "pydantic"}
{"title": "Creating models without validation[Â¶](index.html#creating-models-without-validation \"Permanent link\")", "anchor": "creating-models-without-validationindexhtmlcreating-models-without-validation-permanent-link", "md_text": "Pydantic also provides the [`model_construct()`](../../api/base_model/index.html#pydantic.BaseModel.model_construct) method, which allows models to be created **without validation**.\nThis can be useful in at least a few cases:\n\n* when working with complex data that is already known to be valid (for performance reasons)\n* when one or more of the validator functions are non-idempotent\n* when one or more of the validator functions have side effects that you don't want to be triggered.\n\n[`model_construct()`](../../api/base_model/index.html#pydantic.BaseModel.model_construct) does not do any validation, meaning it can create\nmodels which are invalid. **You should only ever use the [`model_construct()`](../../api/base_model/index.html#pydantic.BaseModel.model_construct)\nmethod with data which has already been validated, or that you definitely trust.**\n\nIn Pydantic V2, the performance gap between validation (either with direct instantiation or the `model_validate*` methods)\nand [`model_construct()`](../../api/base_model/index.html#pydantic.BaseModel.model_construct) has been narrowed\nconsiderably. For simple models, going with validation may even be faster. If you are using [`model_construct()`](../../api/base_model/index.html#pydantic.BaseModel.model_construct)\nfor performance reasons, you may want to profile your use case before assuming it is actually faster.\n\nNote that for [root models](index.html#rootmodel-and-custom-root-types), the root value can be passed to\n[`model_construct()`](../../api/base_model/index.html#pydantic.BaseModel.model_construct) positionally, instead of using a keyword argument.\n\nHere are some additional notes on the behavior of [`model_construct()`](../../api/base_model/index.html#pydantic.BaseModel.model_construct):\n\n* When we say \"no validation is performed\" â€” this includes converting dictionaries to model instances. So if you have a field\n  referring to a model type, you will need to convert the inner dictionary to a model yourself.\n* If you do not pass keyword arguments for fields with defaults, the default values will still be used.\n* For models with private attributes, the `__pydantic_private__` dictionary will be populated the same as it would be when\n  creating the model with validation.\n* No `__init__` method from the model or any of its parent classes will be called, even when a custom `__init__` method is defined.\n\n* For models with [`extra`](../../api/config/index.html#pydantic.config.ConfigDict.extra) set to `'allow'`, data not corresponding to fields will be correctly stored in\n  the `__pydantic_extra__` dictionary and saved to the model's `__dict__` attribute.\n* For models with [`extra`](../../api/config/index.html#pydantic.config.ConfigDict.extra) set to `'ignore'`, data not corresponding to fields will be ignored â€” that is,\n  not stored in `__pydantic_extra__` or `__dict__` on the instance.\n* Unlike when instantiating the model with validation, a call to [`model_construct()`](../../api/base_model/index.html#pydantic.BaseModel.model_construct) with [`extra`](../../api/config/index.html#pydantic.config.ConfigDict.extra) set to `'forbid'` doesn't raise an error in the presence of data not corresponding to fields. Rather, said input data is simply ignored.", "url": "https://docs.pydantic.dev/latest/concepts/models/index.html#creating-models-without-validationindexhtmlcreating-models-without-validation-permanent-link", "page": "concepts/models/index.html", "source_site": "pydantic"}
{"title": "Model copy[Â¶](index.html#model-copy \"Permanent link\")", "anchor": "model-copyindexhtmlmodel-copy-permanent-link", "md_text": "API Documentation\n\n[`pydantic.main.BaseModel.model_copy`](../../api/base_model/index.html#pydantic.BaseModel.model_copy)\n\nThe [`model_copy()`](../../api/base_model/index.html#pydantic.BaseModel.model_copy) method allows models to be duplicated (with optional updates),\nwhich is particularly useful when working with frozen models.\n\n```\nfrom pydantic import BaseModel\n\n\nclass BarModel(BaseModel):\n    whatever: int\n\n\nclass FooBarModel(BaseModel):\n    banana: float\n    foo: str\n    bar: BarModel\n\n\nm = FooBarModel(banana=3.14, foo='hello', bar={'whatever': 123})\n\nprint(m.model_copy(update={'banana': 0}))\n#> banana=0 foo='hello' bar=BarModel(whatever=123)\n\n# normal copy gives the same object reference for bar:\nprint(id(m.bar) == id(m.model_copy().bar))\n#> True\n# deep copy gives a new object reference for `bar`:\nprint(id(m.bar) == id(m.model_copy(deep=True).bar))\n#> False\n```", "url": "https://docs.pydantic.dev/latest/concepts/models/index.html#model-copyindexhtmlmodel-copy-permanent-link", "page": "concepts/models/index.html", "source_site": "pydantic"}
{"title": "Generic models[Â¶](index.html#generic-models \"Permanent link\")", "anchor": "generic-modelsindexhtmlgeneric-models-permanent-link", "md_text": "Pydantic supports the creation of generic models to make it easier to reuse a common model structure. Both the new\n[type parameter syntax](https://docs.python.org/3/reference/compound_stmts.html#type-params) (introduced by [PEP 695](https://peps.python.org/pep-0695/) in Python 3.12)\nand the old syntax are supported (refer to\n[the Python documentation](https://docs.python.org/3/library/typing.html#building-generic-types-and-type-aliases)\nfor more details).\n\nHere is an example using a generic Pydantic model to create an easily-reused HTTP response payload wrapper:\n\nPython 3.9 and abovePython 3.12 and above (new syntax)\n\n```\nfrom typing import Generic, TypeVar\n\nfrom pydantic import BaseModel, ValidationError\n\nDataT = TypeVar('DataT')  # (1)!\n\n\nclass DataModel(BaseModel):\n    number: int\n\n\nclass Response(BaseModel, Generic[DataT]):  # (2)!\n    data: DataT  # (3)!\n\n\nprint(Response[int](data=1))\n#> data=1\nprint(Response[str](data='value'))\n#> data='value'\nprint(Response[str](data='value').model_dump())\n#> {'data': 'value'}\n\ndata = DataModel(number=1)\nprint(Response[DataModel](data=data).model_dump())\n#> {'data': {'number': 1}}\ntry:\n    Response[int](data='value')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Response[int]\n    data\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='value', input_type=str]\n    \"\"\"\n```\n\n1. Declare one or more [type variables](https://docs.python.org/3/library/typing.html#typing.TypeVar) to use to parameterize your model.\n2. Declare a Pydantic model that inherits from [`BaseModel`](../../api/base_model/index.html#pydantic.BaseModel) and [`typing.Generic`](https://docs.python.org/3/library/typing.html#typing.Generic)\n   (in this specific order), and add the list of type variables you declared previously as parameters to the\n   [`Generic`](https://docs.python.org/3/library/typing.html#typing.Generic) parent.\n3. Use the type variables as annotations where you will want to replace them with other types.\n\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass DataModel(BaseModel):\n    number: int\n\n\nclass Response[DataT](BaseModel):  # (1)!\n    data: DataT  # (2)!\n\n\nprint(Response[int](data=1))\n#> data=1\nprint(Response[str](data='value'))\n#> data='value'\nprint(Response[str](data='value').model_dump())\n#> {'data': 'value'}\n\ndata = DataModel(number=1)\nprint(Response[DataModel](data=data).model_dump())\n#> {'data': {'number': 1}}\ntry:\n    Response[int](data='value')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Response[int]\n    data\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='value', input_type=str]\n    \"\"\"\n```\n\n1. Declare a Pydantic model and add the list of type variables as type parameters.\n2. Use the type variables as annotations where you will want to replace them with other types.\n\nWhen parametrizing a model with a concrete type, Pydantic **does not** validate that the provided type\nis [assignable to the type variable](https://typing.readthedocs.io/en/latest/spec/generics.html#type-variables-with-an-upper-bound) if it has an upper bound.\n\nAny [configuration](../config/index.html), [validation](../validators/index.html) or [serialization](../serialization/index.html) logic\nset on the generic model will also be applied to the parametrized classes, in the same way as when inheriting from\na model class. Any custom methods or attributes will also be inherited.\n\nGeneric models also integrate properly with type checkers, so you get all the type checking\nyou would expect if you were to declare a distinct type for each parametrization.\n\nInternally, Pydantic creates subclasses of the generic model at runtime when the generic model class is parametrized.\nThese classes are cached, so there should be minimal overhead introduced by the use of generics models.\n\nTo inherit from a generic model and preserve the fact that it is generic, the subclass must also inherit from\n[`Generic`](https://docs.python.org/3/library/typing.html#typing.Generic):\n\n```\nfrom typing import Generic, TypeVar\n\nfrom pydantic import BaseModel\n\nTypeX = TypeVar('TypeX')\n\n\nclass BaseClass(BaseModel, Generic[TypeX]):\n    X: TypeX\n\n\nclass ChildClass(BaseClass[TypeX], Generic[TypeX]):\n    pass\n\n\n# Parametrize `TypeX` with `int`:\nprint(ChildClass[int](X=1))\n#> X=1\n```\n\nYou can also create a generic subclass of a model that partially or fully replaces the type variables in the\nsuperclass:\n\n```\nfrom typing import Generic, TypeVar\n\nfrom pydantic import BaseModel\n\nTypeX = TypeVar('TypeX')\nTypeY = TypeVar('TypeY')\nTypeZ = TypeVar('TypeZ')\n\n\nclass BaseClass(BaseModel, Generic[TypeX, TypeY]):\n    x: TypeX\n    y: TypeY\n\n\nclass ChildClass(BaseClass[int, TypeY], Generic[TypeY, TypeZ]):\n    z: TypeZ", "url": "https://docs.pydantic.dev/latest/concepts/models/index.html#generic-modelsindexhtmlgeneric-models-permanent-link", "page": "concepts/models/index.html", "source_site": "pydantic"}
{"title": "Generic models[Â¶](index.html#generic-models \"Permanent link\")", "anchor": "generic-modelsindexhtmlgeneric-models-permanent-link", "md_text": "\n# Parametrize `TypeY` with `str`:\nprint(ChildClass[str, int](x='1', y='y', z='3'))\n#> x=1 y='y' z=3\n```\n\nIf the name of the concrete subclasses is important, you can also override the default name generation\nby overriding the [`model_parametrized_name()`](../../api/base_model/index.html#pydantic.BaseModel.model_parametrized_name) method:\n\n```\nfrom typing import Any, Generic, TypeVar\n\nfrom pydantic import BaseModel\n\nDataT = TypeVar('DataT')\n\n\nclass Response(BaseModel, Generic[DataT]):\n    data: DataT\n\n    @classmethod\n    def model_parametrized_name(cls, params: tuple[type[Any], ...]) -> str:\n        return f'{params[0].__name__.title()}Response'\n\n\nprint(repr(Response[int](data=1)))\n#> IntResponse(data=1)\nprint(repr(Response[str](data='a')))\n#> StrResponse(data='a')\n```\n\nYou can use parametrized generic models as types in other models:\n\n```\nfrom typing import Generic, TypeVar\n\nfrom pydantic import BaseModel\n\nT = TypeVar('T')\n\n\nclass ResponseModel(BaseModel, Generic[T]):\n    content: T\n\n\nclass Product(BaseModel):\n    name: str\n    price: float\n\n\nclass Order(BaseModel):\n    id: int\n    product: ResponseModel[Product]\n\n\nproduct = Product(name='Apple', price=0.5)\nresponse = ResponseModel[Product](content=product)\norder = Order(id=1, product=response)\nprint(repr(order))\n\"\"\"\nOrder(id=1, product=ResponseModel[Product](content=Product(name='Apple', price=0.5)))\n\"\"\"\n```\n\nUsing the same type variable in nested models allows you to enforce typing relationships at different points in your model:\n\n```\nfrom typing import Generic, TypeVar\n\nfrom pydantic import BaseModel, ValidationError\n\nT = TypeVar('T')\n\n\nclass InnerT(BaseModel, Generic[T]):\n    inner: T\n\n\nclass OuterT(BaseModel, Generic[T]):\n    outer: T\n    nested: InnerT[T]\n\n\nnested = InnerT[int](inner=1)\nprint(OuterT[int](outer=1, nested=nested))\n#> outer=1 nested=InnerT[int](inner=1)\ntry:\n    print(OuterT[int](outer='a', nested=InnerT(inner='a')))  # (1)!\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for OuterT[int]\n    outer\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='a', input_type=str]\n    nested.inner\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='a', input_type=str]\n    \"\"\"\n```\n\n1. The `OuterT` model is parametrized with `int`, but the data associated with the the `T` annotations during validation is of type `str`, leading to validation errors.\n\nWhile it may not raise an error, we strongly advise against using parametrized generics in [`isinstance()`](https://docs.python.org/3/library/functions.html#isinstance) checks.\n\nFor example, you should not do `isinstance(my_model, MyGenericModel[int])`. However, it is fine to do `isinstance(my_model, MyGenericModel)` (note that, for standard generics, it would raise an error to do a subclass check with a parameterized generic class).\n\nIf you need to perform [`isinstance()`](https://docs.python.org/3/library/functions.html#isinstance) checks against parametrized generics, you can do this by subclassing the parametrized generic class:\n\n```\nclass MyIntModel(MyGenericModel[int]): ...\n\nisinstance(my_model, MyIntModel)\n```\n\nImplementation Details\n\nWhen using nested generic models, Pydantic sometimes performs revalidation in an attempt to produce the most intuitive validation result.\nSpecifically, if you have a field of type `GenericModel[SomeType]` and you validate data like `GenericModel[SomeCompatibleType]` against this field,\nwe will inspect the data, recognize that the input data is sort of a \"loose\" subclass of `GenericModel`, and revalidate the contained `SomeCompatibleType` data.\n\nThis adds some validation overhead, but makes things more intuitive for cases like that shown below.\n\n```\nfrom typing import Any, Generic, TypeVar\n\nfrom pydantic import BaseModel\n\nT = TypeVar('T')\n\n\nclass GenericModel(BaseModel, Generic[T]):\n    a: T\n\n\nclass Model(BaseModel):\n    inner: GenericModel[Any]\n\n\nprint(repr(Model.model_validate(Model(inner=GenericModel[int](a=1)))))\n#> Model(inner=GenericModel[Any](a=1))\n```\n\nNote, validation will still fail if you, for example are validating against `GenericModel[int]` and pass in an instance `GenericModel[str](a='not an int')`.\n\nIt's also worth noting that this pattern will re-trigger any custom validation as well, like additional model validators and the like.\nValidators will be called once on the first pass, validating directly against `GenericModel[Any]`. That validation fails, as `GenericModel[int]` is not a subclass of `GenericModel[Any]`. This relates to the warning above about the complications of using parametrized generics in `isinstance()` and `issubclass()` checks.\nThen, the validators will be called again on the second pass, during more lax force-revalidation phase, which succeeds.\nTo better understand this consequence, see below:\n\n```\nfrom typing import Any, Generic, Self, TypeVar\n\nfrom pydantic import BaseModel, model_validator", "url": "https://docs.pydantic.dev/latest/concepts/models/index.html#generic-modelsindexhtmlgeneric-models-permanent-link", "page": "concepts/models/index.html", "source_site": "pydantic"}
{"title": "Generic models[Â¶](index.html#generic-models \"Permanent link\")", "anchor": "generic-modelsindexhtmlgeneric-models-permanent-link", "md_text": "T = TypeVar('T')\n\n\nclass GenericModel(BaseModel, Generic[T]):\n    a: T\n\n    @model_validator(mode='after')\n    def validate_after(self: Self) -> Self:\n        print('after validator running custom validation...')\n        return self\n\n\nclass Model(BaseModel):\n    inner: GenericModel[Any]\n\n\nm = Model.model_validate(Model(inner=GenericModel[int](a=1)))\n#> after validator running custom validation...\n#> after validator running custom validation...\nprint(repr(m))\n#> Model(inner=GenericModel[Any](a=1))\n```", "url": "https://docs.pydantic.dev/latest/concepts/models/index.html#generic-modelsindexhtmlgeneric-models-permanent-link", "page": "concepts/models/index.html", "source_site": "pydantic"}
{"title": "Validation of unparametrized type variables[Â¶](index.html#validation-of-unparametrized-type-variables \"Permanent link\")", "anchor": "validation-of-unparametrized-type-variablesindexhtmlvalidation-of-unparametrized-type-variables-permanent-link", "md_text": "When leaving type variables unparametrized, Pydantic treats generic models similarly to how it treats built-in generic\ntypes like [`list`](https://docs.python.org/3/glossary.html#term-list) and [`dict`](https://docs.python.org/3/reference/expressions.html#dict):\n\n* If the type variable is [bound](https://typing.readthedocs.io/en/latest/reference/generics.html#type-variables-with-upper-bounds)\n  or [constrained](https://typing.readthedocs.io/en/latest/reference/generics.html#type-variables-with-constraints) to a specific type,\n  it will be used.\n* If the type variable has a default type (as specified by [PEP 696](https://peps.python.org/pep-0696/)), it will be used.\n* For unbound or unconstrained type variables, Pydantic will fallback to [`Any`](https://docs.python.org/3/library/typing.html#typing.Any).\n\n```\nfrom typing import Generic\n\nfrom typing_extensions import TypeVar\n\nfrom pydantic import BaseModel, ValidationError\n\nT = TypeVar('T')\nU = TypeVar('U', bound=int)\nV = TypeVar('V', default=str)\n\n\nclass Model(BaseModel, Generic[T, U, V]):\n    t: T\n    u: U\n    v: V\n\n\nprint(Model(t='t', u=1, v='v'))\n#> t='t' u=1 v='v'\n\ntry:\n    Model(t='t', u='u', v=1)\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    2 validation errors for Model\n    u\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='u', input_type=str]\n    v\n      Input should be a valid string [type=string_type, input_value=1, input_type=int]\n    \"\"\"\n```\n\nIn some cases, validation against an unparametrized generic model can lead to data loss. Specifically, if a subtype of the type variable upper bound, constraints, or default is being used and the model isn't explicitly parametrized, the resulting type **will not be** the one being provided:\n\n```\nfrom typing import Generic, TypeVar\n\nfrom pydantic import BaseModel\n\nItemT = TypeVar('ItemT', bound='ItemBase')\n\n\nclass ItemBase(BaseModel): ...\n\n\nclass IntItem(ItemBase):\n    value: int\n\n\nclass ItemHolder(BaseModel, Generic[ItemT]):\n    item: ItemT\n\n\nloaded_data = {'item': {'value': 1}}\n\n\nprint(ItemHolder(**loaded_data))  # (1)!\n#> item=ItemBase()\n\nprint(ItemHolder[IntItem](**loaded_data))  # (2)!\n#> item=IntItem(value=1)\n```\n\n1. When the generic isn't parametrized, the input data is validated against the `ItemT` upper bound.\n   Given that `ItemBase` has no fields, the `item` field information is lost.\n2. In this case, the type variable is explicitly parametrized, so the input data is validated against the `IntItem` class.", "url": "https://docs.pydantic.dev/latest/concepts/models/index.html#validation-of-unparametrized-type-variablesindexhtmlvalidation-of-unparametrized-type-variables-permanent-link", "page": "concepts/models/index.html", "source_site": "pydantic"}
{"title": "Serialization of unparametrized type variables[Â¶](index.html#serialization-of-unparametrized-type-variables \"Permanent link\")", "anchor": "serialization-of-unparametrized-type-variablesindexhtmlserialization-of-unparametrized-type-variables-permanent-link", "md_text": "The behavior of serialization differs when using type variables with [upper bounds](https://typing.readthedocs.io/en/latest/reference/generics.html#type-variables-with-upper-bounds), [constraints](https://typing.readthedocs.io/en/latest/reference/generics.html#type-variables-with-constraints), or a default value:\n\nIf a Pydantic model is used in a type variable upper bound and the type variable is never parametrized, then Pydantic will use the upper bound for validation but treat the value as [`Any`](https://docs.python.org/3/library/typing.html#typing.Any) in terms of serialization:\n\n```\nfrom typing import Generic, TypeVar\n\nfrom pydantic import BaseModel\n\n\nclass ErrorDetails(BaseModel):\n    foo: str\n\n\nErrorDataT = TypeVar('ErrorDataT', bound=ErrorDetails)\n\n\nclass Error(BaseModel, Generic[ErrorDataT]):\n    message: str\n    details: ErrorDataT\n\n\nclass MyErrorDetails(ErrorDetails):\n    bar: str\n\n\n# serialized as Any\nerror = Error(\n    message='We just had an error',\n    details=MyErrorDetails(foo='var', bar='var2'),\n)\nassert error.model_dump() == {\n    'message': 'We just had an error',\n    'details': {\n        'foo': 'var',\n        'bar': 'var2',\n    },\n}\n\n# serialized using the concrete parametrization\n# note that `'bar': 'var2'` is missing\nerror = Error[ErrorDetails](\n    message='We just had an error',\n    details=ErrorDetails(foo='var'),\n)\nassert error.model_dump() == {\n    'message': 'We just had an error',\n    'details': {\n        'foo': 'var',\n    },\n}\n```\n\nHere's another example of the above behavior, enumerating all permutations regarding bound specification and generic type parametrization:\n\n```\nfrom typing import Generic, TypeVar\n\nfrom pydantic import BaseModel\n\nTBound = TypeVar('TBound', bound=BaseModel)\nTNoBound = TypeVar('TNoBound')\n\n\nclass IntValue(BaseModel):\n    value: int\n\n\nclass ItemBound(BaseModel, Generic[TBound]):\n    item: TBound\n\n\nclass ItemNoBound(BaseModel, Generic[TNoBound]):\n    item: TNoBound\n\n\nitem_bound_inferred = ItemBound(item=IntValue(value=3))\nitem_bound_explicit = ItemBound[IntValue](item=IntValue(value=3))\nitem_no_bound_inferred = ItemNoBound(item=IntValue(value=3))\nitem_no_bound_explicit = ItemNoBound[IntValue](item=IntValue(value=3))\n\n# calling `print(x.model_dump())` on any of the above instances results in the following:\n#> {'item': {'value': 3}}\n```\n\nHowever, if [constraints](https://typing.readthedocs.io/en/latest/reference/generics.html#type-variables-with-constraints)\nor a default value (as per [PEP 696](https://peps.python.org/pep-0696/)) is being used, then the default type or constraints\nwill be used for both validation and serialization if the type variable is not parametrized. You can override this behavior\nusing [`SerializeAsAny`](../serialization/index.html#serializeasany-annotation):\n\nPython 3.9 and abovePython 3.13 and above\n\n```\nfrom typing import Generic\n\nfrom typing_extensions import TypeVar\n\nfrom pydantic import BaseModel, SerializeAsAny\n\n\nclass ErrorDetails(BaseModel):\n    foo: str\n\n\nErrorDataT = TypeVar('ErrorDataT', default=ErrorDetails)\n\n\nclass Error(BaseModel, Generic[ErrorDataT]):\n    message: str\n    details: ErrorDataT\n\n\nclass MyErrorDetails(ErrorDetails):\n    bar: str\n\n\n# serialized using the default's serializer\nerror = Error(\n    message='We just had an error',\n    details=MyErrorDetails(foo='var', bar='var2'),\n)\nassert error.model_dump() == {\n    'message': 'We just had an error',\n    'details': {\n        'foo': 'var',\n    },\n}\n# If `ErrorDataT` was using an upper bound, `bar` would be present in `details`.\n\n\nclass SerializeAsAnyError(BaseModel, Generic[ErrorDataT]):\n    message: str\n    details: SerializeAsAny[ErrorDataT]\n\n\n# serialized as Any\nerror = SerializeAsAnyError(\n    message='We just had an error',\n    details=MyErrorDetails(foo='var', bar='baz'),\n)\nassert error.model_dump() == {\n    'message': 'We just had an error',\n    'details': {\n        'foo': 'var',\n        'bar': 'baz',\n    },\n}\n\nfrom typing import Generic\n\nfrom typing import TypeVar\n\nfrom pydantic import BaseModel, SerializeAsAny\n\n\nclass ErrorDetails(BaseModel):\n    foo: str\n\n\nErrorDataT = TypeVar('ErrorDataT', default=ErrorDetails)\n\n\nclass Error(BaseModel, Generic[ErrorDataT]):\n    message: str\n    details: ErrorDataT\n\n\nclass MyErrorDetails(ErrorDetails):\n    bar: str\n\n\n# serialized using the default's serializer\nerror = Error(\n    message='We just had an error',\n    details=MyErrorDetails(foo='var', bar='var2'),\n)\nassert error.model_dump() == {\n    'message': 'We just had an error',\n    'details': {\n        'foo': 'var',\n    },\n}\n# If `ErrorDataT` was using an upper bound, `bar` would be present in `details`.\n\n\nclass SerializeAsAnyError(BaseModel, Generic[ErrorDataT]):\n    message: str\n    details: SerializeAsAny[ErrorDataT]", "url": "https://docs.pydantic.dev/latest/concepts/models/index.html#serialization-of-unparametrized-type-variablesindexhtmlserialization-of-unparametrized-type-variables-permanent-link", "page": "concepts/models/index.html", "source_site": "pydantic"}
{"title": "Serialization of unparametrized type variables[Â¶](index.html#serialization-of-unparametrized-type-variables \"Permanent link\")", "anchor": "serialization-of-unparametrized-type-variablesindexhtmlserialization-of-unparametrized-type-variables-permanent-link", "md_text": "\n# serialized as Any\nerror = SerializeAsAnyError(\n    message='We just had an error',\n    details=MyErrorDetails(foo='var', bar='baz'),\n)\nassert error.model_dump() == {\n    'message': 'We just had an error',\n    'details': {\n        'foo': 'var',\n        'bar': 'baz',\n    },\n}\n```", "url": "https://docs.pydantic.dev/latest/concepts/models/index.html#serialization-of-unparametrized-type-variablesindexhtmlserialization-of-unparametrized-type-variables-permanent-link", "page": "concepts/models/index.html", "source_site": "pydantic"}
{"title": "Dynamic model creation[Â¶](index.html#dynamic-model-creation \"Permanent link\")", "anchor": "dynamic-model-creationindexhtmldynamic-model-creation-permanent-link", "md_text": "API Documentation\n\n[`pydantic.main.create_model`](../../api/base_model/index.html#pydantic.create_model)\n\nThere are some occasions where it is desirable to create a model using runtime information to specify the fields.\nPydantic provides the [`create_model()`](../../api/base_model/index.html#pydantic.create_model) function to allow models to be created dynamically:\n\n```\nfrom pydantic import BaseModel, create_model\n\nDynamicFoobarModel = create_model('DynamicFoobarModel', foo=str, bar=(int, 123))\n\n# Equivalent to:\n\n\nclass StaticFoobarModel(BaseModel):\n    foo: str\n    bar: int = 123\n```\n\nField definitions are specified as keyword arguments, and should either be:\n\n* A single element, representing the type annotation of the field.\n* A two-tuple, the first element being the type and the second element the assigned value\n  (either a default or the [`Field()`](../../api/fields/index.html#pydantic.fields.Field) function).\n\nHere is a more advanced example:\n\n```\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Field, PrivateAttr, create_model\n\nDynamicModel = create_model(\n    'DynamicModel',\n    foo=(str, Field(alias='FOO')),\n    bar=Annotated[str, Field(description='Bar field')],\n    _private=(int, PrivateAttr(default=1)),\n)\n\n\nclass StaticModel(BaseModel):\n    foo: str = Field(alias='FOO')\n    bar: Annotated[str, Field(description='Bar field')]\n    _private: int = PrivateAttr(default=1)\n```\n\nThe special keyword arguments `__config__` and `__base__` can be used to customize the new model.\nThis includes extending a base model with extra fields.\n\n```\nfrom pydantic import BaseModel, create_model\n\n\nclass FooModel(BaseModel):\n    foo: str\n    bar: int = 123\n\n\nBarModel = create_model(\n    'BarModel',\n    apple=(str, 'russet'),\n    banana=(str, 'yellow'),\n    __base__=FooModel,\n)\nprint(BarModel)\n#> <class '__main__.BarModel'>\nprint(BarModel.model_fields.keys())\n#> dict_keys(['foo', 'bar', 'apple', 'banana'])\n```\n\nYou can also add validators by passing a dictionary to the `__validators__` argument.\n\n```\nfrom pydantic import ValidationError, create_model, field_validator\n\n\ndef alphanum(cls, v):\n    assert v.isalnum(), 'must be alphanumeric'\n    return v\n\n\nvalidators = {\n    'username_validator': field_validator('username')(alphanum)  # (1)!\n}\n\nUserModel = create_model(\n    'UserModel', username=(str, ...), __validators__=validators\n)\n\nuser = UserModel(username='scolvin')\nprint(user)\n#> username='scolvin'\n\ntry:\n    UserModel(username='scolvi%n')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for UserModel\n    username\n      Assertion failed, must be alphanumeric [type=assertion_error, input_value='scolvi%n', input_type=str]\n    \"\"\"\n```\n\n1. Make sure that the validators names do not clash with any of the field names as\n   internally, Pydantic gathers all members into a namespace and mimics the normal\n   creation of a class using the [`types` module utilities](https://docs.python.org/3/library/types.html#dynamic-type-creation).\n\nTo pickle a dynamically created model:\n\n* the model must be defined globally\n* the `__module__` argument must be provided\n\nSee also: the [dynamic model example](../../examples/dynamic_models/index.html), providing guidelines to derive an optional model from another one.", "url": "https://docs.pydantic.dev/latest/concepts/models/index.html#dynamic-model-creationindexhtmldynamic-model-creation-permanent-link", "page": "concepts/models/index.html", "source_site": "pydantic"}
{"title": "`RootModel` and custom root types[Â¶](index.html#rootmodel-and-custom-root-types \"Permanent link\")", "anchor": "rootmodel-and-custom-root-typesindexhtmlrootmodel-and-custom-root-types-permanent-link", "md_text": "API Documentation\n\n[`pydantic.root_model.RootModel`](../../api/root_model/index.html#pydantic.root_model.RootModel)\n\nPydantic models can be defined with a \"custom root type\" by subclassing [`pydantic.RootModel`](../../api/root_model/index.html#pydantic.root_model.RootModel).\n\nThe root type can be any type supported by Pydantic, and is specified by the generic parameter to `RootModel`.\nThe root value can be passed to the model `__init__` or [`model_validate`](../../api/base_model/index.html#pydantic.BaseModel.model_validate)\nvia the first and only argument.\n\nHere's an example of how this works:\n\n```\nfrom pydantic import RootModel\n\nPets = RootModel[list[str]]\nPetsByName = RootModel[dict[str, str]]\n\n\nprint(Pets(['dog', 'cat']))\n#> root=['dog', 'cat']\nprint(Pets(['dog', 'cat']).model_dump_json())\n#> [\"dog\",\"cat\"]\nprint(Pets.model_validate(['dog', 'cat']))\n#> root=['dog', 'cat']\nprint(Pets.model_json_schema())\n\"\"\"\n{'items': {'type': 'string'}, 'title': 'RootModel[list[str]]', 'type': 'array'}\n\"\"\"\n\nprint(PetsByName({'Otis': 'dog', 'Milo': 'cat'}))\n#> root={'Otis': 'dog', 'Milo': 'cat'}\nprint(PetsByName({'Otis': 'dog', 'Milo': 'cat'}).model_dump_json())\n#> {\"Otis\":\"dog\",\"Milo\":\"cat\"}\nprint(PetsByName.model_validate({'Otis': 'dog', 'Milo': 'cat'}))\n#> root={'Otis': 'dog', 'Milo': 'cat'}\n```\n\nIf you want to access items in the `root` field directly or to iterate over the items, you can implement\ncustom `__iter__` and `__getitem__` functions, as shown in the following example.\n\n```\nfrom pydantic import RootModel\n\n\nclass Pets(RootModel):\n    root: list[str]\n\n    def __iter__(self):\n        return iter(self.root)\n\n    def __getitem__(self, item):\n        return self.root[item]\n\n\npets = Pets.model_validate(['dog', 'cat'])\nprint(pets[0])\n#> dog\nprint([pet for pet in pets])\n#> ['dog', 'cat']\n```\n\nYou can also create subclasses of the parametrized root model directly:\n\n```\nfrom pydantic import RootModel\n\n\nclass Pets(RootModel[list[str]]):\n    def describe(self) -> str:\n        return f'Pets: {\", \".join(self.root)}'\n\n\nmy_pets = Pets.model_validate(['dog', 'cat'])\n\nprint(my_pets.describe())\n#> Pets: dog, cat\n```", "url": "https://docs.pydantic.dev/latest/concepts/models/index.html#rootmodel-and-custom-root-typesindexhtmlrootmodel-and-custom-root-types-permanent-link", "page": "concepts/models/index.html", "source_site": "pydantic"}
{"title": "Faux immutability[Â¶](index.html#faux-immutability \"Permanent link\")", "anchor": "faux-immutabilityindexhtmlfaux-immutability-permanent-link", "md_text": "Models can be configured to be immutable via `model_config['frozen'] = True`. When this is set, attempting to change the\nvalues of instance attributes will raise errors. See the [API reference](../../api/config/index.html#pydantic.config.ConfigDict.frozen) for more details.\n\nThis behavior was achieved in Pydantic V1 via the config setting `allow_mutation = False`.\nThis config flag is deprecated in Pydantic V2, and has been replaced with `frozen`.\n\nIn Python, immutability is not enforced. Developers have the ability to modify objects\nthat are conventionally considered \"immutable\" if they choose to do so.\n\n```\nfrom pydantic import BaseModel, ConfigDict, ValidationError\n\n\nclass FooBarModel(BaseModel):\n    model_config = ConfigDict(frozen=True)\n\n    a: str\n    b: dict\n\n\nfoobar = FooBarModel(a='hello', b={'apple': 'pear'})\n\ntry:\n    foobar.a = 'different'\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for FooBarModel\n    a\n      Instance is frozen [type=frozen_instance, input_value='different', input_type=str]\n    \"\"\"\n\nprint(foobar.a)\n#> hello\nprint(foobar.b)\n#> {'apple': 'pear'}\nfoobar.b['apple'] = 'grape'\nprint(foobar.b)\n#> {'apple': 'grape'}\n```\n\nTrying to change `a` caused an error, and `a` remains unchanged. However, the dict `b` is mutable, and the\nimmutability of `foobar` doesn't stop `b` from being changed.", "url": "https://docs.pydantic.dev/latest/concepts/models/index.html#faux-immutabilityindexhtmlfaux-immutability-permanent-link", "page": "concepts/models/index.html", "source_site": "pydantic"}
{"title": "Abstract base classes[Â¶](index.html#abstract-base-classes \"Permanent link\")", "anchor": "abstract-base-classesindexhtmlabstract-base-classes-permanent-link", "md_text": "Pydantic models can be used alongside Python's\n[Abstract Base Classes](https://docs.python.org/3/library/abc.html) (ABCs).\n\n```\nimport abc\n\nfrom pydantic import BaseModel\n\n\nclass FooBarModel(BaseModel, abc.ABC):\n    a: str\n    b: int\n\n    @abc.abstractmethod\n    def my_abstract_method(self):\n        pass\n```", "url": "https://docs.pydantic.dev/latest/concepts/models/index.html#abstract-base-classesindexhtmlabstract-base-classes-permanent-link", "page": "concepts/models/index.html", "source_site": "pydantic"}
{"title": "Field ordering[Â¶](index.html#field-ordering \"Permanent link\")", "anchor": "field-orderingindexhtmlfield-ordering-permanent-link", "md_text": "Field order affects models in the following ways:\n\n* field order is preserved in the model [JSON Schema](../json_schema/index.html)\n* field order is preserved in [validation errors](index.html#error-handling)\n* field order is preserved when [serializing data](../serialization/index.html#serializing-data)\n\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    a: int\n    b: int = 2\n    c: int = 1\n    d: int = 0\n    e: float\n\n\nprint(Model.model_fields.keys())\n#> dict_keys(['a', 'b', 'c', 'd', 'e'])\nm = Model(e=2, a=1)\nprint(m.model_dump())\n#> {'a': 1, 'b': 2, 'c': 1, 'd': 0, 'e': 2.0}\ntry:\n    Model(a='x', b='x', c='x', d='x', e='x')\nexcept ValidationError as err:\n    error_locations = [e['loc'] for e in err.errors()]\n\nprint(error_locations)\n#> [('a',), ('b',), ('c',), ('d',), ('e',)]\n```", "url": "https://docs.pydantic.dev/latest/concepts/models/index.html#field-orderingindexhtmlfield-ordering-permanent-link", "page": "concepts/models/index.html", "source_site": "pydantic"}
{"title": "Automatically excluded attributes[Â¶](index.html#automatically-excluded-attributes \"Permanent link\")", "anchor": "automatically-excluded-attributesindexhtmlautomatically-excluded-attributes-permanent-link", "md_text": "", "url": "https://docs.pydantic.dev/latest/concepts/models/index.html#automatically-excluded-attributesindexhtmlautomatically-excluded-attributes-permanent-link", "page": "concepts/models/index.html", "source_site": "pydantic"}
{"title": "Class variables[Â¶](index.html#class-variables \"Permanent link\")", "anchor": "class-variablesindexhtmlclass-variables-permanent-link", "md_text": "Attributes annotated with [`ClassVar`](https://docs.python.org/3/library/typing.html#typing.ClassVar) are properly treated by Pydantic as class variables, and will not\nbecome fields on model instances:\n\n```\nfrom typing import ClassVar\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    x: ClassVar[int] = 1\n\n    y: int = 2\n\n\nm = Model()\nprint(m)\n#> y=2\nprint(Model.x)\n#> 1\n```", "url": "https://docs.pydantic.dev/latest/concepts/models/index.html#class-variablesindexhtmlclass-variables-permanent-link", "page": "concepts/models/index.html", "source_site": "pydantic"}
{"title": "Private model attributes[Â¶](index.html#private-model-attributes \"Permanent link\")", "anchor": "private-model-attributesindexhtmlprivate-model-attributes-permanent-link", "md_text": "API Documentation\n\n[`pydantic.fields.PrivateAttr`](../../api/fields/index.html#pydantic.fields.PrivateAttr)\n\nAttributes whose name has a leading underscore are not treated as fields by Pydantic, and are not included in the\nmodel schema. Instead, these are converted into a \"private attribute\" which is not validated or even set during\ncalls to `__init__`, `model_validate`, etc.\n\nHere is an example of usage:\n\n```\nfrom datetime import datetime\nfrom random import randint\nfrom typing import Any\n\nfrom pydantic import BaseModel, PrivateAttr\n\n\nclass TimeAwareModel(BaseModel):\n    _processed_at: datetime = PrivateAttr(default_factory=datetime.now)\n    _secret_value: str\n\n    def model_post_init(self, context: Any) -> None:\n        # this could also be done with `default_factory`:\n        self._secret_value = randint(1, 5)\n\n\nm = TimeAwareModel()\nprint(m._processed_at)\n#> 2032-01-02 03:04:05.000006\nprint(m._secret_value)\n#> 3\n```\n\nPrivate attribute names must start with underscore to prevent conflicts with model fields. However, dunder names\n(such as `__attr__`) are not supported, and will be completely ignored from the model definition.", "url": "https://docs.pydantic.dev/latest/concepts/models/index.html#private-model-attributesindexhtmlprivate-model-attributes-permanent-link", "page": "concepts/models/index.html", "source_site": "pydantic"}
{"title": "Model signature[Â¶](index.html#model-signature \"Permanent link\")", "anchor": "model-signatureindexhtmlmodel-signature-permanent-link", "md_text": "All Pydantic models will have their signature generated based on their fields:\n\n```\nimport inspect\n\nfrom pydantic import BaseModel, Field\n\n\nclass FooModel(BaseModel):\n    id: int\n    name: str = None\n    description: str = 'Foo'\n    apple: int = Field(alias='pear')\n\n\nprint(inspect.signature(FooModel))\n#> (*, id: int, name: str = None, description: str = 'Foo', pear: int) -> None\n```\n\nAn accurate signature is useful for introspection purposes and libraries like `FastAPI` or `hypothesis`.\n\nThe generated signature will also respect custom `__init__` functions:\n\n```\nimport inspect\n\nfrom pydantic import BaseModel\n\n\nclass MyModel(BaseModel):\n    id: int\n    info: str = 'Foo'\n\n    def __init__(self, id: int = 1, *, bar: str, **data) -> None:\n        \"\"\"My custom init!\"\"\"\n        super().__init__(id=id, bar=bar, **data)\n\n\nprint(inspect.signature(MyModel))\n#> (id: int = 1, *, bar: str, info: str = 'Foo') -> None\n```\n\nTo be included in the signature, a field's alias or name must be a valid Python identifier.\nPydantic will prioritize a field's alias over its name when generating the signature, but may use the field name if the\nalias is not a valid Python identifier.\n\nIf a field's alias and name are *both* not valid identifiers (which may be possible through exotic use of `create_model`),\na `**data` argument will be added. In addition, the `**data` argument will always be present in the signature if\n`model_config['extra'] == 'allow'`.", "url": "https://docs.pydantic.dev/latest/concepts/models/index.html#model-signatureindexhtmlmodel-signature-permanent-link", "page": "concepts/models/index.html", "source_site": "pydantic"}
{"title": "Structural pattern matching[Â¶](index.html#structural-pattern-matching \"Permanent link\")", "anchor": "structural-pattern-matchingindexhtmlstructural-pattern-matching-permanent-link", "md_text": "Pydantic supports structural pattern matching for models, as introduced by [PEP 636](https://peps.python.org/pep-0636/) in Python 3.10.\n\n```\nfrom pydantic import BaseModel\n\n\nclass Pet(BaseModel):\n    name: str\n    species: str\n\n\na = Pet(name='Bones', species='dog')\n\nmatch a:\n    # match `species` to 'dog', declare and initialize `dog_name`\n    case Pet(species='dog', name=dog_name):\n        print(f'{dog_name} is a dog')\n#> Bones is a dog\n    # default case\n    case _:\n        print('No dog matched')\n```\n\nA match-case statement may seem as if it creates a new model, but don't be fooled;\nit is just syntactic sugar for getting an attribute and either comparing it or declaring and initializing it.", "url": "https://docs.pydantic.dev/latest/concepts/models/index.html#structural-pattern-matchingindexhtmlstructural-pattern-matching-permanent-link", "page": "concepts/models/index.html", "source_site": "pydantic"}
{"title": "Attribute copies[Â¶](index.html#attribute-copies \"Permanent link\")", "anchor": "attribute-copiesindexhtmlattribute-copies-permanent-link", "md_text": "In many cases, arguments passed to the constructor will be copied in order to perform validation and, where necessary,\ncoercion.\n\nIn this example, note that the ID of the list changes after the class is constructed because it has been\ncopied during validation:\n\n```\nfrom pydantic import BaseModel\n\n\nclass C1:\n    arr = []\n\n    def __init__(self, in_arr):\n        self.arr = in_arr\n\n\nclass C2(BaseModel):\n    arr: list[int]\n\n\narr_orig = [1, 9, 10, 3]\n\n\nc1 = C1(arr_orig)\nc2 = C2(arr=arr_orig)\nprint(f'{id(c1.arr) == id(c2.arr)=}')\n#> id(c1.arr) == id(c2.arr)=False\n```\n\nThere are some situations where Pydantic does not copy attributes, such as when passing models â€” we use the\nmodel as is. You can override this behaviour by setting\n[`model_config['revalidate_instances'] = 'always'`](../../api/config/index.html#pydantic.config.ConfigDict).\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/concepts/models/index.html#attribute-copiesindexhtmlattribute-copies-permanent-link", "page": "concepts/models/index.html", "source_site": "pydantic"}
{"title": "Serializing data[Â¶](index.html#serializing-data \"Permanent link\")", "anchor": "serializing-dataindexhtmlserializing-data-permanent-link", "md_text": "Pydantic allows models (and any other type using [type adapters](../type_adapter/index.html)) to be serialized in *two* modes:\n[Python](index.html#python-mode) and [JSON](index.html#json-mode). The Python output may contain non-JSON serializable data (although this\ncan be emulated).", "url": "https://docs.pydantic.dev/latest/concepts/serialization/index.html#serializing-dataindexhtmlserializing-data-permanent-link", "page": "concepts/serialization/index.html", "source_site": "pydantic"}
{"title": "Python mode[Â¶](index.html#python-mode \"Permanent link\")", "anchor": "python-modeindexhtmlpython-mode-permanent-link", "md_text": "When using the Python mode, Pydantic models (and model-like types such as [dataclasses](https://docs.python.org/3/library/dataclasses.html#module-dataclasses)) (1) will be (recursively) converted to dictionaries. This is achievable by using the [`model_dump()`](../../api/base_model/index.html#pydantic.BaseModel.model_dump) method:\n\n1. With the exception of [root models](../models/index.html#rootmodel-and-custom-root-types), where the root value is dumped directly.\n\nPython 3.9 and abovePython 3.10 and above\n\n```\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field\n\n\nclass BarModel(BaseModel):\n    whatever: tuple[int, ...]\n\n\nclass FooBarModel(BaseModel):\n    banana: Optional[float] = 1.1\n    foo: str = Field(serialization_alias='foo_alias')\n    bar: BarModel\n\n\nm = FooBarModel(banana=3.14, foo='hello', bar={'whatever': (1, 2)})\n\n# returns a dictionary:\nprint(m.model_dump())\n#> {'banana': 3.14, 'foo': 'hello', 'bar': {'whatever': (1, 2)}}\n\nprint(m.model_dump(by_alias=True))\n#> {'banana': 3.14, 'foo_alias': 'hello', 'bar': {'whatever': (1, 2)}}\n\nfrom pydantic import BaseModel, Field\n\n\nclass BarModel(BaseModel):\n    whatever: tuple[int, ...]\n\n\nclass FooBarModel(BaseModel):\n    banana: float | None = 1.1\n    foo: str = Field(serialization_alias='foo_alias')\n    bar: BarModel\n\n\nm = FooBarModel(banana=3.14, foo='hello', bar={'whatever': (1, 2)})\n\n# returns a dictionary:\nprint(m.model_dump())\n#> {'banana': 3.14, 'foo': 'hello', 'bar': {'whatever': (1, 2)}}\n\nprint(m.model_dump(by_alias=True))\n#> {'banana': 3.14, 'foo_alias': 'hello', 'bar': {'whatever': (1, 2)}}\n```\n\nNotice that the value of `whatever` was dumped as tuple, which isn't a known JSON type. The `mode` argument can be set to `'json'`\nto ensure JSON-compatible types are used:\n\n```\nprint(m.model_dump(mode='json'))\n#> {'banana': 3.14, 'foo': 'hello', 'bar': {'whatever': [1, 2]}}\n```\n\nThe [`TypeAdapter.dump_python()`](../../api/type_adapter/index.html#pydantic.type_adapter.TypeAdapter.dump_python) method, useful when *not* dealing with Pydantic models.", "url": "https://docs.pydantic.dev/latest/concepts/serialization/index.html#python-modeindexhtmlpython-mode-permanent-link", "page": "concepts/serialization/index.html", "source_site": "pydantic"}
{"title": "JSON mode[Â¶](index.html#json-mode \"Permanent link\")", "anchor": "json-modeindexhtmljson-mode-permanent-link", "md_text": "Pydantic allows data to be serialized directly to a JSON-encoded string, by trying its best to convert Python values to valid\nJSON data. This is achievable by using the [`model_dump_json()`](../../api/base_model/index.html#pydantic.BaseModel.model_dump_json) method:\n\n```\nfrom datetime import datetime\n\nfrom pydantic import BaseModel\n\n\nclass BarModel(BaseModel):\n    whatever: tuple[int, ...]\n\n\nclass FooBarModel(BaseModel):\n    foo: datetime\n    bar: BarModel\n\n\nm = FooBarModel(foo=datetime(2032, 6, 1, 12, 13, 14), bar={'whatever': (1, 2)})\n\nprint(m.model_dump_json(indent=2))\n\"\"\"\n{\n  \"foo\": \"2032-06-01T12:13:14\",\n  \"bar\": {\n    \"whatever\": [\n      1,\n      2\n    ]\n  }\n}\n\"\"\"\n```\n\nIn addition to the [supported types](https://docs.python.org/3/library/json.html#json.JSONEncoder) by the standard library [`json`](https://docs.python.org/3/library/json.html#module-json) module, Pydantic supports a wide\nvariety of types ([date and time types](https://docs.python.org/3/library/datetime.html#module-datetime), [`UUID`](https://docs.python.org/3/library/uuid.html#uuid.UUID) objects, [sets](https://docs.python.org/3/reference/expressions.html#set), etc). If an unsupported type\nis used and can't be serialized to JSON, a [`PydanticSerializationError`](../../api/pydantic_core/index.html#pydantic_core.PydanticSerializationError) exception\nis raised.\n\nThe [`TypeAdapter.dump_json()`](../../api/type_adapter/index.html#pydantic.type_adapter.TypeAdapter.dump_json) method, useful when *not* dealing with Pydantic models.", "url": "https://docs.pydantic.dev/latest/concepts/serialization/index.html#json-modeindexhtmljson-mode-permanent-link", "page": "concepts/serialization/index.html", "source_site": "pydantic"}
{"title": "Iterating over models[Â¶](index.html#iterating-over-models \"Permanent link\")", "anchor": "iterating-over-modelsindexhtmliterating-over-models-permanent-link", "md_text": "Pydantic models can also be iterated over, yielding `(field_name, field_value)` pairs. Note that field values\nare left as is, so sub-models will *not* be converted to dictionaries:\n\n```\nfrom pydantic import BaseModel\n\n\nclass BarModel(BaseModel):\n    whatever: int\n\n\nclass FooBarModel(BaseModel):\n    banana: float\n    foo: str\n    bar: BarModel\n\n\nm = FooBarModel(banana=3.14, foo='hello', bar={'whatever': 123})\n\nfor name, value in m:\n    print(f'{name}: {value}')\n    #> banana: 3.14\n    #> foo: hello\n    #> bar: whatever=123\n```\n\nThis means that calling [`dict()`](https://docs.python.org/3/reference/expressions.html#dict) on a model can be used to construct a dictionary of the model:\n\n```\nprint(dict(m))\n#> {'banana': 3.14, 'foo': 'hello', 'bar': BarModel(whatever=123)}\n```\n\n[Root models](../models/index.html#rootmodel-and-custom-root-types) *does* get converted to a dictionary with the key `'root'`.", "url": "https://docs.pydantic.dev/latest/concepts/serialization/index.html#iterating-over-modelsindexhtmliterating-over-models-permanent-link", "page": "concepts/serialization/index.html", "source_site": "pydantic"}
{"title": "Pickling support[Â¶](index.html#pickling-support \"Permanent link\")", "anchor": "pickling-supportindexhtmlpickling-support-permanent-link", "md_text": "Pydantic models support efficient pickling and unpickling.\n\n```\nimport pickle\n\nfrom pydantic import BaseModel\n\n\nclass FooBarModel(BaseModel):\n    a: str\n    b: int\n\n\nm = FooBarModel(a='hello', b=123)\nprint(m)\n#> a='hello' b=123\ndata = pickle.dumps(m)\nprint(data[:20])\n#> b'\\x80\\x04\\x95\\x95\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x8c\\x08__main_'\nm2 = pickle.loads(data)\nprint(m2)\n#> a='hello' b=123\n```", "url": "https://docs.pydantic.dev/latest/concepts/serialization/index.html#pickling-supportindexhtmlpickling-support-permanent-link", "page": "concepts/serialization/index.html", "source_site": "pydantic"}
{"title": "Serializers[Â¶](index.html#serializers \"Permanent link\")", "anchor": "serializersindexhtmlserializers-permanent-link", "md_text": "Similar to [custom validators](../validators/index.html), you can leverage custom serializers at the field and model levels to further\ncontrol the serialization behavior.\n\nOnly *one* serializer can be defined per field/model. It is not possible to combine multiple serializers together\n(including *plain* and *wrap* serializers).", "url": "https://docs.pydantic.dev/latest/concepts/serialization/index.html#serializersindexhtmlserializers-permanent-link", "page": "concepts/serialization/index.html", "source_site": "pydantic"}
{"title": "Field serializers[Â¶](index.html#field-serializers \"Permanent link\")", "anchor": "field-serializersindexhtmlfield-serializers-permanent-link", "md_text": "API Documentation\n\n[`pydantic.functional_serializers.PlainSerializer`](../../api/functional_serializers/index.html#pydantic.functional_serializers.PlainSerializer)  \n[`pydantic.functional_serializers.WrapSerializer`](../../api/functional_serializers/index.html#pydantic.functional_serializers.WrapSerializer)  \n[`pydantic.functional_serializers.field_serializer`](../../api/functional_serializers/index.html#pydantic.functional_serializers.field_serializer)\n\nIn its simplest form, a field serializer is a callable taking the value to be serialized as an argument and\n**returning the serialized value**.\n\nIf the `return_type` argument is provided to the serializer (or if a return type annotation is available on the serializer function),\nit will be used to build an extra serializer, to ensure that the serialized field value complies with this return type.\n\n**Two** different types of serializers can be used. They can all be defined using the\n[annotated pattern](../fields/index.html#the-annotated-pattern) or using the\n[`@field_serializer`](../../api/functional_serializers/index.html#pydantic.functional_serializers.field_serializer) decorator, applied on instance or [static methods](https://docs.python.org/3/library/functions.html#staticmethod).\n\n* ***Plain* serializers**: are called unconditionally to serialize a field. The serialization logic for types supported\n  by Pydantic will *not* be called. Using such serializers is also useful to specify the logic for arbitrary types.\n\n  Annotated patternDecorator\n\n  ```\n  from typing import Annotated, Any\n\n  from pydantic import BaseModel, PlainSerializer\n\n\n  def ser_number(value: Any) -> Any:\n      if isinstance(value, int):\n          return value * 2\n      else:\n          return value\n\n\n  class Model(BaseModel):\n      number: Annotated[int, PlainSerializer(ser_number)]\n\n\n  print(Model(number=4).model_dump())\n  #> {'number': 8}\n  m = Model(number=1)\n  m.number = 'invalid'\n  print(m.model_dump())  # (1)!\n  #> {'number': 'invalid'}\n  ```\n\n  1. Pydantic will *not* validate that the serialized value complies with the `int` type.\n\n  ```\n  from typing import Any\n\n  from pydantic import BaseModel, field_serializer\n\n\n  class Model(BaseModel):\n      number: int\n\n      @field_serializer('number', mode='plain')  # (1)!\n      def ser_number(self, value: Any) -> Any:\n          if isinstance(value, int):\n              return value * 2\n          else:\n              return value\n\n\n  print(Model(number=4).model_dump())\n  #> {'number': 8}\n  m = Model(number=1)\n  m.number = 'invalid'\n  print(m.model_dump())  # (2)!\n  #> {'number': 'invalid'}\n  ```\n\n  1. `'plain'` is the default mode for the decorator, and can be omitted.\n  2. Pydantic will *not* validate that the serialized value complies with the `int` type.\n* ***Wrap* serializers**: give more flexibility to customize the serialization behavior. You can run code before or after\n  the Pydantic serialization logic.\n\n  Such serializers must be defined with a **mandatory** extra *handler* parameter: a callable taking the value to be serialized\n  as an argument. Internally, this handler will delegate serialization of the value to Pydantic. You are free to *not* call the\n  handler at all.\n\n  Annotated patternDecorator\n\n  ```\n  from typing import Annotated, Any\n\n  from pydantic import BaseModel, SerializerFunctionWrapHandler, WrapSerializer\n\n\n  def ser_number(value: Any, handler: SerializerFunctionWrapHandler) -> int:\n      return handler(value) + 1\n\n\n  class Model(BaseModel):\n      number: Annotated[int, WrapSerializer(ser_number)]\n\n\n  print(Model(number=4).model_dump())\n  #> {'number': 5}\n  ```\n\n  ```\n  from typing import Any\n\n  from pydantic import BaseModel, SerializerFunctionWrapHandler, field_serializer\n\n\n  class Model(BaseModel):\n      number: int\n\n      @field_serializer('number', mode='wrap')\n      def ser_number(\n          self, value: Any, handler: SerializerFunctionWrapHandler\n      ) -> int:\n          return handler(value) + 1\n\n\n  print(Model(number=4).model_dump())\n  #> {'number': 5}\n  ```\n\n#### Which serializer pattern to use[Â¶](index.html#which-serializer-pattern-to-use \"Permanent link\")\n\nWhile both approaches can achieve the same thing, each pattern provides different benefits.\n\n##### Using the annotated pattern[Â¶](index.html#using-the-annotated-pattern \"Permanent link\")\n\nOne of the key benefits of using the [annotated pattern](../fields/index.html#the-annotated-pattern) is to make\nserializers reusable:\n\n```\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Field, PlainSerializer\n\nDoubleNumber = Annotated[int, PlainSerializer(lambda v: v * 2)]\n\n\nclass Model1(BaseModel):\n    my_number: DoubleNumber\n\n\nclass Model2(BaseModel):\n    other_number: Annotated[DoubleNumber, Field(description='My other number')]\n\n\nclass Model3(BaseModel):\n    list_of_even_numbers: list[DoubleNumber]  # (1)!\n```\n\n1. As mentioned in the [annotated pattern](../fields/index.html#the-annotated-pattern) documentation,\n   we can also make use of serializers for specific parts of the annotation (in this case,\n   serialization is applied for list items, but not the whole list).\n\nIt is also easier to understand which serializers are applied to a type, by just looking at the field annotation.", "url": "https://docs.pydantic.dev/latest/concepts/serialization/index.html#field-serializersindexhtmlfield-serializers-permanent-link", "page": "concepts/serialization/index.html", "source_site": "pydantic"}
{"title": "Field serializers[Â¶](index.html#field-serializers \"Permanent link\")", "anchor": "field-serializersindexhtmlfield-serializers-permanent-link", "md_text": "##### Using the decorator pattern[Â¶](index.html#using-the-decorator-pattern \"Permanent link\")\n\nOne of the key benefits of using the [`@field_serializer`](../../api/functional_serializers/index.html#pydantic.functional_serializers.field_serializer) decorator is to apply\nthe function to multiple fields:\n\n```\nfrom pydantic import BaseModel, field_serializer\n\n\nclass Model(BaseModel):\n    f1: str\n    f2: str\n\n    @field_serializer('f1', 'f2', mode='plain')\n    def capitalize(self, value: str) -> str:\n        return value.capitalize()\n```\n\nHere are a couple additional notes about the decorator usage:\n\n* If you want the serializer to apply to all fields (including the ones defined in subclasses), you can pass\n  `'*'` as the field name argument.\n* By default, the decorator will ensure the provided field name(s) are defined on the model. If you want to\n  disable this check during class creation, you can do so by passing `False` to the `check_fields` argument.\n  This is useful when the field serializer is defined on a base class, and the field is expected to exist on\n  subclasses.", "url": "https://docs.pydantic.dev/latest/concepts/serialization/index.html#field-serializersindexhtmlfield-serializers-permanent-link", "page": "concepts/serialization/index.html", "source_site": "pydantic"}
{"title": "Model serializers[Â¶](index.html#model-serializers \"Permanent link\")", "anchor": "model-serializersindexhtmlmodel-serializers-permanent-link", "md_text": "API Documentation\n\n[`pydantic.functional_serializers.model_serializer`](../../api/functional_serializers/index.html#pydantic.functional_serializers.model_serializer)\n\nSerialization can also be customized on the entire model using the [`@model_serializer`](../../api/functional_serializers/index.html#pydantic.functional_serializers.model_serializer)\ndecorator.\n\nIf the `return_type` argument is provided to the [`@model_serializer`](../../api/functional_serializers/index.html#pydantic.functional_serializers.model_serializer) decorator\n(or if a return type annotation is available on the serializer function), it will be used to build an extra serializer,\nto ensure that the serialized model value complies with this return type.\n\nAs with [field serializers](index.html#field-serializers), **two** different types of model serializers can be used:\n\n* ***Plain* serializers**: are called unconditionally to serialize the model.\n\n  ```\n  from pydantic import BaseModel, model_serializer\n\n\n  class UserModel(BaseModel):\n      username: str\n      password: str\n\n      @model_serializer(mode='plain')  # (1)!\n      def serialize_model(self) -> str:  # (2)!\n          return f'{self.username} - {self.password}'\n\n\n  print(UserModel(username='foo', password='bar').model_dump())\n  #> foo - bar\n  ```\n\n  1. `'plain'` is the default mode for the decorator, and can be omitted.\n  2. You are free to return a value that *isn't* a dictionary.\n* ***Wrap* serializers**: give more flexibility to customize the serialization behavior. You can run code before or after\n  the Pydantic serialization logic.\n\n  Such serializers must be defined with a **mandatory** extra *handler* parameter: a callable taking the instance of the model\n  as an argument. Internally, this handler will delegate serialization of the model to Pydantic. You are free to *not* call the\n  handler at all.\n\n  ```\n  from pydantic import BaseModel, SerializerFunctionWrapHandler, model_serializer\n\n\n  class UserModel(BaseModel):\n      username: str\n      password: str\n\n      @model_serializer(mode='wrap')\n      def serialize_model(\n          self, handler: SerializerFunctionWrapHandler\n      ) -> dict[str, object]:\n          serialized = handler(self)\n          serialized['fields'] = list(serialized)\n          return serialized\n\n\n  print(UserModel(username='foo', password='bar').model_dump())\n  #> {'username': 'foo', 'password': 'bar', 'fields': ['username', 'password']}\n  ```", "url": "https://docs.pydantic.dev/latest/concepts/serialization/index.html#model-serializersindexhtmlmodel-serializers-permanent-link", "page": "concepts/serialization/index.html", "source_site": "pydantic"}
{"title": "Serialization info[Â¶](index.html#serialization-info \"Permanent link\")", "anchor": "serialization-infoindexhtmlserialization-info-permanent-link", "md_text": "Both the field and model serializers callables (in all modes) can optionally take an extra `info` argument,\nproviding useful extra information, such as:\n\n* [user defined context](index.html#serialization-context)\n* the current serialization mode: either `'python'` or `'json'` (see the [`mode`](../../api/pydantic_core_schema/index.html#pydantic_core.core_schema.SerializationInfo.mode) property)\n* the various parameters set during serialization using the [serialization methods](index.html#serializing-data)\n  (e.g. [`exclude_unset`](../../api/pydantic_core_schema/index.html#pydantic_core.core_schema.SerializationInfo.exclude_unset), [`serialize_as_any`](../../api/pydantic_core_schema/index.html#pydantic_core.core_schema.SerializationInfo.serialize_as_any))\n* the current field name, if using a [field serializer](index.html#field-serializers) (see the\n  [`field_name`](../../api/pydantic_core_schema/index.html#pydantic_core.core_schema.FieldSerializationInfo.field_name) property).", "url": "https://docs.pydantic.dev/latest/concepts/serialization/index.html#serialization-infoindexhtmlserialization-info-permanent-link", "page": "concepts/serialization/index.html", "source_site": "pydantic"}
{"title": "Serialization context[Â¶](index.html#serialization-context \"Permanent link\")", "anchor": "serialization-contextindexhtmlserialization-context-permanent-link", "md_text": "You can pass a context object to the [serialization methods](index.html#serializing-data), which can be accessed\ninside the serializer functions using the [`context`](../../api/pydantic_core_schema/index.html#pydantic_core.core_schema.SerializationInfo.context) property:\n\n```\nfrom pydantic import BaseModel, FieldSerializationInfo, field_serializer\n\n\nclass Model(BaseModel):\n    text: str\n\n    @field_serializer('text', mode='plain')\n    @classmethod\n    def remove_stopwords(cls, v: str, info: FieldSerializationInfo) -> str:\n        if isinstance(info.context, dict):\n            stopwords = info.context.get('stopwords', set())\n            v = ' '.join(w for w in v.split() if w.lower() not in stopwords)\n        return v\n\n\nmodel = Model(text='This is an example document')\nprint(model.model_dump())  # no context\n#> {'text': 'This is an example document'}\nprint(model.model_dump(context={'stopwords': ['this', 'is', 'an']}))\n#> {'text': 'example document'}\n```\n\nSimilarly, you can [use a context for validation](../validators/index.html#validation-context).", "url": "https://docs.pydantic.dev/latest/concepts/serialization/index.html#serialization-contextindexhtmlserialization-context-permanent-link", "page": "concepts/serialization/index.html", "source_site": "pydantic"}
{"title": "Serializing subclasses[Â¶](index.html#serializing-subclasses \"Permanent link\")", "anchor": "serializing-subclassesindexhtmlserializing-subclasses-permanent-link", "md_text": "", "url": "https://docs.pydantic.dev/latest/concepts/serialization/index.html#serializing-subclassesindexhtmlserializing-subclasses-permanent-link", "page": "concepts/serialization/index.html", "source_site": "pydantic"}
{"title": "Subclasses of supported types[Â¶](index.html#subclasses-of-supported-types \"Permanent link\")", "anchor": "subclasses-of-supported-typesindexhtmlsubclasses-of-supported-types-permanent-link", "md_text": "Subclasses of supported types are serialized according to their super class:\n\n```\nfrom datetime import date\n\nfrom pydantic import BaseModel\n\n\nclass MyDate(date):\n    @property\n    def my_date_format(self) -> str:\n        return self.strftime('%d/%m/%Y')\n\n\nclass FooModel(BaseModel):\n    date: date\n\n\nm = FooModel(date=MyDate(2023, 1, 1))\nprint(m.model_dump_json())\n#> {\"date\":\"2023-01-01\"}\n```", "url": "https://docs.pydantic.dev/latest/concepts/serialization/index.html#subclasses-of-supported-typesindexhtmlsubclasses-of-supported-types-permanent-link", "page": "concepts/serialization/index.html", "source_site": "pydantic"}
{"title": "Subclasses of model-like types[Â¶](index.html#subclasses-of-model-like-types \"Permanent link\")", "anchor": "subclasses-of-model-like-typesindexhtmlsubclasses-of-model-like-types-permanent-link", "md_text": "When using model-like classes (Pydantic models, dataclasses, etc.) as field annotations, the default behavior is to\nserializer the field value as though it was an instance of the class, even if it is a subclass. More specifically,\nonly the fields declared on the type annotation will be included in the serialization result:\n\n```\nfrom pydantic import BaseModel\n\n\nclass User(BaseModel):\n    name: str\n\n\nclass UserLogin(User):\n    password: str\n\n\nclass OuterModel(BaseModel):\n    user: User\n\n\nuser = UserLogin(name='pydantic', password='hunter2')\n\nm = OuterModel(user=user)\nprint(m)\n#> user=UserLogin(name='pydantic', password='hunter2')\nprint(m.model_dump())  # (1)!\n#> {'user': {'name': 'pydantic'}}\n```\n\n1. Note: the password field is not included\n\nThis behavior is different from how things worked in Pydantic V1, where we would always include\nall (subclass) fields when recursively serializing models to dictionaries. The motivation behind this change\nin behavior is that it helps ensure that you know precisely which fields could be included when serializing,\neven if subclasses get passed when instantiating the object. In particular, this can help prevent surprises\nwhen adding sensitive information like secrets as fields of subclasses. To enable the old V1 behavior, refer\nto the next section.", "url": "https://docs.pydantic.dev/latest/concepts/serialization/index.html#subclasses-of-model-like-typesindexhtmlsubclasses-of-model-like-types-permanent-link", "page": "concepts/serialization/index.html", "source_site": "pydantic"}
{"title": "Serializing with duck typing ðŸ¦†[Â¶](index.html#serializing-with-duck-typing \"Permanent link\")", "anchor": "serializing-with-duck-typing-indexhtmlserializing-with-duck-typing-permanent-link", "md_text": "Duck typing serialization is the behavior of serializing a model instance based on the actual field values, rather\nthan the field definitions. This means that for a field annotated with a model-like class, all the fields present\nin subclasses of such class will be included in the serialized output.\n\nTo achieve duck typing serialization, Pydantic can apply *serialize as any* behavior. In this mode, Pydantic does\n*not* make use of the type annotation (more precisely, the serialization schema derived from the type) to infer\nhow the value should be serialized, but instead inspects the actual type of the value at runtime to do so.\n\nWhen a subclass of a model is used as a value, Pydantic will *not* serialize it according to the schema of the\nparent class, but rather use the value itself and preserve all of its fields.\n\nThis behavior can be configured at the field level and at runtime, for a specific serialization call:\n\n* Field level: use the [`SerializeAsAny`](../../api/functional_serializers/index.html#pydantic.functional_serializers.SerializeAsAny) annotation.\n* Runtime level: use the `serialize_as_any` argument when calling the [serialization methods](index.html#serializing-data).\n\nWe discuss these options below in more detail:\n\n#### `SerializeAsAny` annotation[Â¶](index.html#serializeasany-annotation \"Permanent link\")\n\nIf you want duck typing serialization behavior, this can be done using the\n[`SerializeAsAny`](../../api/functional_serializers/index.html#pydantic.functional_serializers.SerializeAsAny) annotation\non a type:\n\n```\nfrom pydantic import BaseModel, SerializeAsAny\n\n\nclass User(BaseModel):\n    name: str\n\n\nclass UserLogin(User):\n    password: str\n\n\nclass OuterModel(BaseModel):\n    as_any: SerializeAsAny[User]\n    as_user: User\n\n\nuser = UserLogin(name='pydantic', password='password')\n\nprint(OuterModel(as_any=user, as_user=user).model_dump())\n\"\"\"\n{\n    'as_any': {'name': 'pydantic', 'password': 'password'},\n    'as_user': {'name': 'pydantic'},\n}\n\"\"\"\n```\n\nWhen a type is annotated as `SerializeAsAny[<type>]`, the validation behavior will be the same as if it was\nannotated as `<type>`, and static type checkers will treat the annotation as if it was simply `<type>`.\nWhen serializing, the field will be serialized as though the type hint for the field was [`Any`](https://docs.python.org/3/library/typing.html#typing.Any),\nwhich is where the name comes from.\n\n#### `serialize_as_any` runtime setting[Â¶](index.html#serialize_as_any-runtime-setting \"Permanent link\")\n\nThe `serialize_as_any` runtime setting can be used to serialize model data with or without duck typed serialization behavior.\n`serialize_as_any` can be passed as a keyword argument to the various [serialization methods](index.html#serializing-data) (such as\n[`model_dump()`](../../api/base_model/index.html#pydantic.BaseModel.model_dump) and [`model_dump_json()`](../../api/base_model/index.html#pydantic.BaseModel.model_dump_json) on Pydantic models).\n\n```\nfrom pydantic import BaseModel\n\n\nclass User(BaseModel):\n    name: str\n\n\nclass UserLogin(User):\n    password: str\n\n\nclass OuterModel(BaseModel):\n    user1: User\n    user2: User\n\n\nuser = UserLogin(name='pydantic', password='password')\n\nouter_model = OuterModel(user1=user, user2=user)\nprint(outer_model.model_dump(serialize_as_any=True))  # (1)!\n\"\"\"\n{\n    'user1': {'name': 'pydantic', 'password': 'password'},\n    'user2': {'name': 'pydantic', 'password': 'password'},\n}\n\"\"\"\n\nprint(outer_model.model_dump(serialize_as_any=False))  # (2)!\n#> {'user1': {'name': 'pydantic'}, 'user2': {'name': 'pydantic'}}\n```\n\n1. With `serialize_as_any` set to `True`, the result matches that of V1.\n2. With `serialize_as_any` set to `False` (the V2 default), fields present on the subclass,\n   but not the base class, are not included in serialization.\n\nHowever, do note that the *serialize as any* behavior will apply to *all* values, not only the values where duck typing\nis relevant. You may want to prefer using the `SerializeAsAny` annotation when required instead.", "url": "https://docs.pydantic.dev/latest/concepts/serialization/index.html#serializing-with-duck-typing-indexhtmlserializing-with-duck-typing-permanent-link", "page": "concepts/serialization/index.html", "source_site": "pydantic"}
{"title": "Field inclusion and exclusion[Â¶](index.html#field-inclusion-and-exclusion \"Permanent link\")", "anchor": "field-inclusion-and-exclusionindexhtmlfield-inclusion-and-exclusion-permanent-link", "md_text": "For serialization, field inclusion and exclusion can be configured in two ways:\n\n* at the field level, using the `exclude` and `exclude_if` parameters on [the `Field()` function](../fields/index.html).\n* using the various serialization parameters on the [serialization methods](index.html#serializing-data).", "url": "https://docs.pydantic.dev/latest/concepts/serialization/index.html#field-inclusion-and-exclusionindexhtmlfield-inclusion-and-exclusion-permanent-link", "page": "concepts/serialization/index.html", "source_site": "pydantic"}
{"title": "At the field level[Â¶](index.html#at-the-field-level \"Permanent link\")", "anchor": "at-the-field-levelindexhtmlat-the-field-level-permanent-link", "md_text": "At the field level, the `exclude` and `exclude_if` parameters can be used:\n\n```\nfrom pydantic import BaseModel, Field\n\n\nclass Transaction(BaseModel):\n    id: int\n    private_id: int = Field(exclude=True)\n    value: int = Field(ge=0, exclude_if=lambda v: v == 0)\n\n\nprint(Transaction(id=1, private_id=2, value=0).model_dump())\n#> {'id': 1}\n```\n\nExclusion at the field level takes priority over the `include` serialization parameter described below.", "url": "https://docs.pydantic.dev/latest/concepts/serialization/index.html#at-the-field-levelindexhtmlat-the-field-level-permanent-link", "page": "concepts/serialization/index.html", "source_site": "pydantic"}
{"title": "As parameters to the serialization methods[Â¶](index.html#as-parameters-to-the-serialization-methods \"Permanent link\")", "anchor": "as-parameters-to-the-serialization-methodsindexhtmlas-parameters-to-the-serialization-methods-permanent-link", "md_text": "When using the [serialization methods](index.html#serializing-data) (such as [`model_dump()`](../../api/base_model/index.html#pydantic.BaseModel.model_dump)),\nseveral parameters can be used to exclude or include fields.\n\n#### Excluding and including specific fields[Â¶](index.html#excluding-and-including-specific-fields \"Permanent link\")\n\nConsider the following models:\n\n```\nfrom pydantic import BaseModel, Field, SecretStr\n\n\nclass User(BaseModel):\n    id: int\n    username: str\n    password: SecretStr\n\n\nclass Transaction(BaseModel):\n    id: str\n    private_id: str = Field(exclude=True)\n    user: User\n    value: int\n\n\nt = Transaction(\n    id='1234567890',\n    private_id='123',\n    user=User(id=42, username='JohnDoe', password='hashedpassword'),\n    value=9876543210,\n)\n```\n\nThe `exclude` parameter can be used to specify which fields should be excluded (including the others), and vice-versa\nusing the `include` parameter.\n\n```\n# using a set:\nprint(t.model_dump(exclude={'user', 'value'}))\n#> {'id': '1234567890'}\n\n# using a dictionary:\nprint(t.model_dump(exclude={'user': {'username', 'password'}, 'value': True}))\n#> {'id': '1234567890', 'user': {'id': 42}}\n\n# same configuration using `include`:\nprint(t.model_dump(include={'id': True, 'user': {'id'}}))\n#> {'id': '1234567890', 'user': {'id': 42}}\n```\n\nNote that using `False` to *include* a field in `exclude` (or to *exclude* a field in `include`) is not supported.\n\nIt is also possible to exclude or include specific items from sequence and dictionaries:\n\n```\nfrom pydantic import BaseModel\n\n\nclass Hobby(BaseModel):\n    name: str\n    info: str\n\n\nclass User(BaseModel):\n    hobbies: list[Hobby]\n\n\nuser = User(\n    hobbies=[\n        Hobby(name='Programming', info='Writing code and stuff'),\n        Hobby(name='Gaming', info='Hell Yeah!!!'),\n    ],\n)\n\nprint(user.model_dump(exclude={'hobbies': {-1: {'info'}}}))  # (1)!\n\"\"\"\n{\n    'hobbies': [\n        {'name': 'Programming', 'info': 'Writing code and stuff'},\n        {'name': 'Gaming'},\n    ]\n}\n\"\"\"\n```\n\n1. The equivalent call with `include` would be:\n\n   ```\n   user.model_dump(\n      include={'hobbies': {0: True, -1: {'name'}}}\n   )\n   ```\n\nThe special key `'__all__'` can be used to apply an exclusion/inclusion pattern to all members:\n\n```\nprint(user.model_dump(exclude={'hobbies': {'__all__': {'info'}}}))\n#> {'hobbies': [{'name': 'Programming'}, {'name': 'Gaming'}]}\n```\n\n#### Excluding and including fields based on their value[Â¶](index.html#excluding-and-including-fields-based-on-their-value \"Permanent link\")\n\nWhen using the [serialization methods](index.html#serializing-data), it is possible to exclude fields based on their value,\nusing the following parameters:\n\n* `exclude_defaults`: Exclude all fields whose value compares equal to the default value\n  (using the equality (`==`) comparison operator).\n* `exclude_none`: Exclude all fields whose value is `None`.\n* `exclude_unset`: Pydantic keeps track of fields that were *explicitly* set during instantiation (using the\n  [`model_fields_set`](../../api/base_model/index.html#pydantic.BaseModel.model_fields_set) property). Using `exclude_unset`, any field that\n  was not explicitly provided will be excluded:\n\n  ```\n  from pydantic import BaseModel\n\n\n  class UserModel(BaseModel):\n      name: str\n      age: int = 18\n\n\n  user = UserModel(name='John')\n  print(user.model_fields_set)\n  #> {'name'}\n\n  print(user.model_dump(exclude_unset=True))\n  #> {'name': 'John'}\n  ```\n\n  Note that altering a field *after* the instance has been created will remove it from the unset fields:\n\n  ```\n  user.age = 21\n\n  print(user.model_dump(exclude_unset=True))\n  #> {'name': 'John', 'age': 21}\n  ```\n\n  The experimental [`MISSING` sentinel](../experimental/index.html#missing-sentinel) can be used as an alternative to `exclude_unset`.\n  Any field with `MISSING` as a value is automatically excluded from the serialization output.\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/concepts/serialization/index.html#as-parameters-to-the-serialization-methodsindexhtmlas-parameters-to-the-serialization-methods-permanent-link", "page": "concepts/serialization/index.html", "source_site": "pydantic"}
{"title": "Custom Types[Â¶](index.html#custom-types \"Permanent link\")", "anchor": "custom-typesindexhtmlcustom-types-permanent-link", "md_text": "There are several ways to define your custom types.", "url": "https://docs.pydantic.dev/latest/concepts/types/index.html#custom-typesindexhtmlcustom-types-permanent-link", "page": "concepts/types/index.html", "source_site": "pydantic"}
{"title": "Using the annotated pattern[Â¶](index.html#using-the-annotated-pattern \"Permanent link\")", "anchor": "using-the-annotated-patternindexhtmlusing-the-annotated-pattern-permanent-link", "md_text": "The [annotated pattern](../fields/index.html#the-annotated-pattern) can be used to make types reusable across your code base.\nFor example, to create a type representing a positive integer:\n\n```\nfrom typing import Annotated\n\nfrom pydantic import Field, TypeAdapter, ValidationError\n\nPositiveInt = Annotated[int, Field(gt=0)]  # (1)!\n\nta = TypeAdapter(PositiveInt)\n\nprint(ta.validate_python(1))\n#> 1\n\ntry:\n    ta.validate_python(-1)\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for constrained-int\n      Input should be greater than 0 [type=greater_than, input_value=-1, input_type=int]\n    \"\"\"\n```\n\n1. Note that you can also use constraints from the [annotated-types](https://github.com/annotated-types/annotated-types)\n   library to make this Pydantic-agnostic:\n\n   ```\n   from annotated_types import Gt\n\n   PositiveInt = Annotated[int, Gt(0)]\n   ```\n\n#### Adding validation and serialization[Â¶](index.html#adding-validation-and-serialization \"Permanent link\")\n\nYou can add or override validation, serialization, and JSON schemas to an arbitrary type using the markers that\nPydantic exports:\n\n```\nfrom typing import Annotated\n\nfrom pydantic import (\n    AfterValidator,\n    PlainSerializer,\n    TypeAdapter,\n    WithJsonSchema,\n)\n\nTruncatedFloat = Annotated[\n    float,\n    AfterValidator(lambda x: round(x, 1)),\n    PlainSerializer(lambda x: f'{x:.1e}', return_type=str),\n    WithJsonSchema({'type': 'string'}, mode='serialization'),\n]\n\n\nta = TypeAdapter(TruncatedFloat)\n\ninput = 1.02345\nassert input != 1.0\n\nassert ta.validate_python(input) == 1.0\n\nassert ta.dump_json(input) == b'\"1.0e+00\"'\n\nassert ta.json_schema(mode='validation') == {'type': 'number'}\nassert ta.json_schema(mode='serialization') == {'type': 'string'}\n```\n\n#### Generics[Â¶](index.html#generics \"Permanent link\")\n\n[Type variables](https://docs.python.org/3/library/typing.html#typing.TypeVar) can be used within the [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated) type:\n\n```\nfrom typing import Annotated, TypeVar\n\nfrom annotated_types import Gt, Len\n\nfrom pydantic import TypeAdapter, ValidationError\n\nT = TypeVar('T')\n\n\nShortList = Annotated[list[T], Len(max_length=4)]\n\n\nta = TypeAdapter(ShortList[int])\n\nv = ta.validate_python([1, 2, 3, 4])\nassert v == [1, 2, 3, 4]\n\ntry:\n    ta.validate_python([1, 2, 3, 4, 5])\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for list[int]\n      List should have at most 4 items after validation, not 5 [type=too_long, input_value=[1, 2, 3, 4, 5], input_type=list]\n    \"\"\"\n\n\nPositiveList = list[Annotated[T, Gt(0)]]\n\nta = TypeAdapter(PositiveList[float])\n\nv = ta.validate_python([1.0])\nassert type(v[0]) is float\n\n\ntry:\n    ta.validate_python([-1.0])\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for list[constrained-float]\n    0\n      Input should be greater than 0 [type=greater_than, input_value=-1.0, input_type=float]\n    \"\"\"\n```", "url": "https://docs.pydantic.dev/latest/concepts/types/index.html#using-the-annotated-patternindexhtmlusing-the-annotated-pattern-permanent-link", "page": "concepts/types/index.html", "source_site": "pydantic"}
{"title": "Named type aliases[Â¶](index.html#named-type-aliases \"Permanent link\")", "anchor": "named-type-aliasesindexhtmlnamed-type-aliases-permanent-link", "md_text": "The above examples make use of *implicit* type aliases, assigned to a variable. At runtime, Pydantic\nhas no way of knowing the name of the variable it was assigned to, and this can be problematic for\ntwo reasons:\n\n* The [JSON Schema](../json_schema/index.html) of the alias won't be converted into a\n  [definition](https://json-schema.org/understanding-json-schema/structuring#defs).\n  This is mostly useful when you are using the alias more than once in a model definition.\n* In most cases, [recursive type aliases](index.html#named-recursive-types) won't work.\n\nBy leveraging the new [`type` statement](https://typing.readthedocs.io/en/latest/spec/aliases.html#type-statement)\n(introduced in [PEP 695](https://peps.python.org/pep-0695/)), you can define aliases as follows:\n\nPython 3.9 and abovePython 3.12 and above (new syntax)\n\n```\nfrom typing import Annotated\n\nfrom annotated_types import Gt\nfrom typing_extensions import TypeAliasType\n\nfrom pydantic import BaseModel\n\nPositiveIntList = TypeAliasType('PositiveIntList', list[Annotated[int, Gt(0)]])\n\n\nclass Model(BaseModel):\n    x: PositiveIntList\n    y: PositiveIntList\n\n\nprint(Model.model_json_schema())  # (1)!\n\"\"\"\n{\n    '$defs': {\n        'PositiveIntList': {\n            'items': {'exclusiveMinimum': 0, 'type': 'integer'},\n            'type': 'array',\n        }\n    },\n    'properties': {\n        'x': {'$ref': '#/$defs/PositiveIntList'},\n        'y': {'$ref': '#/$defs/PositiveIntList'},\n    },\n    'required': ['x', 'y'],\n    'title': 'Model',\n    'type': 'object',\n}\n\"\"\"\n```\n\n1. If `PositiveIntList` were to be defined as an implicit type alias, its definition\n   would have been duplicated in both `'x'` and `'y'`.\n\n```\nfrom typing import Annotated\n\nfrom annotated_types import Gt\n\nfrom pydantic import BaseModel\n\ntype PositiveIntList = list[Annotated[int, Gt(0)]]\n\n\nclass Model(BaseModel):\n    x: PositiveIntList\n    y: PositiveIntList\n\n\nprint(Model.model_json_schema())  # (1)!\n\"\"\"\n{\n    '$defs': {\n        'PositiveIntList': {\n            'items': {'exclusiveMinimum': 0, 'type': 'integer'},\n            'type': 'array',\n        }\n    },\n    'properties': {\n        'x': {'$ref': '#/$defs/PositiveIntList'},\n        'y': {'$ref': '#/$defs/PositiveIntList'},\n    },\n    'required': ['x', 'y'],\n    'title': 'Model',\n    'type': 'object',\n}\n\"\"\"\n```\n\n1. If `PositiveIntList` were to be defined as an implicit type alias, its definition\n   would have been duplicated in both `'x'` and `'y'`.\n\nWhile (named) PEP 695 and implicit type aliases are meant to be equivalent for static type checkers,\nPydantic will *not* understand field-specific metadata inside named aliases. That is, metadata such as\n`alias`, `default`, `deprecated`, *cannot* be used:\n\nPython 3.9 and abovePython 3.12 and above (new syntax)\n\n```\nfrom typing import Annotated\n\nfrom typing_extensions import TypeAliasType\n\nfrom pydantic import BaseModel, Field\n\nMyAlias = TypeAliasType('MyAlias', Annotated[int, Field(default=1)])\n\n\nclass Model(BaseModel):\n    x: MyAlias  # This is not allowed\n\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Field\n\ntype MyAlias = Annotated[int, Field(default=1)]\n\n\nclass Model(BaseModel):\n    x: MyAlias  # This is not allowed\n```\n\nOnly metadata that can be applied to the annotated type itself is allowed\n(e.g. [validation constraints](../fields/index.html#field-constraints) and JSON metadata).\nTrying to support field-specific metadata would require eagerly inspecting the\ntype alias's [`__value__`](https://docs.python.org/3/library/typing.html#typing.TypeAliasType.__value__), and as such Pydantic\nwouldn't be able to have the alias stored as a JSON Schema definition.\n\nAs with implicit type aliases, [type variables](https://docs.python.org/3/library/typing.html#typing.TypeVar) can also be used inside the generic alias:\n\nPython 3.9 and abovePython 3.12 and above (new syntax)\n\n```\nfrom typing import Annotated, TypeVar\n\nfrom annotated_types import Len\nfrom typing_extensions import TypeAliasType\n\nT = TypeVar('T')\n\nShortList = TypeAliasType(\n    'ShortList', Annotated[list[T], Len(max_length=4)], type_params=(T,)\n)\n\nfrom typing import Annotated, TypeVar\n\nfrom annotated_types import Len\n\ntype ShortList[T] = Annotated[list[T], Len(max_length=4)]\n```\n\n#### Named recursive types[Â¶](index.html#named-recursive-types \"Permanent link\")\n\nNamed type aliases should be used whenever you need to define recursive type aliases (1).\n\n1. For several reasons, Pydantic isn't able to support implicit recursive aliases. For\n   instance, it won't be able to resolve [forward annotations](../forward_annotations/index.html)\n   across modules.\n\nFor instance, here is an example definition of a JSON type:\n\nPython 3.9 and abovePython 3.12 and above (new syntax)\n\n```\nfrom typing import Union\n\nfrom typing_extensions import TypeAliasType\n\nfrom pydantic import TypeAdapter", "url": "https://docs.pydantic.dev/latest/concepts/types/index.html#named-type-aliasesindexhtmlnamed-type-aliases-permanent-link", "page": "concepts/types/index.html", "source_site": "pydantic"}
{"title": "Named type aliases[Â¶](index.html#named-type-aliases \"Permanent link\")", "anchor": "named-type-aliasesindexhtmlnamed-type-aliases-permanent-link", "md_text": "Json = TypeAliasType(\n    'Json',\n    'Union[dict[str, Json], list[Json], str, int, float, bool, None]',  # (1)!\n)\n\nta = TypeAdapter(Json)\nprint(ta.json_schema())\n\"\"\"\n{\n    '$defs': {\n        'Json': {\n            'anyOf': [\n                {\n                    'additionalProperties': {'$ref': '#/$defs/Json'},\n                    'type': 'object',\n                },\n                {'items': {'$ref': '#/$defs/Json'}, 'type': 'array'},\n                {'type': 'string'},\n                {'type': 'integer'},\n                {'type': 'number'},\n                {'type': 'boolean'},\n                {'type': 'null'},\n            ]\n        }\n    },\n    '$ref': '#/$defs/Json',\n}\n\"\"\"\n```\n\n1. Wrapping the annotation in quotes is necessary as it is eagerly evaluated\n   (and `Json` has yet to be defined).\n\n```\nfrom pydantic import TypeAdapter\n\ntype Json = dict[str, Json] | list[Json] | str | int | float | bool | None  # (1)!\n\nta = TypeAdapter(Json)\nprint(ta.json_schema())\n\"\"\"\n{\n    '$defs': {\n        'Json': {\n            'anyOf': [\n                {\n                    'additionalProperties': {'$ref': '#/$defs/Json'},\n                    'type': 'object',\n                },\n                {'items': {'$ref': '#/$defs/Json'}, 'type': 'array'},\n                {'type': 'string'},\n                {'type': 'integer'},\n                {'type': 'number'},\n                {'type': 'boolean'},\n                {'type': 'null'},\n            ]\n        }\n    },\n    '$ref': '#/$defs/Json',\n}\n\"\"\"\n```\n\n1. The value of a named type alias is lazily evaluated, so there's no need to use forward annotations.\n\nPydantic defines a [`JsonValue`](../../api/types/index.html#pydantic.types.JsonValue) type as a convenience.", "url": "https://docs.pydantic.dev/latest/concepts/types/index.html#named-type-aliasesindexhtmlnamed-type-aliases-permanent-link", "page": "concepts/types/index.html", "source_site": "pydantic"}
{"title": "Customizing validation with `__get_pydantic_core_schema__` [Â¶](index.html#customizing-validation-with-__get_pydantic_core_schema__ \"Permanent link\")", "anchor": "customizing-validation-with-getpydanticcoreschema-indexhtmlcustomizing-validation-with-getpydanticcoreschema-permanent-link", "md_text": "To do more extensive customization of how Pydantic handles custom classes, and in particular when you have access to the\nclass or can subclass it, you can implement a special `__get_pydantic_core_schema__` to tell Pydantic how to generate the\n`pydantic-core` schema.\n\nWhile `pydantic` uses `pydantic-core` internally to handle validation and serialization, it is a new API for Pydantic V2,\nthus it is one of the areas most likely to be tweaked in the future and you should try to stick to the built-in\nconstructs like those provided by `annotated-types`, `pydantic.Field`, or `BeforeValidator` and so on.\n\nYou can implement `__get_pydantic_core_schema__` both on a custom type and on metadata intended to be put in `Annotated`.\nIn both cases the API is middleware-like and similar to that of \"wrap\" validators: you get a `source_type` (which isn't\nnecessarily the same as the class, in particular for generics) and a `handler` that you can call with a type to either\ncall the next metadata in `Annotated` or call into Pydantic's internal schema generation.\n\nThe simplest no-op implementation calls the handler with the type you are given, then returns that as the result. You can\nalso choose to modify the type before calling the handler, modify the core schema returned by the handler, or not call the\nhandler at all.\n\n#### As a method on a custom type[Â¶](index.html#as-a-method-on-a-custom-type \"Permanent link\")\n\nThe following is an example of a type that uses `__get_pydantic_core_schema__` to customize how it gets validated.\nThis is equivalent to implementing `__get_validators__` in Pydantic V1.\n\n```\nfrom typing import Any\n\nfrom pydantic_core import CoreSchema, core_schema\n\nfrom pydantic import GetCoreSchemaHandler, TypeAdapter\n\n\nclass Username(str):\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source_type: Any, handler: GetCoreSchemaHandler\n    ) -> CoreSchema:\n        return core_schema.no_info_after_validator_function(cls, handler(str))\n\n\nta = TypeAdapter(Username)\nres = ta.validate_python('abc')\nassert isinstance(res, Username)\nassert res == 'abc'\n```\n\nSee [JSON Schema](../json_schema/index.html) for more details on how to customize JSON schemas for custom types.\n\n#### As an annotation[Â¶](index.html#as-an-annotation \"Permanent link\")\n\nOften you'll want to parametrize your custom type by more than just generic type parameters (which you can do via the type system and will be discussed later). Or you may not actually care (or want to) make an instance of your subclass; you actually want the original type, just with some extra validation done.\n\nFor example, if you were to implement `pydantic.AfterValidator` (see [Adding validation and serialization](index.html#adding-validation-and-serialization)) yourself, you'd do something similar to the following:\n\nPython 3.9 and abovePython 3.10 and above\n\n```\nfrom dataclasses import dataclass\nfrom typing import Annotated, Any, Callable\n\nfrom pydantic_core import CoreSchema, core_schema\n\nfrom pydantic import BaseModel, GetCoreSchemaHandler\n\n\n@dataclass(frozen=True)  # (1)!\nclass MyAfterValidator:\n    func: Callable[[Any], Any]\n\n    def __get_pydantic_core_schema__(\n        self, source_type: Any, handler: GetCoreSchemaHandler\n    ) -> CoreSchema:\n        return core_schema.no_info_after_validator_function(\n            self.func, handler(source_type)\n        )\n\n\nUsername = Annotated[str, MyAfterValidator(str.lower)]\n\n\nclass Model(BaseModel):\n    name: Username\n\n\nassert Model(name='ABC').name == 'abc'  # (2)!\n```\n\n1. The `frozen=True` specification makes `MyAfterValidator` hashable. Without this, a union such as `Username | None` will raise an error.\n2. Notice that type checkers will not complain about assigning `'ABC'` to `Username` like they did in the previous example because they do not consider `Username` to be a distinct type from `str`.\n\n```\nfrom dataclasses import dataclass\nfrom typing import Annotated, Any\nfrom collections.abc import Callable\n\nfrom pydantic_core import CoreSchema, core_schema\n\nfrom pydantic import BaseModel, GetCoreSchemaHandler\n\n\n@dataclass(frozen=True)  # (1)!\nclass MyAfterValidator:\n    func: Callable[[Any], Any]\n\n    def __get_pydantic_core_schema__(\n        self, source_type: Any, handler: GetCoreSchemaHandler\n    ) -> CoreSchema:\n        return core_schema.no_info_after_validator_function(\n            self.func, handler(source_type)\n        )\n\n\nUsername = Annotated[str, MyAfterValidator(str.lower)]\n\n\nclass Model(BaseModel):\n    name: Username\n\n\nassert Model(name='ABC').name == 'abc'  # (2)!\n```\n\n1. The `frozen=True` specification makes `MyAfterValidator` hashable. Without this, a union such as `Username | None` will raise an error.\n2. Notice that type checkers will not complain about assigning `'ABC'` to `Username` like they did in the previous example because they do not consider `Username` to be a distinct type from `str`.\n\n#### Handling third-party types[Â¶](index.html#handling-third-party-types \"Permanent link\")\n\nAnother use case for the pattern in the previous section is to handle third party types.\n\n```\nfrom typing import Annotated, Any\n\nfrom pydantic_core import core_schema", "url": "https://docs.pydantic.dev/latest/concepts/types/index.html#customizing-validation-with-getpydanticcoreschema-indexhtmlcustomizing-validation-with-getpydanticcoreschema-permanent-link", "page": "concepts/types/index.html", "source_site": "pydantic"}
{"title": "Customizing validation with `__get_pydantic_core_schema__` [Â¶](index.html#customizing-validation-with-__get_pydantic_core_schema__ \"Permanent link\")", "anchor": "customizing-validation-with-getpydanticcoreschema-indexhtmlcustomizing-validation-with-getpydanticcoreschema-permanent-link", "md_text": "from pydantic import (\n    BaseModel,\n    GetCoreSchemaHandler,\n    GetJsonSchemaHandler,\n    ValidationError,\n)\nfrom pydantic.json_schema import JsonSchemaValue\n\n\nclass ThirdPartyType:\n    \"\"\"\n    This is meant to represent a type from a third-party library that wasn't designed with Pydantic\n    integration in mind, and so doesn't have a `pydantic_core.CoreSchema` or anything.\n    \"\"\"\n\n    x: int\n\n    def __init__(self):\n        self.x = 0\n\n\nclass _ThirdPartyTypePydanticAnnotation:\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls,\n        _source_type: Any,\n        _handler: GetCoreSchemaHandler,\n    ) -> core_schema.CoreSchema:\n        \"\"\"\n        We return a pydantic_core.CoreSchema that behaves in the following ways:\n\n        * ints will be parsed as `ThirdPartyType` instances with the int as the x attribute\n        * `ThirdPartyType` instances will be parsed as `ThirdPartyType` instances without any changes\n        * Nothing else will pass validation\n        * Serialization will always return just an int\n        \"\"\"\n\n        def validate_from_int(value: int) -> ThirdPartyType:\n            result = ThirdPartyType()\n            result.x = value\n            return result\n\n        from_int_schema = core_schema.chain_schema(\n            [\n                core_schema.int_schema(),\n                core_schema.no_info_plain_validator_function(validate_from_int),\n            ]\n        )\n\n        return core_schema.json_or_python_schema(\n            json_schema=from_int_schema,\n            python_schema=core_schema.union_schema(\n                [\n                    # check if it's an instance first before doing any further work\n                    core_schema.is_instance_schema(ThirdPartyType),\n                    from_int_schema,\n                ]\n            ),\n            serialization=core_schema.plain_serializer_function_ser_schema(\n                lambda instance: instance.x\n            ),\n        )\n\n    @classmethod\n    def __get_pydantic_json_schema__(\n        cls, _core_schema: core_schema.CoreSchema, handler: GetJsonSchemaHandler\n    ) -> JsonSchemaValue:\n        # Use the same schema that would be used for `int`\n        return handler(core_schema.int_schema())\n\n\n# We now create an `Annotated` wrapper that we'll use as the annotation for fields on `BaseModel`s, etc.\nPydanticThirdPartyType = Annotated[\n    ThirdPartyType, _ThirdPartyTypePydanticAnnotation\n]\n\n\n# Create a model class that uses this annotation as a field\nclass Model(BaseModel):\n    third_party_type: PydanticThirdPartyType\n\n\n# Demonstrate that this field is handled correctly, that ints are parsed into `ThirdPartyType`, and that\n# these instances are also \"dumped\" directly into ints as expected.\nm_int = Model(third_party_type=1)\nassert isinstance(m_int.third_party_type, ThirdPartyType)\nassert m_int.third_party_type.x == 1\nassert m_int.model_dump() == {'third_party_type': 1}\n\n# Do the same thing where an instance of ThirdPartyType is passed in\ninstance = ThirdPartyType()\nassert instance.x == 0\ninstance.x = 10\n\nm_instance = Model(third_party_type=instance)\nassert isinstance(m_instance.third_party_type, ThirdPartyType)\nassert m_instance.third_party_type.x == 10\nassert m_instance.model_dump() == {'third_party_type': 10}\n\n# Demonstrate that validation errors are raised as expected for invalid inputs\ntry:\n    Model(third_party_type='a')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for Model\n    third_party_type.is-instance[ThirdPartyType]\n      Input should be an instance of ThirdPartyType [type=is_instance_of, input_value='a', input_type=str]\n    third_party_type.chain[int,function-plain[validate_from_int()]]\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='a', input_type=str]\n    \"\"\"\n\n\nassert Model.model_json_schema() == {\n    'properties': {\n        'third_party_type': {'title': 'Third Party Type', 'type': 'integer'}\n    },\n    'required': ['third_party_type'],\n    'title': 'Model',\n    'type': 'object',\n}\n```\n\nYou can use this approach to e.g. define behavior for Pandas or Numpy types.\n\n#### Using `GetPydanticSchema` to reduce boilerplate[Â¶](index.html#using-getpydanticschema-to-reduce-boilerplate \"Permanent link\")\n\nAPI Documentation\n\n[`pydantic.types.GetPydanticSchema`](../../api/types/index.html#pydantic.types.GetPydanticSchema)\n\nYou may notice that the above examples where we create a marker class require a good amount of boilerplate.\nFor many simple cases you can greatly minimize this by using `pydantic.GetPydanticSchema`:\n\n```\nfrom typing import Annotated\n\nfrom pydantic_core import core_schema\n\nfrom pydantic import BaseModel, GetPydanticSchema\n\n\nclass Model(BaseModel):\n    y: Annotated[\n        str,\n        GetPydanticSchema(\n            lambda tp, handler: core_schema.no_info_after_validator_function(\n                lambda x: x * 2, handler(tp)\n            )\n        ),\n    ]\n\n\nassert Model(y='ab').y == 'abab'\n```\n\n#### Summary[Â¶](index.html#summary \"Permanent link\")\n\nLet's recap:", "url": "https://docs.pydantic.dev/latest/concepts/types/index.html#customizing-validation-with-getpydanticcoreschema-indexhtmlcustomizing-validation-with-getpydanticcoreschema-permanent-link", "page": "concepts/types/index.html", "source_site": "pydantic"}
{"title": "Customizing validation with `__get_pydantic_core_schema__` [Â¶](index.html#customizing-validation-with-__get_pydantic_core_schema__ \"Permanent link\")", "anchor": "customizing-validation-with-getpydanticcoreschema-indexhtmlcustomizing-validation-with-getpydanticcoreschema-permanent-link", "md_text": "1. Pydantic provides high level hooks to customize types via `Annotated` like `AfterValidator` and `Field`. Use these when possible.\n2. Under the hood these use `pydantic-core` to customize validation, and you can hook into that directly using `GetPydanticSchema` or a marker class with `__get_pydantic_core_schema__`.\n3. If you really want a custom type you can implement `__get_pydantic_core_schema__` on the type itself.", "url": "https://docs.pydantic.dev/latest/concepts/types/index.html#customizing-validation-with-getpydanticcoreschema-indexhtmlcustomizing-validation-with-getpydanticcoreschema-permanent-link", "page": "concepts/types/index.html", "source_site": "pydantic"}
{"title": "Handling custom generic classes[Â¶](index.html#handling-custom-generic-classes \"Permanent link\")", "anchor": "handling-custom-generic-classesindexhtmlhandling-custom-generic-classes-permanent-link", "md_text": "This is an advanced technique that you might not need in the beginning. In most of\nthe cases you will probably be fine with standard Pydantic models.\n\nYou can use\n[Generic Classes](https://docs.python.org/3/library/typing.html#typing.Generic) as\nfield types and perform custom validation based on the \"type parameters\" (or sub-types)\nwith `__get_pydantic_core_schema__`.\n\nIf the Generic class that you are using as a sub-type has a classmethod\n`__get_pydantic_core_schema__`, you don't need to use\n[`arbitrary_types_allowed`](../../api/config/index.html#pydantic.config.ConfigDict.arbitrary_types_allowed) for it to work.\n\nBecause the `source_type` parameter is not the same as the `cls` parameter, you can use `typing.get_args` (or `typing_extensions.get_args`) to extract the generic parameters.\nThen you can use the `handler` to generate a schema for them by calling `handler.generate_schema`.\nNote that we do not do something like `handler(get_args(source_type)[0])` because we want to generate an unrelated\nschema for that generic parameter, not one that is influenced by the current context of `Annotated` metadata and such.\nThis is less important for custom types, but crucial for annotated metadata that modifies schema building.\n\nPython 3.9 and abovePython 3.10 and above\n\n```\nfrom dataclasses import dataclass\nfrom typing import Any, Generic, TypeVar\n\nfrom pydantic_core import CoreSchema, core_schema\nfrom typing_extensions import get_args, get_origin\n\nfrom pydantic import (\n    BaseModel,\n    GetCoreSchemaHandler,\n    ValidationError,\n    ValidatorFunctionWrapHandler,\n)\n\nItemType = TypeVar('ItemType')\n\n\n# This is not a pydantic model, it's an arbitrary generic class\n@dataclass\nclass Owner(Generic[ItemType]):\n    name: str\n    item: ItemType\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source_type: Any, handler: GetCoreSchemaHandler\n    ) -> CoreSchema:\n        origin = get_origin(source_type)\n        if origin is None:  # used as `x: Owner` without params\n            origin = source_type\n            item_tp = Any\n        else:\n            item_tp = get_args(source_type)[0]\n        # both calling handler(...) and handler.generate_schema(...)\n        # would work, but prefer the latter for conceptual and consistency reasons\n        item_schema = handler.generate_schema(item_tp)\n\n        def val_item(\n            v: Owner[Any], handler: ValidatorFunctionWrapHandler\n        ) -> Owner[Any]:\n            v.item = handler(v.item)\n            return v\n\n        python_schema = core_schema.chain_schema(\n            # `chain_schema` means do the following steps in order:\n            [\n                # Ensure the value is an instance of Owner\n                core_schema.is_instance_schema(cls),\n                # Use the item_schema to validate `items`\n                core_schema.no_info_wrap_validator_function(\n                    val_item, item_schema\n                ),\n            ]\n        )\n\n        return core_schema.json_or_python_schema(\n            # for JSON accept an object with name and item keys\n            json_schema=core_schema.chain_schema(\n                [\n                    core_schema.typed_dict_schema(\n                        {\n                            'name': core_schema.typed_dict_field(\n                                core_schema.str_schema()\n                            ),\n                            'item': core_schema.typed_dict_field(item_schema),\n                        }\n                    ),\n                    # after validating the json data convert it to python\n                    core_schema.no_info_before_validator_function(\n                        lambda data: Owner(\n                            name=data['name'], item=data['item']\n                        ),\n                        # note that we reuse the same schema here as below\n                        python_schema,\n                    ),\n                ]\n            ),\n            python_schema=python_schema,\n        )\n\n\nclass Car(BaseModel):\n    color: str\n\n\nclass House(BaseModel):\n    rooms: int\n\n\nclass Model(BaseModel):\n    car_owner: Owner[Car]\n    home_owner: Owner[House]\n\n\nmodel = Model(\n    car_owner=Owner(name='John', item=Car(color='black')),\n    home_owner=Owner(name='James', item=House(rooms=3)),\n)\nprint(model)\n\"\"\"\ncar_owner=Owner(name='John', item=Car(color='black')) home_owner=Owner(name='James', item=House(rooms=3))\n\"\"\"\n\ntry:\n    # If the values of the sub-types are invalid, we get an error\n    Model(\n        car_owner=Owner(name='John', item=House(rooms=3)),\n        home_owner=Owner(name='James', item=Car(color='black')),\n    )\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for Model\n    wine\n      Input should be a valid number, unable to parse string as a number [type=float_parsing, input_value='Kinda good', input_type=str]\n    cheese\n      Input should be a valid boolean, unable to interpret input [type=bool_parsing, input_value='yeah', input_type=str]\n    \"\"\"\n\n# Similarly with JSON\nmodel = Model.model_validate_json(\n    '{\"car_owner\":{\"name\":\"John\",\"item\":{\"color\":\"black\"}},\"home_owner\":{\"name\":\"James\",\"item\":{\"rooms\":3}}}'\n)\nprint(model)\n\"\"\"\ncar_owner=Owner(name='John', item=Car(color='black')) home_owner=Owner(name='James', item=House(rooms=3))\n\"\"\"", "url": "https://docs.pydantic.dev/latest/concepts/types/index.html#handling-custom-generic-classesindexhtmlhandling-custom-generic-classes-permanent-link", "page": "concepts/types/index.html", "source_site": "pydantic"}
{"title": "Handling custom generic classes[Â¶](index.html#handling-custom-generic-classes \"Permanent link\")", "anchor": "handling-custom-generic-classesindexhtmlhandling-custom-generic-classes-permanent-link", "md_text": "try:\n    Model.model_validate_json(\n        '{\"car_owner\":{\"name\":\"John\",\"item\":{\"rooms\":3}},\"home_owner\":{\"name\":\"James\",\"item\":{\"color\":\"black\"}}}'\n    )\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for Model\n    car_owner.item.color\n      Field required [type=missing, input_value={'rooms': 3}, input_type=dict]\n    home_owner.item.rooms\n      Field required [type=missing, input_value={'color': 'black'}, input_type=dict]\n    \"\"\"\n\nfrom dataclasses import dataclass\nfrom typing import Any, Generic, TypeVar\n\nfrom pydantic_core import CoreSchema, core_schema\nfrom typing import get_args, get_origin\n\nfrom pydantic import (\n    BaseModel,\n    GetCoreSchemaHandler,\n    ValidationError,\n    ValidatorFunctionWrapHandler,\n)\n\nItemType = TypeVar('ItemType')\n\n\n# This is not a pydantic model, it's an arbitrary generic class\n@dataclass\nclass Owner(Generic[ItemType]):\n    name: str\n    item: ItemType\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source_type: Any, handler: GetCoreSchemaHandler\n    ) -> CoreSchema:\n        origin = get_origin(source_type)\n        if origin is None:  # used as `x: Owner` without params\n            origin = source_type\n            item_tp = Any\n        else:\n            item_tp = get_args(source_type)[0]\n        # both calling handler(...) and handler.generate_schema(...)\n        # would work, but prefer the latter for conceptual and consistency reasons\n        item_schema = handler.generate_schema(item_tp)\n\n        def val_item(\n            v: Owner[Any], handler: ValidatorFunctionWrapHandler\n        ) -> Owner[Any]:\n            v.item = handler(v.item)\n            return v\n\n        python_schema = core_schema.chain_schema(\n            # `chain_schema` means do the following steps in order:\n            [\n                # Ensure the value is an instance of Owner\n                core_schema.is_instance_schema(cls),\n                # Use the item_schema to validate `items`\n                core_schema.no_info_wrap_validator_function(\n                    val_item, item_schema\n                ),\n            ]\n        )\n\n        return core_schema.json_or_python_schema(\n            # for JSON accept an object with name and item keys\n            json_schema=core_schema.chain_schema(\n                [\n                    core_schema.typed_dict_schema(\n                        {\n                            'name': core_schema.typed_dict_field(\n                                core_schema.str_schema()\n                            ),\n                            'item': core_schema.typed_dict_field(item_schema),\n                        }\n                    ),\n                    # after validating the json data convert it to python\n                    core_schema.no_info_before_validator_function(\n                        lambda data: Owner(\n                            name=data['name'], item=data['item']\n                        ),\n                        # note that we reuse the same schema here as below\n                        python_schema,\n                    ),\n                ]\n            ),\n            python_schema=python_schema,\n        )\n\n\nclass Car(BaseModel):\n    color: str\n\n\nclass House(BaseModel):\n    rooms: int\n\n\nclass Model(BaseModel):\n    car_owner: Owner[Car]\n    home_owner: Owner[House]\n\n\nmodel = Model(\n    car_owner=Owner(name='John', item=Car(color='black')),\n    home_owner=Owner(name='James', item=House(rooms=3)),\n)\nprint(model)\n\"\"\"\ncar_owner=Owner(name='John', item=Car(color='black')) home_owner=Owner(name='James', item=House(rooms=3))\n\"\"\"\n\ntry:\n    # If the values of the sub-types are invalid, we get an error\n    Model(\n        car_owner=Owner(name='John', item=House(rooms=3)),\n        home_owner=Owner(name='James', item=Car(color='black')),\n    )\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for Model\n    wine\n      Input should be a valid number, unable to parse string as a number [type=float_parsing, input_value='Kinda good', input_type=str]\n    cheese\n      Input should be a valid boolean, unable to interpret input [type=bool_parsing, input_value='yeah', input_type=str]\n    \"\"\"\n\n# Similarly with JSON\nmodel = Model.model_validate_json(\n    '{\"car_owner\":{\"name\":\"John\",\"item\":{\"color\":\"black\"}},\"home_owner\":{\"name\":\"James\",\"item\":{\"rooms\":3}}}'\n)\nprint(model)\n\"\"\"\ncar_owner=Owner(name='John', item=Car(color='black')) home_owner=Owner(name='James', item=House(rooms=3))\n\"\"\"\n\ntry:\n    Model.model_validate_json(\n        '{\"car_owner\":{\"name\":\"John\",\"item\":{\"rooms\":3}},\"home_owner\":{\"name\":\"James\",\"item\":{\"color\":\"black\"}}}'\n    )\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for Model\n    car_owner.item.color\n      Field required [type=missing, input_value={'rooms': 3}, input_type=dict]\n    home_owner.item.rooms\n      Field required [type=missing, input_value={'color': 'black'}, input_type=dict]\n    \"\"\"\n```\n\n#### Generic containers[Â¶](index.html#generic-containers \"Permanent link\")\n\nThe same idea can be applied to create generic container types, like a custom `Sequence` type:\n\nPython 3.9 and abovePython 3.10 and above\n\n```\nfrom collections.abc import Sequence\nfrom typing import Any, TypeVar\n\nfrom pydantic_core import ValidationError, core_schema\nfrom typing_extensions import get_args\n\nfrom pydantic import BaseModel, GetCoreSchemaHandler\n\nT = TypeVar('T')\n\n\nclass MySequence(Sequence[T]):\n    def __init__(self, v: Sequence[T]):\n        self.v = v\n\n    def __getitem__(self, i):\n        return self.v[i]", "url": "https://docs.pydantic.dev/latest/concepts/types/index.html#handling-custom-generic-classesindexhtmlhandling-custom-generic-classes-permanent-link", "page": "concepts/types/index.html", "source_site": "pydantic"}
{"title": "Handling custom generic classes[Â¶](index.html#handling-custom-generic-classes \"Permanent link\")", "anchor": "handling-custom-generic-classesindexhtmlhandling-custom-generic-classes-permanent-link", "md_text": "    def __len__(self):\n        return len(self.v)\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source: Any, handler: GetCoreSchemaHandler\n    ) -> core_schema.CoreSchema:\n        instance_schema = core_schema.is_instance_schema(cls)\n\n        args = get_args(source)\n        if args:\n            # replace the type and rely on Pydantic to generate the right schema\n            # for `Sequence`\n            sequence_t_schema = handler.generate_schema(Sequence[args[0]])\n        else:\n            sequence_t_schema = handler.generate_schema(Sequence)\n\n        non_instance_schema = core_schema.no_info_after_validator_function(\n            MySequence, sequence_t_schema\n        )\n        return core_schema.union_schema([instance_schema, non_instance_schema])\n\n\nclass M(BaseModel):\n    model_config = dict(validate_default=True)\n\n    s1: MySequence = [3]\n\n\nm = M()\nprint(m)\n#> s1=<__main__.MySequence object at 0x0123456789ab>\nprint(m.s1.v)\n#> [3]\n\n\nclass M(BaseModel):\n    s1: MySequence[int]\n\n\nM(s1=[1])\ntry:\n    M(s1=['a'])\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    2 validation errors for M\n    s1.is-instance[MySequence]\n      Input should be an instance of MySequence [type=is_instance_of, input_value=['a'], input_type=list]\n    s1.function-after[MySequence(), json-or-python[json=list[int],python=chain[is-instance[Sequence],function-wrap[sequence_validator()]]]].0\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='a', input_type=str]\n    \"\"\"\n\nfrom collections.abc import Sequence\nfrom typing import Any, TypeVar\n\nfrom pydantic_core import ValidationError, core_schema\nfrom typing import get_args\n\nfrom pydantic import BaseModel, GetCoreSchemaHandler\n\nT = TypeVar('T')\n\n\nclass MySequence(Sequence[T]):\n    def __init__(self, v: Sequence[T]):\n        self.v = v\n\n    def __getitem__(self, i):\n        return self.v[i]\n\n    def __len__(self):\n        return len(self.v)\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source: Any, handler: GetCoreSchemaHandler\n    ) -> core_schema.CoreSchema:\n        instance_schema = core_schema.is_instance_schema(cls)\n\n        args = get_args(source)\n        if args:\n            # replace the type and rely on Pydantic to generate the right schema\n            # for `Sequence`\n            sequence_t_schema = handler.generate_schema(Sequence[args[0]])\n        else:\n            sequence_t_schema = handler.generate_schema(Sequence)\n\n        non_instance_schema = core_schema.no_info_after_validator_function(\n            MySequence, sequence_t_schema\n        )\n        return core_schema.union_schema([instance_schema, non_instance_schema])\n\n\nclass M(BaseModel):\n    model_config = dict(validate_default=True)\n\n    s1: MySequence = [3]\n\n\nm = M()\nprint(m)\n#> s1=<__main__.MySequence object at 0x0123456789ab>\nprint(m.s1.v)\n#> [3]\n\n\nclass M(BaseModel):\n    s1: MySequence[int]\n\n\nM(s1=[1])\ntry:\n    M(s1=['a'])\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    2 validation errors for M\n    s1.is-instance[MySequence]\n      Input should be an instance of MySequence [type=is_instance_of, input_value=['a'], input_type=list]\n    s1.function-after[MySequence(), json-or-python[json=list[int],python=chain[is-instance[Sequence],function-wrap[sequence_validator()]]]].0\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='a', input_type=str]\n    \"\"\"\n```", "url": "https://docs.pydantic.dev/latest/concepts/types/index.html#handling-custom-generic-classesindexhtmlhandling-custom-generic-classes-permanent-link", "page": "concepts/types/index.html", "source_site": "pydantic"}
{"title": "Access to field name[Â¶](index.html#access-to-field-name \"Permanent link\")", "anchor": "access-to-field-nameindexhtmlaccess-to-field-name-permanent-link", "md_text": "This was not possible with Pydantic V2 to V2.3, it was [re-added](https://github.com/pydantic/pydantic/pull/7542) in Pydantic V2.4.\n\nAs of Pydantic V2.4, you can access the field name via the `handler.field_name` within `__get_pydantic_core_schema__`\nand thereby set the field name which will be available from `info.field_name`.\n\n```\nfrom typing import Any\n\nfrom pydantic_core import core_schema\n\nfrom pydantic import BaseModel, GetCoreSchemaHandler, ValidationInfo\n\n\nclass CustomType:\n    \"\"\"Custom type that stores the field it was used in.\"\"\"\n\n    def __init__(self, value: int, field_name: str):\n        self.value = value\n        self.field_name = field_name\n\n    def __repr__(self):\n        return f'CustomType<{self.value} {self.field_name!r}>'\n\n    @classmethod\n    def validate(cls, value: int, info: ValidationInfo):\n        return cls(value, info.field_name)\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source_type: Any, handler: GetCoreSchemaHandler\n    ) -> core_schema.CoreSchema:\n        return core_schema.with_info_after_validator_function(\n            cls.validate, handler(int)\n        )\n\n\nclass MyModel(BaseModel):\n    my_field: CustomType\n\n\nm = MyModel(my_field=1)\nprint(m.my_field)\n#> CustomType<1 'my_field'>\n```\n\nYou can also access `field_name` from the markers used with `Annotated`, like [`AfterValidator`](../../api/functional_validators/index.html#pydantic.functional_validators.AfterValidator).\n\n```\nfrom typing import Annotated\n\nfrom pydantic import AfterValidator, BaseModel, ValidationInfo\n\n\ndef my_validators(value: int, info: ValidationInfo):\n    return f'<{value} {info.field_name!r}>'\n\n\nclass MyModel(BaseModel):\n    my_field: Annotated[int, AfterValidator(my_validators)]\n\n\nm = MyModel(my_field=1)\nprint(m.my_field)\n#> <1 'my_field'>\n```\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/concepts/types/index.html#access-to-field-nameindexhtmlaccess-to-field-name-permanent-link", "page": "concepts/types/index.html", "source_site": "pydantic"}
{"title": "In general, use `model_validate_json()` not `model_validate(json.loads(...))`[Â¶](index.html#in-general-use-model_validate_json-not-model_validatejsonloads \"Permanent link\")", "anchor": "in-general-use-modelvalidatejson-not-modelvalidatejsonloadsindexhtmlin-general-use-modelvalidatejson-not-modelvalidatejsonloads-permanent-link", "md_text": "On `model_validate(json.loads(...))`, the JSON is parsed in Python, then converted to a dict, then it's validated internally.\nOn the other hand, `model_validate_json()` already performs the validation internally.\n\nThere are a few cases where `model_validate(json.loads(...))` may be faster. Specifically, when using a `'before'` or `'wrap'` validator\non a model, validation may be faster with the two step method. You can read more about these special cases in\n[this discussion](https://github.com/pydantic/pydantic/discussions/6388#discussioncomment-8193105).\n\nMany performance improvements are currently in the works for `pydantic-core`, see\n[this discussion](https://github.com/pydantic/pydantic/discussions/6388#discussioncomment-8194048).\nOnce these changes are merged, we should be at the point where `model_validate_json()` is always faster than `model_validate(json.loads(...))`.", "url": "https://docs.pydantic.dev/latest/concepts/performance/index.html#in-general-use-modelvalidatejson-not-modelvalidatejsonloadsindexhtmlin-general-use-modelvalidatejson-not-modelvalidatejsonloads-permanent-link", "page": "concepts/performance/index.html", "source_site": "pydantic"}
{"title": "`TypeAdapter` instantiated once[Â¶](index.html#typeadapter-instantiated-once \"Permanent link\")", "anchor": "typeadapter-instantiated-onceindexhtmltypeadapter-instantiated-once-permanent-link", "md_text": "The idea here is to avoid constructing validators and serializers more than necessary. Each time a `TypeAdapter` is instantiated,\nit will construct a new validator and serializer. If you're using a `TypeAdapter` in a function, it will be instantiated each time\nthe function is called. Instead, instantiate it once, and reuse it.\n\n![âŒ](https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.1.0/assets/svg/274c.svg \":x:\") Bad![âœ…](https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.1.0/assets/svg/2705.svg \":white_check_mark:\") Good\n\n```\nfrom pydantic import TypeAdapter\n\n\ndef my_func():\n    adapter = TypeAdapter(list[int])\n    # do something with adapter\n\nfrom pydantic import TypeAdapter\n\nadapter = TypeAdapter(list[int])\n\ndef my_func():\n    ...\n    # do something with adapter\n```", "url": "https://docs.pydantic.dev/latest/concepts/performance/index.html#typeadapter-instantiated-onceindexhtmltypeadapter-instantiated-once-permanent-link", "page": "concepts/performance/index.html", "source_site": "pydantic"}
{"title": "`Sequence` vs `list` or `tuple` with `Mapping` vs `dict`[Â¶](index.html#sequence-vs-list-or-tuple-with-mapping-vs-dict \"Permanent link\")", "anchor": "sequence-vs-list-or-tuple-with-mapping-vs-dictindexhtmlsequence-vs-list-or-tuple-with-mapping-vs-dict-permanent-link", "md_text": "When using `Sequence`, Pydantic calls `isinstance(value, Sequence)` to check if the value is a sequence.\nAlso, Pydantic will try to validate against different types of sequences, like `list` and `tuple`.\nIf you know the value is a `list` or `tuple`, use `list` or `tuple` instead of `Sequence`.\n\nThe same applies to `Mapping` and `dict`.\nIf you know the value is a `dict`, use `dict` instead of `Mapping`.", "url": "https://docs.pydantic.dev/latest/concepts/performance/index.html#sequence-vs-list-or-tuple-with-mapping-vs-dictindexhtmlsequence-vs-list-or-tuple-with-mapping-vs-dict-permanent-link", "page": "concepts/performance/index.html", "source_site": "pydantic"}
{"title": "Don't do validation when you don't have to, use `Any` to keep the value unchanged[Â¶](index.html#dont-do-validation-when-you-dont-have-to-use-any-to-keep-the-value-unchanged \"Permanent link\")", "anchor": "dont-do-validation-when-you-dont-have-to-use-any-to-keep-the-value-unchangedindexhtmldont-do-validation-when-you-dont-have-to-use-any-to-keep-the-value-unchanged-permanent-link", "md_text": "If you don't need to validate a value, use `Any` to keep the value unchanged.\n\n```\nfrom typing import Any\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    a: Any\n\n\nmodel = Model(a=1)\n```", "url": "https://docs.pydantic.dev/latest/concepts/performance/index.html#dont-do-validation-when-you-dont-have-to-use-any-to-keep-the-value-unchangedindexhtmldont-do-validation-when-you-dont-have-to-use-any-to-keep-the-value-unchanged-permanent-link", "page": "concepts/performance/index.html", "source_site": "pydantic"}
{"title": "Avoid extra information via subclasses of primitives[Â¶](index.html#avoid-extra-information-via-subclasses-of-primitives \"Permanent link\")", "anchor": "avoid-extra-information-via-subclasses-of-primitivesindexhtmlavoid-extra-information-via-subclasses-of-primitives-permanent-link", "md_text": "Don't do thisDo this\n\n```\nclass CompletedStr(str):\n    def __init__(self, s: str):\n        self.s = s\n        self.done = False\n\nfrom pydantic import BaseModel\n\n\nclass CompletedModel(BaseModel):\n    s: str\n    done: bool = False\n```", "url": "https://docs.pydantic.dev/latest/concepts/performance/index.html#avoid-extra-information-via-subclasses-of-primitivesindexhtmlavoid-extra-information-via-subclasses-of-primitives-permanent-link", "page": "concepts/performance/index.html", "source_site": "pydantic"}
{"title": "Use tagged union, not union[Â¶](index.html#use-tagged-union-not-union \"Permanent link\")", "anchor": "use-tagged-union-not-unionindexhtmluse-tagged-union-not-union-permanent-link", "md_text": "Tagged union (or discriminated union) is a union with a field that indicates which type it is.\n\n```\nfrom typing import Any, Literal\n\nfrom pydantic import BaseModel, Field\n\n\nclass DivModel(BaseModel):\n    el_type: Literal['div'] = 'div'\n    class_name: str | None = None\n    children: list[Any] | None = None\n\n\nclass SpanModel(BaseModel):\n    el_type: Literal['span'] = 'span'\n    class_name: str | None = None\n    contents: str | None = None\n\n\nclass ButtonModel(BaseModel):\n    el_type: Literal['button'] = 'button'\n    class_name: str | None = None\n    contents: str | None = None\n\n\nclass InputModel(BaseModel):\n    el_type: Literal['input'] = 'input'\n    class_name: str | None = None\n    value: str | None = None\n\n\nclass Html(BaseModel):\n    contents: DivModel | SpanModel | ButtonModel | InputModel = Field(\n        discriminator='el_type'\n    )\n```\n\nSee [Discriminated Unions](../unions/index.html#discriminated-unions) for more details.", "url": "https://docs.pydantic.dev/latest/concepts/performance/index.html#use-tagged-union-not-unionindexhtmluse-tagged-union-not-union-permanent-link", "page": "concepts/performance/index.html", "source_site": "pydantic"}
{"title": "Use `TypedDict` over nested models[Â¶](index.html#use-typeddict-over-nested-models \"Permanent link\")", "anchor": "use-typeddict-over-nested-modelsindexhtmluse-typeddict-over-nested-models-permanent-link", "md_text": "Instead of using nested models, use `TypedDict` to define the structure of the data.\n\nPerformance comparison\n\nWith a simple benchmark, `TypedDict` is about ~2.5x faster than nested models:\n\n```\nfrom timeit import timeit\n\nfrom typing_extensions import TypedDict\n\nfrom pydantic import BaseModel, TypeAdapter\n\n\nclass A(TypedDict):\n    a: str\n    b: int\n\n\nclass TypedModel(TypedDict):\n    a: A\n\n\nclass B(BaseModel):\n    a: str\n    b: int\n\n\nclass Model(BaseModel):\n    b: B\n\n\nta = TypeAdapter(TypedModel)\nresult1 = timeit(\n    lambda: ta.validate_python({'a': {'a': 'a', 'b': 2}}), number=10000\n)\nresult2 = timeit(\n    lambda: Model.model_validate({'b': {'a': 'a', 'b': 2}}), number=10000\n)\nprint(result2 / result1)\n```", "url": "https://docs.pydantic.dev/latest/concepts/performance/index.html#use-typeddict-over-nested-modelsindexhtmluse-typeddict-over-nested-models-permanent-link", "page": "concepts/performance/index.html", "source_site": "pydantic"}
{"title": "Avoid wrap validators if you really care about performance[Â¶](index.html#avoid-wrap-validators-if-you-really-care-about-performance \"Permanent link\")", "anchor": "avoid-wrap-validators-if-you-really-care-about-performanceindexhtmlavoid-wrap-validators-if-you-really-care-about-performance-permanent-link", "md_text": "Wrap validators are generally slower than other validators. This is because they require\nthat data is materialized in Python during validation. Wrap validators can be incredibly useful\nfor complex validation logic, but if you're looking for the best performance, you should avoid them.", "url": "https://docs.pydantic.dev/latest/concepts/performance/index.html#avoid-wrap-validators-if-you-really-care-about-performanceindexhtmlavoid-wrap-validators-if-you-really-care-about-performance-permanent-link", "page": "concepts/performance/index.html", "source_site": "pydantic"}
{"title": "Failing early with `FailFast`[Â¶](index.html#failing-early-with-failfast \"Permanent link\")", "anchor": "failing-early-with-failfastindexhtmlfailing-early-with-failfast-permanent-link", "md_text": "Starting in v2.8+, you can apply the `FailFast` annotation to sequence types to fail early if any item in the sequence fails validation.\nIf you use this annotation, you won't get validation errors for the rest of the items in the sequence if one fails, so you're effectively\ntrading off visibility for performance.\n\n```\nfrom typing import Annotated\n\nfrom pydantic import FailFast, TypeAdapter, ValidationError\n\nta = TypeAdapter(Annotated[list[bool], FailFast()])\ntry:\n    ta.validate_python([True, 'invalid', False, 'also invalid'])\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for list[bool]\n    1\n      Input should be a valid boolean, unable to interpret input [type=bool_parsing, input_value='invalid', input_type=str]\n    \"\"\"\n```\n\nRead more about `FailFast` [here](../../api/types/index.html#pydantic.types.FailFast).\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/concepts/performance/index.html#failing-early-with-failfastindexhtmlfailing-early-with-failfast-permanent-link", "page": "concepts/performance/index.html", "source_site": "pydantic"}
{"title": "As a validation parameter[Â¶](index.html#as-a-validation-parameter \"Permanent link\")", "anchor": "as-a-validation-parameterindexhtmlas-a-validation-parameter-permanent-link", "md_text": "Strict mode can be enaled on a per-validation-call basis, when using the [validation methods](../models/index.html#validating-data)\non [Pydantic models](../models/index.html) and [type adapters](../type_adapter/index.html).\n\n```\nfrom datetime import date\n\nfrom pydantic import TypeAdapter, ValidationError\n\nprint(TypeAdapter(date).validate_python('2000-01-01'))  # OK: lax\n#> 2000-01-01\n\ntry:\n    # Not OK: strict:\n    TypeAdapter(date).validate_python('2000-01-01', strict=True)\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for date\n      Input should be a valid date [type=date_type, input_value='2000-01-01', input_type=str]\n    \"\"\"\n\nTypeAdapter(date).validate_json('\"2000-01-01\"', strict=True)  # (1)!\n#> 2000-01-01\n```\n\n1. As mentioned, strict mode is looser when validating from JSON.", "url": "https://docs.pydantic.dev/latest/concepts/strict_mode/index.html#as-a-validation-parameterindexhtmlas-a-validation-parameter-permanent-link", "page": "concepts/strict_mode/index.html", "source_site": "pydantic"}
{"title": "At the field level[Â¶](index.html#at-the-field-level \"Permanent link\")", "anchor": "at-the-field-levelindexhtmlat-the-field-level-permanent-link", "md_text": "Strict mode can be enabled on specific fields, by setting the `strict` parameter of the\n[`Field()`](../../api/fields/index.html#pydantic.fields.Field) function to `True`. Strict mode will be applied for such fields,\neven when the [validation methods](../models/index.html#validating-data) are called in lax mode.\n\n```\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass User(BaseModel):\n    name: str\n    age: int = Field(strict=True)  # (1)!\n\n\nuser = User(name='John', age=42)\nprint(user)\n#> name='John' age=42\n\n\ntry:\n    another_user = User(name='John', age='42')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n    age\n      Input should be a valid integer [type=int_type, input_value='42', input_type=str]\n    \"\"\"\n```\n\n1. The strict constraint can also be applied using the [annotated pattern](../fields/index.html#the-annotated-pattern):\n   `Annotated[int, Field(strict=True)]`", "url": "https://docs.pydantic.dev/latest/concepts/strict_mode/index.html#at-the-field-levelindexhtmlat-the-field-level-permanent-link", "page": "concepts/strict_mode/index.html", "source_site": "pydantic"}
{"title": "Using the `Strict()` metadata class[Â¶](index.html#using-the-strict-metadata-class \"Permanent link\")", "anchor": "using-the-strict-metadata-classindexhtmlusing-the-strict-metadata-class-permanent-link", "md_text": "API Documentation\n\n[`pydantic.types.Strict`](../../api/types/index.html#pydantic.types.Strict)\n\nAs an alternative to the [`Field()`](../../api/fields/index.html#pydantic.fields.Field) function, Pydantic provides the [`Strict`](../../api/types/index.html#pydantic.types.Strict)\nmetadata class, meant to be used with the [annotated pattern](../fields/index.html#the-annotated-pattern). It also provides\nconvenience aliases for the most common types (namely [`StrictBool`](../../api/types/index.html#pydantic.types.StrictBool),\n[`StrictInt`](../../api/types/index.html#pydantic.types.StrictInt), [`StrictFloat`](../../api/types/index.html#pydantic.types.StrictFloat), [`StrictStr`](../../api/types/index.html#pydantic.types.StrictStr)\nand [`StrictBytes`](../../api/types/index.html#pydantic.types.StrictBytes)).\n\n```\nfrom typing import Annotated\nfrom uuid import UUID\n\nfrom pydantic import BaseModel, Strict, StrictInt\n\n\nclass User(BaseModel):\n    id: Annotated[UUID, Strict()]\n    age: StrictInt  # (1)!\n```\n\n1. Equivalent to `Annotated[int, Strict()]`.", "url": "https://docs.pydantic.dev/latest/concepts/strict_mode/index.html#using-the-strict-metadata-classindexhtmlusing-the-strict-metadata-class-permanent-link", "page": "concepts/strict_mode/index.html", "source_site": "pydantic"}
{"title": "As a configuration value[Â¶](index.html#as-a-configuration-value \"Permanent link\")", "anchor": "as-a-configuration-valueindexhtmlas-a-configuration-value-permanent-link", "md_text": "Strict mode behavior can be controlled at the [configuration](../config/index.html) level. When used on\na Pydantic model (or model like class such as [dataclasses](../dataclasses/index.html)), strictness can still\nbe overridden at the [field level](index.html#at-the-field-level):\n\n```\nfrom pydantic import BaseModel, ConfigDict, Field\n\n\nclass User(BaseModel):\n    model_config = ConfigDict(strict=True)\n\n    name: str\n    age: int = Field(strict=False)\n\n\nprint(User(name='John', age='18'))\n#> name='John' age=18\n```\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/concepts/strict_mode/index.html#as-a-configuration-valueindexhtmlas-a-configuration-value-permanent-link", "page": "concepts/strict_mode/index.html", "source_site": "pydantic"}
{"title": "Dataclass config[Â¶](index.html#dataclass-config \"Permanent link\")", "anchor": "dataclass-configindexhtmldataclass-config-permanent-link", "md_text": "If you want to modify the configuration like you would with a [`BaseModel`](../../api/base_model/index.html#pydantic.BaseModel), you have two options:\n\n* Use the `config` argument of the decorator.\n* Define the configuration with the `__pydantic_config__` attribute.\n\n```\nfrom pydantic import ConfigDict\nfrom pydantic.dataclasses import dataclass\n\n\n# Option 1 -- using the decorator argument:\n@dataclass(config=ConfigDict(validate_assignment=True))  # (1)!\nclass MyDataclass1:\n    a: int\n\n\n# Option 2 -- using an attribute:\n@dataclass\nclass MyDataclass2:\n    a: int\n\n    __pydantic_config__ = ConfigDict(validate_assignment=True)\n```\n\n1. You can read more about `validate_assignment` in the [API reference](../../api/config/index.html#pydantic.config.ConfigDict.validate_assignment).\n\nWhile Pydantic dataclasses support the [`extra`](../../api/config/index.html#pydantic.config.ConfigDict.extra) configuration value, some default\nbehavior of stdlib dataclasses may prevail. For example, any extra fields present on a Pydantic dataclass with\n[`extra`](../../api/config/index.html#pydantic.config.ConfigDict.extra) set to `'allow'` are omitted in the dataclass' string representation.\nThere is also no way to provide validation [using the `__pydantic_extra__` attribute](../models/index.html#extra-data).", "url": "https://docs.pydantic.dev/latest/concepts/dataclasses/index.html#dataclass-configindexhtmldataclass-config-permanent-link", "page": "concepts/dataclasses/index.html", "source_site": "pydantic"}
{"title": "Rebuilding dataclass schema[Â¶](index.html#rebuilding-dataclass-schema \"Permanent link\")", "anchor": "rebuilding-dataclass-schemaindexhtmlrebuilding-dataclass-schema-permanent-link", "md_text": "The [`rebuild_dataclass()`](../../api/dataclasses/index.html#pydantic.dataclasses.rebuild_dataclass) function can be used to rebuild the core schema of the dataclass.\nSee the [rebuilding model schema](../models/index.html#rebuilding-model-schema) section for more details.", "url": "https://docs.pydantic.dev/latest/concepts/dataclasses/index.html#rebuilding-dataclass-schemaindexhtmlrebuilding-dataclass-schema-permanent-link", "page": "concepts/dataclasses/index.html", "source_site": "pydantic"}
{"title": "Stdlib dataclasses and Pydantic dataclasses[Â¶](index.html#stdlib-dataclasses-and-pydantic-dataclasses \"Permanent link\")", "anchor": "stdlib-dataclasses-and-pydantic-dataclassesindexhtmlstdlib-dataclasses-and-pydantic-dataclasses-permanent-link", "md_text": "", "url": "https://docs.pydantic.dev/latest/concepts/dataclasses/index.html#stdlib-dataclasses-and-pydantic-dataclassesindexhtmlstdlib-dataclasses-and-pydantic-dataclasses-permanent-link", "page": "concepts/dataclasses/index.html", "source_site": "pydantic"}
{"title": "Inherit from stdlib dataclasses[Â¶](index.html#inherit-from-stdlib-dataclasses \"Permanent link\")", "anchor": "inherit-from-stdlib-dataclassesindexhtmlinherit-from-stdlib-dataclasses-permanent-link", "md_text": "Stdlib dataclasses (nested or not) can also be inherited and Pydantic will automatically validate\nall the inherited fields.\n\n```\nimport dataclasses\n\nimport pydantic\n\n\n@dataclasses.dataclass\nclass Z:\n    z: int\n\n\n@dataclasses.dataclass\nclass Y(Z):\n    y: int = 0\n\n\n@pydantic.dataclasses.dataclass\nclass X(Y):\n    x: int = 0\n\n\nfoo = X(x=b'1', y='2', z='3')\nprint(foo)\n#> X(z=3, y=2, x=1)\n\ntry:\n    X(z='pika')\nexcept pydantic.ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for X\n    z\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='pika', input_type=str]\n    \"\"\"\n```\n\nThe decorator can also be applied directly on a stdlib dataclass, in which case a new subclass will be created:\n\n```\nimport dataclasses\n\nimport pydantic\n\n\n@dataclasses.dataclass\nclass A:\n    a: int\n\n\nPydanticA = pydantic.dataclasses.dataclass(A)\nprint(PydanticA(a='1'))\n#> A(a=1)\n```", "url": "https://docs.pydantic.dev/latest/concepts/dataclasses/index.html#inherit-from-stdlib-dataclassesindexhtmlinherit-from-stdlib-dataclasses-permanent-link", "page": "concepts/dataclasses/index.html", "source_site": "pydantic"}
{"title": "Usage of stdlib dataclasses with `BaseModel`[Â¶](index.html#usage-of-stdlib-dataclasses-with-basemodel \"Permanent link\")", "anchor": "usage-of-stdlib-dataclasses-with-basemodelindexhtmlusage-of-stdlib-dataclasses-with-basemodel-permanent-link", "md_text": "When a standard library dataclass is used within a Pydantic model, a Pydantic dataclass or a [`TypeAdapter`](../../api/type_adapter/index.html#pydantic.type_adapter.TypeAdapter),\nvalidation will be applied (and the [configuration](index.html#dataclass-config) stays the same). This means that using a stdlib or a Pydantic\ndataclass as a field annotation is functionally equivalent.\n\nPython 3.9 and abovePython 3.10 and above\n\n```\nimport dataclasses\nfrom typing import Optional\n\nfrom pydantic import BaseModel, ConfigDict, ValidationError\n\n\n@dataclasses.dataclass(frozen=True)\nclass User:\n    name: str\n\n\nclass Foo(BaseModel):\n    # Required so that pydantic revalidates the model attributes:\n    model_config = ConfigDict(revalidate_instances='always')\n\n    user: Optional[User] = None\n\n\n# nothing is validated as expected:\nuser = User(name=['not', 'a', 'string'])\nprint(user)\n#> User(name=['not', 'a', 'string'])\n\n\ntry:\n    Foo(user=user)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Foo\n    user.name\n      Input should be a valid string [type=string_type, input_value=['not', 'a', 'string'], input_type=list]\n    \"\"\"\n\nfoo = Foo(user=User(name='pika'))\ntry:\n    foo.user.name = 'bulbi'\nexcept dataclasses.FrozenInstanceError as e:\n    print(e)\n    #> cannot assign to field 'name'\n\nimport dataclasses\n\nfrom pydantic import BaseModel, ConfigDict, ValidationError\n\n\n@dataclasses.dataclass(frozen=True)\nclass User:\n    name: str\n\n\nclass Foo(BaseModel):\n    # Required so that pydantic revalidates the model attributes:\n    model_config = ConfigDict(revalidate_instances='always')\n\n    user: User | None = None\n\n\n# nothing is validated as expected:\nuser = User(name=['not', 'a', 'string'])\nprint(user)\n#> User(name=['not', 'a', 'string'])\n\n\ntry:\n    Foo(user=user)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Foo\n    user.name\n      Input should be a valid string [type=string_type, input_value=['not', 'a', 'string'], input_type=list]\n    \"\"\"\n\nfoo = Foo(user=User(name='pika'))\ntry:\n    foo.user.name = 'bulbi'\nexcept dataclasses.FrozenInstanceError as e:\n    print(e)\n    #> cannot assign to field 'name'\n```", "url": "https://docs.pydantic.dev/latest/concepts/dataclasses/index.html#usage-of-stdlib-dataclasses-with-basemodelindexhtmlusage-of-stdlib-dataclasses-with-basemodel-permanent-link", "page": "concepts/dataclasses/index.html", "source_site": "pydantic"}
{"title": "Using custom types[Â¶](index.html#using-custom-types \"Permanent link\")", "anchor": "using-custom-typesindexhtmlusing-custom-types-permanent-link", "md_text": "As said above, validation is applied on standard library dataclasses. If you make use\nof custom types, you will get an error when trying to refer to the dataclass. To circumvent\nthe issue, you can set the [`arbitrary_types_allowed`](../../api/config/index.html#pydantic.config.ConfigDict.arbitrary_types_allowed)\nconfiguration value on the dataclass:\n\n```\nimport dataclasses\n\nfrom pydantic import BaseModel, ConfigDict\nfrom pydantic.errors import PydanticSchemaGenerationError\n\n\nclass ArbitraryType:\n    def __init__(self, value):\n        self.value = value\n\n    def __repr__(self):\n        return f'ArbitraryType(value={self.value!r})'\n\n\n@dataclasses.dataclass\nclass DC:\n    a: ArbitraryType\n    b: str\n\n\n# valid as it is a stdlib dataclass without validation:\nmy_dc = DC(a=ArbitraryType(value=3), b='qwe')\n\ntry:\n\n    class Model(BaseModel):\n        dc: DC\n        other: str\n\n    # invalid as dc is now validated with pydantic, and ArbitraryType is not a known type\n    Model(dc=my_dc, other='other')\n\nexcept PydanticSchemaGenerationError as e:\n    print(e.message)\n    \"\"\"\n    Unable to generate pydantic-core schema for <class '__main__.ArbitraryType'>. Set `arbitrary_types_allowed=True` in the model_config to ignore this error or implement `__get_pydantic_core_schema__` on your type to fully support it.\n\n    If you got this error by calling handler(<some type>) within `__get_pydantic_core_schema__` then you likely need to call `handler.generate_schema(<some type>)` since we do not call `__get_pydantic_core_schema__` on `<some type>` otherwise to avoid infinite recursion.\n    \"\"\"\n\n\n# valid as we set arbitrary_types_allowed=True, and that config pushes down to the nested vanilla dataclass\nclass Model(BaseModel):\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n    dc: DC\n    other: str\n\n\nm = Model(dc=my_dc, other='other')\nprint(repr(m))\n#> Model(dc=DC(a=ArbitraryType(value=3), b='qwe'), other='other')\n```", "url": "https://docs.pydantic.dev/latest/concepts/dataclasses/index.html#using-custom-typesindexhtmlusing-custom-types-permanent-link", "page": "concepts/dataclasses/index.html", "source_site": "pydantic"}
{"title": "Checking if a dataclass is a Pydantic dataclass[Â¶](index.html#checking-if-a-dataclass-is-a-pydantic-dataclass \"Permanent link\")", "anchor": "checking-if-a-dataclass-is-a-pydantic-dataclassindexhtmlchecking-if-a-dataclass-is-a-pydantic-dataclass-permanent-link", "md_text": "Pydantic dataclasses are still considered dataclasses, so using [`dataclasses.is_dataclass()`](https://docs.python.org/3/library/dataclasses.html#dataclasses.is_dataclass)\nwill return `True`. To check if a type is specifically a Pydantic dataclass you can use the\n[`is_pydantic_dataclass()`](../../api/dataclasses/index.html#pydantic.dataclasses.is_pydantic_dataclass) function.\n\n```\nimport dataclasses\n\nimport pydantic\n\n\n@dataclasses.dataclass\nclass StdLibDataclass:\n    id: int\n\n\nPydanticDataclass = pydantic.dataclasses.dataclass(StdLibDataclass)\n\nprint(dataclasses.is_dataclass(StdLibDataclass))\n#> True\nprint(pydantic.dataclasses.is_pydantic_dataclass(StdLibDataclass))\n#> False\n\nprint(dataclasses.is_dataclass(PydanticDataclass))\n#> True\nprint(pydantic.dataclasses.is_pydantic_dataclass(PydanticDataclass))\n#> True\n```", "url": "https://docs.pydantic.dev/latest/concepts/dataclasses/index.html#checking-if-a-dataclass-is-a-pydantic-dataclassindexhtmlchecking-if-a-dataclass-is-a-pydantic-dataclass-permanent-link", "page": "concepts/dataclasses/index.html", "source_site": "pydantic"}
{"title": "Validators and initialization hooks[Â¶](index.html#validators-and-initialization-hooks \"Permanent link\")", "anchor": "validators-and-initialization-hooksindexhtmlvalidators-and-initialization-hooks-permanent-link", "md_text": "Validators also work with Pydantic dataclasses:\n\n```\nfrom pydantic import field_validator\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass DemoDataclass:\n    product_id: str  # should be a five-digit string, may have leading zeros\n\n    @field_validator('product_id', mode='before')\n    @classmethod\n    def convert_int_serial(cls, v):\n        if isinstance(v, int):\n            v = str(v).zfill(5)\n        return v\n\n\nprint(DemoDataclass(product_id='01234'))\n#> DemoDataclass(product_id='01234')\nprint(DemoDataclass(product_id=2468))\n#> DemoDataclass(product_id='02468')\n```\n\nThe dataclass [`__post_init__()`](https://docs.python.org/3/library/dataclasses.html#dataclasses.__post_init__) method is also supported, and will\nbe called between the calls to *before* and *after* model validators.\n\nExample\n\n```\nfrom pydantic_core import ArgsKwargs\nfrom typing_extensions import Self\n\nfrom pydantic import model_validator\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass Birth:\n    year: int\n    month: int\n    day: int\n\n\n@dataclass\nclass User:\n    birth: Birth\n\n    @model_validator(mode='before')\n    @classmethod\n    def before(cls, values: ArgsKwargs) -> ArgsKwargs:\n        print(f'First: {values}')  # (1)!\n        \"\"\"\n        First: ArgsKwargs((), {'birth': {'year': 1995, 'month': 3, 'day': 2}})\n        \"\"\"\n        return values\n\n    @model_validator(mode='after')\n    def after(self) -> Self:\n        print(f'Third: {self}')\n        #> Third: User(birth=Birth(year=1995, month=3, day=2))\n        return self\n\n    def __post_init__(self):\n        print(f'Second: {self.birth}')\n        #> Second: Birth(year=1995, month=3, day=2)\n\n\nuser = User(**{'birth': {'year': 1995, 'month': 3, 'day': 2}})\n```\n\n1. Unlike Pydantic models, the `values` parameter is of type [`ArgsKwargs`](../../api/pydantic_core/index.html#pydantic_core.ArgsKwargs)\n\n\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/concepts/dataclasses/index.html#validators-and-initialization-hooksindexhtmlvalidators-and-initialization-hooks-permanent-link", "page": "concepts/dataclasses/index.html", "source_site": "pydantic"}
{"title": "Json Parsing[Â¶](index.html#json-parsing \"Permanent link\")", "anchor": "json-parsingindexhtmljson-parsing-permanent-link", "md_text": "API Documentation\n\n[`pydantic.main.BaseModel.model_validate_json`](../../api/base_model/index.html#pydantic.BaseModel.model_validate_json)\n[`pydantic.type_adapter.TypeAdapter.validate_json`](../../api/type_adapter/index.html#pydantic.type_adapter.TypeAdapter.validate_json)\n[`pydantic_core.from_json`](../../api/pydantic_core/index.html#pydantic_core.from_json)\n\nPydantic provides builtin JSON parsing, which helps achieve:\n\n* Significant performance improvements without the cost of using a 3rd party library\n* Support for custom errors\n* Support for `strict` specifications\n\nHere's an example of Pydantic's builtin JSON parsing via the [`model_validate_json`](../../api/base_model/index.html#pydantic.BaseModel.model_validate_json) method, showcasing the support for `strict` specifications while parsing JSON data that doesn't match the model's type annotations:\n\n```\nfrom datetime import date\n\nfrom pydantic import BaseModel, ConfigDict, ValidationError\n\n\nclass Event(BaseModel):\n    model_config = ConfigDict(strict=True)\n\n    when: date\n    where: tuple[int, int]\n\n\njson_data = '{\"when\": \"1987-01-28\", \"where\": [51, -1]}'\nprint(Event.model_validate_json(json_data))  # (1)!\n#> when=datetime.date(1987, 1, 28) where=(51, -1)\n\ntry:\n    Event.model_validate({'when': '1987-01-28', 'where': [51, -1]})  # (2)!\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for Event\n    when\n      Input should be a valid date [type=date_type, input_value='1987-01-28', input_type=str]\n    where\n      Input should be a valid tuple [type=tuple_type, input_value=[51, -1], input_type=list]\n    \"\"\"\n```\n\n1. JSON has no `date` or tuple types, but Pydantic knows that so allows strings and arrays as inputs respectively when parsing JSON directly.\n2. If you pass the same values to the [`model_validate`](../../api/base_model/index.html#pydantic.BaseModel.model_validate) method, Pydantic will raise a validation error because the `strict` configuration is enabled.\n\nIn v2.5.0 and above, Pydantic uses [`jiter`](https://docs.rs/jiter/latest/jiter/), a fast and iterable JSON parser, to parse JSON data.\nUsing `jiter` compared to `serde` results in modest performance improvements that will get even better in the future.\n\nThe `jiter` JSON parser is almost entirely compatible with the `serde` JSON parser,\nwith one noticeable enhancement being that `jiter` supports deserialization of `inf` and `NaN` values.\nIn the future, `jiter` is intended to enable support validation errors to include the location\nin the original JSON input which contained the invalid value.", "url": "https://docs.pydantic.dev/latest/concepts/json/index.html#json-parsingindexhtmljson-parsing-permanent-link", "page": "concepts/json/index.html", "source_site": "pydantic"}
{"title": "Partial JSON Parsing[Â¶](index.html#partial-json-parsing \"Permanent link\")", "anchor": "partial-json-parsingindexhtmlpartial-json-parsing-permanent-link", "md_text": "**Starting in v2.7.0**, Pydantic's [JSON parser](https://docs.rs/jiter/latest/jiter/) offers support for partial JSON parsing, which is exposed via [`pydantic_core.from_json`](../../api/pydantic_core/index.html#pydantic_core.from_json). Here's an example of this feature in action:\n\n```\nfrom pydantic_core import from_json\n\npartial_json_data = '[\"aa\", \"bb\", \"c'  # (1)!\n\ntry:\n    result = from_json(partial_json_data, allow_partial=False)\nexcept ValueError as e:\n    print(e)  # (2)!\n    #> EOF while parsing a string at line 1 column 15\n\nresult = from_json(partial_json_data, allow_partial=True)\nprint(result)  # (3)!\n#> ['aa', 'bb']\n```\n\n1. The JSON list is incomplete - it's missing a closing `\"]`\n2. When `allow_partial` is set to `False` (the default), a parsing error occurs.\n3. When `allow_partial` is set to `True`, part of the input is deserialized successfully.\n\nThis also works for deserializing partial dictionaries. For example:\n\n```\nfrom pydantic_core import from_json\n\npartial_dog_json = '{\"breed\": \"lab\", \"name\": \"fluffy\", \"friends\": [\"buddy\", \"spot\", \"rufus\"], \"age'\ndog_dict = from_json(partial_dog_json, allow_partial=True)\nprint(dog_dict)\n#> {'breed': 'lab', 'name': 'fluffy', 'friends': ['buddy', 'spot', 'rufus']}\n```\n\nThis feature is particularly beneficial for validating LLM outputs.\nWe've written some blog posts about this topic, which you can find on [our website](https://pydantic.dev/articles).\n\nIn future versions of Pydantic, we expect to expand support for this feature through either Pydantic's other JSON validation functions\n([`pydantic.main.BaseModel.model_validate_json`](../../api/base_model/index.html#pydantic.BaseModel.model_validate_json) and\n[`pydantic.type_adapter.TypeAdapter.validate_json`](../../api/type_adapter/index.html#pydantic.type_adapter.TypeAdapter.validate_json)) or model configuration. Stay tuned ðŸš€!\n\nFor now, you can use [`pydantic_core.from_json`](../../api/pydantic_core/index.html#pydantic_core.from_json) in combination with [`pydantic.main.BaseModel.model_validate`](../../api/base_model/index.html#pydantic.BaseModel.model_validate) to achieve the same result. Here's an example:\n\n```\nfrom pydantic_core import from_json\n\nfrom pydantic import BaseModel\n\n\nclass Dog(BaseModel):\n    breed: str\n    name: str\n    friends: list\n\n\npartial_dog_json = '{\"breed\": \"lab\", \"name\": \"fluffy\", \"friends\": [\"buddy\", \"spot\", \"rufus\"], \"age'\ndog = Dog.model_validate(from_json(partial_dog_json, allow_partial=True))\nprint(repr(dog))\n#> Dog(breed='lab', name='fluffy', friends=['buddy', 'spot', 'rufus'])\n```\n\nFor partial JSON parsing to work reliably, all fields on the model should have default values.\n\nCheck out the following example for a more in-depth look at how to use default values with partial JSON parsing:\n\n```\nfrom typing import Annotated, Any, Optional\n\nimport pydantic_core\n\nfrom pydantic import BaseModel, ValidationError, WrapValidator\n\n\ndef default_on_error(v, handler) -> Any:\n    \"\"\"\n    Raise a PydanticUseDefault exception if the value is missing.\n\n    This is useful for avoiding errors from partial\n    JSON preventing successful validation.\n    \"\"\"\n    try:\n        return handler(v)\n    except ValidationError as exc:\n        # there might be other types of errors resulting from partial JSON parsing\n        # that you allow here, feel free to customize as needed\n        if all(e['type'] == 'missing' for e in exc.errors()):\n            raise pydantic_core.PydanticUseDefault()\n        else:\n            raise\n\n\nclass NestedModel(BaseModel):\n    x: int\n    y: str\n\n\nclass MyModel(BaseModel):\n    foo: Optional[str] = None\n    bar: Annotated[\n        Optional[tuple[str, int]], WrapValidator(default_on_error)\n    ] = None\n    nested: Annotated[\n        Optional[NestedModel], WrapValidator(default_on_error)\n    ] = None\n\n\nm = MyModel.model_validate(\n    pydantic_core.from_json('{\"foo\": \"x\", \"bar\": [\"world\",', allow_partial=True)\n)\nprint(repr(m))\n#> MyModel(foo='x', bar=None, nested=None)\n\n\nm = MyModel.model_validate(\n    pydantic_core.from_json(\n        '{\"foo\": \"x\", \"bar\": [\"world\", 1], \"nested\": {\"x\":', allow_partial=True\n    )\n)\nprint(repr(m))\n#> MyModel(foo='x', bar=('world', 1), nested=None)\n```", "url": "https://docs.pydantic.dev/latest/concepts/json/index.html#partial-json-parsingindexhtmlpartial-json-parsing-permanent-link", "page": "concepts/json/index.html", "source_site": "pydantic"}
{"title": "Caching Strings[Â¶](index.html#caching-strings \"Permanent link\")", "anchor": "caching-stringsindexhtmlcaching-strings-permanent-link", "md_text": "**Starting in v2.7.0**, Pydantic's [JSON parser](https://docs.rs/jiter/latest/jiter/) offers support for configuring how Python strings are cached during JSON parsing and validation (when Python strings are constructed from Rust strings during Python validation, e.g. after `strip_whitespace=True`).\nThe `cache_strings` setting is exposed via both [model config](../../api/config/index.html#pydantic.config.ConfigDict) and [`pydantic_core.from_json`](../../api/pydantic_core/index.html#pydantic_core.from_json).\n\nThe `cache_strings` setting can take any of the following values:\n\n* `True` or `'all'` (the default): cache all strings\n* `'keys'`: cache only dictionary keys, this **only** applies when used with [`pydantic_core.from_json`](../../api/pydantic_core/index.html#pydantic_core.from_json) or when parsing JSON using [`Json`](../../api/types/index.html#pydantic.types.Json)\n* `False` or `'none'`: no caching\n\nUsing the string caching feature results in performance improvements, but increases memory usage slightly.\n\n1. Strings are cached using a fully associative cache with a size of\n   [16,384](https://github.com/pydantic/jiter/blob/5bbdcfd22882b7b286416b22f74abd549c7b2fd7/src/py_string_cache.rs#L113).\n2. Only strings where `len(string) < 64` are cached.\n3. There is some overhead to looking up the cache, which is normally worth it to avoid constructing strings.\n   However, if you know there will be very few repeated strings in your data, you might get a performance boost by disabling this setting with `cache_strings=False`.", "url": "https://docs.pydantic.dev/latest/concepts/json/index.html#caching-stringsindexhtmlcaching-strings-permanent-link", "page": "concepts/json/index.html", "source_site": "pydantic"}
{"title": "JSON Serialization[Â¶](index.html#json-serialization \"Permanent link\")", "anchor": "json-serializationindexhtmljson-serialization-permanent-link", "md_text": "API Documentation\n\n[`pydantic.main.BaseModel.model_dump_json`](../../api/base_model/index.html#pydantic.BaseModel.model_dump_json)  \n[`pydantic.type_adapter.TypeAdapter.dump_json`](../../api/type_adapter/index.html#pydantic.type_adapter.TypeAdapter.dump_json)  \n[`pydantic_core.to_json`](../../api/pydantic_core/index.html#pydantic_core.to_json)\n\nFor more information on JSON serialization, see the [serialization concepts](../serialization/index.html) page.\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/concepts/json/index.html#json-serializationindexhtmljson-serialization-permanent-link", "page": "concepts/json/index.html", "source_site": "pydantic"}
{"title": "Generating JSON Schema[Â¶](index.html#generating-json-schema \"Permanent link\")", "anchor": "generating-json-schemaindexhtmlgenerating-json-schema-permanent-link", "md_text": "Use the following functions to generate JSON schema:\n\n* [`BaseModel.model_json_schema`](../../api/base_model/index.html#pydantic.BaseModel.model_json_schema) returns a jsonable dict of a model's schema.\n* [`TypeAdapter.json_schema`](../../api/type_adapter/index.html#pydantic.type_adapter.TypeAdapter.json_schema) returns a jsonable dict of an adapted type's schema.\n\nThese methods are not to be confused with [`BaseModel.model_dump_json`](../../api/base_model/index.html#pydantic.BaseModel.model_dump_json)\nand [`TypeAdapter.dump_json`](../../api/type_adapter/index.html#pydantic.type_adapter.TypeAdapter.dump_json), which serialize instances of the\nmodel or adapted type, respectively. These methods return JSON strings. In comparison,\n[`BaseModel.model_json_schema`](../../api/base_model/index.html#pydantic.BaseModel.model_json_schema) and\n[`TypeAdapter.json_schema`](../../api/type_adapter/index.html#pydantic.type_adapter.TypeAdapter.json_schema) return a jsonable dict\nrepresenting the JSON schema of the model or adapted type, respectively.\n\nRegarding the \"jsonable\" nature of the [`model_json_schema`](../../api/base_model/index.html#pydantic.BaseModel.model_json_schema) results,\ncalling `json.dumps(m.model_json_schema())`on some `BaseModel` `m` returns a valid JSON string. Similarly, for\n[`TypeAdapter.json_schema`](../../api/type_adapter/index.html#pydantic.type_adapter.TypeAdapter.json_schema), calling\n`json.dumps(TypeAdapter(<some_type>).json_schema())` returns a valid JSON string.\n\nPydantic offers support for both of:\n\n1. [Customizing JSON Schema](index.html#customizing-json-schema)\n2. [Customizing the JSON Schema Generation Process](index.html#customizing-the-json-schema-generation-process)\n\nThe first approach generally has a more narrow scope, allowing for customization of the JSON schema for\nmore specific cases and types. The second approach generally has a more broad scope, allowing for customization\nof the JSON schema generation process overall. The same effects can be achieved with either approach, but\ndepending on your use case, one approach might offer a more simple solution than the other.\n\nHere's an example of generating JSON schema from a `BaseModel`:\n\nPython 3.9 and abovePython 3.10 and above\n\n```\nimport json\nfrom enum import Enum\nfrom typing import Annotated, Union\n\nfrom pydantic import BaseModel, Field\nfrom pydantic.config import ConfigDict\n\n\nclass FooBar(BaseModel):\n    count: int\n    size: Union[float, None] = None\n\n\nclass Gender(str, Enum):\n    male = 'male'\n    female = 'female'\n    other = 'other'\n    not_given = 'not_given'\n\n\nclass MainModel(BaseModel):\n    \"\"\"\n    This is the description of the main model\n    \"\"\"\n\n    model_config = ConfigDict(title='Main')\n\n    foo_bar: FooBar\n    gender: Annotated[Union[Gender, None], Field(alias='Gender')] = None\n    snap: int = Field(\n        default=42,\n        title='The Snap',\n        description='this is the value of snap',\n        gt=30,\n        lt=50,\n    )\n\n\nmain_model_schema = MainModel.model_json_schema()  # (1)!\nprint(json.dumps(main_model_schema, indent=2))  # (2)!\n```\n\nJSON output:\n\n```\n{\n  \"$defs\": {\n    \"FooBar\": {\n      \"properties\": {\n        \"count\": {\n          \"title\": \"Count\",\n          \"type\": \"integer\"\n        },\n        \"size\": {\n          \"anyOf\": [\n            {\n              \"type\": \"number\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ],\n          \"default\": null,\n          \"title\": \"Size\"\n        }\n      },\n      \"required\": [\n        \"count\"\n      ],\n      \"title\": \"FooBar\",\n      \"type\": \"object\"\n    },\n    \"Gender\": {\n      \"enum\": [\n        \"male\",\n        \"female\",\n        \"other\",\n        \"not_given\"\n      ],\n      \"title\": \"Gender\",\n      \"type\": \"string\"\n    }\n  },\n  \"description\": \"This is the description of the main model\",\n  \"properties\": {\n    \"foo_bar\": {\n      \"$ref\": \"#/$defs/FooBar\"\n    },\n    \"Gender\": {\n      \"anyOf\": [\n        {\n          \"$ref\": \"#/$defs/Gender\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"default\": null\n    },\n    \"snap\": {\n      \"default\": 42,\n      \"description\": \"this is the value of snap\",\n      \"exclusiveMaximum\": 50,\n      \"exclusiveMinimum\": 30,\n      \"title\": \"The Snap\",\n      \"type\": \"integer\"\n    }\n  },\n  \"required\": [\n    \"foo_bar\"\n  ],\n  \"title\": \"Main\",\n  \"type\": \"object\"\n}\n```\n\n1. This produces a \"jsonable\" dict of `MainModel`'s schema.\n2. Calling `json.dumps` on the schema dict produces a JSON string.\n\n```\nimport json\nfrom enum import Enum\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Field\nfrom pydantic.config import ConfigDict\n\n\nclass FooBar(BaseModel):\n    count: int\n    size: float | None = None\n\n\nclass Gender(str, Enum):\n    male = 'male'\n    female = 'female'\n    other = 'other'\n    not_given = 'not_given'\n\n\nclass MainModel(BaseModel):\n    \"\"\"\n    This is the description of the main model\n    \"\"\"\n\n    model_config = ConfigDict(title='Main')", "url": "https://docs.pydantic.dev/latest/concepts/json_schema/index.html#generating-json-schemaindexhtmlgenerating-json-schema-permanent-link", "page": "concepts/json_schema/index.html", "source_site": "pydantic"}
{"title": "Generating JSON Schema[Â¶](index.html#generating-json-schema \"Permanent link\")", "anchor": "generating-json-schemaindexhtmlgenerating-json-schema-permanent-link", "md_text": "    foo_bar: FooBar\n    gender: Annotated[Gender | None, Field(alias='Gender')] = None\n    snap: int = Field(\n        default=42,\n        title='The Snap',\n        description='this is the value of snap',\n        gt=30,\n        lt=50,\n    )\n\n\nmain_model_schema = MainModel.model_json_schema()  # (1)!\nprint(json.dumps(main_model_schema, indent=2))  # (2)!\n```\n\nJSON output:\n\n```\n{\n  \"$defs\": {\n    \"FooBar\": {\n      \"properties\": {\n        \"count\": {\n          \"title\": \"Count\",\n          \"type\": \"integer\"\n        },\n        \"size\": {\n          \"anyOf\": [\n            {\n              \"type\": \"number\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ],\n          \"default\": null,\n          \"title\": \"Size\"\n        }\n      },\n      \"required\": [\n        \"count\"\n      ],\n      \"title\": \"FooBar\",\n      \"type\": \"object\"\n    },\n    \"Gender\": {\n      \"enum\": [\n        \"male\",\n        \"female\",\n        \"other\",\n        \"not_given\"\n      ],\n      \"title\": \"Gender\",\n      \"type\": \"string\"\n    }\n  },\n  \"description\": \"This is the description of the main model\",\n  \"properties\": {\n    \"foo_bar\": {\n      \"$ref\": \"#/$defs/FooBar\"\n    },\n    \"Gender\": {\n      \"anyOf\": [\n        {\n          \"$ref\": \"#/$defs/Gender\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"default\": null\n    },\n    \"snap\": {\n      \"default\": 42,\n      \"description\": \"this is the value of snap\",\n      \"exclusiveMaximum\": 50,\n      \"exclusiveMinimum\": 30,\n      \"title\": \"The Snap\",\n      \"type\": \"integer\"\n    }\n  },\n  \"required\": [\n    \"foo_bar\"\n  ],\n  \"title\": \"Main\",\n  \"type\": \"object\"\n}\n```\n\n1. This produces a \"jsonable\" dict of `MainModel`'s schema.\n2. Calling `json.dumps` on the schema dict produces a JSON string.\n\nThe [`TypeAdapter`](../../api/type_adapter/index.html#pydantic.type_adapter.TypeAdapter) class lets you create an object with methods for validating, serializing,\nand producing JSON schemas for arbitrary types. This serves as a complete replacement for `schema_of` in\nPydantic V1 (which is now deprecated).\n\nHere's an example of generating JSON schema from a [`TypeAdapter`](../../api/type_adapter/index.html#pydantic.type_adapter.TypeAdapter):\n\n```\nfrom pydantic import TypeAdapter\n\nadapter = TypeAdapter(list[int])\nprint(adapter.json_schema())\n#> {'items': {'type': 'integer'}, 'type': 'array'}\n```\n\nYou can also generate JSON schemas for combinations of [`BaseModel`s](../../api/base_model/index.html#pydantic.BaseModel)\nand [`TypeAdapter`s](../../api/type_adapter/index.html#pydantic.type_adapter.TypeAdapter), as shown in this example:\n\n```\nimport json\nfrom typing import Union\n\nfrom pydantic import BaseModel, TypeAdapter\n\n\nclass Cat(BaseModel):\n    name: str\n    color: str\n\n\nclass Dog(BaseModel):\n    name: str\n    breed: str\n\n\nta = TypeAdapter(Union[Cat, Dog])\nta_schema = ta.json_schema()\nprint(json.dumps(ta_schema, indent=2))\n```\n\nJSON output:\n\n```\n{\n  \"$defs\": {\n    \"Cat\": {\n      \"properties\": {\n        \"name\": {\n          \"title\": \"Name\",\n          \"type\": \"string\"\n        },\n        \"color\": {\n          \"title\": \"Color\",\n          \"type\": \"string\"\n        }\n      },\n      \"required\": [\n        \"name\",\n        \"color\"\n      ],\n      \"title\": \"Cat\",\n      \"type\": \"object\"\n    },\n    \"Dog\": {\n      \"properties\": {\n        \"name\": {\n          \"title\": \"Name\",\n          \"type\": \"string\"\n        },\n        \"breed\": {\n          \"title\": \"Breed\",\n          \"type\": \"string\"\n        }\n      },\n      \"required\": [\n        \"name\",\n        \"breed\"\n      ],\n      \"title\": \"Dog\",\n      \"type\": \"object\"\n    }\n  },\n  \"anyOf\": [\n    {\n      \"$ref\": \"#/$defs/Cat\"\n    },\n    {\n      \"$ref\": \"#/$defs/Dog\"\n    }\n  ]\n}\n```", "url": "https://docs.pydantic.dev/latest/concepts/json_schema/index.html#generating-json-schemaindexhtmlgenerating-json-schema-permanent-link", "page": "concepts/json_schema/index.html", "source_site": "pydantic"}
{"title": "Configuring the `JsonSchemaMode`[Â¶](index.html#configuring-the-jsonschemamode \"Permanent link\")", "anchor": "configuring-the-jsonschemamodeindexhtmlconfiguring-the-jsonschemamode-permanent-link", "md_text": "Specify the mode of JSON schema generation via the `mode` parameter in the\n[`model_json_schema`](../../api/base_model/index.html#pydantic.BaseModel.model_json_schema) and\n[`TypeAdapter.json_schema`](../../api/type_adapter/index.html#pydantic.type_adapter.TypeAdapter.json_schema) methods. By default, the mode is set to\n`'validation'`, which produces a JSON schema corresponding to the model's validation schema.\n\nThe [`JsonSchemaMode`](../../api/json_schema/index.html#pydantic.json_schema.JsonSchemaMode) is a type alias that represents the available options for the `mode` parameter:\n\n* `'validation'`\n* `'serialization'`\n\nHere's an example of how to specify the `mode` parameter, and how it affects the generated JSON schema:\n\n```\nfrom decimal import Decimal\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    a: Decimal = Decimal('12.34')\n\n\nprint(Model.model_json_schema(mode='validation'))\n\"\"\"\n{\n    'properties': {\n        'a': {\n            'anyOf': [\n                {'type': 'number'},\n                {\n                    'pattern': '^(?!^[-+.]*$)[+-]?0*\\\\d*\\\\.?\\\\d*$',\n                    'type': 'string',\n                },\n            ],\n            'default': '12.34',\n            'title': 'A',\n        }\n    },\n    'title': 'Model',\n    'type': 'object',\n}\n\"\"\"\n\nprint(Model.model_json_schema(mode='serialization'))\n\"\"\"\n{\n    'properties': {\n        'a': {\n            'default': '12.34',\n            'pattern': '^(?!^[-+.]*$)[+-]?0*\\\\d*\\\\.?\\\\d*$',\n            'title': 'A',\n            'type': 'string',\n        }\n    },\n    'title': 'Model',\n    'type': 'object',\n}\n\"\"\"\n```", "url": "https://docs.pydantic.dev/latest/concepts/json_schema/index.html#configuring-the-jsonschemamodeindexhtmlconfiguring-the-jsonschemamode-permanent-link", "page": "concepts/json_schema/index.html", "source_site": "pydantic"}
{"title": "Customizing JSON Schema[Â¶](index.html#customizing-json-schema \"Permanent link\")", "anchor": "customizing-json-schemaindexhtmlcustomizing-json-schema-permanent-link", "md_text": "The generated JSON schema can be customized at both the field level and model level via:\n\n1. [Field-level customization](index.html#field-level-customization) with the [`Field`](../../api/fields/index.html#pydantic.fields.Field) constructor\n2. [Model-level customization](index.html#model-level-customization) with [`model_config`](../../api/config/index.html#pydantic.config.ConfigDict)\n\nAt both the field and model levels, you can use the `json_schema_extra` option to add extra information to the JSON schema.\nThe [Using `json_schema_extra`](index.html#using-json_schema_extra) section below provides more details on this option.\n\nFor custom types, Pydantic offers other tools for customizing JSON schema generation:\n\n1. [`WithJsonSchema` annotation](index.html#withjsonschema-annotation)\n2. [`SkipJsonSchema` annotation](index.html#skipjsonschema-annotation)\n3. [Implementing `__get_pydantic_core_schema__`](index.html#implementing_get_pydantic_core_schema)\n4. [Implementing `__get_pydantic_json_schema__`](index.html#implementing_get_pydantic_json_schema)", "url": "https://docs.pydantic.dev/latest/concepts/json_schema/index.html#customizing-json-schemaindexhtmlcustomizing-json-schema-permanent-link", "page": "concepts/json_schema/index.html", "source_site": "pydantic"}
{"title": "Field-Level Customization[Â¶](index.html#field-level-customization \"Permanent link\")", "anchor": "field-level-customizationindexhtmlfield-level-customization-permanent-link", "md_text": "Optionally, the [`Field`](../../api/fields/index.html#pydantic.fields.Field) function can be used to provide extra information about the field\nand validations.\n\nSome field parameters are used exclusively to customize the generated JSON Schema:\n\n* `title`: The title of the field.\n* `description`: The description of the field.\n* `examples`: The examples of the field.\n* `json_schema_extra`: Extra JSON Schema properties to be added to the field.\n* `field_title_generator`: A function that programmatically sets the field's title, based on its name and info.\n\nHere's an example:\n\n```\nimport json\n\nfrom pydantic import BaseModel, EmailStr, Field, SecretStr\n\n\nclass User(BaseModel):\n    age: int = Field(description='Age of the user')\n    email: EmailStr = Field(examples=['[emailÂ protected]'])\n    name: str = Field(title='Username')\n    password: SecretStr = Field(\n        json_schema_extra={\n            'title': 'Password',\n            'description': 'Password of the user',\n            'examples': ['123456'],\n        }\n    )\n\n\nprint(json.dumps(User.model_json_schema(), indent=2))\n```\n\nJSON output:\n\n```\n{\n  \"properties\": {\n    \"age\": {\n      \"description\": \"Age of the user\",\n      \"title\": \"Age\",\n      \"type\": \"integer\"\n    },\n    \"email\": {\n      \"examples\": [\n        \"[emailÂ protected]\"\n      ],\n      \"format\": \"email\",\n      \"title\": \"Email\",\n      \"type\": \"string\"\n    },\n    \"name\": {\n      \"title\": \"Username\",\n      \"type\": \"string\"\n    },\n    \"password\": {\n      \"description\": \"Password of the user\",\n      \"examples\": [\n        \"123456\"\n      ],\n      \"format\": \"password\",\n      \"title\": \"Password\",\n      \"type\": \"string\",\n      \"writeOnly\": true\n    }\n  },\n  \"required\": [\n    \"age\",\n    \"email\",\n    \"name\",\n    \"password\"\n  ],\n  \"title\": \"User\",\n  \"type\": \"object\"\n}\n```\n\n#### Unenforced `Field` constraints[Â¶](index.html#unenforced-field-constraints \"Permanent link\")\n\nIf Pydantic finds constraints which are not being enforced, an error will be raised. If you want to force the\nconstraint to appear in the schema, even though it's not being checked upon parsing, you can use variadic arguments\nto [`Field`](../../api/fields/index.html#pydantic.fields.Field) with the raw schema attribute name:\n\n```\nfrom pydantic import BaseModel, Field, PositiveInt\n\ntry:\n    # this won't work since `PositiveInt` takes precedence over the\n    # constraints defined in `Field`, meaning they're ignored\n    class Model(BaseModel):\n        foo: PositiveInt = Field(lt=10)\n\nexcept ValueError as e:\n    print(e)\n\n\n# if you find yourself needing this, an alternative is to declare\n# the constraints in `Field` (or you could use `conint()`)\n# here both constraints will be enforced:\nclass ModelB(BaseModel):\n    # Here both constraints will be applied and the schema\n    # will be generated correctly\n    foo: int = Field(gt=0, lt=10)\n\n\nprint(ModelB.model_json_schema())\n\"\"\"\n{\n    'properties': {\n        'foo': {\n            'exclusiveMaximum': 10,\n            'exclusiveMinimum': 0,\n            'title': 'Foo',\n            'type': 'integer',\n        }\n    },\n    'required': ['foo'],\n    'title': 'ModelB',\n    'type': 'object',\n}\n\"\"\"\n```\n\nYou can specify JSON schema modifications via the [`Field`](../../api/fields/index.html#pydantic.fields.Field) constructor via [`typing.Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated) as well:\n\n```\nimport json\nfrom typing import Annotated\nfrom uuid import uuid4\n\nfrom pydantic import BaseModel, Field\n\n\nclass Foo(BaseModel):\n    id: Annotated[str, Field(default_factory=lambda: uuid4().hex)]\n    name: Annotated[str, Field(max_length=256)] = Field(\n        'Bar', title='CustomName'\n    )\n\n\nprint(json.dumps(Foo.model_json_schema(), indent=2))\n```\n\nJSON output:\n\n```\n{\n  \"properties\": {\n    \"id\": {\n      \"title\": \"Id\",\n      \"type\": \"string\"\n    },\n    \"name\": {\n      \"default\": \"Bar\",\n      \"maxLength\": 256,\n      \"title\": \"CustomName\",\n      \"type\": \"string\"\n    }\n  },\n  \"title\": \"Foo\",\n  \"type\": \"object\"\n}\n```", "url": "https://docs.pydantic.dev/latest/concepts/json_schema/index.html#field-level-customizationindexhtmlfield-level-customization-permanent-link", "page": "concepts/json_schema/index.html", "source_site": "pydantic"}
{"title": "Programmatic field title generation[Â¶](index.html#programmatic-field-title-generation \"Permanent link\")", "anchor": "programmatic-field-title-generationindexhtmlprogrammatic-field-title-generation-permanent-link", "md_text": "The `field_title_generator` parameter can be used to programmatically generate the title for a field based on its name and info.\n\nSee the following example:\n\n```\nimport json\n\nfrom pydantic import BaseModel, Field\nfrom pydantic.fields import FieldInfo\n\n\ndef make_title(field_name: str, field_info: FieldInfo) -> str:\n    return field_name.upper()\n\n\nclass Person(BaseModel):\n    name: str = Field(field_title_generator=make_title)\n    age: int = Field(field_title_generator=make_title)\n\n\nprint(json.dumps(Person.model_json_schema(), indent=2))\n\"\"\"\n{\n  \"properties\": {\n    \"name\": {\n      \"title\": \"NAME\",\n      \"type\": \"string\"\n    },\n    \"age\": {\n      \"title\": \"AGE\",\n      \"type\": \"integer\"\n    }\n  },\n  \"required\": [\n    \"name\",\n    \"age\"\n  ],\n  \"title\": \"Person\",\n  \"type\": \"object\"\n}\n\"\"\"\n```", "url": "https://docs.pydantic.dev/latest/concepts/json_schema/index.html#programmatic-field-title-generationindexhtmlprogrammatic-field-title-generation-permanent-link", "page": "concepts/json_schema/index.html", "source_site": "pydantic"}
{"title": "Model-Level Customization[Â¶](index.html#model-level-customization \"Permanent link\")", "anchor": "model-level-customizationindexhtmlmodel-level-customization-permanent-link", "md_text": "You can also use [model config](../../api/config/index.html#pydantic.config.ConfigDict) to customize JSON schema generation on a model.\nSpecifically, the following config options are relevant:\n\n* [`title`](../../api/config/index.html#pydantic.config.ConfigDict.title)\n* [`json_schema_extra`](../../api/config/index.html#pydantic.config.ConfigDict.json_schema_extra)\n* [`json_schema_mode_override`](../../api/config/index.html#pydantic.config.ConfigDict.json_schema_mode_override)\n* [`field_title_generator`](../../api/config/index.html#pydantic.config.ConfigDict.field_title_generator)\n* [`model_title_generator`](../../api/config/index.html#pydantic.config.ConfigDict.model_title_generator)", "url": "https://docs.pydantic.dev/latest/concepts/json_schema/index.html#model-level-customizationindexhtmlmodel-level-customization-permanent-link", "page": "concepts/json_schema/index.html", "source_site": "pydantic"}
{"title": "Using `json_schema_extra`[Â¶](index.html#using-json_schema_extra \"Permanent link\")", "anchor": "using-jsonschemaextraindexhtmlusing-jsonschemaextra-permanent-link", "md_text": "The `json_schema_extra` option can be used to add extra information to the JSON schema, either at the\n[Field level](index.html#field-level-customization) or at the [Model level](index.html#model-level-customization).\nYou can pass a `dict` or a `Callable` to `json_schema_extra`.\n\n#### Using `json_schema_extra` with a `dict`[Â¶](index.html#using-json_schema_extra-with-a-dict \"Permanent link\")\n\nYou can pass a `dict` to `json_schema_extra` to add extra information to the JSON schema:\n\n```\nimport json\n\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass Model(BaseModel):\n    a: str\n\n    model_config = ConfigDict(json_schema_extra={'examples': [{'a': 'Foo'}]})\n\n\nprint(json.dumps(Model.model_json_schema(), indent=2))\n```\n\nJSON output:\n\n```\n{\n  \"examples\": [\n    {\n      \"a\": \"Foo\"\n    }\n  ],\n  \"properties\": {\n    \"a\": {\n      \"title\": \"A\",\n      \"type\": \"string\"\n    }\n  },\n  \"required\": [\n    \"a\"\n  ],\n  \"title\": \"Model\",\n  \"type\": \"object\"\n}\n```\n\n#### Using `json_schema_extra` with a `Callable`[Â¶](index.html#using-json_schema_extra-with-a-callable \"Permanent link\")\n\nYou can pass a `Callable` to `json_schema_extra` to modify the JSON schema with a function:\n\n```\nimport json\n\nfrom pydantic import BaseModel, Field\n\n\ndef pop_default(s):\n    s.pop('default')\n\n\nclass Model(BaseModel):\n    a: int = Field(default=1, json_schema_extra=pop_default)\n\n\nprint(json.dumps(Model.model_json_schema(), indent=2))\n```\n\nJSON output:\n\n```\n{\n  \"properties\": {\n    \"a\": {\n      \"title\": \"A\",\n      \"type\": \"integer\"\n    }\n  },\n  \"title\": \"Model\",\n  \"type\": \"object\"\n}\n```\n\n#### Merging `json_schema_extra`[Â¶](index.html#merging-json_schema_extra \"Permanent link\")\n\nStarting in v2.9, Pydantic merges `json_schema_extra` dictionaries from annotated types.\nThis pattern offers a more additive approach to merging rather than the previous override behavior.\nThis can be quite helpful for cases of reusing json schema extra information across multiple types.\n\nWe viewed this change largely as a bug fix, as it resolves unintentional differences in the `json_schema_extra` merging behavior\nbetween `BaseModel` and `TypeAdapter` instances - see [this issue](https://github.com/pydantic/pydantic/issues/9210)\nfor more details.\n\nPython 3.9 and abovePython 3.10 and above\n\n```\nimport json\nfrom typing import Annotated\n\nfrom typing_extensions import TypeAlias\n\nfrom pydantic import Field, TypeAdapter\n\nExternalType: TypeAlias = Annotated[\n    int, Field(json_schema_extra={'key1': 'value1'})\n]\n\nta = TypeAdapter(\n    Annotated[ExternalType, Field(json_schema_extra={'key2': 'value2'})]\n)\nprint(json.dumps(ta.json_schema(), indent=2))\n\"\"\"\n{\n  \"key1\": \"value1\",\n  \"key2\": \"value2\",\n  \"type\": \"integer\"\n}\n\"\"\"\n\nimport json\nfrom typing import Annotated\n\nfrom typing import TypeAlias\n\nfrom pydantic import Field, TypeAdapter\n\nExternalType: TypeAlias = Annotated[\n    int, Field(json_schema_extra={'key1': 'value1'})\n]\n\nta = TypeAdapter(\n    Annotated[ExternalType, Field(json_schema_extra={'key2': 'value2'})]\n)\nprint(json.dumps(ta.json_schema(), indent=2))\n\"\"\"\n{\n  \"key1\": \"value1\",\n  \"key2\": \"value2\",\n  \"type\": \"integer\"\n}\n\"\"\"\n```\n\nWe no longer (and never fully did) support composing a mix of `dict` and `callable` type `json_schema_extra` specifications.\nIf this is a requirement for your use case, please [open a pydantic issue](https://github.com/pydantic/pydantic/issues/new/choose) and explain your situation - we'd be happy to reconsider this decision when presented with a compelling case.", "url": "https://docs.pydantic.dev/latest/concepts/json_schema/index.html#using-jsonschemaextraindexhtmlusing-jsonschemaextra-permanent-link", "page": "concepts/json_schema/index.html", "source_site": "pydantic"}
{"title": "`WithJsonSchema` annotation[Â¶](index.html#withjsonschema-annotation \"Permanent link\")", "anchor": "withjsonschema-annotationindexhtmlwithjsonschema-annotation-permanent-link", "md_text": "API Documentation\n\n[`pydantic.json_schema.WithJsonSchema`](../../api/json_schema/index.html#pydantic.json_schema.WithJsonSchema)\n\nUsing [`WithJsonSchema`](../../api/json_schema/index.html#pydantic.json_schema.WithJsonSchema) is preferred over\n[implementing `__get_pydantic_json_schema__`](index.html#implementing_get_pydantic_json_schema) for custom types,\nas it's more simple and less error-prone.\n\nThe [`WithJsonSchema`](../../api/json_schema/index.html#pydantic.json_schema.WithJsonSchema) annotation can be used to override the generated (base)\nJSON schema for a given type without the need to implement `__get_pydantic_core_schema__`\nor `__get_pydantic_json_schema__` on the type itself. Note that this overrides the whole JSON Schema generation process\nfor the field (in the following example, the `'type'` also needs to be provided).\n\n```\nimport json\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, WithJsonSchema\n\nMyInt = Annotated[\n    int,\n    WithJsonSchema({'type': 'integer', 'examples': [1, 0, -1]}),\n]\n\n\nclass Model(BaseModel):\n    a: MyInt\n\n\nprint(json.dumps(Model.model_json_schema(), indent=2))\n```\n\nJSON output:\n\n```\n{\n  \"properties\": {\n    \"a\": {\n      \"examples\": [\n        1,\n        0,\n        -1\n      ],\n      \"title\": \"A\",\n      \"type\": \"integer\"\n    }\n  },\n  \"required\": [\n    \"a\"\n  ],\n  \"title\": \"Model\",\n  \"type\": \"object\"\n}\n```\n\nYou might be tempted to use the [`WithJsonSchema`](../../api/json_schema/index.html#pydantic.json_schema.WithJsonSchema) annotation\nto fine-tune the JSON Schema of fields having [validators](../validators/index.html) attached. Instead, it\nis recommended to use [the `json_schema_input_type` argument](../validators/index.html#json-schema-and-field-validators).", "url": "https://docs.pydantic.dev/latest/concepts/json_schema/index.html#withjsonschema-annotationindexhtmlwithjsonschema-annotation-permanent-link", "page": "concepts/json_schema/index.html", "source_site": "pydantic"}
{"title": "`SkipJsonSchema` annotation[Â¶](index.html#skipjsonschema-annotation \"Permanent link\")", "anchor": "skipjsonschema-annotationindexhtmlskipjsonschema-annotation-permanent-link", "md_text": "API Documentation\n\n[`pydantic.json_schema.SkipJsonSchema`](../../api/json_schema/index.html#pydantic.json_schema.SkipJsonSchema)\n\nThe [`SkipJsonSchema`](../../api/json_schema/index.html#pydantic.json_schema.SkipJsonSchema) annotation can be used to skip an included field (or part of a field's specifications)\nfrom the generated JSON schema. See the API docs for more details.", "url": "https://docs.pydantic.dev/latest/concepts/json_schema/index.html#skipjsonschema-annotationindexhtmlskipjsonschema-annotation-permanent-link", "page": "concepts/json_schema/index.html", "source_site": "pydantic"}
{"title": "Implementing `__get_pydantic_core_schema__` [Â¶](index.html#implementing-__get_pydantic_core_schema__ \"Permanent link\")", "anchor": "implementing-getpydanticcoreschema-indexhtmlimplementing-getpydanticcoreschema-permanent-link", "md_text": "Custom types (used as `field_name: TheType` or `field_name: Annotated[TheType, ...]`) as well as `Annotated` metadata\n(used as `field_name: Annotated[int, SomeMetadata]`)\ncan modify or override the generated schema by implementing `__get_pydantic_core_schema__`.\nThis method receives two positional arguments:\n\n1. The type annotation that corresponds to this type (so in the case of `TheType[T][int]` it would be `TheType[int]`).\n2. A handler/callback to call the next implementer of `__get_pydantic_core_schema__`.\n\nThe handler system works just like [*wrap* field validators](../validators/index.html#field-wrap-validator).\nIn this case the input is the type and the output is a `core_schema`.\n\nHere is an example of a custom type that *overrides* the generated `core_schema`:\n\n```\nfrom dataclasses import dataclass\nfrom typing import Any\n\nfrom pydantic_core import core_schema\n\nfrom pydantic import BaseModel, GetCoreSchemaHandler\n\n\n@dataclass\nclass CompressedString:\n    dictionary: dict[int, str]\n    text: list[int]\n\n    def build(self) -> str:\n        return ' '.join([self.dictionary[key] for key in self.text])\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source: type[Any], handler: GetCoreSchemaHandler\n    ) -> core_schema.CoreSchema:\n        assert source is CompressedString\n        return core_schema.no_info_after_validator_function(\n            cls._validate,\n            core_schema.str_schema(),\n            serialization=core_schema.plain_serializer_function_ser_schema(\n                cls._serialize,\n                info_arg=False,\n                return_schema=core_schema.str_schema(),\n            ),\n        )\n\n    @staticmethod\n    def _validate(value: str) -> 'CompressedString':\n        inverse_dictionary: dict[str, int] = {}\n        text: list[int] = []\n        for word in value.split(' '):\n            if word not in inverse_dictionary:\n                inverse_dictionary[word] = len(inverse_dictionary)\n            text.append(inverse_dictionary[word])\n        return CompressedString(\n            {v: k for k, v in inverse_dictionary.items()}, text\n        )\n\n    @staticmethod\n    def _serialize(value: 'CompressedString') -> str:\n        return value.build()\n\n\nclass MyModel(BaseModel):\n    value: CompressedString\n\n\nprint(MyModel.model_json_schema())\n\"\"\"\n{\n    'properties': {'value': {'title': 'Value', 'type': 'string'}},\n    'required': ['value'],\n    'title': 'MyModel',\n    'type': 'object',\n}\n\"\"\"\nprint(MyModel(value='fox fox fox dog fox'))\n\"\"\"\nvalue = CompressedString(dictionary={0: 'fox', 1: 'dog'}, text=[0, 0, 0, 1, 0])\n\"\"\"\n\nprint(MyModel(value='fox fox fox dog fox').model_dump(mode='json'))\n#> {'value': 'fox fox fox dog fox'}\n```\n\nSince Pydantic would not know how to generate a schema for `CompressedString`, if you call `handler(source)` in its\n`__get_pydantic_core_schema__` method you would get a `pydantic.errors.PydanticSchemaGenerationError` error.\nThis will be the case for most custom types, so you almost never want to call into `handler` for custom types.\n\nThe process for `Annotated` metadata is much the same except that you can generally call into `handler` to have\nPydantic handle generating the schema.\n\n```\nfrom collections.abc import Sequence\nfrom dataclasses import dataclass\nfrom typing import Annotated, Any\n\nfrom pydantic_core import core_schema\n\nfrom pydantic import BaseModel, GetCoreSchemaHandler, ValidationError\n\n\n@dataclass\nclass RestrictCharacters:\n    alphabet: Sequence[str]\n\n    def __get_pydantic_core_schema__(\n        self, source: type[Any], handler: GetCoreSchemaHandler\n    ) -> core_schema.CoreSchema:\n        if not self.alphabet:\n            raise ValueError('Alphabet may not be empty')\n        schema = handler(\n            source\n        )  # get the CoreSchema from the type / inner constraints\n        if schema['type'] != 'str':\n            raise TypeError('RestrictCharacters can only be applied to strings')\n        return core_schema.no_info_after_validator_function(\n            self.validate,\n            schema,\n        )\n\n    def validate(self, value: str) -> str:\n        if any(c not in self.alphabet for c in value):\n            raise ValueError(\n                f'{value!r} is not restricted to {self.alphabet!r}'\n            )\n        return value\n\n\nclass MyModel(BaseModel):\n    value: Annotated[str, RestrictCharacters('ABC')]\n\n\nprint(MyModel.model_json_schema())\n\"\"\"\n{\n    'properties': {'value': {'title': 'Value', 'type': 'string'}},\n    'required': ['value'],\n    'title': 'MyModel',\n    'type': 'object',\n}\n\"\"\"\nprint(MyModel(value='CBA'))\n#> value='CBA'\n\ntry:\n    MyModel(value='XYZ')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for MyModel\n    value\n      Value error, 'XYZ' is not restricted to 'ABC' [type=value_error, input_value='XYZ', input_type=str]\n    \"\"\"\n```\n\nSo far we have been wrapping the schema, but if you just want to *modify* it or *ignore* it you can as well.\n\nTo modify the schema, first call the handler, then mutate the result:\n\n```\nfrom typing import Annotated, Any\n\nfrom pydantic_core import ValidationError, core_schema", "url": "https://docs.pydantic.dev/latest/concepts/json_schema/index.html#implementing-getpydanticcoreschema-indexhtmlimplementing-getpydanticcoreschema-permanent-link", "page": "concepts/json_schema/index.html", "source_site": "pydantic"}
{"title": "Implementing `__get_pydantic_core_schema__` [Â¶](index.html#implementing-__get_pydantic_core_schema__ \"Permanent link\")", "anchor": "implementing-getpydanticcoreschema-indexhtmlimplementing-getpydanticcoreschema-permanent-link", "md_text": "from pydantic import BaseModel, GetCoreSchemaHandler\n\n\nclass SmallString:\n    def __get_pydantic_core_schema__(\n        self,\n        source: type[Any],\n        handler: GetCoreSchemaHandler,\n    ) -> core_schema.CoreSchema:\n        schema = handler(source)\n        assert schema['type'] == 'str'\n        schema['max_length'] = 10  # modify in place\n        return schema\n\n\nclass MyModel(BaseModel):\n    value: Annotated[str, SmallString()]\n\n\ntry:\n    MyModel(value='too long!!!!!')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for MyModel\n    value\n      String should have at most 10 characters [type=string_too_long, input_value='too long!!!!!', input_type=str]\n    \"\"\"\n```\n\nNote that you *must* return a schema, even if you are just mutating it in place.\n\nTo override the schema completely, do not call the handler and return your own\n`CoreSchema`:\n\n```\nfrom typing import Annotated, Any\n\nfrom pydantic_core import ValidationError, core_schema\n\nfrom pydantic import BaseModel, GetCoreSchemaHandler\n\n\nclass AllowAnySubclass:\n    def __get_pydantic_core_schema__(\n        self, source: type[Any], handler: GetCoreSchemaHandler\n    ) -> core_schema.CoreSchema:\n        # we can't call handler since it will fail for arbitrary types\n        def validate(value: Any) -> Any:\n            if not isinstance(value, source):\n                raise ValueError(\n                    f'Expected an instance of {source}, got an instance of {type(value)}'\n                )\n\n        return core_schema.no_info_plain_validator_function(validate)\n\n\nclass Foo:\n    pass\n\n\nclass Model(BaseModel):\n    f: Annotated[Foo, AllowAnySubclass()]\n\n\nprint(Model(f=Foo()))\n#> f=None\n\n\nclass NotFoo:\n    pass\n\n\ntry:\n    Model(f=NotFoo())\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    f\n      Value error, Expected an instance of <class '__main__.Foo'>, got an instance of <class '__main__.NotFoo'> [type=value_error, input_value=<__main__.NotFoo object at 0x0123456789ab>, input_type=NotFoo]\n    \"\"\"\n```", "url": "https://docs.pydantic.dev/latest/concepts/json_schema/index.html#implementing-getpydanticcoreschema-indexhtmlimplementing-getpydanticcoreschema-permanent-link", "page": "concepts/json_schema/index.html", "source_site": "pydantic"}
{"title": "Implementing `__get_pydantic_json_schema__` [Â¶](index.html#implementing-__get_pydantic_json_schema__ \"Permanent link\")", "anchor": "implementing-getpydanticjsonschema-indexhtmlimplementing-getpydanticjsonschema-permanent-link", "md_text": "You can also implement `__get_pydantic_json_schema__` to modify or override the generated json schema.\nModifying this method only affects the JSON schema - it doesn't affect the core schema, which is used for validation and serialization.\n\nHere's an example of modifying the generated JSON schema:\n\n```\nimport json\nfrom typing import Any\n\nfrom pydantic_core import core_schema as cs\n\nfrom pydantic import GetCoreSchemaHandler, GetJsonSchemaHandler, TypeAdapter\nfrom pydantic.json_schema import JsonSchemaValue\n\n\nclass Person:\n    name: str\n    age: int\n\n    def __init__(self, name: str, age: int):\n        self.name = name\n        self.age = age\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source_type: Any, handler: GetCoreSchemaHandler\n    ) -> cs.CoreSchema:\n        return cs.typed_dict_schema(\n            {\n                'name': cs.typed_dict_field(cs.str_schema()),\n                'age': cs.typed_dict_field(cs.int_schema()),\n            },\n        )\n\n    @classmethod\n    def __get_pydantic_json_schema__(\n        cls, core_schema: cs.CoreSchema, handler: GetJsonSchemaHandler\n    ) -> JsonSchemaValue:\n        json_schema = handler(core_schema)\n        json_schema = handler.resolve_ref_schema(json_schema)\n        json_schema['examples'] = [\n            {\n                'name': 'John Doe',\n                'age': 25,\n            }\n        ]\n        json_schema['title'] = 'Person'\n        return json_schema\n\n\nprint(json.dumps(TypeAdapter(Person).json_schema(), indent=2))\n```\n\nJSON output:\n\n```\n{\n  \"examples\": [\n    {\n      \"age\": 25,\n      \"name\": \"John Doe\"\n    }\n  ],\n  \"properties\": {\n    \"name\": {\n      \"title\": \"Name\",\n      \"type\": \"string\"\n    },\n    \"age\": {\n      \"title\": \"Age\",\n      \"type\": \"integer\"\n    }\n  },\n  \"required\": [\n    \"name\",\n    \"age\"\n  ],\n  \"title\": \"Person\",\n  \"type\": \"object\"\n}\n```", "url": "https://docs.pydantic.dev/latest/concepts/json_schema/index.html#implementing-getpydanticjsonschema-indexhtmlimplementing-getpydanticjsonschema-permanent-link", "page": "concepts/json_schema/index.html", "source_site": "pydantic"}
{"title": "Using `field_title_generator`[Â¶](index.html#using-field_title_generator \"Permanent link\")", "anchor": "using-fieldtitlegeneratorindexhtmlusing-fieldtitlegenerator-permanent-link", "md_text": "The `field_title_generator` parameter can be used to programmatically generate the title for a field based on its name and info.\nThis is similar to the field level `field_title_generator`, but the `ConfigDict` option will be applied to all fields of the class.\n\nSee the following example:\n\n```\nimport json\n\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass Person(BaseModel):\n    model_config = ConfigDict(\n        field_title_generator=lambda field_name, field_info: field_name.upper()\n    )\n    name: str\n    age: int\n\n\nprint(json.dumps(Person.model_json_schema(), indent=2))\n\"\"\"\n{\n  \"properties\": {\n    \"name\": {\n      \"title\": \"NAME\",\n      \"type\": \"string\"\n    },\n    \"age\": {\n      \"title\": \"AGE\",\n      \"type\": \"integer\"\n    }\n  },\n  \"required\": [\n    \"name\",\n    \"age\"\n  ],\n  \"title\": \"Person\",\n  \"type\": \"object\"\n}\n\"\"\"\n```", "url": "https://docs.pydantic.dev/latest/concepts/json_schema/index.html#using-fieldtitlegeneratorindexhtmlusing-fieldtitlegenerator-permanent-link", "page": "concepts/json_schema/index.html", "source_site": "pydantic"}
{"title": "Using `model_title_generator`[Â¶](index.html#using-model_title_generator \"Permanent link\")", "anchor": "using-modeltitlegeneratorindexhtmlusing-modeltitlegenerator-permanent-link", "md_text": "The `model_title_generator` config option is similar to the `field_title_generator` option, but it applies to the title of the model itself,\nand accepts the model class as input.\n\nSee the following example:\n\n```\nimport json\n\nfrom pydantic import BaseModel, ConfigDict\n\n\ndef make_title(model: type) -> str:\n    return f'Title-{model.__name__}'\n\n\nclass Person(BaseModel):\n    model_config = ConfigDict(model_title_generator=make_title)\n    name: str\n    age: int\n\n\nprint(json.dumps(Person.model_json_schema(), indent=2))\n\"\"\"\n{\n  \"properties\": {\n    \"name\": {\n      \"title\": \"Name\",\n      \"type\": \"string\"\n    },\n    \"age\": {\n      \"title\": \"Age\",\n      \"type\": \"integer\"\n    }\n  },\n  \"required\": [\n    \"name\",\n    \"age\"\n  ],\n  \"title\": \"Title-Person\",\n  \"type\": \"object\"\n}\n\"\"\"\n```", "url": "https://docs.pydantic.dev/latest/concepts/json_schema/index.html#using-modeltitlegeneratorindexhtmlusing-modeltitlegenerator-permanent-link", "page": "concepts/json_schema/index.html", "source_site": "pydantic"}
{"title": "JSON schema types[Â¶](index.html#json-schema-types \"Permanent link\")", "anchor": "json-schema-typesindexhtmljson-schema-types-permanent-link", "md_text": "Types, custom field types, and constraints (like `max_length`) are mapped to the corresponding spec formats in the\nfollowing priority order (when there is an equivalent available):\n\n1. [JSON Schema Core](https://json-schema.org/draft/2020-12/json-schema-core)\n2. [JSON Schema Validation](https://json-schema.org/draft/2020-12/json-schema-validation)\n3. [OpenAPI Data Types](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md#data-types)\n4. The standard `format` JSON field is used to define Pydantic extensions for more complex `string` sub-types.\n\nThe field schema mapping from Python or Pydantic to JSON schema is done as follows:\n\n{{ schema\\_mappings\\_table }}", "url": "https://docs.pydantic.dev/latest/concepts/json_schema/index.html#json-schema-typesindexhtmljson-schema-types-permanent-link", "page": "concepts/json_schema/index.html", "source_site": "pydantic"}
{"title": "Top-level schema generation[Â¶](index.html#top-level-schema-generation \"Permanent link\")", "anchor": "top-level-schema-generationindexhtmltop-level-schema-generation-permanent-link", "md_text": "You can also generate a top-level JSON schema that only includes a list of models and related\nsub-models in its `$defs`:\n\n```\nimport json\n\nfrom pydantic import BaseModel\nfrom pydantic.json_schema import models_json_schema\n\n\nclass Foo(BaseModel):\n    a: str = None\n\n\nclass Model(BaseModel):\n    b: Foo\n\n\nclass Bar(BaseModel):\n    c: int\n\n\n_, top_level_schema = models_json_schema(\n    [(Model, 'validation'), (Bar, 'validation')], title='My Schema'\n)\nprint(json.dumps(top_level_schema, indent=2))\n```\n\nJSON output:\n\n```\n{\n  \"$defs\": {\n    \"Bar\": {\n      \"properties\": {\n        \"c\": {\n          \"title\": \"C\",\n          \"type\": \"integer\"\n        }\n      },\n      \"required\": [\n        \"c\"\n      ],\n      \"title\": \"Bar\",\n      \"type\": \"object\"\n    },\n    \"Foo\": {\n      \"properties\": {\n        \"a\": {\n          \"default\": null,\n          \"title\": \"A\",\n          \"type\": \"string\"\n        }\n      },\n      \"title\": \"Foo\",\n      \"type\": \"object\"\n    },\n    \"Model\": {\n      \"properties\": {\n        \"b\": {\n          \"$ref\": \"#/$defs/Foo\"\n        }\n      },\n      \"required\": [\n        \"b\"\n      ],\n      \"title\": \"Model\",\n      \"type\": \"object\"\n    }\n  },\n  \"title\": \"My Schema\"\n}\n```", "url": "https://docs.pydantic.dev/latest/concepts/json_schema/index.html#top-level-schema-generationindexhtmltop-level-schema-generation-permanent-link", "page": "concepts/json_schema/index.html", "source_site": "pydantic"}
{"title": "Customizing the JSON Schema Generation Process[Â¶](index.html#customizing-the-json-schema-generation-process \"Permanent link\")", "anchor": "customizing-the-json-schema-generation-processindexhtmlcustomizing-the-json-schema-generation-process-permanent-link", "md_text": "API Documentation\n\n[`pydantic.json_schema`](../../api/json_schema/index.html#pydantic.json_schema.GenerateJsonSchema)\n\nIf you need custom schema generation, you can use a `schema_generator`, modifying the\n[`GenerateJsonSchema`](../../api/json_schema/index.html#pydantic.json_schema.GenerateJsonSchema) class as necessary for your application.\n\nThe various methods that can be used to produce JSON schema accept a keyword argument `schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema`, and you can pass your custom subclass to these methods in order to use your own approach to generating JSON schema.\n\n`GenerateJsonSchema` implements the translation of a type's `pydantic-core` schema into a JSON schema.\nBy design, this class breaks the JSON schema generation process into smaller methods that can be easily overridden in\nsubclasses to modify the \"global\" approach to generating JSON schema.\n\n```\nfrom pydantic import BaseModel\nfrom pydantic.json_schema import GenerateJsonSchema\n\n\nclass MyGenerateJsonSchema(GenerateJsonSchema):\n    def generate(self, schema, mode='validation'):\n        json_schema = super().generate(schema, mode=mode)\n        json_schema['title'] = 'Customize title'\n        json_schema['$schema'] = self.schema_dialect\n        return json_schema\n\n\nclass MyModel(BaseModel):\n    x: int\n\n\nprint(MyModel.model_json_schema(schema_generator=MyGenerateJsonSchema))\n\"\"\"\n{\n    'properties': {'x': {'title': 'X', 'type': 'integer'}},\n    'required': ['x'],\n    'title': 'Customize title',\n    'type': 'object',\n    '$schema': 'https://json-schema.org/draft/2020-12/schema',\n}\n\"\"\"\n```\n\nBelow is an approach you can use to exclude any fields from the schema that don't have valid json schemas:\n\nPython 3.9 and abovePython 3.10 and above\n\n```\nfrom typing import Callable\n\nfrom pydantic_core import PydanticOmit, core_schema\n\nfrom pydantic import BaseModel\nfrom pydantic.json_schema import GenerateJsonSchema, JsonSchemaValue\n\n\nclass MyGenerateJsonSchema(GenerateJsonSchema):\n    def handle_invalid_for_json_schema(\n        self, schema: core_schema.CoreSchema, error_info: str\n    ) -> JsonSchemaValue:\n        raise PydanticOmit\n\n\ndef example_callable():\n    return 1\n\n\nclass Example(BaseModel):\n    name: str = 'example'\n    function: Callable = example_callable\n\n\ninstance_example = Example()\n\nvalidation_schema = instance_example.model_json_schema(\n    schema_generator=MyGenerateJsonSchema, mode='validation'\n)\nprint(validation_schema)\n\"\"\"\n{\n    'properties': {\n        'name': {'default': 'example', 'title': 'Name', 'type': 'string'}\n    },\n    'title': 'Example',\n    'type': 'object',\n}\n\"\"\"\n\nfrom collections.abc import Callable\n\nfrom pydantic_core import PydanticOmit, core_schema\n\nfrom pydantic import BaseModel\nfrom pydantic.json_schema import GenerateJsonSchema, JsonSchemaValue\n\n\nclass MyGenerateJsonSchema(GenerateJsonSchema):\n    def handle_invalid_for_json_schema(\n        self, schema: core_schema.CoreSchema, error_info: str\n    ) -> JsonSchemaValue:\n        raise PydanticOmit\n\n\ndef example_callable():\n    return 1\n\n\nclass Example(BaseModel):\n    name: str = 'example'\n    function: Callable = example_callable\n\n\ninstance_example = Example()\n\nvalidation_schema = instance_example.model_json_schema(\n    schema_generator=MyGenerateJsonSchema, mode='validation'\n)\nprint(validation_schema)\n\"\"\"\n{\n    'properties': {\n        'name': {'default': 'example', 'title': 'Name', 'type': 'string'}\n    },\n    'title': 'Example',\n    'type': 'object',\n}\n\"\"\"\n```", "url": "https://docs.pydantic.dev/latest/concepts/json_schema/index.html#customizing-the-json-schema-generation-processindexhtmlcustomizing-the-json-schema-generation-process-permanent-link", "page": "concepts/json_schema/index.html", "source_site": "pydantic"}
{"title": "JSON schema sorting[Â¶](index.html#json-schema-sorting \"Permanent link\")", "anchor": "json-schema-sortingindexhtmljson-schema-sorting-permanent-link", "md_text": "By default, Pydantic recursively sorts JSON schemas by alphabetically sorting keys. Notably, Pydantic skips sorting the values of the `properties` key,\nto preserve the order of the fields as they were defined in the model.\n\nIf you would like to customize this behavior, you can override the `sort` method in your custom `GenerateJsonSchema` subclass. The below example\nuses a no-op `sort` method to disable sorting entirely, which is reflected in the preserved order of the model fields and `json_schema_extra` keys:\n\nPython 3.9 and abovePython 3.10 and above\n\n```\nimport json\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field\nfrom pydantic.json_schema import GenerateJsonSchema, JsonSchemaValue\n\n\nclass MyGenerateJsonSchema(GenerateJsonSchema):\n    def sort(\n        self, value: JsonSchemaValue, parent_key: Optional[str] = None\n    ) -> JsonSchemaValue:\n        \"\"\"No-op, we don't want to sort schema values at all.\"\"\"\n        return value\n\n\nclass Bar(BaseModel):\n    c: str\n    b: str\n    a: str = Field(json_schema_extra={'c': 'hi', 'b': 'hello', 'a': 'world'})\n\n\njson_schema = Bar.model_json_schema(schema_generator=MyGenerateJsonSchema)\nprint(json.dumps(json_schema, indent=2))\n\"\"\"\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"c\": {\n      \"type\": \"string\",\n      \"title\": \"C\"\n    },\n    \"b\": {\n      \"type\": \"string\",\n      \"title\": \"B\"\n    },\n    \"a\": {\n      \"type\": \"string\",\n      \"c\": \"hi\",\n      \"b\": \"hello\",\n      \"a\": \"world\",\n      \"title\": \"A\"\n    }\n  },\n  \"required\": [\n    \"c\",\n    \"b\",\n    \"a\"\n  ],\n  \"title\": \"Bar\"\n}\n\"\"\"\n\nimport json\n\nfrom pydantic import BaseModel, Field\nfrom pydantic.json_schema import GenerateJsonSchema, JsonSchemaValue\n\n\nclass MyGenerateJsonSchema(GenerateJsonSchema):\n    def sort(\n        self, value: JsonSchemaValue, parent_key: str | None = None\n    ) -> JsonSchemaValue:\n        \"\"\"No-op, we don't want to sort schema values at all.\"\"\"\n        return value\n\n\nclass Bar(BaseModel):\n    c: str\n    b: str\n    a: str = Field(json_schema_extra={'c': 'hi', 'b': 'hello', 'a': 'world'})\n\n\njson_schema = Bar.model_json_schema(schema_generator=MyGenerateJsonSchema)\nprint(json.dumps(json_schema, indent=2))\n\"\"\"\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"c\": {\n      \"type\": \"string\",\n      \"title\": \"C\"\n    },\n    \"b\": {\n      \"type\": \"string\",\n      \"title\": \"B\"\n    },\n    \"a\": {\n      \"type\": \"string\",\n      \"c\": \"hi\",\n      \"b\": \"hello\",\n      \"a\": \"world\",\n      \"title\": \"A\"\n    }\n  },\n  \"required\": [\n    \"c\",\n    \"b\",\n    \"a\"\n  ],\n  \"title\": \"Bar\"\n}\n\"\"\"\n```", "url": "https://docs.pydantic.dev/latest/concepts/json_schema/index.html#json-schema-sortingindexhtmljson-schema-sorting-permanent-link", "page": "concepts/json_schema/index.html", "source_site": "pydantic"}
{"title": "Customizing the `$ref`s in JSON Schema[Â¶](index.html#customizing-the-refs-in-json-schema \"Permanent link\")", "anchor": "customizing-the-refs-in-json-schemaindexhtmlcustomizing-the-refs-in-json-schema-permanent-link", "md_text": "The format of `$ref`s can be altered by calling [`model_json_schema()`](../../api/base_model/index.html#pydantic.BaseModel.model_json_schema)\nor [`model_dump_json()`](../../api/base_model/index.html#pydantic.BaseModel.model_dump_json) with the `ref_template` keyword argument.\nThe definitions are always stored under the key `$defs`, but a specified prefix can be used for the references.\n\nThis is useful if you need to extend or modify the JSON schema default definitions location. For example, with OpenAPI:\n\n```\nimport json\n\nfrom pydantic import BaseModel\nfrom pydantic.type_adapter import TypeAdapter\n\n\nclass Foo(BaseModel):\n    a: int\n\n\nclass Model(BaseModel):\n    a: Foo\n\n\nadapter = TypeAdapter(Model)\n\nprint(\n    json.dumps(\n        adapter.json_schema(ref_template='#/components/schemas/{model}'),\n        indent=2,\n    )\n)\n```\n\nJSON output:\n\n```\n{\n  \"$defs\": {\n    \"Foo\": {\n      \"properties\": {\n        \"a\": {\n          \"title\": \"A\",\n          \"type\": \"integer\"\n        }\n      },\n      \"required\": [\n        \"a\"\n      ],\n      \"title\": \"Foo\",\n      \"type\": \"object\"\n    }\n  },\n  \"properties\": {\n    \"a\": {\n      \"$ref\": \"#/components/schemas/Foo\"\n    }\n  },\n  \"required\": [\n    \"a\"\n  ],\n  \"title\": \"Model\",\n  \"type\": \"object\"\n}\n```", "url": "https://docs.pydantic.dev/latest/concepts/json_schema/index.html#customizing-the-refs-in-json-schemaindexhtmlcustomizing-the-refs-in-json-schema-permanent-link", "page": "concepts/json_schema/index.html", "source_site": "pydantic"}
{"title": "Miscellaneous Notes on JSON Schema Generation[Â¶](index.html#miscellaneous-notes-on-json-schema-generation \"Permanent link\")", "anchor": "miscellaneous-notes-on-json-schema-generationindexhtmlmiscellaneous-notes-on-json-schema-generation-permanent-link", "md_text": "* The JSON schema for `Optional` fields indicates that the value `null` is allowed.\n* The `Decimal` type is exposed in JSON schema (and serialized) as a string.\n* Since the `namedtuple` type doesn't exist in JSON, a model's JSON schema does not preserve `namedtuple`s as `namedtuple`s.\n* Sub-models used are added to the `$defs` JSON attribute and referenced, as per the spec.\n* Sub-models with modifications (via the `Field` class) like a custom title, description, or default value,\n  are recursively included instead of referenced.\n* The `description` for models is taken from either the docstring of the class or the argument `description` to\n  the `Field` class.\n* The schema is generated by default using aliases as keys, but it can be generated using model\n  property names instead by calling [`model_json_schema()`](../../api/base_model/index.html#pydantic.BaseModel.model_json_schema) or\n  [`model_dump_json()`](../../api/base_model/index.html#pydantic.BaseModel.model_dump_json) with the `by_alias=False` keyword argument.\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/concepts/json_schema/index.html#miscellaneous-notes-on-json-schema-generationindexhtmlmiscellaneous-notes-on-json-schema-generation-permanent-link", "page": "concepts/json_schema/index.html", "source_site": "pydantic"}
{"title": "Union Modes[Â¶](index.html#union-modes \"Permanent link\")", "anchor": "union-modesindexhtmlunion-modes-permanent-link", "md_text": "", "url": "https://docs.pydantic.dev/latest/concepts/unions/index.html#union-modesindexhtmlunion-modes-permanent-link", "page": "concepts/unions/index.html", "source_site": "pydantic"}
{"title": "Left to Right Mode[Â¶](index.html#left-to-right-mode \"Permanent link\")", "anchor": "left-to-right-modeindexhtmlleft-to-right-mode-permanent-link", "md_text": "Because this mode often leads to unexpected validation results, it is not the default in Pydantic >=2, instead `union_mode='smart'` is the default.\n\nWith this approach, validation is attempted against each member of the union in their order they're defined, and the first successful validation is accepted as input.\n\nIf validation fails on all members, the validation error includes the errors from all members of the union.\n\n`union_mode='left_to_right'` must be set as a [`Field`](../fields/index.html) parameter on union fields where you want to use it.\n\nPython 3.9 and abovePython 3.10 and above\n\nUnion with left to right mode\n\n```\nfrom typing import Union\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass User(BaseModel):\n    id: Union[str, int] = Field(union_mode='left_to_right')\n\n\nprint(User(id=123))\n#> id=123\nprint(User(id='hello'))\n#> id='hello'\n\ntry:\n    User(id=[])\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for User\n    id.str\n      Input should be a valid string [type=string_type, input_value=[], input_type=list]\n    id.int\n      Input should be a valid integer [type=int_type, input_value=[], input_type=list]\n    \"\"\"\n```\n\nUnion with left to right mode\n\n```\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass User(BaseModel):\n    id: str | int = Field(union_mode='left_to_right')\n\n\nprint(User(id=123))\n#> id=123\nprint(User(id='hello'))\n#> id='hello'\n\ntry:\n    User(id=[])\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for User\n    id.str\n      Input should be a valid string [type=string_type, input_value=[], input_type=list]\n    id.int\n      Input should be a valid integer [type=int_type, input_value=[], input_type=list]\n    \"\"\"\n```\n\nThe order of members is very important in this case, as demonstrated by tweak the above example:\n\nPython 3.9 and abovePython 3.10 and above\n\nUnion with left to right - unexpected results\n\n```\nfrom typing import Union\n\nfrom pydantic import BaseModel, Field\n\n\nclass User(BaseModel):\n    id: Union[int, str] = Field(union_mode='left_to_right')\n\n\nprint(User(id=123))  # (1)\n#> id=123\nprint(User(id='456'))  # (2)\n#> id=456\n```\n\n1. As expected the input is validated against the `int` member and the result is as expected.\n2. We're in lax mode and the numeric string `'123'` is valid as input to the first member of the union, `int`.\n   Since that is tried first, we get the surprising result of `id` being an `int` instead of a `str`.\n\nUnion with left to right - unexpected results\n\n```\nfrom pydantic import BaseModel, Field\n\n\nclass User(BaseModel):\n    id: int | str = Field(union_mode='left_to_right')\n\n\nprint(User(id=123))  # (1)\n#> id=123\nprint(User(id='456'))  # (2)\n#> id=456\n```\n\n1. As expected the input is validated against the `int` member and the result is as expected.\n2. We're in lax mode and the numeric string `'123'` is valid as input to the first member of the union, `int`.\n   Since that is tried first, we get the surprising result of `id` being an `int` instead of a `str`.", "url": "https://docs.pydantic.dev/latest/concepts/unions/index.html#left-to-right-modeindexhtmlleft-to-right-mode-permanent-link", "page": "concepts/unions/index.html", "source_site": "pydantic"}
{"title": "Smart Mode[Â¶](index.html#smart-mode \"Permanent link\")", "anchor": "smart-modeindexhtmlsmart-mode-permanent-link", "md_text": "Because of the potentially surprising results of `union_mode='left_to_right'`, in Pydantic >=2 the default mode for `Union` validation is `union_mode='smart'`.\n\nIn this mode, pydantic attempts to select the best match for the input from the union members. The exact algorithm may change between Pydantic minor releases to allow for improvements in both performance and accuracy.\n\nWe reserve the right to tweak the internal `smart` matching algorithm in future versions of Pydantic. If you rely on very specific\nmatching behavior, it's recommended to use `union_mode='left_to_right'` or [discriminated unions](index.html#discriminated-unions).\n\nSmart Mode Algorithm\n\nThe smart mode algorithm uses two metrics to determine the best match for the input:\n\n1. The number of valid fields set (relevant for models, dataclasses, and typed dicts)\n2. The exactness of the match (relevant for all types)\n\n#### Number of valid fields set[Â¶](index.html#number-of-valid-fields-set \"Permanent link\")\n\nThis metric was introduced in Pydantic v2.8.0. Prior to this version, only exactness was used to determine the best match.\n\nThis metric is currently only relevant for models, dataclasses, and typed dicts.\n\nThe greater the number of valid fields set, the better the match. The number of fields set on nested models is also taken into account.\nThese counts bubble up to the top-level union, where the union member with the highest count is considered the best match.\n\nFor data types where this metric is relevant, we prioritize this count over exactness. For all other types, we use solely exactness.\n\n#### Exactness[Â¶](index.html#exactness \"Permanent link\")\n\nFor `exactness`, Pydantic scores a match of a union member into one of the following three groups (from highest score to lowest score):\n\n* An exact type match, for example an `int` input to a `float | int` union validation is an exact type match for the `int` member\n* Validation would have succeeded in [`strict` mode](../strict_mode/index.html)\n* Validation would have succeeded in lax mode\n\nThe union match which produced the highest exactness score will be considered the best match.\n\nIn smart mode, the following steps are taken to try to select the best match for the input:\n\n`BaseModel`, `dataclass`, and `TypedDict`All other data types\n\n1. Union members are attempted left to right, with any successful matches scored into one of the three exactness categories described above,\n   with the valid fields set count also tallied.\n2. After all members have been evaluated, the member with the highest \"valid fields set\" count is returned.\n3. If there's a tie for the highest \"valid fields set\" count, the exactness score is used as a tiebreaker, and the member with the highest exactness score is returned.\n4. If validation failed on all the members, return all the errors.\n\n1. Union members are attempted left to right, with any successful matches scored into one of the three exactness categories described above.\n   * If validation succeeds with an exact type match, that member is returned immediately and following members will not be attempted.\n2. If validation succeeded on at least one member as a \"strict\" match, the leftmost of those \"strict\" matches is returned.\n3. If validation succeeded on at least one member in \"lax\" mode, the leftmost match is returned.\n4. Validation failed on all the members, return all the errors.\n\nPython 3.9 and abovePython 3.10 and above\n\n```\nfrom typing import Union\nfrom uuid import UUID\n\nfrom pydantic import BaseModel\n\n\nclass User(BaseModel):\n    id: Union[int, str, UUID]\n    name: str\n\n\nuser_01 = User(id=123, name='John Doe')\nprint(user_01)\n#> id=123 name='John Doe'\nprint(user_01.id)\n#> 123\nuser_02 = User(id='1234', name='John Doe')\nprint(user_02)\n#> id='1234' name='John Doe'\nprint(user_02.id)\n#> 1234\nuser_03_uuid = UUID('cf57432e-809e-4353-adbd-9d5c0d733868')\nuser_03 = User(id=user_03_uuid, name='John Doe')\nprint(user_03)\n#> id=UUID('cf57432e-809e-4353-adbd-9d5c0d733868') name='John Doe'\nprint(user_03.id)\n#> cf57432e-809e-4353-adbd-9d5c0d733868\nprint(user_03_uuid.int)\n#> 275603287559914445491632874575877060712\n\nfrom uuid import UUID\n\nfrom pydantic import BaseModel\n\n\nclass User(BaseModel):\n    id: int | str | UUID\n    name: str", "url": "https://docs.pydantic.dev/latest/concepts/unions/index.html#smart-modeindexhtmlsmart-mode-permanent-link", "page": "concepts/unions/index.html", "source_site": "pydantic"}
{"title": "Smart Mode[Â¶](index.html#smart-mode \"Permanent link\")", "anchor": "smart-modeindexhtmlsmart-mode-permanent-link", "md_text": "\nuser_01 = User(id=123, name='John Doe')\nprint(user_01)\n#> id=123 name='John Doe'\nprint(user_01.id)\n#> 123\nuser_02 = User(id='1234', name='John Doe')\nprint(user_02)\n#> id='1234' name='John Doe'\nprint(user_02.id)\n#> 1234\nuser_03_uuid = UUID('cf57432e-809e-4353-adbd-9d5c0d733868')\nuser_03 = User(id=user_03_uuid, name='John Doe')\nprint(user_03)\n#> id=UUID('cf57432e-809e-4353-adbd-9d5c0d733868') name='John Doe'\nprint(user_03.id)\n#> cf57432e-809e-4353-adbd-9d5c0d733868\nprint(user_03_uuid.int)\n#> 275603287559914445491632874575877060712\n```", "url": "https://docs.pydantic.dev/latest/concepts/unions/index.html#smart-modeindexhtmlsmart-mode-permanent-link", "page": "concepts/unions/index.html", "source_site": "pydantic"}
{"title": "Discriminated Unions[Â¶](index.html#discriminated-unions \"Permanent link\")", "anchor": "discriminated-unionsindexhtmldiscriminated-unions-permanent-link", "md_text": "**Discriminated unions are sometimes referred to as \"Tagged Unions\".**\n\nWe can use discriminated unions to more efficiently validate `Union` types, by choosing which member of the union to validate against.\n\nThis makes validation more efficient and also avoids a proliferation of errors when validation fails.\n\nAdding discriminator to unions also means the generated JSON schema implements the [associated OpenAPI specification](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#discriminator-object).", "url": "https://docs.pydantic.dev/latest/concepts/unions/index.html#discriminated-unionsindexhtmldiscriminated-unions-permanent-link", "page": "concepts/unions/index.html", "source_site": "pydantic"}
{"title": "Discriminated Unions with `str` discriminators[Â¶](index.html#discriminated-unions-with-str-discriminators \"Permanent link\")", "anchor": "discriminated-unions-with-str-discriminatorsindexhtmldiscriminated-unions-with-str-discriminators-permanent-link", "md_text": "Frequently, in the case of a `Union` with multiple models,\nthere is a common field to all members of the union that can be used to distinguish\nwhich union case the data should be validated against; this is referred to as the \"discriminator\" in\n[OpenAPI](https://swagger.io/docs/specification/data-models/inheritance-and-polymorphism/).\n\nTo validate models based on that information you can set the same field - let's call it `my_discriminator` -\nin each of the models with a discriminated value, which is one (or many) `Literal` value(s).\nFor your `Union`, you can set the discriminator in its value: `Field(discriminator='my_discriminator')`.\n\nPython 3.9 and abovePython 3.10 and above\n\n```\nfrom typing import Literal, Union\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Cat(BaseModel):\n    pet_type: Literal['cat']\n    meows: int\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n    barks: float\n\n\nclass Lizard(BaseModel):\n    pet_type: Literal['reptile', 'lizard']\n    scales: bool\n\n\nclass Model(BaseModel):\n    pet: Union[Cat, Dog, Lizard] = Field(discriminator='pet_type')\n    n: int\n\n\nprint(Model(pet={'pet_type': 'dog', 'barks': 3.14}, n=1))\n#> pet=Dog(pet_type='dog', barks=3.14) n=1\ntry:\n    Model(pet={'pet_type': 'dog'}, n=1)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    pet.dog.barks\n      Field required [type=missing, input_value={'pet_type': 'dog'}, input_type=dict]\n    \"\"\"\n\nfrom typing import Literal\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Cat(BaseModel):\n    pet_type: Literal['cat']\n    meows: int\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n    barks: float\n\n\nclass Lizard(BaseModel):\n    pet_type: Literal['reptile', 'lizard']\n    scales: bool\n\n\nclass Model(BaseModel):\n    pet: Cat | Dog | Lizard = Field(discriminator='pet_type')\n    n: int\n\n\nprint(Model(pet={'pet_type': 'dog', 'barks': 3.14}, n=1))\n#> pet=Dog(pet_type='dog', barks=3.14) n=1\ntry:\n    Model(pet={'pet_type': 'dog'}, n=1)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    pet.dog.barks\n      Field required [type=missing, input_value={'pet_type': 'dog'}, input_type=dict]\n    \"\"\"\n```", "url": "https://docs.pydantic.dev/latest/concepts/unions/index.html#discriminated-unions-with-str-discriminatorsindexhtmldiscriminated-unions-with-str-discriminators-permanent-link", "page": "concepts/unions/index.html", "source_site": "pydantic"}
{"title": "Discriminated Unions with callable `Discriminator`[Â¶](index.html#discriminated-unions-with-callable-discriminator \"Permanent link\")", "anchor": "discriminated-unions-with-callable-discriminatorindexhtmldiscriminated-unions-with-callable-discriminator-permanent-link", "md_text": "API Documentation\n\n[`pydantic.types.Discriminator`](../../api/types/index.html#pydantic.types.Discriminator)\n\nIn the case of a `Union` with multiple models, sometimes there isn't a single uniform field\nacross all models that you can use as a discriminator.\nThis is the perfect use case for a callable `Discriminator`.\n\nWhen you're designing callable discriminators, remember that you might have to account\nfor both `dict` and model type inputs. This pattern is similar to that of `mode='before'` validators,\nwhere you have to anticipate various forms of input.\n\nBut wait! You ask, I only anticipate passing in `dict` types, why do I need to account for models?\nPydantic uses callable discriminators for serialization as well, at which point the input to your callable is\nvery likely to be a model instance.\n\nIn the following examples, you'll see that the callable discriminators are designed to handle both `dict` and model inputs.\nIf you don't follow this practice, it's likely that you'll, in the best case, get warnings during serialization,\nand in the worst case, get runtime errors during validation.\n\nPython 3.9 and abovePython 3.10 and above\n\n```\nfrom typing import Annotated, Any, Literal, Union\n\nfrom pydantic import BaseModel, Discriminator, Tag\n\n\nclass Pie(BaseModel):\n    time_to_cook: int\n    num_ingredients: int\n\n\nclass ApplePie(Pie):\n    fruit: Literal['apple'] = 'apple'\n\n\nclass PumpkinPie(Pie):\n    filling: Literal['pumpkin'] = 'pumpkin'\n\n\ndef get_discriminator_value(v: Any) -> str:\n    if isinstance(v, dict):\n        return v.get('fruit', v.get('filling'))\n    return getattr(v, 'fruit', getattr(v, 'filling', None))\n\n\nclass ThanksgivingDinner(BaseModel):\n    dessert: Annotated[\n        Union[\n            Annotated[ApplePie, Tag('apple')],\n            Annotated[PumpkinPie, Tag('pumpkin')],\n        ],\n        Discriminator(get_discriminator_value),\n    ]\n\n\napple_variation = ThanksgivingDinner.model_validate(\n    {'dessert': {'fruit': 'apple', 'time_to_cook': 60, 'num_ingredients': 8}}\n)\nprint(repr(apple_variation))\n\"\"\"\nThanksgivingDinner(dessert=ApplePie(time_to_cook=60, num_ingredients=8, fruit='apple'))\n\"\"\"\n\npumpkin_variation = ThanksgivingDinner.model_validate(\n    {\n        'dessert': {\n            'filling': 'pumpkin',\n            'time_to_cook': 40,\n            'num_ingredients': 6,\n        }\n    }\n)\nprint(repr(pumpkin_variation))\n\"\"\"\nThanksgivingDinner(dessert=PumpkinPie(time_to_cook=40, num_ingredients=6, filling='pumpkin'))\n\"\"\"\n\nfrom typing import Annotated, Any, Literal\n\nfrom pydantic import BaseModel, Discriminator, Tag\n\n\nclass Pie(BaseModel):\n    time_to_cook: int\n    num_ingredients: int\n\n\nclass ApplePie(Pie):\n    fruit: Literal['apple'] = 'apple'\n\n\nclass PumpkinPie(Pie):\n    filling: Literal['pumpkin'] = 'pumpkin'\n\n\ndef get_discriminator_value(v: Any) -> str:\n    if isinstance(v, dict):\n        return v.get('fruit', v.get('filling'))\n    return getattr(v, 'fruit', getattr(v, 'filling', None))\n\n\nclass ThanksgivingDinner(BaseModel):\n    dessert: Annotated[\n        (\n            Annotated[ApplePie, Tag('apple')] |\n            Annotated[PumpkinPie, Tag('pumpkin')]\n        ),\n        Discriminator(get_discriminator_value),\n    ]\n\n\napple_variation = ThanksgivingDinner.model_validate(\n    {'dessert': {'fruit': 'apple', 'time_to_cook': 60, 'num_ingredients': 8}}\n)\nprint(repr(apple_variation))\n\"\"\"\nThanksgivingDinner(dessert=ApplePie(time_to_cook=60, num_ingredients=8, fruit='apple'))\n\"\"\"\n\npumpkin_variation = ThanksgivingDinner.model_validate(\n    {\n        'dessert': {\n            'filling': 'pumpkin',\n            'time_to_cook': 40,\n            'num_ingredients': 6,\n        }\n    }\n)\nprint(repr(pumpkin_variation))\n\"\"\"\nThanksgivingDinner(dessert=PumpkinPie(time_to_cook=40, num_ingredients=6, filling='pumpkin'))\n\"\"\"\n```\n\n`Discriminator`s can also be used to validate `Union` types with combinations of models and primitive types.\n\nFor example:\n\nPython 3.9 and abovePython 3.10 and above\n\n```\nfrom typing import Annotated, Any, Union\n\nfrom pydantic import BaseModel, Discriminator, Tag, ValidationError\n\n\ndef model_x_discriminator(v: Any) -> str:\n    if isinstance(v, int):\n        return 'int'\n    if isinstance(v, (dict, BaseModel)):\n        return 'model'\n    else:\n        # return None if the discriminator value isn't found\n        return None\n\n\nclass SpecialValue(BaseModel):\n    value: int\n\n\nclass DiscriminatedModel(BaseModel):\n    value: Annotated[\n        Union[\n            Annotated[int, Tag('int')],\n            Annotated['SpecialValue', Tag('model')],\n        ],\n        Discriminator(model_x_discriminator),\n    ]\n\n\nmodel_data = {'value': {'value': 1}}\nm = DiscriminatedModel.model_validate(model_data)\nprint(m)\n#> value=SpecialValue(value=1)", "url": "https://docs.pydantic.dev/latest/concepts/unions/index.html#discriminated-unions-with-callable-discriminatorindexhtmldiscriminated-unions-with-callable-discriminator-permanent-link", "page": "concepts/unions/index.html", "source_site": "pydantic"}
{"title": "Discriminated Unions with callable `Discriminator`[Â¶](index.html#discriminated-unions-with-callable-discriminator \"Permanent link\")", "anchor": "discriminated-unions-with-callable-discriminatorindexhtmldiscriminated-unions-with-callable-discriminator-permanent-link", "md_text": "int_data = {'value': 123}\nm = DiscriminatedModel.model_validate(int_data)\nprint(m)\n#> value=123\n\ntry:\n    DiscriminatedModel.model_validate({'value': 'not an int or a model'})\nexcept ValidationError as e:\n    print(e)  # (1)!\n    \"\"\"\n    1 validation error for DiscriminatedModel\n    value\n      Unable to extract tag using discriminator model_x_discriminator() [type=union_tag_not_found, input_value='not an int or a model', input_type=str]\n    \"\"\"\n```\n\n1. Notice the callable discriminator function returns `None` if a discriminator value is not found.\n   When `None` is returned, this `union_tag_not_found` error is raised.\n\n```\nfrom typing import Annotated, Any\n\nfrom pydantic import BaseModel, Discriminator, Tag, ValidationError\n\n\ndef model_x_discriminator(v: Any) -> str:\n    if isinstance(v, int):\n        return 'int'\n    if isinstance(v, (dict, BaseModel)):\n        return 'model'\n    else:\n        # return None if the discriminator value isn't found\n        return None\n\n\nclass SpecialValue(BaseModel):\n    value: int\n\n\nclass DiscriminatedModel(BaseModel):\n    value: Annotated[\n        (\n            Annotated[int, Tag('int')] |\n            Annotated['SpecialValue', Tag('model')]\n        ),\n        Discriminator(model_x_discriminator),\n    ]\n\n\nmodel_data = {'value': {'value': 1}}\nm = DiscriminatedModel.model_validate(model_data)\nprint(m)\n#> value=SpecialValue(value=1)\n\nint_data = {'value': 123}\nm = DiscriminatedModel.model_validate(int_data)\nprint(m)\n#> value=123\n\ntry:\n    DiscriminatedModel.model_validate({'value': 'not an int or a model'})\nexcept ValidationError as e:\n    print(e)  # (1)!\n    \"\"\"\n    1 validation error for DiscriminatedModel\n    value\n      Unable to extract tag using discriminator model_x_discriminator() [type=union_tag_not_found, input_value='not an int or a model', input_type=str]\n    \"\"\"\n```\n\n1. Notice the callable discriminator function returns `None` if a discriminator value is not found.\n   When `None` is returned, this `union_tag_not_found` error is raised.\n\nUsing the [annotated pattern](../fields/index.html#the-annotated-pattern) can be handy to regroup\nthe `Union` and `discriminator` information. See the next example for more details.\n\nThere are a few ways to set a discriminator for a field, all varying slightly in syntax.\n\nFor `str` discriminators:\n\n```\nsome_field: Union[...] = Field(discriminator='my_discriminator')\nsome_field: Annotated[Union[...], Field(discriminator='my_discriminator')]\n```\n\nFor callable `Discriminator`s:\n\n```\nsome_field: Union[...] = Field(discriminator=Discriminator(...))\nsome_field: Annotated[Union[...], Discriminator(...)]\nsome_field: Annotated[Union[...], Field(discriminator=Discriminator(...))]\n```\n\nDiscriminated unions cannot be used with only a single variant, such as `Union[Cat]`.\n\nPython changes `Union[T]` into `T` at interpretation time, so it is not possible for `pydantic` to\ndistinguish fields of `Union[T]` from `T`.", "url": "https://docs.pydantic.dev/latest/concepts/unions/index.html#discriminated-unions-with-callable-discriminatorindexhtmldiscriminated-unions-with-callable-discriminator-permanent-link", "page": "concepts/unions/index.html", "source_site": "pydantic"}
{"title": "Nested Discriminated Unions[Â¶](index.html#nested-discriminated-unions \"Permanent link\")", "anchor": "nested-discriminated-unionsindexhtmlnested-discriminated-unions-permanent-link", "md_text": "Only one discriminator can be set for a field but sometimes you want to combine multiple discriminators.\nYou can do it by creating nested `Annotated` types, e.g.:\n\n```\nfrom typing import Annotated, Literal, Union\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass BlackCat(BaseModel):\n    pet_type: Literal['cat']\n    color: Literal['black']\n    black_name: str\n\n\nclass WhiteCat(BaseModel):\n    pet_type: Literal['cat']\n    color: Literal['white']\n    white_name: str\n\n\nCat = Annotated[Union[BlackCat, WhiteCat], Field(discriminator='color')]\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n    name: str\n\n\nPet = Annotated[Union[Cat, Dog], Field(discriminator='pet_type')]\n\n\nclass Model(BaseModel):\n    pet: Pet\n    n: int\n\n\nm = Model(pet={'pet_type': 'cat', 'color': 'black', 'black_name': 'felix'}, n=1)\nprint(m)\n#> pet=BlackCat(pet_type='cat', color='black', black_name='felix') n=1\ntry:\n    Model(pet={'pet_type': 'cat', 'color': 'red'}, n='1')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    pet.cat\n      Input tag 'red' found using 'color' does not match any of the expected tags: 'black', 'white' [type=union_tag_invalid, input_value={'pet_type': 'cat', 'color': 'red'}, input_type=dict]\n    \"\"\"\ntry:\n    Model(pet={'pet_type': 'cat', 'color': 'black'}, n='1')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    pet.cat.black.black_name\n      Field required [type=missing, input_value={'pet_type': 'cat', 'color': 'black'}, input_type=dict]\n    \"\"\"\n```\n\nIf you want to validate data against a union, and solely a union, you can use pydantic's [`TypeAdapter`](../type_adapter/index.html) construct instead of inheriting from the standard `BaseModel`.\n\nIn the context of the previous example, we have the following:\n\n```\ntype_adapter = TypeAdapter(Pet)\n\npet = type_adapter.validate_python(\n    {'pet_type': 'cat', 'color': 'black', 'black_name': 'felix'}\n)\nprint(repr(pet))\n#> BlackCat(pet_type='cat', color='black', black_name='felix')\n```", "url": "https://docs.pydantic.dev/latest/concepts/unions/index.html#nested-discriminated-unionsindexhtmlnested-discriminated-unions-permanent-link", "page": "concepts/unions/index.html", "source_site": "pydantic"}
{"title": "Union Validation Errors[Â¶](index.html#union-validation-errors \"Permanent link\")", "anchor": "union-validation-errorsindexhtmlunion-validation-errors-permanent-link", "md_text": "When `Union` validation fails, error messages can be quite verbose, as they will produce validation errors for\neach case in the union.\nThis is especially noticeable when dealing with recursive models, where reasons may be generated at each level of\nrecursion.\nDiscriminated unions help to simplify error messages in this case, as validation errors are only produced for\nthe case with a matching discriminator value.\n\nYou can also customize the error type, message, and context for a `Discriminator` by passing\nthese specifications as parameters to the `Discriminator` constructor, as seen in the example below.\n\n```\nfrom typing import Annotated, Union\n\nfrom pydantic import BaseModel, Discriminator, Tag, ValidationError\n\n\n# Errors are quite verbose with a normal Union:\nclass Model(BaseModel):\n    x: Union[str, 'Model']\n\n\ntry:\n    Model.model_validate({'x': {'x': {'x': 1}}})\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    4 validation errors for Model\n    x.str\n      Input should be a valid string [type=string_type, input_value={'x': {'x': 1}}, input_type=dict]\n    x.Model.x.str\n      Input should be a valid string [type=string_type, input_value={'x': 1}, input_type=dict]\n    x.Model.x.Model.x.str\n      Input should be a valid string [type=string_type, input_value=1, input_type=int]\n    x.Model.x.Model.x.Model\n      Input should be a valid dictionary or instance of Model [type=model_type, input_value=1, input_type=int]\n    \"\"\"\n\ntry:\n    Model.model_validate({'x': {'x': {'x': {}}}})\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    4 validation errors for Model\n    x.str\n      Input should be a valid string [type=string_type, input_value={'x': {'x': {}}}, input_type=dict]\n    x.Model.x.str\n      Input should be a valid string [type=string_type, input_value={'x': {}}, input_type=dict]\n    x.Model.x.Model.x.str\n      Input should be a valid string [type=string_type, input_value={}, input_type=dict]\n    x.Model.x.Model.x.Model.x\n      Field required [type=missing, input_value={}, input_type=dict]\n    \"\"\"\n\n\n# Errors are much simpler with a discriminated union:\ndef model_x_discriminator(v):\n    if isinstance(v, str):\n        return 'str'\n    if isinstance(v, (dict, BaseModel)):\n        return 'model'\n\n\nclass DiscriminatedModel(BaseModel):\n    x: Annotated[\n        Union[\n            Annotated[str, Tag('str')],\n            Annotated['DiscriminatedModel', Tag('model')],\n        ],\n        Discriminator(\n            model_x_discriminator,\n            custom_error_type='invalid_union_member',  # (1)!\n            custom_error_message='Invalid union member',  # (2)!\n            custom_error_context={'discriminator': 'str_or_model'},  # (3)!\n        ),\n    ]\n\n\ntry:\n    DiscriminatedModel.model_validate({'x': {'x': {'x': 1}}})\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for DiscriminatedModel\n    x.model.x.model.x\n      Invalid union member [type=invalid_union_member, input_value=1, input_type=int]\n    \"\"\"\n\ntry:\n    DiscriminatedModel.model_validate({'x': {'x': {'x': {}}}})\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for DiscriminatedModel\n    x.model.x.model.x.model.x\n      Field required [type=missing, input_value={}, input_type=dict]\n    \"\"\"\n\n# The data is still handled properly when valid:\ndata = {'x': {'x': {'x': 'a'}}}\nm = DiscriminatedModel.model_validate(data)\nprint(m.model_dump())\n#> {'x': {'x': {'x': 'a'}}}\n```\n\n1. `custom_error_type` is the `type` attribute of the `ValidationError` raised when validation fails.\n2. `custom_error_message` is the `msg` attribute of the `ValidationError` raised when validation fails.\n3. `custom_error_context` is the `ctx` attribute of the `ValidationError` raised when validation fails.\n\nYou can also simplify error messages by labeling each case with a [`Tag`](../../api/types/index.html#pydantic.types.Tag).\nThis is especially useful when you have complex types like those in this example:\n\n```\nfrom typing import Annotated, Union\n\nfrom pydantic import AfterValidator, Tag, TypeAdapter, ValidationError\n\nDoubledList = Annotated[list[int], AfterValidator(lambda x: x * 2)]\nStringsMap = dict[str, str]\n\n\n# Not using any `Tag`s for each union case, the errors are not so nice to look at\nadapter = TypeAdapter(Union[DoubledList, StringsMap])\n\ntry:\n    adapter.validate_python(['a'])\nexcept ValidationError as exc_info:\n    print(exc_info)\n    \"\"\"\n    2 validation errors for union[function-after[<lambda>(), list[int]],dict[str,str]]\n    function-after[<lambda>(), list[int]].0\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='a', input_type=str]\n    dict[str,str]\n      Input should be a valid dictionary [type=dict_type, input_value=['a'], input_type=list]\n    \"\"\"\n\ntag_adapter = TypeAdapter(\n    Union[\n        Annotated[DoubledList, Tag('DoubledList')],\n        Annotated[StringsMap, Tag('StringsMap')],\n    ]\n)", "url": "https://docs.pydantic.dev/latest/concepts/unions/index.html#union-validation-errorsindexhtmlunion-validation-errors-permanent-link", "page": "concepts/unions/index.html", "source_site": "pydantic"}
{"title": "Union Validation Errors[Â¶](index.html#union-validation-errors \"Permanent link\")", "anchor": "union-validation-errorsindexhtmlunion-validation-errors-permanent-link", "md_text": "try:\n    tag_adapter.validate_python(['a'])\nexcept ValidationError as exc_info:\n    print(exc_info)\n    \"\"\"\n    2 validation errors for union[DoubledList,StringsMap]\n    DoubledList.0\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='a', input_type=str]\n    StringsMap\n      Input should be a valid dictionary [type=dict_type, input_value=['a'], input_type=list]\n    \"\"\"\n```\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/concepts/unions/index.html#union-validation-errorsindexhtmlunion-validation-errors-permanent-link", "page": "concepts/unions/index.html", "source_site": "pydantic"}
{"title": "The annotated pattern[Â¶](index.html#the-annotated-pattern \"Permanent link\")", "anchor": "the-annotated-patternindexhtmlthe-annotated-pattern-permanent-link", "md_text": "To apply constraints or attach [`Field()`](../../api/fields/index.html#pydantic.fields.Field) functions to a model field, Pydantic\nalso supports the [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated) typing construct to attach metadata to an annotation:\n\n```\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Field, WithJsonSchema\n\n\nclass Model(BaseModel):\n    name: Annotated[str, Field(strict=True), WithJsonSchema({'extra': 'data'})]\n```\n\nAs far as static type checkers are concerned, `name` is still typed as `str`, but Pydantic leverages\nthe available metadata to add validation logic, type constraints, etc.\n\nUsing this pattern has some advantages:\n\n* Using the `f: <type> = Field(...)` form can be confusing and might trick users into thinking `f`\n  has a default value, while in reality it is still required.\n* You can provide an arbitrary amount of metadata elements for a field. As shown in the example above,\n  the [`Field()`](../../api/fields/index.html#pydantic.fields.Field) function only supports a limited set of constraints/metadata,\n  and you may have to use different Pydantic utilities such as [`WithJsonSchema`](../../api/json_schema/index.html#pydantic.json_schema.WithJsonSchema)\n  in some cases.\n* Types can be made reusable (see the documentation on [custom types](../types/index.html#using-the-annotated-pattern)\n  using this pattern).\n\nHowever, note that certain arguments to the [`Field()`](../../api/fields/index.html#pydantic.fields.Field) function (namely, `default`,\n`default_factory`, and `alias`) are taken into account by static type checkers to synthesize a correct\n`__init__()` method. The annotated pattern is *not* understood by them, so you should use the normal\nassignment form instead.\n\nThe annotated pattern can also be used to add metadata to specific parts of the type. For instance,\n[validation constraints](index.html#field-constraints) can be added this way:\n\n```\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    int_list: list[Annotated[int, Field(gt=0)]]\n    # Valid: [1, 3]\n    # Invalid: [-1, 2]\n```\n\nBe careful not mixing *field* and *type* metadata:\n\n```\nclass Model(BaseModel):\n    field_bad: Annotated[int, Field(deprecated=True)] | None = None  # (1)!\n    field_ok: Annotated[int | None, Field(deprecated=True)] = None  # (2)!\n```\n\n1. The [`Field()`](../../api/fields/index.html#pydantic.fields.Field) function is applied to `int` type, hence the\n   `deprecated` flag won't have any effect. While this may be confusing given that the name of\n   the [`Field()`](../../api/fields/index.html#pydantic.fields.Field) function would imply it should apply to the field,\n   the API was designed when this function was the only way to provide metadata. You can\n   alternatively make use of the [`annotated_types`](https://github.com/annotated-types/annotated-types)\n   library which is now supported by Pydantic.\n2. The [`Field()`](../../api/fields/index.html#pydantic.fields.Field) function is applied to the \"top-level\" union type,\n   hence the `deprecated` flag will be applied to the field.", "url": "https://docs.pydantic.dev/latest/concepts/fields/index.html#the-annotated-patternindexhtmlthe-annotated-pattern-permanent-link", "page": "concepts/fields/index.html", "source_site": "pydantic"}
{"title": "Inspecting model fields[Â¶](index.html#inspecting-model-fields \"Permanent link\")", "anchor": "inspecting-model-fieldsindexhtmlinspecting-model-fields-permanent-link", "md_text": "The fields of a model can be inspected using the [`model_fields`](../../api/base_model/index.html#pydantic.BaseModel.model_fields) class attribute\n(or the `__pydantic_fields__` attribute for [Pydantic dataclasses](../dataclasses/index.html)). It is a mapping of field names\nto their definition (represented as [`FieldInfo`](../../api/fields/index.html#pydantic.fields.FieldInfo) instances).\n\n```\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Field, WithJsonSchema\n\n\nclass Model(BaseModel):\n    a: Annotated[\n        int, Field(gt=1), WithJsonSchema({'extra': 'data'}), Field(alias='b')\n    ] = 1\n\n\nfield_info = Model.model_fields['a']\nprint(field_info.annotation)\n#> <class 'int'>\nprint(field_info.alias)\n#> b\nprint(field_info.metadata)\n#> [Gt(gt=1), WithJsonSchema(json_schema={'extra': 'data'}, mode=None)]\n```", "url": "https://docs.pydantic.dev/latest/concepts/fields/index.html#inspecting-model-fieldsindexhtmlinspecting-model-fields-permanent-link", "page": "concepts/fields/index.html", "source_site": "pydantic"}
{"title": "Default values[Â¶](index.html#default-values \"Permanent link\")", "anchor": "default-valuesindexhtmldefault-values-permanent-link", "md_text": "Default values for fields can be provided using the normal assignment syntax or by providing a value\nto the `default` argument:\n\n```\nfrom pydantic import BaseModel, Field\n\n\nclass User(BaseModel):\n    # Both fields aren't required:\n    name: str = 'John Doe'\n    age: int = Field(default=20)\n```\n\n[In Pydantic V1](../../migration/index.html#required-optional-and-nullable-fields), a type annotated as [`Any`](https://docs.python.org/3/library/typing.html#typing.Any)\nor wrapped by [`Optional`](https://docs.python.org/3/library/typing.html#typing.Optional) would be given an implicit default of `None` even if no\ndefault was explicitly specified. This is no longer the case in Pydantic V2.\n\nYou can also pass a callable to the `default_factory` argument that will be called to generate a default value:\n\n```\nfrom uuid import uuid4\n\nfrom pydantic import BaseModel, Field\n\n\nclass User(BaseModel):\n    id: str = Field(default_factory=lambda: uuid4().hex)\n```\n\nThe default factory can also take a single required argument, in which case the already validated data will be passed as a dictionary.\n\n```\nfrom pydantic import BaseModel, EmailStr, Field\n\n\nclass User(BaseModel):\n    email: EmailStr\n    username: str = Field(default_factory=lambda data: data['email'])\n\n\nuser = User(email='[emailÂ protected]')\nprint(user.username)\n#> [emailÂ protected]\n```\n\nThe `data` argument will *only* contain the already validated data, based on the [order of model fields](../models/index.html#field-ordering)\n(the above example would fail if `username` were to be defined before `email`).", "url": "https://docs.pydantic.dev/latest/concepts/fields/index.html#default-valuesindexhtmldefault-values-permanent-link", "page": "concepts/fields/index.html", "source_site": "pydantic"}
{"title": "Validate default values[Â¶](index.html#validate-default-values \"Permanent link\")", "anchor": "validate-default-valuesindexhtmlvalidate-default-values-permanent-link", "md_text": "By default, Pydantic will *not* validate default values. The `validate_default` field parameter\n(or the [`validate_default`](../../api/config/index.html#pydantic.config.ConfigDict.validate_default) configuration value) can be used\nto enable this behavior:\n\n```\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass User(BaseModel):\n    age: int = Field(default='twelve', validate_default=True)\n\n\ntry:\n    user = User()\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n    age\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='twelve', input_type=str]\n    \"\"\"\n```", "url": "https://docs.pydantic.dev/latest/concepts/fields/index.html#validate-default-valuesindexhtmlvalidate-default-values-permanent-link", "page": "concepts/fields/index.html", "source_site": "pydantic"}
{"title": "Mutable default values[Â¶](index.html#mutable-default-values \"Permanent link\")", "anchor": "mutable-default-valuesindexhtmlmutable-default-values-permanent-link", "md_text": "A common source of bugs in Python is to use a mutable object as a default value for a function or method argument,\nas the same instance ends up being reused in each call.\n\nThe [`dataclasses`](https://docs.python.org/3/library/dataclasses.html#module-dataclasses) module actually raises an error in this case, indicating that you should use\na [default factory](https://docs.python.org/3/library/dataclasses.html#default-factory-functions) instead.\n\nWhile the same thing can be done in Pydantic, it is not required. In the event that the default value is not hashable,\nPydantic will create a deep copy of the default value when creating each instance of the model:\n\n```\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    item_counts: list[dict[str, int]] = [{}]\n\n\nm1 = Model()\nm1.item_counts[0]['a'] = 1\nprint(m1.item_counts)\n#> [{'a': 1}]\n\nm2 = Model()\nprint(m2.item_counts)\n#> [{}]\n```", "url": "https://docs.pydantic.dev/latest/concepts/fields/index.html#mutable-default-valuesindexhtmlmutable-default-values-permanent-link", "page": "concepts/fields/index.html", "source_site": "pydantic"}
{"title": "Field aliases[Â¶](index.html#field-aliases \"Permanent link\")", "anchor": "field-aliasesindexhtmlfield-aliases-permanent-link", "md_text": "Read more about aliases in the [dedicated section](../alias/index.html).\n\nFor validation and serialization, you can define an alias for a field.\n\nThere are three ways to define an alias:\n\n* `Field(alias='foo')`\n* `Field(validation_alias='foo')`\n* `Field(serialization_alias='foo')`\n\nThe `alias` parameter is used for both validation *and* serialization. If you want to use\n*different* aliases for validation and serialization respectively, you can use the `validation_alias`\nand `serialization_alias` parameters, which will apply only in their respective use cases.\n\nHere is an example of using the `alias` parameter:\n\n```\nfrom pydantic import BaseModel, Field\n\n\nclass User(BaseModel):\n    name: str = Field(alias='username')\n\n\nuser = User(username='johndoe')  # (1)!\nprint(user)\n#> name='johndoe'\nprint(user.model_dump(by_alias=True))  # (2)!\n#> {'username': 'johndoe'}\n```\n\n1. The alias `'username'` is used for instance creation and validation.\n2. We are using [`model_dump()`](../../api/base_model/index.html#pydantic.BaseModel.model_dump) to convert the model into a serializable format.\n\n   Note that the `by_alias` keyword argument defaults to `False`, and must be specified explicitly to dump\n   models using the field (serialization) aliases.\n\n   You can also use [`ConfigDict.serialize_by_alias`](../../api/config/index.html#pydantic.config.ConfigDict.serialize_by_alias) to\n   configure this behavior at the model level.\n\n   When `by_alias=True`, the alias `'username'` used during serialization.\n\nIf you want to use an alias *only* for validation, you can use the `validation_alias` parameter:\n\n```\nfrom pydantic import BaseModel, Field\n\n\nclass User(BaseModel):\n    name: str = Field(validation_alias='username')\n\n\nuser = User(username='johndoe')  # (1)!\nprint(user)\n#> name='johndoe'\nprint(user.model_dump(by_alias=True))  # (2)!\n#> {'name': 'johndoe'}\n```\n\n1. The validation alias `'username'` is used during validation.\n2. The field name `'name'` is used during serialization.\n\nIf you only want to define an alias for *serialization*, you can use the `serialization_alias` parameter:\n\n```\nfrom pydantic import BaseModel, Field\n\n\nclass User(BaseModel):\n    name: str = Field(serialization_alias='username')\n\n\nuser = User(name='johndoe')  # (1)!\nprint(user)\n#> name='johndoe'\nprint(user.model_dump(by_alias=True))  # (2)!\n#> {'username': 'johndoe'}\n```\n\n1. The field name `'name'` is used for validation.\n2. The serialization alias `'username'` is used for serialization.\n\nIn case you use `alias` together with `validation_alias` or `serialization_alias` at the same time,\nthe `validation_alias` will have priority over `alias` for validation, and `serialization_alias` will have priority\nover `alias` for serialization.\n\nIf you provide a value for the [`alias_generator`](../../api/config/index.html#pydantic.config.ConfigDict.alias_generator) model setting, you can control the order of precedence for field alias and generated aliases via the `alias_priority` field parameter. You can read more about alias precedence [here](../alias/index.html#alias-precedence).\n\nStatic type checking/IDE support\n\nIf you provide a value for the `alias` field parameter, static type checkers will use this alias instead\nof the actual field name to synthesize the `__init__` method:\n\n```\nfrom pydantic import BaseModel, Field\n\n\nclass User(BaseModel):\n    name: str = Field(alias='username')\n\n\nuser = User(username='johndoe')  # (1)!\n```\n\n1. Accepted by type checkers.\n\nThis means that when using the [`validate_by_name`](../../api/config/index.html#pydantic.config.ConfigDict.validate_by_name) model setting (which allows both the field name and alias to be used during model validation), type checkers will error when the actual field name is used:\n\n```\nfrom pydantic import BaseModel, ConfigDict, Field\n\n\nclass User(BaseModel):\n    model_config = ConfigDict(validate_by_name=True)\n\n    name: str = Field(alias='username')\n\n\nuser = User(name='johndoe')  # (1)!\n```\n\n1. *Not* accepted by type checkers.\n\nIf you still want type checkers to use the field name and not the alias, the [annotated pattern](index.html#the-annotated-pattern)\ncan be used (which is only understood by Pydantic):\n\n```\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, ConfigDict, Field\n\n\nclass User(BaseModel):\n    model_config = ConfigDict(validate_by_name=True, validate_by_alias=True)\n\n    name: Annotated[str, Field(alias='username')]\n\n\nuser = User(name='johndoe')  # (1)!\nuser = User(username='johndoe')  # (2)!\n```\n\n1. Accepted by type checkers.\n2. *Not* accepted by type checkers.", "url": "https://docs.pydantic.dev/latest/concepts/fields/index.html#field-aliasesindexhtmlfield-aliases-permanent-link", "page": "concepts/fields/index.html", "source_site": "pydantic"}
{"title": "Validation Alias", "anchor": "validation-alias", "md_text": "Even though Pydantic treats `alias` and `validation_alias` the same when creating model instances, type checkers\nonly understand the `alias` field parameter. As a workaround, you can instead specify both an `alias` and\n`serialization_alias` (identical to the field name), as the `serialization_alias` will override the `alias` during\nserialization:\n\n```\nfrom pydantic import BaseModel, Field\n\n\nclass MyModel(BaseModel):\n    my_field: int = Field(validation_alias='myValidationAlias')\n```\n\nwith:\n\n```\nfrom pydantic import BaseModel, Field\n\n\nclass MyModel(BaseModel):\n    my_field: int = Field(\n        alias='myValidationAlias',\n        serialization_alias='my_field',\n    )\n\n\nm = MyModel(myValidationAlias=1)\nprint(m.model_dump(by_alias=True))\n#> {'my_field': 1}\n```", "url": "https://docs.pydantic.dev/latest/concepts/fields/index.html#validation-alias", "page": "concepts/fields/index.html", "source_site": "pydantic"}
{"title": "Field constraints[Â¶](index.html#field-constraints \"Permanent link\")", "anchor": "field-constraintsindexhtmlfield-constraints-permanent-link", "md_text": "The [`Field()`](../../api/fields/index.html#pydantic.fields.Field) function can also be used to add constraints to specific types:\n\n```\nfrom decimal import Decimal\n\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    positive: int = Field(gt=0)\n    short_str: str = Field(max_length=3)\n    precise_decimal: Decimal = Field(max_digits=5, decimal_places=2)\n```\n\nThe available constraints for each type (and the way they affect the JSON Schema) are described\nin the [standard library types](../../api/standard_library_types/index.html) documentation.", "url": "https://docs.pydantic.dev/latest/concepts/fields/index.html#field-constraintsindexhtmlfield-constraints-permanent-link", "page": "concepts/fields/index.html", "source_site": "pydantic"}
{"title": "Strict fields[Â¶](index.html#strict-fields \"Permanent link\")", "anchor": "strict-fieldsindexhtmlstrict-fields-permanent-link", "md_text": "The `strict` parameter of the [`Field()`](../../api/fields/index.html#pydantic.fields.Field) function specifies whether the field should be validated in\n[strict mode](../strict_mode/index.html).\n\n```\nfrom pydantic import BaseModel, Field\n\n\nclass User(BaseModel):\n    name: str = Field(strict=True)\n    age: int = Field(strict=False)  # (1)!\n\n\nuser = User(name='John', age='42')  # (2)!\nprint(user)\n#> name='John' age=42\n```\n\n1. This is the default value.\n2. The `age` field is validated in lax mode. Therefore, it can be assigned a string.\n\nThe [standard library types](../../api/standard_library_types/index.html) documentation describes the strict behavior for each type.", "url": "https://docs.pydantic.dev/latest/concepts/fields/index.html#strict-fieldsindexhtmlstrict-fields-permanent-link", "page": "concepts/fields/index.html", "source_site": "pydantic"}
{"title": "Dataclass fields[Â¶](index.html#dataclass-fields \"Permanent link\")", "anchor": "dataclass-fieldsindexhtmldataclass-fields-permanent-link", "md_text": "Some parameters of the [`Field()`](../../api/fields/index.html#pydantic.fields.Field) function can be used on [dataclasses](../dataclasses/index.html):\n\n* `init`: Whether the field should be included in the synthesized `__init__()` method of the dataclass.\n* `init_var`: Whether the field should be [init-only](https://docs.python.org/3/library/dataclasses.html#dataclasses-init-only-variables) in the dataclass.\n* `kw_only`: Whether the field should be a keyword-only argument in the constructor of the dataclass.\n\nHere is an example:\n\n```\nfrom pydantic import BaseModel, Field\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass Foo:\n    bar: str\n    baz: str = Field(init_var=True)\n    qux: str = Field(kw_only=True)\n\n\nclass Model(BaseModel):\n    foo: Foo\n\n\nmodel = Model(foo=Foo('bar', baz='baz', qux='qux'))\nprint(model.model_dump())  # (1)!\n#> {'foo': {'bar': 'bar', 'qux': 'qux'}}\n```\n\n1. The `baz` field is not included in the serialized output, since it is an init-only field.", "url": "https://docs.pydantic.dev/latest/concepts/fields/index.html#dataclass-fieldsindexhtmldataclass-fields-permanent-link", "page": "concepts/fields/index.html", "source_site": "pydantic"}
{"title": "Field Representation[Â¶](index.html#field-representation \"Permanent link\")", "anchor": "field-representationindexhtmlfield-representation-permanent-link", "md_text": "The parameter `repr` can be used to control whether the field should be included in the string\nrepresentation of the model.\n\n```\nfrom pydantic import BaseModel, Field\n\n\nclass User(BaseModel):\n    name: str = Field(repr=True)  # (1)!\n    age: int = Field(repr=False)\n\n\nuser = User(name='John', age=42)\nprint(user)\n#> name='John'\n```\n\n1. This is the default value.", "url": "https://docs.pydantic.dev/latest/concepts/fields/index.html#field-representationindexhtmlfield-representation-permanent-link", "page": "concepts/fields/index.html", "source_site": "pydantic"}
{"title": "Discriminator[Â¶](index.html#discriminator \"Permanent link\")", "anchor": "discriminatorindexhtmldiscriminator-permanent-link", "md_text": "The parameter `discriminator` can be used to control the field that will be used to discriminate between different\nmodels in a union. It takes either the name of a field or a `Discriminator` instance. The `Discriminator`\napproach can be useful when the discriminator fields aren't the same for all the models in the `Union`.\n\nThe following example shows how to use `discriminator` with a field name:\n\nPython 3.9 and abovePython 3.10 and above\n\n```\nfrom typing import Literal, Union\n\nfrom pydantic import BaseModel, Field\n\n\nclass Cat(BaseModel):\n    pet_type: Literal['cat']\n    age: int\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n    age: int\n\n\nclass Model(BaseModel):\n    pet: Union[Cat, Dog] = Field(discriminator='pet_type')\n\n\nprint(Model.model_validate({'pet': {'pet_type': 'cat', 'age': 12}}))  # (1)!\n#> pet=Cat(pet_type='cat', age=12)\n```\n\n1. See more about [Validating data](../models/index.html#validating-data) in the [Models](../models/index.html) page.\n\n```\nfrom typing import Literal\n\nfrom pydantic import BaseModel, Field\n\n\nclass Cat(BaseModel):\n    pet_type: Literal['cat']\n    age: int\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n    age: int\n\n\nclass Model(BaseModel):\n    pet: Cat | Dog = Field(discriminator='pet_type')\n\n\nprint(Model.model_validate({'pet': {'pet_type': 'cat', 'age': 12}}))  # (1)!\n#> pet=Cat(pet_type='cat', age=12)\n```\n\n1. See more about [Validating data](../models/index.html#validating-data) in the [Models](../models/index.html) page.\n\nThe following example shows how to use the `discriminator` keyword argument with a `Discriminator` instance:\n\nPython 3.9 and abovePython 3.10 and above\n\n```\nfrom typing import Annotated, Literal, Union\n\nfrom pydantic import BaseModel, Discriminator, Field, Tag\n\n\nclass Cat(BaseModel):\n    pet_type: Literal['cat']\n    age: int\n\n\nclass Dog(BaseModel):\n    pet_kind: Literal['dog']\n    age: int\n\n\ndef pet_discriminator(v):\n    if isinstance(v, dict):\n        return v.get('pet_type', v.get('pet_kind'))\n    return getattr(v, 'pet_type', getattr(v, 'pet_kind', None))\n\n\nclass Model(BaseModel):\n    pet: Union[Annotated[Cat, Tag('cat')], Annotated[Dog, Tag('dog')]] = Field(\n        discriminator=Discriminator(pet_discriminator)\n    )\n\n\nprint(repr(Model.model_validate({'pet': {'pet_type': 'cat', 'age': 12}})))\n#> Model(pet=Cat(pet_type='cat', age=12))\n\nprint(repr(Model.model_validate({'pet': {'pet_kind': 'dog', 'age': 12}})))\n#> Model(pet=Dog(pet_kind='dog', age=12))\n\nfrom typing import Annotated, Literal\n\nfrom pydantic import BaseModel, Discriminator, Field, Tag\n\n\nclass Cat(BaseModel):\n    pet_type: Literal['cat']\n    age: int\n\n\nclass Dog(BaseModel):\n    pet_kind: Literal['dog']\n    age: int\n\n\ndef pet_discriminator(v):\n    if isinstance(v, dict):\n        return v.get('pet_type', v.get('pet_kind'))\n    return getattr(v, 'pet_type', getattr(v, 'pet_kind', None))\n\n\nclass Model(BaseModel):\n    pet: Annotated[Cat, Tag('cat')] | Annotated[Dog, Tag('dog')] = Field(\n        discriminator=Discriminator(pet_discriminator)\n    )\n\n\nprint(repr(Model.model_validate({'pet': {'pet_type': 'cat', 'age': 12}})))\n#> Model(pet=Cat(pet_type='cat', age=12))\n\nprint(repr(Model.model_validate({'pet': {'pet_kind': 'dog', 'age': 12}})))\n#> Model(pet=Dog(pet_kind='dog', age=12))\n```\n\nYou can also take advantage of `Annotated` to define your discriminated unions.\nSee the [Discriminated Unions](../unions/index.html#discriminated-unions) docs for more details.", "url": "https://docs.pydantic.dev/latest/concepts/fields/index.html#discriminatorindexhtmldiscriminator-permanent-link", "page": "concepts/fields/index.html", "source_site": "pydantic"}
{"title": "Immutability[Â¶](index.html#immutability \"Permanent link\")", "anchor": "immutabilityindexhtmlimmutability-permanent-link", "md_text": "The parameter `frozen` is used to emulate the frozen dataclass behaviour. It is used to prevent the field from being\nassigned a new value after the model is created (immutability).\n\nSee the [frozen dataclass documentation](https://docs.python.org/3/library/dataclasses.html#frozen-instances) for more details.\n\n```\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass User(BaseModel):\n    name: str = Field(frozen=True)\n    age: int\n\n\nuser = User(name='John', age=42)\n\ntry:\n    user.name = 'Jane'  # (1)!\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n    name\n      Field is frozen [type=frozen_field, input_value='Jane', input_type=str]\n    \"\"\"\n```\n\n1. Since `name` field is frozen, the assignment is not allowed.", "url": "https://docs.pydantic.dev/latest/concepts/fields/index.html#immutabilityindexhtmlimmutability-permanent-link", "page": "concepts/fields/index.html", "source_site": "pydantic"}
{"title": "Excluding fields[Â¶](index.html#excluding-fields \"Permanent link\")", "anchor": "excluding-fieldsindexhtmlexcluding-fields-permanent-link", "md_text": "The `exclude` and `exclude_if` parameters can be used to control which fields should be excluded from the\nmodel when exporting the model.\n\nSee the following example:\n\n```\nfrom pydantic import BaseModel, Field\n\n\nclass User(BaseModel):\n    name: str\n    age: int = Field(exclude=True)\n\n\nuser = User(name='John', age=42)\nprint(user.model_dump())  # (1)!\n#> {'name': 'John'}\n```\n\n1. The `age` field is not included in the [`model_dump()`](../../api/base_model/index.html#pydantic.BaseModel.model_dump) output, since it is excluded.\n\nSee the dedicated [serialization section](../serialization/index.html#field-inclusion-and-exclusion) for more details.", "url": "https://docs.pydantic.dev/latest/concepts/fields/index.html#excluding-fieldsindexhtmlexcluding-fields-permanent-link", "page": "concepts/fields/index.html", "source_site": "pydantic"}
{"title": "Deprecated fields[Â¶](index.html#deprecated-fields \"Permanent link\")", "anchor": "deprecated-fieldsindexhtmldeprecated-fields-permanent-link", "md_text": "The `deprecated` parameter can be used to mark a field as being deprecated. Doing so will result in:\n\n* a runtime deprecation warning emitted when accessing the field.\n* The [deprecated](https://json-schema.org/draft/2020-12/json-schema-validation#section-9.3) keyword\n  being set in the generated JSON schema.\n\nThis parameter accepts different types, described below.", "url": "https://docs.pydantic.dev/latest/concepts/fields/index.html#deprecated-fieldsindexhtmldeprecated-fields-permanent-link", "page": "concepts/fields/index.html", "source_site": "pydantic"}
{"title": "`deprecated` as a string[Â¶](index.html#deprecated-as-a-string \"Permanent link\")", "anchor": "deprecated-as-a-stringindexhtmldeprecated-as-a-string-permanent-link", "md_text": "The value will be used as the deprecation message.\n\n```\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    deprecated_field: Annotated[int, Field(deprecated='This is deprecated')]\n\n\nprint(Model.model_json_schema()['properties']['deprecated_field'])\n#> {'deprecated': True, 'title': 'Deprecated Field', 'type': 'integer'}\n```", "url": "https://docs.pydantic.dev/latest/concepts/fields/index.html#deprecated-as-a-stringindexhtmldeprecated-as-a-string-permanent-link", "page": "concepts/fields/index.html", "source_site": "pydantic"}
{"title": "`deprecated` via the `@warnings.deprecated` decorator[Â¶](index.html#deprecated-via-the-warningsdeprecated-decorator \"Permanent link\")", "anchor": "deprecated-via-the-warningsdeprecated-decoratorindexhtmldeprecated-via-the-warningsdeprecated-decorator-permanent-link", "md_text": "The [`@warnings.deprecated`](https://docs.python.org/3/library/warnings.html#warnings.deprecated) decorator (or the\n[`typing_extensions` backport](https://typing-extensions.readthedocs.io/en/latest/index.html#typing_extensions.deprecated) on Python\n3.12 and lower) can be used as an instance.\n\nPython 3.9 and abovePython 3.13 and above\n\n```\nfrom typing import Annotated\n\nfrom typing_extensions import deprecated\n\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    deprecated_field: Annotated[int, deprecated('This is deprecated')]\n\n    # Or explicitly using `Field`:\n    alt_form: Annotated[int, Field(deprecated=deprecated('This is deprecated'))]\n\nfrom typing import Annotated\nfrom warnings import deprecated\n\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    deprecated_field: Annotated[int, deprecated('This is deprecated')]\n\n    # Or explicitly using `Field`:\n    alt_form: Annotated[int, Field(deprecated=deprecated('This is deprecated'))]\n```\n\nThe current implementation of this feature does not take into account the `category` and `stacklevel`\narguments to the `deprecated` decorator. This might land in a future version of Pydantic.", "url": "https://docs.pydantic.dev/latest/concepts/fields/index.html#deprecated-via-the-warningsdeprecated-decoratorindexhtmldeprecated-via-the-warningsdeprecated-decorator-permanent-link", "page": "concepts/fields/index.html", "source_site": "pydantic"}
{"title": "`deprecated` as a boolean[Â¶](index.html#deprecated-as-a-boolean \"Permanent link\")", "anchor": "deprecated-as-a-booleanindexhtmldeprecated-as-a-boolean-permanent-link", "md_text": "```\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    deprecated_field: Annotated[int, Field(deprecated=True)]\n\n\nprint(Model.model_json_schema()['properties']['deprecated_field'])\n#> {'deprecated': True, 'title': 'Deprecated Field', 'type': 'integer'}\n```\n\nWhen accessing a deprecated field inside a validator, the deprecation warning will be emitted. You can use\n[`catch_warnings`](https://docs.python.org/3/library/warnings.html#warnings.catch_warnings) to explicitly ignore it:\n\n```\nimport warnings\n\nfrom typing_extensions import Self\n\nfrom pydantic import BaseModel, Field, model_validator\n\n\nclass Model(BaseModel):\n    deprecated_field: int = Field(deprecated='This is deprecated')\n\n    @model_validator(mode='after')\n    def validate_model(self) -> Self:\n        with warnings.catch_warnings():\n            warnings.simplefilter('ignore', DeprecationWarning)\n            self.deprecated_field = self.deprecated_field * 2\n```", "url": "https://docs.pydantic.dev/latest/concepts/fields/index.html#deprecated-as-a-booleanindexhtmldeprecated-as-a-boolean-permanent-link", "page": "concepts/fields/index.html", "source_site": "pydantic"}
{"title": "Customizing JSON Schema[Â¶](index.html#customizing-json-schema \"Permanent link\")", "anchor": "customizing-json-schemaindexhtmlcustomizing-json-schema-permanent-link", "md_text": "Some field parameters are used exclusively to customize the generated JSON schema. The parameters in question are:\n\n* `title`\n* `description`\n* `examples`\n* `json_schema_extra`\n\nRead more about JSON schema customization / modification with fields in the [Customizing JSON Schema](../json_schema/index.html#field-level-customization) section of the JSON schema docs.", "url": "https://docs.pydantic.dev/latest/concepts/fields/index.html#customizing-json-schemaindexhtmlcustomizing-json-schema-permanent-link", "page": "concepts/fields/index.html", "source_site": "pydantic"}
{"title": "The `computed_field` decorator[Â¶](index.html#the-computed_field-decorator \"Permanent link\")", "anchor": "the-computedfield-decoratorindexhtmlthe-computedfield-decorator-permanent-link", "md_text": "API Documentation\n\n[`computed_field`](../../api/fields/index.html#pydantic.fields.computed_field)\n\nThe [`computed_field`](../../api/fields/index.html#pydantic.fields.computed_field) decorator can be used to include [`property`](https://docs.python.org/3/library/functions.html#property) or\n[`cached_property`](https://docs.python.org/3/library/functools.html#functools.cached_property) attributes when serializing a model or dataclass.\nThe property will also be taken into account in the JSON Schema (in serialization mode).\n\nProperties can be useful for fields that are computed from other fields, or for fields that\nare expensive to be computed (and thus, are cached if using [`cached_property`](https://docs.python.org/3/library/functools.html#functools.cached_property)).\n\nHowever, note that Pydantic will *not* perform any additional logic on the wrapped property\n(validation, cache invalidation, etc.).\n\nHere's an example of the JSON schema (in serialization mode) generated for a model with a computed field:\n\n```\nfrom pydantic import BaseModel, computed_field\n\n\nclass Box(BaseModel):\n    width: float\n    height: float\n    depth: float\n\n    @computed_field\n    @property  # (1)!\n    def volume(self) -> float:\n        return self.width * self.height * self.depth\n\n\nprint(Box.model_json_schema(mode='serialization'))\n\"\"\"\n{\n    'properties': {\n        'width': {'title': 'Width', 'type': 'number'},\n        'height': {'title': 'Height', 'type': 'number'},\n        'depth': {'title': 'Depth', 'type': 'number'},\n        'volume': {'readOnly': True, 'title': 'Volume', 'type': 'number'},\n    },\n    'required': ['width', 'height', 'depth', 'volume'],\n    'title': 'Box',\n    'type': 'object',\n}\n\"\"\"\n```\n\n1. If not specified, [`computed_field`](../../api/fields/index.html#pydantic.fields.computed_field) will implicitly convert the method\n   to a [`property`](https://docs.python.org/3/library/functions.html#property). However, it is preferable to explicitly use the [`@property`](https://docs.python.org/3/library/functions.html#property) decorator\n   for type checking purposes.\n\nHere's an example using the `model_dump` method with a computed field:\n\n```\nfrom pydantic import BaseModel, computed_field\n\n\nclass Box(BaseModel):\n    width: float\n    height: float\n    depth: float\n\n    @computed_field\n    @property\n    def volume(self) -> float:\n        return self.width * self.height * self.depth\n\n\nb = Box(width=1, height=2, depth=3)\nprint(b.model_dump())\n#> {'width': 1.0, 'height': 2.0, 'depth': 3.0, 'volume': 6.0}\n```\n\nAs with regular fields, computed fields can be marked as being deprecated:\n\n```\nfrom typing_extensions import deprecated\n\nfrom pydantic import BaseModel, computed_field\n\n\nclass Box(BaseModel):\n    width: float\n    height: float\n    depth: float\n\n    @computed_field\n    @property\n    @deprecated(\"'volume' is deprecated\")\n    def volume(self) -> float:\n        return self.width * self.height * self.depth\n```\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/concepts/fields/index.html#the-computedfield-decoratorindexhtmlthe-computedfield-decorator-permanent-link", "page": "concepts/fields/index.html", "source_site": "pydantic"}
{"title": "Feedback[Â¶](index.html#feedback \"Permanent link\")", "anchor": "feedbackindexhtmlfeedback-permanent-link", "md_text": "We welcome feedback on experimental features! Please open an issue on the [Pydantic GitHub repository](https://github.com/pydantic/pydantic/issues/new/choose) to share your thoughts, requests, or suggestions.\n\nWe also encourage you to read through existing feedback and add your thoughts to existing issues.", "url": "https://docs.pydantic.dev/latest/concepts/experimental/index.html#feedbackindexhtmlfeedback-permanent-link", "page": "concepts/experimental/index.html", "source_site": "pydantic"}
{"title": "Pipeline API[Â¶](index.html#pipeline-api \"Permanent link\")", "anchor": "pipeline-apiindexhtmlpipeline-api-permanent-link", "md_text": "Pydantic v2.8.0 introduced an experimental \"pipeline\" API that allows composing of parsing (validation), constraints and transformations in a more type-safe manner than existing APIs. This API is subject to change or removal, we are looking for feedback and suggestions before making it a permanent part of Pydantic.\n\nAPI Documentation\n\n[`pydantic.experimental.pipeline`](../../api/experimental/index.html#pydantic.experimental.pipeline)\n\nGenerally, the pipeline API is used to define a sequence of steps to apply to incoming data during validation. The pipeline API is designed to be more type-safe and composable than the existing Pydantic API.\n\nEach step in the pipeline can be:\n\n* A validation step that runs pydantic validation on the provided type\n* A transformation step that modifies the data\n* A constraint step that checks the data against a condition\n* A predicate step that checks the data against a condition and raises an error if it returns `False`\n\nNote that the following example attempts to be exhaustive at the cost of complexity: if you find yourself writing this many transformations in type annotations you may want to consider having a `UserIn` and `UserOut` model (example below) or similar where you make the transformations via idiomatic plain Python code.\nThese APIs are meant for situations where the code savings are significant and the added complexity is relatively small.\n\n```\nfrom __future__ import annotations\n\nfrom datetime import datetime\nfrom typing import Annotated\n\nfrom pydantic import BaseModel\nfrom pydantic.experimental.pipeline import validate_as\n\n\nclass User(BaseModel):\n    name: Annotated[str, validate_as(str).str_lower()]  # (1)!\n    age: Annotated[int, validate_as(int).gt(0)]  # (2)!\n    username: Annotated[str, validate_as(str).str_pattern(r'[a-z]+')]  # (3)!\n    password: Annotated[\n        str,\n        validate_as(str)\n        .transform(str.lower)\n        .predicate(lambda x: x != 'password'),  # (4)!\n    ]\n    favorite_number: Annotated[  # (5)!\n        int,\n        (validate_as(int) | validate_as(str).str_strip().validate_as(int)).gt(\n            0\n        ),\n    ]\n    friends: Annotated[list[User], validate_as(...).len(0, 100)]  # (6)!\n    bio: Annotated[\n        datetime,\n        validate_as(int)\n        .transform(lambda x: x / 1_000_000)\n        .validate_as(...),  # (8)!\n    ]\n```\n\n1. Lowercase a string.\n2. Constrain an integer to be greater than zero.\n3. Constrain a string to match a regex pattern.\n4. You can also use the lower level transform, constrain and predicate methods.\n5. Use the `|` or `&` operators to combine steps (like a logical OR or AND).\n6. Calling `validate_as(...)` with `Ellipsis`, `...` as the first positional argument implies `validate_as(<field type>)`. Use `validate_as(Any)` to accept any type.\n7. You can call `validate_as()` before or after other steps to do pre or post processing.", "url": "https://docs.pydantic.dev/latest/concepts/experimental/index.html#pipeline-apiindexhtmlpipeline-api-permanent-link", "page": "concepts/experimental/index.html", "source_site": "pydantic"}
{"title": "Mapping from `BeforeValidator`, `AfterValidator` and `WrapValidator`[Â¶](index.html#mapping-from-beforevalidator-aftervalidator-and-wrapvalidator \"Permanent link\")", "anchor": "mapping-from-beforevalidator-aftervalidator-and-wrapvalidatorindexhtmlmapping-from-beforevalidator-aftervalidator-and-wrapvalidator-permanent-link", "md_text": "The `validate_as` method is a more type-safe way to define `BeforeValidator`, `AfterValidator` and `WrapValidator`:\n\n```\nfrom typing import Annotated\n\nfrom pydantic.experimental.pipeline import transform, validate_as\n\n# BeforeValidator\nAnnotated[int, validate_as(str).str_strip().validate_as(...)]  # (1)!\n# AfterValidator\nAnnotated[int, transform(lambda x: x * 2)]  # (2)!\n# WrapValidator\nAnnotated[\n    int,\n    validate_as(str)\n    .str_strip()\n    .validate_as(...)\n    .transform(lambda x: x * 2),  # (3)!\n]\n```\n\n1. Strip whitespace from a string before parsing it as an integer.\n2. Multiply an integer by 2 after parsing it.\n3. Strip whitespace from a string, validate it as an integer, then multiply it by 2.", "url": "https://docs.pydantic.dev/latest/concepts/experimental/index.html#mapping-from-beforevalidator-aftervalidator-and-wrapvalidatorindexhtmlmapping-from-beforevalidator-aftervalidator-and-wrapvalidator-permanent-link", "page": "concepts/experimental/index.html", "source_site": "pydantic"}
{"title": "Alternative patterns[Â¶](index.html#alternative-patterns \"Permanent link\")", "anchor": "alternative-patternsindexhtmlalternative-patterns-permanent-link", "md_text": "There are many alternative patterns to use depending on the scenario.\nJust as an example, consider the `UserIn` and `UserOut` pattern mentioned above:\n\n```\nfrom __future__ import annotations\n\nfrom pydantic import BaseModel\n\n\nclass UserIn(BaseModel):\n    favorite_number: int | str\n\n\nclass UserOut(BaseModel):\n    favorite_number: int\n\n\ndef my_api(user: UserIn) -> UserOut:\n    favorite_number = user.favorite_number\n    if isinstance(favorite_number, str):\n        favorite_number = int(user.favorite_number.strip())\n\n    return UserOut(favorite_number=favorite_number)\n\n\nassert my_api(UserIn(favorite_number=' 1 ')).favorite_number == 1\n```\n\nThis example uses plain idiomatic Python code that may be easier to understand, type-check, etc. than the examples above.\nThe approach you choose should really depend on your use case.\nYou will have to compare verbosity, performance, ease of returning meaningful errors to your users, etc. to choose the right pattern.\nJust be mindful of abusing advanced patterns like the pipeline API just because you can.", "url": "https://docs.pydantic.dev/latest/concepts/experimental/index.html#alternative-patternsindexhtmlalternative-patterns-permanent-link", "page": "concepts/experimental/index.html", "source_site": "pydantic"}
{"title": "Partial Validation[Â¶](index.html#partial-validation \"Permanent link\")", "anchor": "partial-validationindexhtmlpartial-validation-permanent-link", "md_text": "Pydantic v2.10.0 introduces experimental support for \"partial validation\".\n\nThis allows you to validate an incomplete JSON string, or a Python object representing incomplete input data.\n\nPartial validation is particularly helpful when processing the output of an LLM, where the model streams structured responses, and you may wish to begin validating the stream while you're still receiving data (e.g. to show partial data to users).\n\nPartial validation is an experimental feature and may change in future versions of Pydantic. The current implementation should be considered a proof of concept at this time and has a number of [limitations](index.html#limitations-of-partial-validation).\n\nPartial validation can be enabled when using the three validation methods on `TypeAdapter`: [`TypeAdapter.validate_json()`](../../api/type_adapter/index.html#pydantic.type_adapter.TypeAdapter.validate_json), [`TypeAdapter.validate_python()`](../../api/type_adapter/index.html#pydantic.type_adapter.TypeAdapter.validate_python), and [`TypeAdapter.validate_strings()`](../../api/type_adapter/index.html#pydantic.type_adapter.TypeAdapter.validate_strings). This allows you to parse and validation incomplete JSON, but also to validate Python objects created by parsing incomplete data of any format.\n\nThe `experimental_allow_partial` flag can be passed to these methods to enable partial validation.\nIt can take the following values (and is `False`, by default):\n\n* `False` or `'off'` - disable partial validation\n* `True` or `'on'` - enable partial validation, but don't support trailing strings\n* `'trailing-strings'` - enable partial validation and support trailing strings\n\n`'trailing-strings'` mode allows for trailing incomplete strings at the end of partial JSON to be included in the output.\nFor example, if you're validating against the following model:\n\n```\nfrom typing import TypedDict\n\n\nclass Model(TypedDict):\n    a: str\n    b: str\n```\n\nThen the following JSON input would be considered valid, despite the incomplete string at the end:\n\n```\n'{\"a\": \"hello\", \"b\": \"wor'\n```\n\nAnd would be validated as:\n\n```\n{'a': 'hello', 'b': 'wor'}\n```\n\n`experiment_allow_partial` in action:\n\n```\nfrom typing import Annotated\n\nfrom annotated_types import MinLen\nfrom typing_extensions import NotRequired, TypedDict\n\nfrom pydantic import TypeAdapter\n\n\nclass Foobar(TypedDict):  # (1)!\n    a: int\n    b: NotRequired[float]\n    c: NotRequired[Annotated[str, MinLen(5)]]\n\n\nta = TypeAdapter(list[Foobar])\n\nv = ta.validate_json('[{\"a\": 1, \"b\"', experimental_allow_partial=True)  # (2)!\nprint(v)\n#> [{'a': 1}]\n\nv = ta.validate_json(\n    '[{\"a\": 1, \"b\": 1.0, \"c\": \"abcd', experimental_allow_partial=True  # (3)!\n)\nprint(v)\n#> [{'a': 1, 'b': 1.0}]\n\nv = ta.validate_json(\n    '[{\"b\": 1.0, \"c\": \"abcde\"', experimental_allow_partial=True  # (4)!\n)\nprint(v)\n#> []\n\nv = ta.validate_json(\n    '[{\"a\": 1, \"b\": 1.0, \"c\": \"abcde\"},{\"a\": ', experimental_allow_partial=True\n)\nprint(v)\n#> [{'a': 1, 'b': 1.0, 'c': 'abcde'}]\n\nv = ta.validate_python([{'a': 1}], experimental_allow_partial=True)  # (5)!\nprint(v)\n#> [{'a': 1}]\n\nv = ta.validate_python(\n    [{'a': 1, 'b': 1.0, 'c': 'abcd'}], experimental_allow_partial=True  # (6)!\n)\nprint(v)\n#> [{'a': 1, 'b': 1.0}]\n\nv = ta.validate_json(\n    '[{\"a\": 1, \"b\": 1.0, \"c\": \"abcdefg',\n    experimental_allow_partial='trailing-strings',  # (7)!\n)\nprint(v)\n#> [{'a': 1, 'b': 1.0, 'c': 'abcdefg'}]\n```\n\n1. The TypedDict `Foobar` has three field, but only `a` is required, that means that a valid instance of `Foobar` can be created even if the `b` and `c` fields are missing.\n2. Parsing JSON, the input is valid JSON up to the point where the string is truncated.\n3. In this case truncation of the input means the value of `c` (`abcd`) is invalid as input to `c` field, hence it's omitted.\n4. The `a` field is required, so validation on the only item in the list fails and is dropped.\n5. Partial validation also works with Python objects, it should have the same semantics as with JSON except of course you can't have a genuinely \"incomplete\" Python object.\n6. The same as above but with a Python object, `c` is dropped as it's not required and failed validation.\n7. The `trailing-strings` mode allows for incomplete strings at the end of partial JSON to be included in the output, in this case the input is valid JSON up to the point where the string is truncated, so the last string is included.", "url": "https://docs.pydantic.dev/latest/concepts/experimental/index.html#partial-validationindexhtmlpartial-validation-permanent-link", "page": "concepts/experimental/index.html", "source_site": "pydantic"}
{"title": "How Partial Validation Works[Â¶](index.html#how-partial-validation-works \"Permanent link\")", "anchor": "how-partial-validation-worksindexhtmlhow-partial-validation-works-permanent-link", "md_text": "Partial validation follows the zen of Pydantic â€” it makes no guarantees about what the input data might have been, but it does guarantee to return a valid instance of the type you required, or raise a validation error.\n\nTo do this, the `experimental_allow_partial` flag enables two pieces of behavior:\n\n#### 1. Partial JSON parsing[Â¶](index.html#1-partial-json-parsing \"Permanent link\")\n\nThe [jiter](https://github.com/pydantic/jiter) JSON parser used by Pydantic already supports parsing partial JSON,\n`experimental_allow_partial` is simply passed to jiter via the `allow_partial` argument.\n\nIf you just want pure JSON parsing with support for partial JSON, you can use the [`jiter`](https://pypi.org/project/jiter/) Python library directly, or pass the `allow_partial` argument when calling [`pydantic_core.from_json`](../../api/pydantic_core/index.html#pydantic_core.from_json).\n\n#### 2. Ignore errors in the last element of the input[Â¶](index.html#2-ignore-errors-in-last \"Permanent link\")\n\nOnly having access to part of the input data means errors can commonly occur in the last element of the input data.\n\nFor example:\n\n* if a string has a constraint `MinLen(5)`, when you only see part of the input, validation might fail because part of the string is missing (e.g. `{\"name\": \"Sam` instead of `{\"name\": \"Samuel\"}`)\n* if an `int` field has a constraint `Ge(10)`, when you only see part of the input, validation might fail because the number is too small (e.g. `1` instead of `10`)\n* if a `TypedDict` field has 3 required fields, but the partial input only has two of the fields, validation would fail because some field are missing\n* etc. etc. â€” there are lost more cases like this\n\nThe point is that if you only see part of some valid input data, validation errors can often occur in the last element of a sequence or last value of mapping.\n\nTo avoid these errors breaking partial validation, Pydantic will ignore ALL errors in the last element of the input data.\n\nErrors in last element ignored\n\n```\nfrom typing import Annotated\n\nfrom annotated_types import MinLen\n\nfrom pydantic import BaseModel, TypeAdapter\n\n\nclass MyModel(BaseModel):\n    a: int\n    b: Annotated[str, MinLen(5)]\n\n\nta = TypeAdapter(list[MyModel])\nv = ta.validate_json(\n    '[{\"a\": 1, \"b\": \"12345\"}, {\"a\": 1,',\n    experimental_allow_partial=True,\n)\nprint(v)\n#> [MyModel(a=1, b='12345')]\n```", "url": "https://docs.pydantic.dev/latest/concepts/experimental/index.html#how-partial-validation-worksindexhtmlhow-partial-validation-works-permanent-link", "page": "concepts/experimental/index.html", "source_site": "pydantic"}
{"title": "Limitations of Partial Validation[Â¶](index.html#limitations-of-partial-validation \"Permanent link\")", "anchor": "limitations-of-partial-validationindexhtmllimitations-of-partial-validation-permanent-link", "md_text": "#### TypeAdapter only[Â¶](index.html#typeadapter-only \"Permanent link\")\n\nYou can only pass `experiment_allow_partial` to [`TypeAdapter`](../../api/type_adapter/index.html#pydantic.type_adapter.TypeAdapter) methods, it's not yet supported via other Pydantic entry points like [`BaseModel`](../../api/base_model/index.html#pydantic.BaseModel).\n\n#### Types supported[Â¶](index.html#types-supported \"Permanent link\")\n\nRight now only a subset of collection validators know how to handle partial validation:\n\n* `list`\n* `set`\n* `frozenset`\n* `dict` (as in `dict[X, Y]`)\n* `TypedDict` â€” only non-required fields may be missing, e.g. via [`NotRequired`](https://docs.python.org/3/library/typing.html#typing.NotRequired) or [`total=False`](https://docs.python.org/3/library/typing.html#typing.TypedDict.__total__))\n\nWhile you can use `experimental_allow_partial` while validating against types that include other collection validators, those types will be validated \"all or nothing\", and partial validation will not work on more nested types.\n\nE.g. in the [above](index.html#2-ignore-errors-in-last) example partial validation works although the second item in the list is dropped completely since `BaseModel` doesn't (yet) support partial validation.\n\nBut partial validation won't work at all in the follow example because `BaseModel` doesn't support partial validation so it doesn't forward the `allow_partial` instruction down to the list validator in `b`:\n\n```\nfrom typing import Annotated\n\nfrom annotated_types import MinLen\n\nfrom pydantic import BaseModel, TypeAdapter, ValidationError\n\n\nclass MyModel(BaseModel):\n    a: int = 1\n    b: list[Annotated[str, MinLen(5)]] = []  # (1)!\n\n\nta = TypeAdapter(MyModel)\ntry:\n    v = ta.validate_json(\n        '{\"a\": 1, \"b\": [\"12345\", \"12', experimental_allow_partial=True\n    )\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for MyModel\n    b.1\n      String should have at least 5 characters [type=string_too_short, input_value='12', input_type=str]\n    \"\"\"\n```\n\n1. The list validator for `b` doesn't get the `allow_partial` instruction passed down to it by the model validator so it doesn't know to ignore errors in the last element of the input.\n\n#### Some invalid but complete JSON will be accepted[Â¶](index.html#some-invalid-but-complete-json-will-be-accepted \"Permanent link\")\n\nThe way [jiter](https://github.com/pydantic/jiter) (the JSON parser used by Pydantic) works means it's currently not possible to differentiate between complete JSON like `{\"a\": 1, \"b\": \"12\"}` and incomplete JSON like `{\"a\": 1, \"b\": \"12`.\n\nThis means that some invalid JSON will be accepted by Pydantic when using `experimental_allow_partial`, e.g.:\n\nPython 3.9 and abovePython 3.13 and above\n\n```\nfrom typing import Annotated\n\nfrom annotated_types import MinLen\nfrom typing_extensions import TypedDict\n\nfrom pydantic import TypeAdapter\n\n\nclass Foobar(TypedDict, total=False):\n    a: int\n    b: Annotated[str, MinLen(5)]\n\n\nta = TypeAdapter(Foobar)\n\nv = ta.validate_json(\n    '{\"a\": 1, \"b\": \"12', experimental_allow_partial=True  # (1)!\n)\nprint(v)\n#> {'a': 1}\n\nv = ta.validate_json(\n    '{\"a\": 1, \"b\": \"12\"}', experimental_allow_partial=True  # (2)!\n)\nprint(v)\n#> {'a': 1}\n```\n\n1. This will pass validation as expected although the last field will be omitted as it failed validation.\n2. This will also pass validation since the binary representation of the JSON data passed to pydantic-core is indistinguishable from the previous case.\n\n```\nfrom typing import Annotated\n\nfrom annotated_types import MinLen\nfrom typing import TypedDict\n\nfrom pydantic import TypeAdapter\n\n\nclass Foobar(TypedDict, total=False):\n    a: int\n    b: Annotated[str, MinLen(5)]\n\n\nta = TypeAdapter(Foobar)\n\nv = ta.validate_json(\n    '{\"a\": 1, \"b\": \"12', experimental_allow_partial=True  # (1)!\n)\nprint(v)\n#> {'a': 1}\n\nv = ta.validate_json(\n    '{\"a\": 1, \"b\": \"12\"}', experimental_allow_partial=True  # (2)!\n)\nprint(v)\n#> {'a': 1}\n```\n\n1. This will pass validation as expected although the last field will be omitted as it failed validation.\n2. This will also pass validation since the binary representation of the JSON data passed to pydantic-core is indistinguishable from the previous case.\n\n#### Any error in the last field of the input will be ignored[Â¶](index.html#any-error-in-the-last-field-of-the-input-will-be-ignored \"Permanent link\")\n\nAs described [above](index.html#2-ignore-errors-in-last), many errors can result from truncating the input. Rather than trying to specifically ignore errors that could result from truncation, Pydantic ignores all errors in the last element of the input in partial validation mode.\n\nThis means clearly invalid data will pass validation if the error is in the last field of the input:\n\n```\nfrom typing import Annotated\n\nfrom annotated_types import Ge\n\nfrom pydantic import TypeAdapter", "url": "https://docs.pydantic.dev/latest/concepts/experimental/index.html#limitations-of-partial-validationindexhtmllimitations-of-partial-validation-permanent-link", "page": "concepts/experimental/index.html", "source_site": "pydantic"}
{"title": "Limitations of Partial Validation[Â¶](index.html#limitations-of-partial-validation \"Permanent link\")", "anchor": "limitations-of-partial-validationindexhtmllimitations-of-partial-validation-permanent-link", "md_text": "ta = TypeAdapter(list[Annotated[int, Ge(10)]])\nv = ta.validate_python([20, 30, 4], experimental_allow_partial=True)  # (1)!\nprint(v)\n#> [20, 30]\n\nta = TypeAdapter(list[int])\n\nv = ta.validate_python([1, 2, 'wrong'], experimental_allow_partial=True)  # (2)!\nprint(v)\n#> [1, 2]\n```\n\n1. As you would expect, this will pass validation since Pydantic correctly ignores the error in the (truncated) last item.\n2. This will also pass validation since the error in the last item is ignored.", "url": "https://docs.pydantic.dev/latest/concepts/experimental/index.html#limitations-of-partial-validationindexhtmllimitations-of-partial-validation-permanent-link", "page": "concepts/experimental/index.html", "source_site": "pydantic"}
{"title": "Validation of a callable's arguments[Â¶](index.html#validation-of-a-callables-arguments \"Permanent link\")", "anchor": "validation-of-a-callables-argumentsindexhtmlvalidation-of-a-callables-arguments-permanent-link", "md_text": "Pydantic provides the [`@validate_call`](../../api/validate_call/index.html#pydantic.validate_call_decorator.validate_call) decorator to perform validation on the provided\narguments (and additionally return type) of a callable. However, it only allows arguments to be provided\nby actually calling the decorated callable. In some situations, you may want to just *validate* the arguments,\nsuch as when loading from other data sources such as JSON data.\n\nFor this reason, the experimental [`generate_arguments_schema()`](../../api/experimental/index.html#pydantic.experimental.arguments_schema.generate_arguments_schema)\nfunction can be used to construct a core schema, which can later be used with a [`SchemaValidator`](../../api/pydantic_core/index.html#pydantic_core.SchemaValidator).\n\n```\nfrom pydantic_core import SchemaValidator\n\nfrom pydantic.experimental.arguments_schema import generate_arguments_schema\n\n\ndef func(p: bool, *args: str, **kwargs: int) -> None: ...\n\n\narguments_schema = generate_arguments_schema(func=func)\n\nval = SchemaValidator(arguments_schema, config={'coerce_numbers_to_str': True})\n\nargs, kwargs = val.validate_json(\n    '{\"p\": true, \"args\": [\"arg1\", 1], \"kwargs\": {\"extra\": 1}}'\n)\nprint(args, kwargs)  # (1)!\n#> (True, 'arg1', '1') {'extra': 1}\n```\n\n1. If you want the validated arguments as a dictionary, you can use the [`Signature.bind()`](https://docs.python.org/3/library/inspect.html#inspect.Signature.bind)\n   method:\n\n   ```\n   from inspect import signature\n\n   signature(func).bind(*args, **kwargs).arguments\n   #> {'p': True, 'args': ('arg1', '1'), 'kwargs': {'extra': 1}}\n   ```\n\nUnlike [`@validate_call`](../../api/validate_call/index.html#pydantic.validate_call_decorator.validate_call), this core schema will only validate the provided arguments;\nthe underlying callable will *not* be called.\n\nAdditionally, you can ignore specific parameters by providing a callback, which is called for every parameter:\n\n```\nfrom typing import Any\n\nfrom pydantic_core import SchemaValidator\n\nfrom pydantic.experimental.arguments_schema import generate_arguments_schema\n\n\ndef func(p: bool, *args: str, **kwargs: int) -> None: ...\n\n\ndef skip_first_parameter(index: int, name: str, annotation: Any) -> Any:\n    if index == 0:\n        return 'skip'\n\n\narguments_schema = generate_arguments_schema(\n    func=func,\n    parameters_callback=skip_first_parameter,\n)\n\nval = SchemaValidator(arguments_schema)\n\nargs, kwargs = val.validate_json('{\"args\": [\"arg1\"], \"kwargs\": {\"extra\": 1}}')\nprint(args, kwargs)\n#> ('arg1',) {'extra': 1}\n```", "url": "https://docs.pydantic.dev/latest/concepts/experimental/index.html#validation-of-a-callables-argumentsindexhtmlvalidation-of-a-callables-arguments-permanent-link", "page": "concepts/experimental/index.html", "source_site": "pydantic"}
{"title": "`MISSING` sentinel[Â¶](index.html#missing-sentinel \"Permanent link\")", "anchor": "missing-sentinelindexhtmlmissing-sentinel-permanent-link", "md_text": "The `MISSING` sentinel is a singleton indicating a field value was not provided during validation.\n\nThis singleton can be used as a default value, as an alternative to `None` when it has an explicit\nmeaning. During serialization, any field with `MISSING` as a value is excluded from the output.\n\nPython 3.9 and abovePython 3.10 and above\n\n```\nfrom typing import Union\n\nfrom pydantic import BaseModel\nfrom pydantic.experimental.missing_sentinel import MISSING\n\n\nclass Configuration(BaseModel):\n    timeout: Union[int, None, MISSING] = MISSING\n\n\n# configuration defaults, stored somewhere else:\ndefaults = {'timeout': 200}\n\nconf = Configuration()\n\n# `timeout` is excluded from the serialization output:\nconf.model_dump()\n# {}\n\n# The `MISSING` value doesn't appear in the JSON Schema:\nConfiguration.model_json_schema()['properties']['timeout']\n#> {'anyOf': [{'type': 'integer'}, {'type': 'null'}], 'title': 'Timeout'}}\n\n\n# `is` can be used to discriminate between the sentinel and other values:\ntimeout = conf.timeout if conf.timeout is not MISSING else defaults['timeout']\n\nfrom pydantic import BaseModel\nfrom pydantic.experimental.missing_sentinel import MISSING\n\n\nclass Configuration(BaseModel):\n    timeout: int | None | MISSING = MISSING\n\n\n# configuration defaults, stored somewhere else:\ndefaults = {'timeout': 200}\n\nconf = Configuration()\n\n# `timeout` is excluded from the serialization output:\nconf.model_dump()\n# {}\n\n# The `MISSING` value doesn't appear in the JSON Schema:\nConfiguration.model_json_schema()['properties']['timeout']\n#> {'anyOf': [{'type': 'integer'}, {'type': 'null'}], 'title': 'Timeout'}}\n\n\n# `is` can be used to discriminate between the sentinel and other values:\ntimeout = conf.timeout if conf.timeout is not MISSING else defaults['timeout']\n```\n\nThis feature is marked as experimental because it relies on the draft [PEP 661](https://peps.python.org/pep-0661/), introducing sentinels in the standard library.\n\nAs such, the following limitations currently apply:\n\n* Static type checking of sentinels is only supported with Pyright\n  [1.1.402](https://github.com/microsoft/pyright/releases/tag/1.1.402)\n  or greater, and the `enableExperimentalFeatures` type evaluation setting\n  should be enabled.\n* Pickling of models containing `MISSING` as a value is not supported.\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/concepts/experimental/index.html#missing-sentinelindexhtmlmissing-sentinel-permanent-link", "page": "concepts/experimental/index.html", "source_site": "pydantic"}
{"title": "Parsing data into a specified type[Â¶](index.html#parsing-data-into-a-specified-type \"Permanent link\")", "anchor": "parsing-data-into-a-specified-typeindexhtmlparsing-data-into-a-specified-type-permanent-link", "md_text": "[`TypeAdapter`](../../api/type_adapter/index.html#pydantic.type_adapter.TypeAdapter) can be used to apply the parsing logic to populate Pydantic models\nin a more ad-hoc way. This function behaves similarly to\n[`BaseModel.model_validate`](../../api/base_model/index.html#pydantic.BaseModel.model_validate),\nbut works with arbitrary Pydantic-compatible types.\n\nThis is especially useful when you want to parse results into a type that is not a direct subclass of\n[`BaseModel`](../../api/base_model/index.html#pydantic.BaseModel). For example:\n\n```\nfrom pydantic import BaseModel, TypeAdapter\n\n\nclass Item(BaseModel):\n    id: int\n    name: str\n\n\n# `item_data` could come from an API call, eg., via something like:\n# item_data = requests.get('https://my-api.com/items').json()\nitem_data = [{'id': 1, 'name': 'My Item'}]\n\nitems = TypeAdapter(list[Item]).validate_python(item_data)\nprint(items)\n#> [Item(id=1, name='My Item')]\n```\n\n[`TypeAdapter`](../../api/type_adapter/index.html#pydantic.type_adapter.TypeAdapter) is capable of parsing data into any of the types Pydantic can\nhandle as fields of a [`BaseModel`](../../api/base_model/index.html#pydantic.BaseModel).\n\nWhen creating an instance of [`TypeAdapter`](../../api/type_adapter/index.html#pydantic.type_adapter.TypeAdapter), the provided type must be analyzed and converted into a pydantic-core\nschema. This comes with some non-trivial overhead, so it is recommended to create a `TypeAdapter` for a given type\njust once and reuse it in loops or other performance-critical code.", "url": "https://docs.pydantic.dev/latest/concepts/type_adapter/index.html#parsing-data-into-a-specified-typeindexhtmlparsing-data-into-a-specified-type-permanent-link", "page": "concepts/type_adapter/index.html", "source_site": "pydantic"}
{"title": "Rebuilding a `TypeAdapter`'s schema[Â¶](index.html#rebuilding-a-typeadapters-schema \"Permanent link\")", "anchor": "rebuilding-a-typeadapters-schemaindexhtmlrebuilding-a-typeadapters-schema-permanent-link", "md_text": "In v2.10+, [`TypeAdapter`](../../api/type_adapter/index.html#pydantic.type_adapter.TypeAdapter)'s support deferred schema building and manual rebuilds. This is helpful for the case of:\n\n* Types with forward references\n* Types for which core schema builds are expensive\n\nWhen you initialize a [`TypeAdapter`](../../api/type_adapter/index.html#pydantic.type_adapter.TypeAdapter) with a type, Pydantic analyzes the type and creates a core schema for it.\nThis core schema contains the information needed to validate and serialize data for that type.\nSee the [architecture documentation](../../internals/architecture/index.html) for more information on core schemas.\n\nIf you set [`defer_build`](../../api/config/index.html#pydantic.config.ConfigDict.defer_build) to `True` when initializing a `TypeAdapter`,\nPydantic will defer building the core schema until the first time it is needed (for validation or serialization).\n\nIn order to manually trigger the building of the core schema, you can call the\n[`rebuild`](../../api/type_adapter/index.html#pydantic.type_adapter.TypeAdapter.rebuild) method on the [`TypeAdapter`](../../api/type_adapter/index.html#pydantic.type_adapter.TypeAdapter) instance:\n\n```\nfrom pydantic import ConfigDict, TypeAdapter\n\nta = TypeAdapter('MyInt', config=ConfigDict(defer_build=True))\n\n# some time later, the forward reference is defined\nMyInt = int\n\nta.rebuild()\nassert ta.validate_python(1) == 1\n```\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/concepts/type_adapter/index.html#rebuilding-a-typeadapters-schemaindexhtmlrebuilding-a-typeadapters-schema-permanent-link", "page": "concepts/type_adapter/index.html", "source_site": "pydantic"}
{"title": "Field validators[Â¶](index.html#field-validators \"Permanent link\")", "anchor": "field-validatorsindexhtmlfield-validators-permanent-link", "md_text": "API Documentation\n\n[`pydantic.functional_validators.WrapValidator`](../../api/functional_validators/index.html#pydantic.functional_validators.WrapValidator)  \n[`pydantic.functional_validators.PlainValidator`](../../api/functional_validators/index.html#pydantic.functional_validators.PlainValidator)  \n[`pydantic.functional_validators.BeforeValidator`](../../api/functional_validators/index.html#pydantic.functional_validators.BeforeValidator)  \n[`pydantic.functional_validators.AfterValidator`](../../api/functional_validators/index.html#pydantic.functional_validators.AfterValidator)  \n[`pydantic.functional_validators.field_validator`](../../api/functional_validators/index.html#pydantic.functional_validators.field_validator)\n\nIn its simplest form, a field validator is a callable taking the value to be validated as an argument and\n**returning the validated value**. The callable can perform checks for specific conditions (see\n[raising validation errors](index.html#raising-validation-errors)) and make changes to the validated value (coercion or mutation).\n\n**Four** different types of validators can be used. They can all be defined using the\n[annotated pattern](../fields/index.html#the-annotated-pattern) or using the\n[`field_validator()`](../../api/functional_validators/index.html#pydantic.functional_validators.field_validator) decorator, applied on a [class method](https://docs.python.org/3/library/functions.html#classmethod):\n\n* ***After* validators**: run after Pydantic's internal validation. They are generally more type safe and thus easier to implement.\n\n  Annotated patternDecorator\n\n  Here is an example of a validator performing a validation check, and returning the value unchanged.\n\n  ```\n  from typing import Annotated\n\n  from pydantic import AfterValidator, BaseModel, ValidationError\n\n\n  def is_even(value: int) -> int:\n      if value % 2 == 1:\n          raise ValueError(f'{value} is not an even number')\n      return value  # (1)!\n\n\n  class Model(BaseModel):\n      number: Annotated[int, AfterValidator(is_even)]\n\n\n  try:\n      Model(number=1)\n  except ValidationError as err:\n      print(err)\n      \"\"\"\n      1 validation error for Model\n      number\n        Value error, 1 is not an even number [type=value_error, input_value=1, input_type=int]\n      \"\"\"\n  ```\n\n  1. Note that it is important to return the validated value.\n\n  Here is an example of a validator performing a validation check, and returning the value unchanged,\n  this time using the [`field_validator()`](../../api/functional_validators/index.html#pydantic.functional_validators.field_validator) decorator.\n\n  ```\n  from pydantic import BaseModel, ValidationError, field_validator\n\n\n  class Model(BaseModel):\n      number: int\n\n      @field_validator('number', mode='after')  # (1)!\n      @classmethod\n      def is_even(cls, value: int) -> int:\n          if value % 2 == 1:\n              raise ValueError(f'{value} is not an even number')\n          return value  # (2)!\n\n\n  try:\n      Model(number=1)\n  except ValidationError as err:\n      print(err)\n      \"\"\"\n      1 validation error for Model\n      number\n        Value error, 1 is not an even number [type=value_error, input_value=1, input_type=int]\n      \"\"\"\n  ```\n\n  1. `'after'` is the default mode for the decorator, and can be omitted.\n  2. Note that it is important to return the validated value.\n\n  Example mutating the value\n\n  Here is an example of a validator making changes to the validated value (no exception is raised).\n\n  Annotated patternDecorator\n\n  ```\n  from typing import Annotated\n\n  from pydantic import AfterValidator, BaseModel\n\n\n  def double_number(value: int) -> int:\n      return value * 2\n\n\n  class Model(BaseModel):\n      number: Annotated[int, AfterValidator(double_number)]\n\n\n  print(Model(number=2))\n  #> number=4\n  ```\n\n  ```\n  from pydantic import BaseModel, field_validator\n\n\n  class Model(BaseModel):\n      number: int\n\n      @field_validator('number', mode='after')  # (1)!\n      @classmethod\n      def double_number(cls, value: int) -> int:\n          return value * 2\n\n\n  print(Model(number=2))\n  #> number=4\n  ```\n\n  1. `'after'` is the default mode for the decorator, and can be omitted.\n* ***Before* validators**: run before Pydantic's internal parsing and validation (e.g. coercion of a `str` to an `int`).\n  These are more flexible than [*after* validators](index.html#field-after-validator), but they also have to deal with the raw input, which\n  in theory could be any arbitrary object. You should also avoid mutating the value directly if you are raising a\n  [validation error](index.html#raising-validation-errors) later in your validator function, as the mutated value may be passed to other\n  validators if using [unions](../unions/index.html).\n\n  The value returned from this callable is then validated against the provided type annotation by Pydantic.\n\n  Annotated patternDecorator\n\n  ```\n  from typing import Annotated, Any\n\n  from pydantic import BaseModel, BeforeValidator, ValidationError\n\n\n  def ensure_list(value: Any) -> Any:  # (1)!\n      if not isinstance(value, list):  # (2)!\n          return [value]\n      else:\n          return value\n\n\n  class Model(BaseModel):\n      numbers: Annotated[list[int], BeforeValidator(ensure_list)]", "url": "https://docs.pydantic.dev/latest/concepts/validators/index.html#field-validatorsindexhtmlfield-validators-permanent-link", "page": "concepts/validators/index.html", "source_site": "pydantic"}
{"title": "Field validators[Â¶](index.html#field-validators \"Permanent link\")", "anchor": "field-validatorsindexhtmlfield-validators-permanent-link", "md_text": "\n  print(Model(numbers=2))\n  #> numbers=[2]\n  try:\n      Model(numbers='str')\n  except ValidationError as err:\n      print(err)  # (3)!\n      \"\"\"\n      1 validation error for Model\n      numbers.0\n        Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='str', input_type=str]\n      \"\"\"\n  ```\n\n  1. Notice the use of [`Any`](https://docs.python.org/3/library/typing.html#typing.Any) as a type hint for `value`. *Before* validators take the raw input, which\n     can be anything.\n  2. Note that you might want to check for other sequence types (such as tuples) that would normally successfully\n     validate against the `list` type. *Before* validators give you more flexibility, but you have to account for\n     every possible case.\n  3. Pydantic still performs validation against the `int` type, no matter if our `ensure_list` validator\n     did operations on the original input type.\n\n  ```\n  from typing import Any\n\n  from pydantic import BaseModel, ValidationError, field_validator\n\n\n  class Model(BaseModel):\n      numbers: list[int]\n\n      @field_validator('numbers', mode='before')\n      @classmethod\n      def ensure_list(cls, value: Any) -> Any:  # (1)!\n          if not isinstance(value, list):  # (2)!\n              return [value]\n          else:\n              return value\n\n\n  print(Model(numbers=2))\n  #> numbers=[2]\n  try:\n      Model(numbers='str')\n  except ValidationError as err:\n      print(err)  # (3)!\n      \"\"\"\n      1 validation error for Model\n      numbers.0\n        Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='str', input_type=str]\n      \"\"\"\n  ```\n\n  1. Notice the use of [`Any`](https://docs.python.org/3/library/typing.html#typing.Any) as a type hint for `value`. *Before* validators take the raw input, which\n     can be anything.\n  2. Note that you might want to check for other sequence types (such as tuples) that would normally successfully\n     validate against the `list` type. *Before* validators give you more flexibility, but you have to account for\n     every possible case.\n  3. Pydantic still performs validation against the `int` type, no matter if our `ensure_list` validator\n     did operations on the original input type.\n* ***Plain* validators**: act similarly to *before* validators but they **terminate validation immediately** after returning,\n  so no further validators are called and Pydantic does not do any of its internal validation against the field type.\n\n  Annotated patternDecorator\n\n  ```\n  from typing import Annotated, Any\n\n  from pydantic import BaseModel, PlainValidator\n\n\n  def val_number(value: Any) -> Any:\n      if isinstance(value, int):\n          return value * 2\n      else:\n          return value\n\n\n  class Model(BaseModel):\n      number: Annotated[int, PlainValidator(val_number)]\n\n\n  print(Model(number=4))\n  #> number=8\n  print(Model(number='invalid'))  # (1)!\n  #> number='invalid'\n  ```\n\n  1. Although `'invalid'` shouldn't validate against the `int` type, Pydantic accepts the input.\n\n  ```\n  from typing import Any\n\n  from pydantic import BaseModel, field_validator\n\n\n  class Model(BaseModel):\n      number: int\n\n      @field_validator('number', mode='plain')\n      @classmethod\n      def val_number(cls, value: Any) -> Any:\n          if isinstance(value, int):\n              return value * 2\n          else:\n              return value\n\n\n  print(Model(number=4))\n  #> number=8\n  print(Model(number='invalid'))  # (1)!\n  #> number='invalid'\n  ```\n\n  1. Although `'invalid'` shouldn't validate against the `int` type, Pydantic accepts the input.\n* ***Wrap* validators**: are the most flexible of all. You can run code before or after Pydantic and other validators\n  process the input, or you can terminate validation immediately, either by returning the value early or by raising an\n  error.\n\n  Such validators must be defined with a **mandatory** extra *handler* parameter: a callable taking the value to be validated\n  as an argument. Internally, this handler will delegate validation of the value to Pydantic. You are free to wrap the call\n  to the handler in a [`try..except`](https://docs.python.org/3/tutorial/errors.html#handling-exceptions) block, or not call it at all.\n\n  Annotated patternDecorator\n\n  ```\n  from typing import Any\n\n  from typing import Annotated\n\n  from pydantic import BaseModel, Field, ValidationError, ValidatorFunctionWrapHandler, WrapValidator\n\n\n  def truncate(value: Any, handler: ValidatorFunctionWrapHandler) -> str:\n      try:\n          return handler(value)\n      except ValidationError as err:\n          if err.errors()[0]['type'] == 'string_too_long':\n              return handler(value[:5])\n          else:\n              raise\n\n\n  class Model(BaseModel):\n      my_string: Annotated[str, Field(max_length=5), WrapValidator(truncate)]\n\n\n  print(Model(my_string='abcde'))\n  #> my_string='abcde'\n  print(Model(my_string='abcdef'))\n  #> my_string='abcde'\n  ```\n\n  ```\n  from typing import Any\n\n  from typing import Annotated", "url": "https://docs.pydantic.dev/latest/concepts/validators/index.html#field-validatorsindexhtmlfield-validators-permanent-link", "page": "concepts/validators/index.html", "source_site": "pydantic"}
{"title": "Field validators[Â¶](index.html#field-validators \"Permanent link\")", "anchor": "field-validatorsindexhtmlfield-validators-permanent-link", "md_text": "  from pydantic import BaseModel, Field, ValidationError, ValidatorFunctionWrapHandler, field_validator\n\n\n  class Model(BaseModel):\n      my_string: Annotated[str, Field(max_length=5)]\n\n      @field_validator('my_string', mode='wrap')\n      @classmethod\n      def truncate(cls, value: Any, handler: ValidatorFunctionWrapHandler) -> str:\n          try:\n              return handler(value)\n          except ValidationError as err:\n              if err.errors()[0]['type'] == 'string_too_long':\n                  return handler(value[:5])\n              else:\n                  raise\n\n\n  print(Model(my_string='abcde'))\n  #> my_string='abcde'\n  print(Model(my_string='abcdef'))\n  #> my_string='abcde'\n  ```\n\nAs mentioned in the [fields documentation](../fields/index.html#validate-default-values), default values of fields\nare *not* validated unless configured to do so, and thus custom validators will not be applied as well.", "url": "https://docs.pydantic.dev/latest/concepts/validators/index.html#field-validatorsindexhtmlfield-validators-permanent-link", "page": "concepts/validators/index.html", "source_site": "pydantic"}
{"title": "Which validator pattern to use[Â¶](index.html#which-validator-pattern-to-use \"Permanent link\")", "anchor": "which-validator-pattern-to-useindexhtmlwhich-validator-pattern-to-use-permanent-link", "md_text": "While both approaches can achieve the same thing, each pattern provides different benefits.\n\n#### Using the annotated pattern[Â¶](index.html#using-the-annotated-pattern \"Permanent link\")\n\nOne of the key benefits of using the [annotated pattern](../fields/index.html#the-annotated-pattern) is to make\nvalidators reusable:\n\n```\nfrom typing import Annotated\n\nfrom pydantic import AfterValidator, BaseModel\n\n\ndef is_even(value: int) -> int:\n    if value % 2 == 1:\n        raise ValueError(f'{value} is not an even number')\n    return value\n\n\nEvenNumber = Annotated[int, AfterValidator(is_even)]\n\n\nclass Model1(BaseModel):\n    my_number: EvenNumber\n\n\nclass Model2(BaseModel):\n    other_number: Annotated[EvenNumber, AfterValidator(lambda v: v + 2)]\n\n\nclass Model3(BaseModel):\n    list_of_even_numbers: list[EvenNumber]  # (1)!\n```\n\n1. As mentioned in the [annotated pattern](../fields/index.html#the-annotated-pattern) documentation,\n   we can also make use of validators for specific parts of the annotation (in this case,\n   validation is applied for list items, but not the whole list).\n\nIt is also easier to understand which validators are applied to a type, by just looking at the field annotation.\n\n#### Using the decorator pattern[Â¶](index.html#using-the-decorator-pattern \"Permanent link\")\n\nOne of the key benefits of using the [`field_validator()`](../../api/functional_validators/index.html#pydantic.functional_validators.field_validator) decorator is to apply\nthe function to multiple fields:\n\n```\nfrom pydantic import BaseModel, field_validator\n\n\nclass Model(BaseModel):\n    f1: str\n    f2: str\n\n    @field_validator('f1', 'f2', mode='before')\n    @classmethod\n    def capitalize(cls, value: str) -> str:\n        return value.capitalize()\n```\n\nHere are a couple additional notes about the decorator usage:\n\n* If you want the validator to apply to all fields (including the ones defined in subclasses), you can pass\n  `'*'` as the field name argument.\n* By default, the decorator will ensure the provided field name(s) are defined on the model. If you want to\n  disable this check during class creation, you can do so by passing `False` to the `check_fields` argument.\n  This is useful when the field validator is defined on a base class, and the field is expected to exist on\n  subclasses.", "url": "https://docs.pydantic.dev/latest/concepts/validators/index.html#which-validator-pattern-to-useindexhtmlwhich-validator-pattern-to-use-permanent-link", "page": "concepts/validators/index.html", "source_site": "pydantic"}
{"title": "Model validators[Â¶](index.html#model-validators \"Permanent link\")", "anchor": "model-validatorsindexhtmlmodel-validators-permanent-link", "md_text": "API Documentation\n\n[`pydantic.functional_validators.model_validator`](../../api/functional_validators/index.html#pydantic.functional_validators.model_validator)\n\nValidation can also be performed on the entire model's data using the [`model_validator()`](../../api/functional_validators/index.html#pydantic.functional_validators.model_validator)\ndecorator.\n\n**Three** different types of model validators can be used:\n\n* ***After* validators**: run after the whole model has been validated. As such, they are defined as\n  *instance* methods and can be seen as post-initialization hooks. Important note: the validated instance\n  should be returned.\n\n  ```\n  from typing_extensions import Self\n\n  from pydantic import BaseModel, model_validator\n\n\n  class UserModel(BaseModel):\n      username: str\n      password: str\n      password_repeat: str\n\n      @model_validator(mode='after')\n      def check_passwords_match(self) -> Self:\n          if self.password != self.password_repeat:\n              raise ValueError('Passwords do not match')\n          return self\n  ```\n* ***Before* validators**: are run before the model is instantiated. These are more flexible than *after* validators,\n  but they also have to deal with the raw input, which in theory could be any arbitrary object. You should also avoid\n  mutating the value directly if you are raising a [validation error](index.html#raising-validation-errors) later in your validator\n  function, as the mutated value may be passed to other validators if using [unions](../unions/index.html).\n\n  ```\n  from typing import Any\n\n  from pydantic import BaseModel, model_validator\n\n\n  class UserModel(BaseModel):\n      username: str\n\n      @model_validator(mode='before')\n      @classmethod\n      def check_card_number_not_present(cls, data: Any) -> Any:  # (1)!\n          if isinstance(data, dict):  # (2)!\n              if 'card_number' in data:\n                  raise ValueError(\"'card_number' should not be included\")\n          return data\n  ```\n\n  1. Notice the use of [`Any`](https://docs.python.org/3/library/typing.html#typing.Any) as a type hint for `data`. *Before* validators take the raw input, which\n     can be anything.\n  2. Most of the time, the input data will be a dictionary (e.g. when calling `UserModel(username='...')`). However,\n     this is not always the case. For instance, if the [`from_attributes`](../../api/config/index.html#pydantic.config.ConfigDict.from_attributes)\n     configuration value is set, you might receive an arbitrary class instance for the `data` argument.\n* ***Wrap* validators**: are the most flexible of all. You can run code before or after Pydantic and\n  other validators process the input data, or you can terminate validation immediately, either by returning\n  the data early or by raising an error.\n\n  ```\n  import logging\n  from typing import Any\n\n  from typing_extensions import Self\n\n  from pydantic import BaseModel, ModelWrapValidatorHandler, ValidationError, model_validator\n\n\n  class UserModel(BaseModel):\n      username: str\n\n      @model_validator(mode='wrap')\n      @classmethod\n      def log_failed_validation(cls, data: Any, handler: ModelWrapValidatorHandler[Self]) -> Self:\n          try:\n              return handler(data)\n          except ValidationError:\n              logging.error('Model %s failed to validate with data %s', cls, data)\n              raise\n  ```\n\nA model validator defined in a base class will be called during the validation of a subclass instance.\n\nOverriding a model validator in a subclass will override the base class' validator, and thus only the subclass' version of said validator will be called.", "url": "https://docs.pydantic.dev/latest/concepts/validators/index.html#model-validatorsindexhtmlmodel-validators-permanent-link", "page": "concepts/validators/index.html", "source_site": "pydantic"}
{"title": "Raising validation errors[Â¶](index.html#raising-validation-errors \"Permanent link\")", "anchor": "raising-validation-errorsindexhtmlraising-validation-errors-permanent-link", "md_text": "To raise a validation error, three types of exceptions can be used:\n\n* [`ValueError`](https://docs.python.org/3/library/exceptions.html#ValueError): this is the most common exception raised inside validators.\n* [`AssertionError`](https://docs.python.org/3/library/exceptions.html#AssertionError): using the [assert](https://docs.python.org/3/reference/simple_stmts.html#assert) statement also works, but be aware that these statements\n  are skipped when Python is run with the [-O](https://docs.python.org/3/using/cmdline.html#cmdoption-O) optimization flag.\n* [`PydanticCustomError`](../../api/pydantic_core/index.html#pydantic_core.PydanticCustomError): a bit more verbose, but provides extra flexibility:\n\n  ```\n  from pydantic_core import PydanticCustomError\n\n  from pydantic import BaseModel, ValidationError, field_validator\n\n\n  class Model(BaseModel):\n      x: int\n\n      @field_validator('x', mode='after')\n      @classmethod\n      def validate_x(cls, v: int) -> int:\n          if v % 42 == 0:\n              raise PydanticCustomError(\n                  'the_answer_error',\n                  '{number} is the answer!',\n                  {'number': v},\n              )\n          return v\n\n\n  try:\n      Model(x=42 * 2)\n  except ValidationError as e:\n      print(e)\n      \"\"\"\n      1 validation error for Model\n      x\n        84 is the answer! [type=the_answer_error, input_value=84, input_type=int]\n      \"\"\"\n  ```", "url": "https://docs.pydantic.dev/latest/concepts/validators/index.html#raising-validation-errorsindexhtmlraising-validation-errors-permanent-link", "page": "concepts/validators/index.html", "source_site": "pydantic"}
{"title": "Validation info[Â¶](index.html#validation-info \"Permanent link\")", "anchor": "validation-infoindexhtmlvalidation-info-permanent-link", "md_text": "Both the field and model validators callables (in all modes) can optionally take an extra\n[`ValidationInfo`](../../api/pydantic_core_schema/index.html#pydantic_core.core_schema.ValidationInfo) argument, providing useful extra information, such as:\n\n* [already validated data](index.html#validation-data)\n* [user defined context](index.html#validation-context)\n* the current validation mode: either `'python'` or `'json'` (see the [`mode`](../../api/pydantic_core_schema/index.html#pydantic_core.core_schema.ValidationInfo.mode) property)\n* the current field name, if using a [field validator](index.html#field-validators) (see the [`field_name`](../../api/pydantic_core_schema/index.html#pydantic_core.core_schema.ValidationInfo.field_name) property).", "url": "https://docs.pydantic.dev/latest/concepts/validators/index.html#validation-infoindexhtmlvalidation-info-permanent-link", "page": "concepts/validators/index.html", "source_site": "pydantic"}
{"title": "Validation data[Â¶](index.html#validation-data \"Permanent link\")", "anchor": "validation-dataindexhtmlvalidation-data-permanent-link", "md_text": "For field validators, the already validated data can be accessed using the [`data`](../../api/pydantic_core_schema/index.html#pydantic_core.core_schema.ValidationInfo.data)\nproperty. Here is an example than can be used as an alternative to the [*after* model validator](index.html#model-after-validator)\nexample:\n\n```\nfrom pydantic import BaseModel, ValidationInfo, field_validator\n\n\nclass UserModel(BaseModel):\n    password: str\n    password_repeat: str\n    username: str\n\n    @field_validator('password_repeat', mode='after')\n    @classmethod\n    def check_passwords_match(cls, value: str, info: ValidationInfo) -> str:\n        if value != info.data['password']:\n            raise ValueError('Passwords do not match')\n        return value\n```\n\nAs validation is performed in the [order fields are defined](../models/index.html#field-ordering), you have to\nmake sure you are not accessing a field that hasn't been validated yet. In the code above, for example,\nthe `username` validated value is not available yet, as it is defined *after* `password_repeat`.\n\nThe [`data`](../../api/pydantic_core_schema/index.html#pydantic_core.core_schema.ValidationInfo.data) property is `None` for [model validators](index.html#model-validators).", "url": "https://docs.pydantic.dev/latest/concepts/validators/index.html#validation-dataindexhtmlvalidation-data-permanent-link", "page": "concepts/validators/index.html", "source_site": "pydantic"}
{"title": "Validation context[Â¶](index.html#validation-context \"Permanent link\")", "anchor": "validation-contextindexhtmlvalidation-context-permanent-link", "md_text": "You can pass a context object to the [validation methods](../models/index.html#validating-data), which can be accessed\ninside the validator functions using the [`context`](../../api/pydantic_core_schema/index.html#pydantic_core.core_schema.ValidationInfo.context) property:\n\n```\nfrom pydantic import BaseModel, ValidationInfo, field_validator\n\n\nclass Model(BaseModel):\n    text: str\n\n    @field_validator('text', mode='after')\n    @classmethod\n    def remove_stopwords(cls, v: str, info: ValidationInfo) -> str:\n        if isinstance(info.context, dict):\n            stopwords = info.context.get('stopwords', set())\n            v = ' '.join(w for w in v.split() if w.lower() not in stopwords)\n        return v\n\n\ndata = {'text': 'This is an example document'}\nprint(Model.model_validate(data))  # no context\n#> text='This is an example document'\nprint(Model.model_validate(data, context={'stopwords': ['this', 'is', 'an']}))\n#> text='example document'\n```\n\nSimilarly, you can [use a context for serialization](../serialization/index.html#serialization-context).\n\nProviding context when directly instantiating a model\n\nIt is currently not possible to provide a context when directly instantiating a model\n(i.e. when calling `Model(...)`). You can work around this through the use of a\n[`ContextVar`](https://docs.python.org/3/library/contextvars.html#contextvars.ContextVar) and a custom `__init__` method:\n\n```\nfrom __future__ import annotations\n\nfrom collections.abc import Generator\nfrom contextlib import contextmanager\nfrom contextvars import ContextVar\nfrom typing import Any\n\nfrom pydantic import BaseModel, ValidationInfo, field_validator\n\n_init_context_var = ContextVar('_init_context_var', default=None)\n\n\n@contextmanager\ndef init_context(value: dict[str, Any]) -> Generator[None]:\n    token = _init_context_var.set(value)\n    try:\n        yield\n    finally:\n        _init_context_var.reset(token)\n\n\nclass Model(BaseModel):\n    my_number: int\n\n    def __init__(self, /, **data: Any) -> None:\n        self.__pydantic_validator__.validate_python(\n            data,\n            self_instance=self,\n            context=_init_context_var.get(),\n        )\n\n    @field_validator('my_number')\n    @classmethod\n    def multiply_with_context(cls, value: int, info: ValidationInfo) -> int:\n        if isinstance(info.context, dict):\n            multiplier = info.context.get('multiplier', 1)\n            value = value * multiplier\n        return value\n\n\nprint(Model(my_number=2))\n#> my_number=2\n\nwith init_context({'multiplier': 3}):\n    print(Model(my_number=2))\n    #> my_number=6\n\nprint(Model(my_number=2))\n#> my_number=2\n```", "url": "https://docs.pydantic.dev/latest/concepts/validators/index.html#validation-contextindexhtmlvalidation-context-permanent-link", "page": "concepts/validators/index.html", "source_site": "pydantic"}
{"title": "Ordering of validators[Â¶](index.html#ordering-of-validators \"Permanent link\")", "anchor": "ordering-of-validatorsindexhtmlordering-of-validators-permanent-link", "md_text": "When using the [annotated pattern](index.html#using-the-annotated-pattern), the order in which validators are applied\nis defined as follows: [*before*](index.html#field-before-validator) and [*wrap*](index.html#field-wrap-validator) validators\nare run from right to left, and [*after*](index.html#field-after-validator) validators are then run from left to right:\n\n```\nfrom pydantic import AfterValidator, BaseModel, BeforeValidator, WrapValidator\n\n\nclass Model(BaseModel):\n    name: Annotated[\n        str,\n        AfterValidator(runs_3rd),\n        AfterValidator(runs_4th),\n        BeforeValidator(runs_2nd),\n        WrapValidator(runs_1st),\n    ]\n```\n\nInternally, validators defined using [the decorator](index.html#using-the-decorator-pattern) are converted to their annotated\nform counterpart and added last after the existing metadata for the field. This means that the same ordering\nlogic applies.", "url": "https://docs.pydantic.dev/latest/concepts/validators/index.html#ordering-of-validatorsindexhtmlordering-of-validators-permanent-link", "page": "concepts/validators/index.html", "source_site": "pydantic"}
{"title": "Special types[Â¶](index.html#special-types \"Permanent link\")", "anchor": "special-typesindexhtmlspecial-types-permanent-link", "md_text": "Pydantic provides a few special utilities that can be used to customize validation.\n\n* [`InstanceOf`](../../api/functional_validators/index.html#pydantic.functional_validators.InstanceOf) can be used to validate that a value is an instance of a given class.\n\n  ```\n  from pydantic import BaseModel, InstanceOf, ValidationError\n\n\n  class Fruit:\n      def __repr__(self):\n          return self.__class__.__name__\n\n\n  class Banana(Fruit): ...\n\n\n  class Apple(Fruit): ...\n\n\n  class Basket(BaseModel):\n      fruits: list[InstanceOf[Fruit]]\n\n\n  print(Basket(fruits=[Banana(), Apple()]))\n  #> fruits=[Banana, Apple]\n  try:\n      Basket(fruits=[Banana(), 'Apple'])\n  except ValidationError as e:\n      print(e)\n      \"\"\"\n      1 validation error for Basket\n      fruits.1\n        Input should be an instance of Fruit [type=is_instance_of, input_value='Apple', input_type=str]\n      \"\"\"\n  ```\n* [`SkipValidation`](../../api/functional_validators/index.html#pydantic.functional_validators.SkipValidation) can be used to skip validation on a field.\n\n  ```\n  from pydantic import BaseModel, SkipValidation\n\n\n  class Model(BaseModel):\n      names: list[SkipValidation[str]]\n\n\n  m = Model(names=['foo', 'bar'])\n  print(m)\n  #> names=['foo', 'bar']\n\n  m = Model(names=['foo', 123])  # (1)!\n  print(m)\n  #> names=['foo', 123]\n  ```\n\n  1. Note that the validation of the second item is skipped. If it has the wrong type it will emit a\n     warning during serialization.\n* [`ValidateAs`](../../api/functional_validators/index.html#pydantic.functional_validators.ValidateAs) can be used to validate an custom type from a\n  type natively supported by Pydantic. This is particularly useful when using custom types with multiple fields.\n\n  ```\n  from typing import Annotated\n\n  from pydantic import BaseModel, TypeAdapter, ValidateAs\n\n  class MyCls:\n      def __init__(self, a: int) -> None:\n          self.a = a\n\n      def __repr__(self) -> str:\n          return f\"MyCls(a={self.a})\"\n\n  class ValModel(BaseModel):\n      a: int\n\n\n  ta = TypeAdapter(\n      Annotated[MyCls, ValidateAs(ValModel, lambda v: MyCls(a=v.a))]\n  )\n\n  print(ta.validate_python({'a': 1}))\n  #> MyCls(a=1)\n  ```\n* [`PydanticUseDefault`](../../api/pydantic_core/index.html#pydantic_core.PydanticUseDefault) can be used to notify Pydantic that the default value\n  should be used.\n\n  ```\n  from typing import Annotated, Any\n\n  from pydantic_core import PydanticUseDefault\n\n  from pydantic import BaseModel, BeforeValidator\n\n\n  def default_if_none(value: Any) -> Any:\n      if value is None:\n          raise PydanticUseDefault()\n      return value\n\n\n  class Model(BaseModel):\n      name: Annotated[str, BeforeValidator(default_if_none)] = 'default_name'\n\n\n  print(Model(name=None))\n  #> name='default_name'\n  ```", "url": "https://docs.pydantic.dev/latest/concepts/validators/index.html#special-typesindexhtmlspecial-types-permanent-link", "page": "concepts/validators/index.html", "source_site": "pydantic"}
{"title": "JSON Schema and field validators[Â¶](index.html#json-schema-and-field-validators \"Permanent link\")", "anchor": "json-schema-and-field-validatorsindexhtmljson-schema-and-field-validators-permanent-link", "md_text": "When using [*before*](index.html#field-before-validator), [*plain*](index.html#field-plain-validator) or [*wrap*](index.html#field-wrap-validator)\nfield validators, the accepted input type may be different from the field annotation.\n\nConsider the following example:\n\n```\nfrom typing import Any\n\nfrom pydantic import BaseModel, field_validator\n\n\nclass Model(BaseModel):\n    value: str\n\n    @field_validator('value', mode='before')\n    @classmethod\n    def cast_ints(cls, value: Any) -> Any:\n        if isinstance(value, int):\n            return str(value)\n        else:\n            return value\n\n\nprint(Model(value='a'))\n#> value='a'\nprint(Model(value=1))\n#> value='1'\n```\n\nWhile the type hint for `value` is `str`, the `cast_ints` validator also allows integers. To specify the correct\ninput type, the `json_schema_input_type` argument can be provided:\n\n```\nfrom typing import Any, Union\n\nfrom pydantic import BaseModel, field_validator\n\n\nclass Model(BaseModel):\n    value: str\n\n    @field_validator(\n        'value', mode='before', json_schema_input_type=Union[int, str]\n    )\n    @classmethod\n    def cast_ints(cls, value: Any) -> Any:\n        if isinstance(value, int):\n            return str(value)\n        else:\n            return value\n\n\nprint(Model.model_json_schema()['properties']['value'])\n#> {'anyOf': [{'type': 'integer'}, {'type': 'string'}], 'title': 'Value'}\n```\n\nAs a convenience, Pydantic will use the field type if the argument is not provided (unless you are using\na [*plain*](index.html#field-plain-validator) validator, in which case `json_schema_input_type` defaults to\n[`Any`](https://docs.python.org/3/library/typing.html#typing.Any) as the field type is completely discarded).\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/concepts/validators/index.html#json-schema-and-field-validatorsindexhtmljson-schema-and-field-validators-permanent-link", "page": "concepts/validators/index.html", "source_site": "pydantic"}
{"title": "Installation[Â¶](index.html#installation \"Permanent link\")", "anchor": "installationindexhtmlinstallation-permanent-link", "md_text": "Installation is as simple as:\n\n```\npip install pydantic-settings\n```", "url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/index.html#installationindexhtmlinstallation-permanent-link", "page": "concepts/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "Usage[Â¶](index.html#usage \"Permanent link\")", "anchor": "usageindexhtmlusage-permanent-link", "md_text": "If you create a model that inherits from `BaseSettings`, the model initialiser will attempt to determine\nthe values of any fields not passed as keyword arguments by reading from the environment. (Default values\nwill still be used if the matching environment variable is not set.)\n\nThis makes it easy to:\n\n* Create a clearly-defined, type-hinted application configuration class\n* Automatically read modifications to the configuration from environment variables\n* Manually override specific settings in the initialiser where desired (e.g. in unit tests)\n\nFor example:\n\n```\nfrom collections.abc import Callable\nfrom typing import Any\n\nfrom pydantic import (\n    AliasChoices,\n    AmqpDsn,\n    BaseModel,\n    Field,\n    ImportString,\n    PostgresDsn,\n    RedisDsn,\n)\n\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass SubModel(BaseModel):\n    foo: str = 'bar'\n    apple: int = 1\n\n\nclass Settings(BaseSettings):\n    auth_key: str = Field(validation_alias='my_auth_key')  # (1)!\n\n    api_key: str = Field(alias='my_api_key')  # (2)!\n\n    redis_dsn: RedisDsn = Field(\n        'redis://user:pass@localhost:6379/1',\n        validation_alias=AliasChoices('service_redis_dsn', 'redis_url'),  # (3)!\n    )\n    pg_dsn: PostgresDsn = 'postgres://user:pass@localhost:5432/foobar'\n    amqp_dsn: AmqpDsn = 'amqp://user:pass@localhost:5672/'\n\n    special_function: ImportString[Callable[[Any], Any]] = 'math.cos'  # (4)!\n\n    # to override domains:\n    # export my_prefix_domains='[\"foo.com\", \"bar.com\"]'\n    domains: set[str] = set()\n\n    # to override more_settings:\n    # export my_prefix_more_settings='{\"foo\": \"x\", \"apple\": 1}'\n    more_settings: SubModel = SubModel()\n\n    model_config = SettingsConfigDict(env_prefix='my_prefix_')  # (5)!\n\n\nprint(Settings().model_dump())\n\"\"\"\n{\n    'auth_key': 'xxx',\n    'api_key': 'xxx',\n    'redis_dsn': RedisDsn('redis://user:pass@localhost:6379/1'),\n    'pg_dsn': PostgresDsn('postgres://user:pass@localhost:5432/foobar'),\n    'amqp_dsn': AmqpDsn('amqp://user:pass@localhost:5672/'),\n    'special_function': math.cos,\n    'domains': set(),\n    'more_settings': {'foo': 'bar', 'apple': 1},\n}\n\"\"\"\n```\n\n1. The environment variable name is overridden using `validation_alias`. In this case, the environment variable\n   `my_auth_key` will be read instead of `auth_key`.\n\n   Check the [`Field` documentation](../fields/index.html) for more information.\n2. The environment variable name is overridden using `alias`. In this case, the environment variable\n   `my_api_key` will be used for both validation and serialization instead of `api_key`.\n\n   Check the [`Field` documentation](../fields/index.html#field-aliases) for more information.\n3. The [`AliasChoices`](../../api/aliases/index.html#pydantic.aliases.AliasChoices) class allows to have multiple environment variable names for a single field.\n   The first environment variable that is found will be used.\n\n   Check the [documentation on alias choices](../alias/index.html#aliaspath-and-aliaschoices) for more information.\n4. The [`ImportString`](../../api/types/index.html#pydantic.types.ImportString) class allows to import an object from a string.\n   In this case, the environment variable `special_function` will be read and the function [`math.cos`](https://docs.python.org/3/library/math.html#math.cos) will be imported.\n5. The `env_prefix` config setting allows to set a prefix for all environment variables.\n\n   Check the [Environment variable names documentation](index.html#environment-variable-names) for more information.", "url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/index.html#usageindexhtmlusage-permanent-link", "page": "concepts/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "Validation of default values[Â¶](index.html#validation-of-default-values \"Permanent link\")", "anchor": "validation-of-default-valuesindexhtmlvalidation-of-default-values-permanent-link", "md_text": "Unlike pydantic `BaseModel`, default values of `BaseSettings` fields are validated by default.\nYou can disable this behaviour by setting `validate_default=False` either in `model_config`\nor on field level by `Field(validate_default=False)`:\n\n```\nfrom pydantic import Field\n\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(validate_default=False)\n\n    # default won't be validated\n    foo: int = 'test'\n\n\nprint(Settings())\n#> foo='test'\n\n\nclass Settings1(BaseSettings):\n    # default won't be validated\n    foo: int = Field('test', validate_default=False)\n\n\nprint(Settings1())\n#> foo='test'\n```\n\nCheck the [validation of default values](../fields/index.html#validate-default-values) for more information.", "url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/index.html#validation-of-default-valuesindexhtmlvalidation-of-default-values-permanent-link", "page": "concepts/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "Environment variable names[Â¶](index.html#environment-variable-names \"Permanent link\")", "anchor": "environment-variable-namesindexhtmlenvironment-variable-names-permanent-link", "md_text": "By default, the environment variable name is the same as the field name.\n\nYou can change the prefix for all environment variables by setting the `env_prefix` config setting,\nor via the `_env_prefix` keyword argument on instantiation:\n\n```\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(env_prefix='my_prefix_')\n\n    auth_key: str = 'xxx'  # will be read from `my_prefix_auth_key`\n```\n\nThe default `env_prefix` is `''` (empty string). `env_prefix` is not only for env settings but also for\ndotenv files, secrets, and other sources.\n\nIf you want to change the environment variable name for a single field, you can use an alias.\n\nThere are two ways to do this:\n\n* Using `Field(alias=...)` (see `api_key` above)\n* Using `Field(validation_alias=...)` (see `auth_key` above)\n\nCheck the [`Field` aliases documentation](../fields/index.html#field-aliases) for more information about aliases.\n\n`env_prefix` does not apply to fields with alias. It means the environment variable name is the same\nas field alias:\n\n```\nfrom pydantic import Field\n\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(env_prefix='my_prefix_')\n\n    foo: str = Field('xxx', alias='FooAlias')  # (1)!\n```\n\n1. `env_prefix` will be ignored and the value will be read from `FooAlias` environment variable.", "url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/index.html#environment-variable-namesindexhtmlenvironment-variable-names-permanent-link", "page": "concepts/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "Case-sensitivity[Â¶](index.html#case-sensitivity \"Permanent link\")", "anchor": "case-sensitivityindexhtmlcase-sensitivity-permanent-link", "md_text": "By default, environment variable names are case-insensitive.\n\nIf you want to make environment variable names case-sensitive, you can set the `case_sensitive` config setting:\n\n```\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(case_sensitive=True)\n\n    redis_host: str = 'localhost'\n```\n\nWhen `case_sensitive` is `True`, the environment variable names must match field names (optionally with a prefix),\nso in this example `redis_host` could only be modified via `export redis_host`. If you want to name environment variables\nall upper-case, you should name attribute all upper-case too. You can still name environment variables anything\nyou like through `Field(validation_alias=...)`.\n\nCase-sensitivity can also be set via the `_case_sensitive` keyword argument on instantiation.\n\nIn case of nested models, the `case_sensitive` setting will be applied to all nested models.\n\n```\nimport os\n\nfrom pydantic import BaseModel, ValidationError\n\nfrom pydantic_settings import BaseSettings\n\n\nclass RedisSettings(BaseModel):\n    host: str\n    port: int\n\n\nclass Settings(BaseSettings, case_sensitive=True):\n    redis: RedisSettings\n\n\nos.environ['redis'] = '{\"host\": \"localhost\", \"port\": 6379}'\nprint(Settings().model_dump())\n#> {'redis': {'host': 'localhost', 'port': 6379}}\nos.environ['redis'] = '{\"HOST\": \"localhost\", \"port\": 6379}'  # (1)!\ntry:\n    Settings()\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Settings\n    redis.host\n      Field required [type=missing, input_value={'HOST': 'localhost', 'port': 6379}, input_type=dict]\n        For further information visit https://errors.pydantic.dev/2/v/missing\n    \"\"\"\n```\n\n1. Note that the `host` field is not found because the environment variable name is `HOST` (all upper-case).\n\nOn Windows, Python's `os` module always treats environment variables as case-insensitive, so the\n`case_sensitive` config setting will have no effect - settings will always be updated ignoring case.", "url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/index.html#case-sensitivityindexhtmlcase-sensitivity-permanent-link", "page": "concepts/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "Parsing environment variable values[Â¶](index.html#parsing-environment-variable-values \"Permanent link\")", "anchor": "parsing-environment-variable-valuesindexhtmlparsing-environment-variable-values-permanent-link", "md_text": "By default environment variables are parsed verbatim, including if the value is empty. You can choose to\nignore empty environment variables by setting the `env_ignore_empty` config setting to `True`. This can be\nuseful if you would prefer to use the default value for a field rather than an empty value from the\nenvironment.\n\nFor most simple field types (such as `int`, `float`, `str`, etc.), the environment variable value is parsed\nthe same way it would be if passed directly to the initialiser (as a string).\n\nComplex types like `list`, `set`, `dict`, and sub-models are populated from the environment by treating the\nenvironment variable's value as a JSON-encoded string.\n\nAnother way to populate nested complex variables is to configure your model with the `env_nested_delimiter`\nconfig setting, then use an environment variable with a name pointing to the nested module fields.\nWhat it does is simply explodes your variable into nested models or dicts.\nSo if you define a variable `FOO__BAR__BAZ=123` it will convert it into `FOO={'BAR': {'BAZ': 123}}`\nIf you have multiple variables with the same structure they will be merged.\n\nSub model has to inherit from `pydantic.BaseModel`, Otherwise `pydantic-settings` will initialize sub model,\ncollects values for sub model fields separately, and you may get unexpected results.\n\nAs an example, given the following environment variables:\n\n```\n# your environment\nexport V0=0\nexport SUB_MODEL='{\"v1\": \"json-1\", \"v2\": \"json-2\"}'\nexport SUB_MODEL__V2=nested-2\nexport SUB_MODEL__V3=3\nexport SUB_MODEL__DEEP__V4=v4\n```\n\nYou could load them into the following settings model:\n\n```\nfrom pydantic import BaseModel\n\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass DeepSubModel(BaseModel):  # (1)!\n    v4: str\n\n\nclass SubModel(BaseModel):  # (2)!\n    v1: str\n    v2: bytes\n    v3: int\n    deep: DeepSubModel\n\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(env_nested_delimiter='__')\n\n    v0: str\n    sub_model: SubModel\n\n\nprint(Settings().model_dump())\n\"\"\"\n{\n    'v0': '0',\n    'sub_model': {'v1': 'json-1', 'v2': b'nested-2', 'v3': 3, 'deep': {'v4': 'v4'}},\n}\n\"\"\"\n```\n\n1. Sub model has to inherit from `pydantic.BaseModel`.\n2. Sub model has to inherit from `pydantic.BaseModel`.\n\n`env_nested_delimiter` can be configured via the `model_config` as shown above, or via the\n`_env_nested_delimiter` keyword argument on instantiation.\n\nBy default environment variables are split by `env_nested_delimiter` into arbitrarily deep nested fields. You can limit\nthe depth of the nested fields with the `env_nested_max_split` config setting. A common use case this is particularly useful\nis for two-level deep settings, where the `env_nested_delimiter` (usually a single `_`) may be a substring of model\nfield names. For example:\n\n```\n# your environment\nexport GENERATION_LLM_PROVIDER='anthropic'\nexport GENERATION_LLM_API_KEY='your-api-key'\nexport GENERATION_LLM_API_VERSION='2024-03-15'\n```\n\nYou could load them into the following settings model:\n\n```\nfrom pydantic import BaseModel\n\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass LLMConfig(BaseModel):\n    provider: str = 'openai'\n    api_key: str\n    api_type: str = 'azure'\n    api_version: str = '2023-03-15-preview'\n\n\nclass GenerationConfig(BaseSettings):\n    model_config = SettingsConfigDict(\n        env_nested_delimiter='_', env_nested_max_split=1, env_prefix='GENERATION_'\n    )\n\n    llm: LLMConfig\n    ...\n\n\nprint(GenerationConfig().model_dump())\n\"\"\"\n{\n    'llm': {\n        'provider': 'anthropic',\n        'api_key': 'your-api-key',\n        'api_type': 'azure',\n        'api_version': '2024-03-15',\n    }\n}\n\"\"\"\n```\n\nWithout `env_nested_max_split=1` set, `GENERATION_LLM_API_KEY` would be parsed as `llm.api.key` instead of `llm.api_key`\nand it would raise a `ValidationError`.\n\nNested environment variables take precedence over the top-level environment variable JSON\n(e.g. in the example above, `SUB_MODEL__V2` trumps `SUB_MODEL`).\n\nYou may also populate a complex type by providing your own source class.\n\n```\nimport json\nimport os\nfrom typing import Any\n\nfrom pydantic.fields import FieldInfo\n\nfrom pydantic_settings import (\n    BaseSettings,\n    EnvSettingsSource,\n    PydanticBaseSettingsSource,\n)\n\n\nclass MyCustomSource(EnvSettingsSource):\n    def prepare_field_value(\n        self, field_name: str, field: FieldInfo, value: Any, value_is_complex: bool\n    ) -> Any:\n        if field_name == 'numbers':\n            return [int(x) for x in value.split(',')]\n        return json.loads(value)\n\n\nclass Settings(BaseSettings):\n    numbers: list[int]", "url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/index.html#parsing-environment-variable-valuesindexhtmlparsing-environment-variable-values-permanent-link", "page": "concepts/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "Parsing environment variable values[Â¶](index.html#parsing-environment-variable-values \"Permanent link\")", "anchor": "parsing-environment-variable-valuesindexhtmlparsing-environment-variable-values-permanent-link", "md_text": "    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls: type[BaseSettings],\n        init_settings: PydanticBaseSettingsSource,\n        env_settings: PydanticBaseSettingsSource,\n        dotenv_settings: PydanticBaseSettingsSource,\n        file_secret_settings: PydanticBaseSettingsSource,\n    ) -> tuple[PydanticBaseSettingsSource, ...]:\n        return (MyCustomSource(settings_cls),)\n\n\nos.environ['numbers'] = '1,2,3'\nprint(Settings().model_dump())\n#> {'numbers': [1, 2, 3]}\n```", "url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/index.html#parsing-environment-variable-valuesindexhtmlparsing-environment-variable-values-permanent-link", "page": "concepts/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "Disabling JSON parsing[Â¶](index.html#disabling-json-parsing \"Permanent link\")", "anchor": "disabling-json-parsingindexhtmldisabling-json-parsing-permanent-link", "md_text": "pydantic-settings by default parses complex types from environment variables as JSON strings. If you want to disable\nthis behavior for a field and parse the value in your own validator, you can annotate the field with\n[`NoDecode`](../../api/pydantic_settings/index.html#pydantic_settings.NoDecode):\n\n```\nimport os\nfrom typing import Annotated\n\nfrom pydantic import field_validator\n\nfrom pydantic_settings import BaseSettings, NoDecode\n\n\nclass Settings(BaseSettings):\n    numbers: Annotated[list[int], NoDecode]  # (1)!\n\n    @field_validator('numbers', mode='before')\n    @classmethod\n    def decode_numbers(cls, v: str) -> list[int]:\n        return [int(x) for x in v.split(',')]\n\n\nos.environ['numbers'] = '1,2,3'\nprint(Settings().model_dump())\n#> {'numbers': [1, 2, 3]}\n```\n\n1. The `NoDecode` annotation disables JSON parsing for the `numbers` field. The `decode_numbers` field validator\n   will be called to parse the value.\n\nYou can also disable JSON parsing for all fields by setting the `enable_decoding` config setting to `False`:\n\n```\nimport os\n\nfrom pydantic import field_validator\n\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(enable_decoding=False)\n\n    numbers: list[int]\n\n    @field_validator('numbers', mode='before')\n    @classmethod\n    def decode_numbers(cls, v: str) -> list[int]:\n        return [int(x) for x in v.split(',')]\n\n\nos.environ['numbers'] = '1,2,3'\nprint(Settings().model_dump())\n#> {'numbers': [1, 2, 3]}\n```\n\nYou can force JSON parsing for a field by annotating it with [`ForceDecode`](../../api/pydantic_settings/index.html#pydantic_settings.ForceDecode).\nThis will bypass the `enable_decoding` config setting:\n\n```\nimport os\nfrom typing import Annotated\n\nfrom pydantic import field_validator\n\nfrom pydantic_settings import BaseSettings, ForceDecode, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(enable_decoding=False)\n\n    numbers: Annotated[list[int], ForceDecode]\n    numbers1: list[int]  # (1)!\n\n    @field_validator('numbers1', mode='before')\n    @classmethod\n    def decode_numbers1(cls, v: str) -> list[int]:\n        return [int(x) for x in v.split(',')]\n\n\nos.environ['numbers'] = '[\"1\",\"2\",\"3\"]'\nos.environ['numbers1'] = '1,2,3'\nprint(Settings().model_dump())\n#> {'numbers': [1, 2, 3], 'numbers1': [1, 2, 3]}\n```\n\n1. The `numbers1` field is not annotated with `ForceDecode`, so it will not be parsed as JSON.\n   and we have to provide a custom validator to parse the value.", "url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/index.html#disabling-json-parsingindexhtmldisabling-json-parsing-permanent-link", "page": "concepts/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "Nested model default partial updates[Â¶](index.html#nested-model-default-partial-updates \"Permanent link\")", "anchor": "nested-model-default-partial-updatesindexhtmlnested-model-default-partial-updates-permanent-link", "md_text": "By default, Pydantic settings does not allow partial updates to nested model default objects. This behavior can be\noverriden by setting the `nested_model_default_partial_update` flag to `True`, which will allow partial updates on\nnested model default object fields.\n\n```\nimport os\n\nfrom pydantic import BaseModel\n\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass SubModel(BaseModel):\n    val: int = 0\n    flag: bool = False\n\n\nclass SettingsPartialUpdate(BaseSettings):\n    model_config = SettingsConfigDict(\n        env_nested_delimiter='__', nested_model_default_partial_update=True\n    )\n\n    nested_model: SubModel = SubModel(val=1)\n\n\nclass SettingsNoPartialUpdate(BaseSettings):\n    model_config = SettingsConfigDict(\n        env_nested_delimiter='__', nested_model_default_partial_update=False\n    )\n\n    nested_model: SubModel = SubModel(val=1)\n\n\n# Apply a partial update to the default object using environment variables\nos.environ['NESTED_MODEL__FLAG'] = 'True'\n\n# When partial update is enabled, the existing SubModel instance is updated\n# with nested_model.flag=True change\nassert SettingsPartialUpdate().model_dump() == {\n    'nested_model': {'val': 1, 'flag': True}\n}\n\n# When partial update is disabled, a new SubModel instance is instantiated\n# with nested_model.flag=True change\nassert SettingsNoPartialUpdate().model_dump() == {\n    'nested_model': {'val': 0, 'flag': True}\n}\n```", "url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/index.html#nested-model-default-partial-updatesindexhtmlnested-model-default-partial-updates-permanent-link", "page": "concepts/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "Dotenv (.env) support[Â¶](index.html#dotenv-env-support \"Permanent link\")", "anchor": "dotenv-env-supportindexhtmldotenv-env-support-permanent-link", "md_text": "Dotenv files (generally named `.env`) are a common pattern that make it easy to use environment variables in a\nplatform-independent manner.\n\nA dotenv file follows the same general principles of all environment variables, and it looks like this:\n\n.env\n\n```\n# ignore comment\nENVIRONMENT=\"production\"\nREDIS_ADDRESS=localhost:6379\nMEANING_OF_LIFE=42\nMY_VAR='Hello world'\n```\n\nOnce you have your `.env` file filled with variables, *pydantic* supports loading it in two ways:\n\n1. Setting the `env_file` (and `env_file_encoding` if you don't want the default encoding of your OS) on `model_config`\n   in the `BaseSettings` class:\n\n   ```\n   from pydantic_settings import BaseSettings, SettingsConfigDict\n\n\n   class Settings(BaseSettings):\n       model_config = SettingsConfigDict(env_file='.env', env_file_encoding='utf-8')\n   ```\n2. Instantiating the `BaseSettings` derived class with the `_env_file` keyword argument\n   (and the `_env_file_encoding` if needed):\n\n   ```\n   from pydantic_settings import BaseSettings, SettingsConfigDict\n\n\n   class Settings(BaseSettings):\n       model_config = SettingsConfigDict(env_file='.env', env_file_encoding='utf-8')\n\n\n   settings = Settings(_env_file='prod.env', _env_file_encoding='utf-8')\n   ```\n\n   In either case, the value of the passed argument can be any valid path or filename, either absolute or relative to the\n   current working directory. From there, *pydantic* will handle everything for you by loading in your variables and\n   validating them.\n\nIf a filename is specified for `env_file`, Pydantic will only check the current working directory and\nwon't check any parent directories for the `.env` file.\n\nEven when using a dotenv file, *pydantic* will still read environment variables as well as the dotenv file,\n**environment variables will always take priority over values loaded from a dotenv file**.\n\nPassing a file path via the `_env_file` keyword argument on instantiation (method 2) will override\nthe value (if any) set on the `model_config` class. If the above snippets were used in conjunction, `prod.env` would be loaded\nwhile `.env` would be ignored.\n\nIf you need to load multiple dotenv files, you can pass multiple file paths as a tuple or list. The files will be\nloaded in order, with each file overriding the previous one.\n\n```\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(\n        # `.env.prod` takes priority over `.env`\n        env_file=('.env', '.env.prod')\n    )\n```\n\nYou can also use the keyword argument override to tell Pydantic not to load any file at all (even if one is set in\nthe `model_config` class) by passing `None` as the instantiation keyword argument, e.g. `settings = Settings(_env_file=None)`.\n\nBecause python-dotenv is used to parse the file, bash-like semantics such as `export` can be used which\n(depending on your OS and environment) may allow your dotenv file to also be used with `source`,\nsee [python-dotenv's documentation](https://saurabh-kumar.com/python-dotenv/#usages) for more details.\n\nPydantic settings consider `extra` config in case of dotenv file. It means if you set the `extra=forbid` (*default*)\non `model_config` and your dotenv file contains an entry for a field that is not defined in settings model,\nit will raise `ValidationError` in settings construction.\n\nFor compatibility with pydantic 1.x BaseSettings you should use `extra=ignore`:\n\n```\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(env_file='.env', extra='ignore')\n```\n\nPydantic settings loads all the values from dotenv file and passes it to the model, regardless of the model's `env_prefix`.\nSo if you provide extra values in a dotenv file, whether they start with `env_prefix` or not,\na `ValidationError` will be raised.", "url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/index.html#dotenv-env-supportindexhtmldotenv-env-support-permanent-link", "page": "concepts/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "Command Line Support[Â¶](index.html#command-line-support \"Permanent link\")", "anchor": "command-line-supportindexhtmlcommand-line-support-permanent-link", "md_text": "Pydantic settings provides integrated CLI support, making it easy to quickly define CLI applications using Pydantic\nmodels. There are two primary use cases for Pydantic settings CLI:\n\n1. When using a CLI to override fields in Pydantic models.\n2. When using Pydantic models to define CLIs.\n\nBy default, the experience is tailored towards use case #1 and builds on the foundations established in [parsing\nenvironment variables](index.html#parsing-environment-variable-values). If your use case primarily falls into #2, you will likely\nwant to enable most of the defaults outlined at the end of [creating CLI applications](index.html#creating-cli-applications).", "url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/index.html#command-line-supportindexhtmlcommand-line-support-permanent-link", "page": "concepts/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "The Basics[Â¶](index.html#the-basics \"Permanent link\")", "anchor": "the-basicsindexhtmlthe-basics-permanent-link", "md_text": "To get started, let's revisit the example presented in [parsing environment\nvariables](index.html#parsing-environment-variable-values) but using a Pydantic settings CLI:\n\n```\nimport sys\n\nfrom pydantic import BaseModel\n\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass DeepSubModel(BaseModel):\n    v4: str\n\n\nclass SubModel(BaseModel):\n    v1: str\n    v2: bytes\n    v3: int\n    deep: DeepSubModel\n\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(cli_parse_args=True)\n\n    v0: str\n    sub_model: SubModel\n\n\nsys.argv = [\n    'example.py',\n    '--v0=0',\n    '--sub_model={\"v1\": \"json-1\", \"v2\": \"json-2\"}',\n    '--sub_model.v2=nested-2',\n    '--sub_model.v3=3',\n    '--sub_model.deep.v4=v4',\n]\n\nprint(Settings().model_dump())\n\"\"\"\n{\n    'v0': '0',\n    'sub_model': {'v1': 'json-1', 'v2': b'nested-2', 'v3': 3, 'deep': {'v4': 'v4'}},\n}\n\"\"\"\n```\n\nTo enable CLI parsing, we simply set the `cli_parse_args` flag to a valid value, which retains similar connotations as\ndefined in `argparse`.\n\nNote that a CLI settings source is [**the topmost source**](index.html#field-value-priority) by default unless its [priority value\nis customised](index.html#customise-settings-sources):\n\n```\nimport os\nimport sys\n\nfrom pydantic_settings import (\n    BaseSettings,\n    CliSettingsSource,\n    PydanticBaseSettingsSource,\n)\n\n\nclass Settings(BaseSettings):\n    my_foo: str\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls: type[BaseSettings],\n        init_settings: PydanticBaseSettingsSource,\n        env_settings: PydanticBaseSettingsSource,\n        dotenv_settings: PydanticBaseSettingsSource,\n        file_secret_settings: PydanticBaseSettingsSource,\n    ) -> tuple[PydanticBaseSettingsSource, ...]:\n        return env_settings, CliSettingsSource(settings_cls, cli_parse_args=True)\n\n\nos.environ['MY_FOO'] = 'from environment'\n\nsys.argv = ['example.py', '--my_foo=from cli']\n\nprint(Settings().model_dump())\n#> {'my_foo': 'from environment'}\n```\n\n#### Lists[Â¶](index.html#lists \"Permanent link\")\n\nCLI argument parsing of lists supports intermixing of any of the below three styles:\n\n* JSON style `--field='[1,2]'`\n* Argparse style `--field 1 --field 2`\n* Lazy style `--field=1,2`\n\n```\nimport sys\n\nfrom pydantic_settings import BaseSettings\n\n\nclass Settings(BaseSettings, cli_parse_args=True):\n    my_list: list[int]\n\n\nsys.argv = ['example.py', '--my_list', '[1,2]']\nprint(Settings().model_dump())\n#> {'my_list': [1, 2]}\n\nsys.argv = ['example.py', '--my_list', '1', '--my_list', '2']\nprint(Settings().model_dump())\n#> {'my_list': [1, 2]}\n\nsys.argv = ['example.py', '--my_list', '1,2']\nprint(Settings().model_dump())\n#> {'my_list': [1, 2]}\n```\n\n#### Dictionaries[Â¶](index.html#dictionaries \"Permanent link\")\n\nCLI argument parsing of dictionaries supports intermixing of any of the below two styles:\n\n* JSON style `--field='{\"k1\": 1, \"k2\": 2}'`\n* Environment variable style `--field k1=1 --field k2=2`\n\nThese can be used in conjunction with list forms as well, e.g:\n\n* `--field k1=1,k2=2 --field k3=3 --field '{\"k4\": 4}'` etc.\n\n```\nimport sys\n\nfrom pydantic_settings import BaseSettings\n\n\nclass Settings(BaseSettings, cli_parse_args=True):\n    my_dict: dict[str, int]\n\n\nsys.argv = ['example.py', '--my_dict', '{\"k1\":1,\"k2\":2}']\nprint(Settings().model_dump())\n#> {'my_dict': {'k1': 1, 'k2': 2}}\n\nsys.argv = ['example.py', '--my_dict', 'k1=1', '--my_dict', 'k2=2']\nprint(Settings().model_dump())\n#> {'my_dict': {'k1': 1, 'k2': 2}}\n```\n\n#### Literals and Enums[Â¶](index.html#literals-and-enums \"Permanent link\")\n\nCLI argument parsing of literals and enums are converted into CLI choices.\n\n```\nimport sys\nfrom enum import IntEnum\nfrom typing import Literal\n\nfrom pydantic_settings import BaseSettings\n\n\nclass Fruit(IntEnum):\n    pear = 0\n    kiwi = 1\n    lime = 2\n\n\nclass Settings(BaseSettings, cli_parse_args=True):\n    fruit: Fruit\n    pet: Literal['dog', 'cat', 'bird']\n\n\nsys.argv = ['example.py', '--fruit', 'lime', '--pet', 'cat']\nprint(Settings().model_dump())\n#> {'fruit': <Fruit.lime: 2>, 'pet': 'cat'}\n```\n\n#### Aliases[Â¶](index.html#aliases \"Permanent link\")\n\nPydantic field aliases are added as CLI argument aliases. Aliases of length one are converted into short options.\n\n```\nimport sys", "url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/index.html#the-basicsindexhtmlthe-basics-permanent-link", "page": "concepts/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "The Basics[Â¶](index.html#the-basics \"Permanent link\")", "anchor": "the-basicsindexhtmlthe-basics-permanent-link", "md_text": "from pydantic import AliasChoices, AliasPath, Field\n\nfrom pydantic_settings import BaseSettings\n\n\nclass User(BaseSettings, cli_parse_args=True):\n    first_name: str = Field(\n        validation_alias=AliasChoices('f', 'fname', AliasPath('name', 0))\n    )\n    last_name: str = Field(\n        validation_alias=AliasChoices('l', 'lname', AliasPath('name', 1))\n    )\n\n\nsys.argv = ['example.py', '--fname', 'John', '--lname', 'Doe']\nprint(User().model_dump())\n#> {'first_name': 'John', 'last_name': 'Doe'}\n\nsys.argv = ['example.py', '-f', 'John', '-l', 'Doe']\nprint(User().model_dump())\n#> {'first_name': 'John', 'last_name': 'Doe'}\n\nsys.argv = ['example.py', '--name', 'John,Doe']\nprint(User().model_dump())\n#> {'first_name': 'John', 'last_name': 'Doe'}\n\nsys.argv = ['example.py', '--name', 'John', '--lname', 'Doe']\nprint(User().model_dump())\n#> {'first_name': 'John', 'last_name': 'Doe'}\n```", "url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/index.html#the-basicsindexhtmlthe-basics-permanent-link", "page": "concepts/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "Subcommands and Positional Arguments[Â¶](index.html#subcommands-and-positional-arguments \"Permanent link\")", "anchor": "subcommands-and-positional-argumentsindexhtmlsubcommands-and-positional-arguments-permanent-link", "md_text": "Subcommands and positional arguments are expressed using the `CliSubCommand` and `CliPositionalArg` annotations. The\nsubcommand annotation can only be applied to required fields (i.e. fields that do not have a default value).\nFurthermore, subcommands must be a valid type derived from either a pydantic `BaseModel` or pydantic.dataclasses\n`dataclass`.\n\nParsed subcommands can be retrieved from model instances using the `get_subcommand` utility function. If a subcommand is\nnot required, set the `is_required` flag to `False` to disable raising an error if no subcommand is found.\n\nCLI settings subcommands are limited to a single subparser per model. In other words, all subcommands for a model\nare grouped under a single subparser; it does not allow for multiple subparsers with each subparser having its own\nset of subcommands. For more information on subparsers, see [argparse\nsubcommands](https://docs.python.org/3/library/argparse.html#sub-commands).\n\n`CliSubCommand` and `CliPositionalArg` are always case sensitive.\n\n```\nimport sys\n\nfrom pydantic import BaseModel\n\nfrom pydantic_settings import (\n    BaseSettings,\n    CliPositionalArg,\n    CliSubCommand,\n    SettingsError,\n    get_subcommand,\n)\n\n\nclass Init(BaseModel):\n    directory: CliPositionalArg[str]\n\n\nclass Clone(BaseModel):\n    repository: CliPositionalArg[str]\n    directory: CliPositionalArg[str]\n\n\nclass Git(BaseSettings, cli_parse_args=True, cli_exit_on_error=False):\n    clone: CliSubCommand[Clone]\n    init: CliSubCommand[Init]\n\n\n# Run without subcommands\nsys.argv = ['example.py']\ncmd = Git()\nassert cmd.model_dump() == {'clone': None, 'init': None}\n\ntry:\n    # Will raise an error since no subcommand was provided\n    get_subcommand(cmd).model_dump()\nexcept SettingsError as err:\n    assert str(err) == 'Error: CLI subcommand is required {clone, init}'\n\n# Will not raise an error since subcommand is not required\nassert get_subcommand(cmd, is_required=False) is None\n\n\n# Run the clone subcommand\nsys.argv = ['example.py', 'clone', 'repo', 'dest']\ncmd = Git()\nassert cmd.model_dump() == {\n    'clone': {'repository': 'repo', 'directory': 'dest'},\n    'init': None,\n}\n\n# Returns the subcommand model instance (in this case, 'clone')\nassert get_subcommand(cmd).model_dump() == {\n    'directory': 'dest',\n    'repository': 'repo',\n}\n```\n\nThe `CliSubCommand` and `CliPositionalArg` annotations also support union operations and aliases. For unions of Pydantic\nmodels, it is important to remember the [nuances](../unions/index.html) that can arise\nduring validation. Specifically, for unions of subcommands that are identical in content, it is recommended to break\nthem out into separate `CliSubCommand` fields to avoid any complications. Lastly, the derived subcommand names from\nunions will be the names of the Pydantic model classes themselves.\n\nWhen assigning aliases to `CliSubCommand` or `CliPositionalArg` fields, only a single alias can be assigned. For\nnon-union subcommands, aliasing will change the displayed help text and subcommand name. Conversely, for union\nsubcommands, aliasing will have no tangible effect from the perspective of the CLI settings source. Lastly, for\npositional arguments, aliasing will change the CLI help text displayed for the field.\n\n```\nimport sys\nfrom typing import Union\n\nfrom pydantic import BaseModel, Field\n\nfrom pydantic_settings import (\n    BaseSettings,\n    CliPositionalArg,\n    CliSubCommand,\n    get_subcommand,\n)\n\n\nclass Alpha(BaseModel):\n    \"\"\"Apha Help\"\"\"\n\n    cmd_alpha: CliPositionalArg[str] = Field(alias='alpha-cmd')\n\n\nclass Beta(BaseModel):\n    \"\"\"Beta Help\"\"\"\n\n    opt_beta: str = Field(alias='opt-beta')\n\n\nclass Gamma(BaseModel):\n    \"\"\"Gamma Help\"\"\"\n\n    opt_gamma: str = Field(alias='opt-gamma')\n\n\nclass Root(BaseSettings, cli_parse_args=True, cli_exit_on_error=False):\n    alpha_or_beta: CliSubCommand[Union[Alpha, Beta]] = Field(alias='alpha-or-beta-cmd')\n    gamma: CliSubCommand[Gamma] = Field(alias='gamma-cmd')\n\n\nsys.argv = ['example.py', 'Alpha', 'hello']\nassert get_subcommand(Root()).model_dump() == {'cmd_alpha': 'hello'}\n\nsys.argv = ['example.py', 'Beta', '--opt-beta=hey']\nassert get_subcommand(Root()).model_dump() == {'opt_beta': 'hey'}\n\nsys.argv = ['example.py', 'gamma-cmd', '--opt-gamma=hi']\nassert get_subcommand(Root()).model_dump() == {'opt_gamma': 'hi'}\n```", "url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/index.html#subcommands-and-positional-argumentsindexhtmlsubcommands-and-positional-arguments-permanent-link", "page": "concepts/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "Creating CLI Applications[Â¶](index.html#creating-cli-applications \"Permanent link\")", "anchor": "creating-cli-applicationsindexhtmlcreating-cli-applications-permanent-link", "md_text": "The `CliApp` class provides two utility methods, `CliApp.run` and `CliApp.run_subcommand`, that can be used to run a\nPydantic `BaseSettings`, `BaseModel`, or `pydantic.dataclasses.dataclass` as a CLI application. Primarily, the methods\nprovide structure for running `cli_cmd` methods associated with models.\n\n`CliApp.run` can be used in directly providing the `cli_args` to be parsed, and will run the model `cli_cmd` method (if\ndefined) after instantiation:\n\n```\nfrom pydantic_settings import BaseSettings, CliApp\n\n\nclass Settings(BaseSettings):\n    this_foo: str\n\n    def cli_cmd(self) -> None:\n        # Print the parsed data\n        print(self.model_dump())\n        #> {'this_foo': 'is such a foo'}\n\n        # Update the parsed data showing cli_cmd ran\n        self.this_foo = 'ran the foo cli cmd'\n\n\ns = CliApp.run(Settings, cli_args=['--this_foo', 'is such a foo'])\nprint(s.model_dump())\n#> {'this_foo': 'ran the foo cli cmd'}\n```\n\nSimilarly, the `CliApp.run_subcommand` can be used in recursive fashion to run the `cli_cmd` method of a subcommand:\n\n```\nfrom pydantic import BaseModel\n\nfrom pydantic_settings import CliApp, CliPositionalArg, CliSubCommand\n\n\nclass Init(BaseModel):\n    directory: CliPositionalArg[str]\n\n    def cli_cmd(self) -> None:\n        print(f'git init \"{self.directory}\"')\n        #> git init \"dir\"\n        self.directory = 'ran the git init cli cmd'\n\n\nclass Clone(BaseModel):\n    repository: CliPositionalArg[str]\n    directory: CliPositionalArg[str]\n\n    def cli_cmd(self) -> None:\n        print(f'git clone from \"{self.repository}\" into \"{self.directory}\"')\n        self.directory = 'ran the clone cli cmd'\n\n\nclass Git(BaseModel):\n    clone: CliSubCommand[Clone]\n    init: CliSubCommand[Init]\n\n    def cli_cmd(self) -> None:\n        CliApp.run_subcommand(self)\n\n\ncmd = CliApp.run(Git, cli_args=['init', 'dir'])\nassert cmd.model_dump() == {\n    'clone': None,\n    'init': {'directory': 'ran the git init cli cmd'},\n}\n```\n\nUnlike `CliApp.run`, `CliApp.run_subcommand` requires the subcommand model to have a defined `cli_cmd` method.\n\nFor `BaseModel` and `pydantic.dataclasses.dataclass` types, `CliApp.run` will internally use the following\n`BaseSettings` configuration defaults:\n\n* `nested_model_default_partial_update=True`\n* `case_sensitive=True`\n* `cli_hide_none_type=True`\n* `cli_avoid_json=True`\n* `cli_enforce_required=True`\n* `cli_implicit_flags=True`\n* `cli_kebab_case=True`", "url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/index.html#creating-cli-applicationsindexhtmlcreating-cli-applications-permanent-link", "page": "concepts/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "Asynchronous CLI Commands[Â¶](index.html#asynchronous-cli-commands \"Permanent link\")", "anchor": "asynchronous-cli-commandsindexhtmlasynchronous-cli-commands-permanent-link", "md_text": "Pydantic settings supports running asynchronous CLI commands via `CliApp.run` and `CliApp.run_subcommand`. With this feature, you can define async def methods within your Pydantic models (including subcommands) and have them executed just like their synchronous counterparts. Specifically:\n\n1. Asynchronous methods are supported: You can now mark your cli\\_cmd or similar CLI entrypoint methods as async def and have CliApp execute them.\n2. Subcommands may also be asynchronous: If you have nested CLI subcommands, the final (lowest-level) subcommand methods can likewise be asynchronous.\n3. Limit asynchronous methods to final subcommands: Defining parent commands as asynchronous is not recommended, because it can result in additional threads and event loops being created. For best performance and to avoid unnecessary resource usage, only implement your deepest (child) subcommands as async def.\n\nBelow is a simple example demonstrating an asynchronous top-level command:\n\n```\nfrom pydantic_settings import BaseSettings, CliApp\n\n\nclass AsyncSettings(BaseSettings):\n    async def cli_cmd(self) -> None:\n        print('Hello from an async CLI method!')\n        #> Hello from an async CLI method!\n\n\n# If an event loop is already running, a new thread will be used;\n# otherwise, asyncio.run() is used to execute this async method.\nassert CliApp.run(AsyncSettings, cli_args=[]).model_dump() == {}\n```\n\n#### Asynchronous Subcommands[Â¶](index.html#asynchronous-subcommands \"Permanent link\")\n\nAs mentioned above, you can also define subcommands as async. However, only do so for the leaf (lowest-level) subcommand to avoid spawning new threads and event loops unnecessarily in parent commands:\n\n```\nfrom pydantic import BaseModel\n\nfrom pydantic_settings import (\n    BaseSettings,\n    CliApp,\n    CliPositionalArg,\n    CliSubCommand,\n)\n\n\nclass Clone(BaseModel):\n    repository: CliPositionalArg[str]\n    directory: CliPositionalArg[str]\n\n    async def cli_cmd(self) -> None:\n        # Perform async tasks here, e.g. network or I/O operations\n        print(f'Cloning async from \"{self.repository}\" into \"{self.directory}\"')\n        #> Cloning async from \"repo\" into \"dir\"\n\n\nclass Git(BaseSettings):\n    clone: CliSubCommand[Clone]\n\n    def cli_cmd(self) -> None:\n        # Run the final subcommand (clone/init). It is recommended to define async methods only at the deepest level.\n        CliApp.run_subcommand(self)\n\n\nCliApp.run(Git, cli_args=['clone', 'repo', 'dir']).model_dump() == {\n    'repository': 'repo',\n    'directory': 'dir',\n}\n```\n\nWhen executing a subcommand with an asynchronous cli\\_cmd, Pydantic settings automatically detects whether the current thread already has an active event loop. If so, the async command is run in a fresh thread to avoid conflicts. Otherwise, it uses asyncio.run() in the current thread. This handling ensures your asynchronous subcommands \"just work\" without additional manual setup.", "url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/index.html#asynchronous-cli-commandsindexhtmlasynchronous-cli-commands-permanent-link", "page": "concepts/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "Serializing CLI Arguments[Â¶](index.html#serializing-cli-arguments \"Permanent link\")", "anchor": "serializing-cli-argumentsindexhtmlserializing-cli-arguments-permanent-link", "md_text": "An instantiated Pydantic model can be serialized into its CLI arguments using the `CliApp.serialize` method.\n\n```\nfrom pydantic import BaseModel\n\nfrom pydantic_settings import CliApp\n\n\nclass Nested(BaseModel):\n    that: int\n\n\nclass Settings(BaseModel):\n    this: str\n    nested: Nested\n\n\nprint(CliApp.serialize(Settings(this='hello', nested=Nested(that=123))))\n#> ['--this', 'hello', '--nested.that', '123']\n```", "url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/index.html#serializing-cli-argumentsindexhtmlserializing-cli-arguments-permanent-link", "page": "concepts/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "Mutually Exclusive Groups[Â¶](index.html#mutually-exclusive-groups \"Permanent link\")", "anchor": "mutually-exclusive-groupsindexhtmlmutually-exclusive-groups-permanent-link", "md_text": "CLI mutually exclusive groups can be created by inheriting from the `CliMutuallyExclusiveGroup` class.\n\nA `CliMutuallyExclusiveGroup` cannot be used in a union or contain nested models.\n\n```\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\nfrom pydantic_settings import CliApp, CliMutuallyExclusiveGroup, SettingsError\n\n\nclass Circle(CliMutuallyExclusiveGroup):\n    radius: Optional[float] = None\n    diameter: Optional[float] = None\n    perimeter: Optional[float] = None\n\n\nclass Settings(BaseModel):\n    circle: Circle\n\n\ntry:\n    CliApp.run(\n        Settings,\n        cli_args=['--circle.radius=1', '--circle.diameter=2'],\n        cli_exit_on_error=False,\n    )\nexcept SettingsError as e:\n    print(e)\n    \"\"\"\n    error parsing CLI: argument --circle.diameter: not allowed with argument --circle.radius\n    \"\"\"\n```", "url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/index.html#mutually-exclusive-groupsindexhtmlmutually-exclusive-groups-permanent-link", "page": "concepts/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "Customizing the CLI Experience[Â¶](index.html#customizing-the-cli-experience \"Permanent link\")", "anchor": "customizing-the-cli-experienceindexhtmlcustomizing-the-cli-experience-permanent-link", "md_text": "The below flags can be used to customise the CLI experience to your needs.\n\n#### Change the Displayed Program Name[Â¶](index.html#change-the-displayed-program-name \"Permanent link\")\n\nChange the default program name displayed in the help text usage by setting `cli_prog_name`. By default, it will derive\nthe name of the currently executing program from `sys.argv[0]`, just like argparse.\n\n```\nimport sys\n\nfrom pydantic_settings import BaseSettings\n\n\nclass Settings(BaseSettings, cli_parse_args=True, cli_prog_name='appdantic'):\n    pass\n\n\ntry:\n    sys.argv = ['example.py', '--help']\n    Settings()\nexcept SystemExit as e:\n    print(e)\n    #> 0\n\"\"\"\nusage: appdantic [-h]\n\noptions:\n  -h, --help  show this help message and exit\n\"\"\"\n```\n\n#### CLI Boolean Flags[Â¶](index.html#cli-boolean-flags \"Permanent link\")\n\nChange whether boolean fields should be explicit or implicit by default using the `cli_implicit_flags` setting. By\ndefault, boolean fields are \"explicit\", meaning a boolean value must be explicitly provided on the CLI, e.g.\n`--flag=True`. Conversely, boolean fields that are \"implicit\" derive the value from the flag itself, e.g.\n`--flag,--no-flag`, which removes the need for an explicit value to be passed.\n\nAdditionally, the provided `CliImplicitFlag` and `CliExplicitFlag` annotations can be used for more granular control\nwhen necessary.\n\n```\nfrom pydantic_settings import BaseSettings, CliExplicitFlag, CliImplicitFlag\n\n\nclass ExplicitSettings(BaseSettings, cli_parse_args=True):\n    \"\"\"Boolean fields are explicit by default.\"\"\"\n\n    explicit_req: bool\n    \"\"\"\n    --explicit_req bool   (required)\n    \"\"\"\n\n    explicit_opt: bool = False\n    \"\"\"\n    --explicit_opt bool   (default: False)\n    \"\"\"\n\n    # Booleans are explicit by default, so must override implicit flags with annotation\n    implicit_req: CliImplicitFlag[bool]\n    \"\"\"\n    --implicit_req, --no-implicit_req (required)\n    \"\"\"\n\n    implicit_opt: CliImplicitFlag[bool] = False\n    \"\"\"\n    --implicit_opt, --no-implicit_opt (default: False)\n    \"\"\"\n\n\nclass ImplicitSettings(BaseSettings, cli_parse_args=True, cli_implicit_flags=True):\n    \"\"\"With cli_implicit_flags=True, boolean fields are implicit by default.\"\"\"\n\n    # Booleans are implicit by default, so must override explicit flags with annotation\n    explicit_req: CliExplicitFlag[bool]\n    \"\"\"\n    --explicit_req bool   (required)\n    \"\"\"\n\n    explicit_opt: CliExplicitFlag[bool] = False\n    \"\"\"\n    --explicit_opt bool   (default: False)\n    \"\"\"\n\n    implicit_req: bool\n    \"\"\"\n    --implicit_req, --no-implicit_req (required)\n    \"\"\"\n\n    implicit_opt: bool = False\n    \"\"\"\n    --implicit_opt, --no-implicit_opt (default: False)\n    \"\"\"\n```\n\n#### Ignore and Retrieve Unknown Arguments[Â¶](index.html#ignore-and-retrieve-unknown-arguments \"Permanent link\")\n\nChange whether to ignore unknown CLI arguments and only parse known ones using `cli_ignore_unknown_args`. By default, the CLI\ndoes not ignore any args. Ignored arguments can then be retrieved using the `CliUnknownArgs` annotation.\n\n```\nimport sys\n\nfrom pydantic_settings import BaseSettings, CliUnknownArgs\n\n\nclass Settings(BaseSettings, cli_parse_args=True, cli_ignore_unknown_args=True):\n    good_arg: str\n    ignored_args: CliUnknownArgs\n\n\nsys.argv = ['example.py', '--bad-arg=bad', 'ANOTHER_BAD_ARG', '--good_arg=hello world']\nprint(Settings().model_dump())\n#> {'good_arg': 'hello world', 'ignored_args': ['--bad-arg=bad', 'ANOTHER_BAD_ARG']}\n```\n\n#### CLI Kebab Case for Arguments[Â¶](index.html#cli-kebab-case-for-arguments \"Permanent link\")\n\nChange whether CLI arguments should use kebab case by enabling `cli_kebab_case`. By default, `cli_kebab_case=True` will\nignore enum fields, and is equivalent to `cli_kebab_case='no_enums'`. To apply kebab case to everything, including\nenums, use `cli_kebab_case='all'`.\n\n```\nimport sys\n\nfrom pydantic import Field\n\nfrom pydantic_settings import BaseSettings\n\n\nclass Settings(BaseSettings, cli_parse_args=True, cli_kebab_case=True):\n    my_option: str = Field(description='will show as kebab case on CLI')\n\n\ntry:\n    sys.argv = ['example.py', '--help']\n    Settings()\nexcept SystemExit as e:\n    print(e)\n    #> 0\n\"\"\"\nusage: example.py [-h] [--my-option str]\n\noptions:\n  -h, --help       show this help message and exit\n  --my-option str  will show as kebab case on CLI (required)\n\"\"\"\n```\n\n#### Change Whether CLI Should Exit on Error[Â¶](index.html#change-whether-cli-should-exit-on-error \"Permanent link\")\n\nChange whether the CLI internal parser will exit on error or raise a `SettingsError` exception by using\n`cli_exit_on_error`. By default, the CLI internal parser will exit on error.\n\n```\nimport sys\n\nfrom pydantic_settings import BaseSettings, SettingsError\n\n\nclass Settings(BaseSettings, cli_parse_args=True, cli_exit_on_error=False): ...\n\n\ntry:\n    sys.argv = ['example.py', '--bad-arg']\n    Settings()\nexcept SettingsError as e:\n    print(e)\n    #> error parsing CLI: unrecognized arguments: --bad-arg\n```", "url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/index.html#customizing-the-cli-experienceindexhtmlcustomizing-the-cli-experience-permanent-link", "page": "concepts/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "Customizing the CLI Experience[Â¶](index.html#customizing-the-cli-experience \"Permanent link\")", "anchor": "customizing-the-cli-experienceindexhtmlcustomizing-the-cli-experience-permanent-link", "md_text": "#### Enforce Required Arguments at CLI[Â¶](index.html#enforce-required-arguments-at-cli \"Permanent link\")\n\nPydantic settings is designed to pull values in from various sources when instantating a model. This means a field that\nis required is not strictly required from any single source (e.g. the CLI). Instead, all that matters is that one of the\nsources provides the required value.\n\nHowever, if your use case [aligns more with #2](index.html#command-line-support), using Pydantic models to define CLIs, you will\nlikely want required fields to be *strictly required at the CLI*. We can enable this behavior by using\n`cli_enforce_required`.\n\nA required `CliPositionalArg` field is always strictly required (enforced) at the CLI.\n\n```\nimport os\nimport sys\n\nfrom pydantic import Field\n\nfrom pydantic_settings import BaseSettings, SettingsError\n\n\nclass Settings(\n    BaseSettings,\n    cli_parse_args=True,\n    cli_enforce_required=True,\n    cli_exit_on_error=False,\n):\n    my_required_field: str = Field(description='a top level required field')\n\n\nos.environ['MY_REQUIRED_FIELD'] = 'hello from environment'\n\ntry:\n    sys.argv = ['example.py']\n    Settings()\nexcept SettingsError as e:\n    print(e)\n    #> error parsing CLI: the following arguments are required: --my_required_field\n```\n\n#### Change the None Type Parse String[Â¶](index.html#change-the-none-type-parse-string \"Permanent link\")\n\nChange the CLI string value that will be parsed (e.g. \"null\", \"void\", \"None\", etc.) into `None` by setting\n`cli_parse_none_str`. By default it will use the `env_parse_none_str` value if set. Otherwise, it will default to \"null\"\nif `cli_avoid_json` is `False`, and \"None\" if `cli_avoid_json` is `True`.\n\n```\nimport sys\nfrom typing import Optional\n\nfrom pydantic import Field\n\nfrom pydantic_settings import BaseSettings\n\n\nclass Settings(BaseSettings, cli_parse_args=True, cli_parse_none_str='void'):\n    v1: Optional[int] = Field(description='the top level v0 option')\n\n\nsys.argv = ['example.py', '--v1', 'void']\nprint(Settings().model_dump())\n#> {'v1': None}\n```\n\n#### Hide None Type Values[Â¶](index.html#hide-none-type-values \"Permanent link\")\n\nHide `None` values from the CLI help text by enabling `cli_hide_none_type`.\n\n```\nimport sys\nfrom typing import Optional\n\nfrom pydantic import Field\n\nfrom pydantic_settings import BaseSettings\n\n\nclass Settings(BaseSettings, cli_parse_args=True, cli_hide_none_type=True):\n    v0: Optional[str] = Field(description='the top level v0 option')\n\n\ntry:\n    sys.argv = ['example.py', '--help']\n    Settings()\nexcept SystemExit as e:\n    print(e)\n    #> 0\n\"\"\"\nusage: example.py [-h] [--v0 str]\n\noptions:\n  -h, --help  show this help message and exit\n  --v0 str    the top level v0 option (required)\n\"\"\"\n```\n\n#### Avoid Adding JSON CLI Options[Â¶](index.html#avoid-adding-json-cli-options \"Permanent link\")\n\nAvoid adding complex fields that result in JSON strings at the CLI by enabling `cli_avoid_json`.\n\n```\nimport sys\n\nfrom pydantic import BaseModel, Field\n\nfrom pydantic_settings import BaseSettings\n\n\nclass SubModel(BaseModel):\n    v1: int = Field(description='the sub model v1 option')\n\n\nclass Settings(BaseSettings, cli_parse_args=True, cli_avoid_json=True):\n    sub_model: SubModel = Field(\n        description='The help summary for SubModel related options'\n    )\n\n\ntry:\n    sys.argv = ['example.py', '--help']\n    Settings()\nexcept SystemExit as e:\n    print(e)\n    #> 0\n\"\"\"\nusage: example.py [-h] [--sub_model.v1 int]\n\noptions:\n  -h, --help          show this help message and exit\n\nsub_model options:\n  The help summary for SubModel related options\n\n  --sub_model.v1 int  the sub model v1 option (required)\n\"\"\"\n```\n\n#### Use Class Docstring for Group Help Text[Â¶](index.html#use-class-docstring-for-group-help-text \"Permanent link\")\n\nBy default, when populating the group help text for nested models it will pull from the field descriptions.\nAlternatively, we can also configure CLI settings to pull from the class docstring instead.\n\nIf the field is a union of nested models the group help text will always be pulled from the field description;\neven if `cli_use_class_docs_for_groups` is set to `True`.\n\n```\nimport sys\n\nfrom pydantic import BaseModel, Field\n\nfrom pydantic_settings import BaseSettings\n\n\nclass SubModel(BaseModel):\n    \"\"\"The help text from the class docstring.\"\"\"\n\n    v1: int = Field(description='the sub model v1 option')\n\n\nclass Settings(BaseSettings, cli_parse_args=True, cli_use_class_docs_for_groups=True):\n    \"\"\"My application help text.\"\"\"\n\n    sub_model: SubModel = Field(description='The help text from the field description')\n\n\ntry:\n    sys.argv = ['example.py', '--help']\n    Settings()\nexcept SystemExit as e:\n    print(e)\n    #> 0\n\"\"\"\nusage: example.py [-h] [--sub_model JSON] [--sub_model.v1 int]\n\nMy application help text.\n\noptions:\n  -h, --help          show this help message and exit\n\nsub_model options:\n  The help text from the class docstring.", "url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/index.html#customizing-the-cli-experienceindexhtmlcustomizing-the-cli-experience-permanent-link", "page": "concepts/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "Customizing the CLI Experience[Â¶](index.html#customizing-the-cli-experience \"Permanent link\")", "anchor": "customizing-the-cli-experienceindexhtmlcustomizing-the-cli-experience-permanent-link", "md_text": "  --sub_model JSON    set sub_model from JSON string\n  --sub_model.v1 int  the sub model v1 option (required)\n\"\"\"\n```\n\n#### Change the CLI Flag Prefix Character[Â¶](index.html#change-the-cli-flag-prefix-character \"Permanent link\")\n\nChange The CLI flag prefix character used in CLI optional arguments by settings `cli_flag_prefix_char`.\n\n```\nimport sys\n\nfrom pydantic import AliasChoices, Field\n\nfrom pydantic_settings import BaseSettings\n\n\nclass Settings(BaseSettings, cli_parse_args=True, cli_flag_prefix_char='+'):\n    my_arg: str = Field(validation_alias=AliasChoices('m', 'my-arg'))\n\n\nsys.argv = ['example.py', '++my-arg', 'hi']\nprint(Settings().model_dump())\n#> {'my_arg': 'hi'}\n\nsys.argv = ['example.py', '+m', 'hi']\nprint(Settings().model_dump())\n#> {'my_arg': 'hi'}\n```\n\n#### Suppressing Fields from CLI Help Text[Â¶](index.html#suppressing-fields-from-cli-help-text \"Permanent link\")\n\nTo suppress a field from the CLI help text, the `CliSuppress` annotation can be used for field types, or the\n`CLI_SUPPRESS` string constant can be used for field descriptions.\n\n```\nimport sys\n\nfrom pydantic import Field\n\nfrom pydantic_settings import CLI_SUPPRESS, BaseSettings, CliSuppress\n\n\nclass Settings(BaseSettings, cli_parse_args=True):\n    \"\"\"Suppress fields from CLI help text.\"\"\"\n\n    field_a: CliSuppress[int] = 0\n    field_b: str = Field(default=1, description=CLI_SUPPRESS)\n\n\ntry:\n    sys.argv = ['example.py', '--help']\n    Settings()\nexcept SystemExit as e:\n    print(e)\n    #> 0\n\"\"\"\nusage: example.py [-h]\n\nSuppress fields from CLI help text.\n\noptions:\n  -h, --help          show this help message and exit\n\"\"\"\n```\n\n#### CLI Shortcuts for Arguments[Â¶](index.html#cli-shortcuts-for-arguments \"Permanent link\")\n\nAdd alternative CLI argument names (shortcuts) for fields using the `cli_shortcuts` option in `SettingsConfigDict`. This allows you to define additional names for CLI arguments, which can be especially useful for providing more user-friendly or shorter aliases for deeply nested or verbose field names.\n\nThe `cli_shortcuts` option takes a dictionary mapping the target field name (using dot notation for nested fields) to one or more shortcut names. If multiple fields share the same shortcut, the first matching field will take precedence.\n\n**Flat Example:**\n\n```\nfrom pydantic import Field\n\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    option: str = Field(default='foo')\n    list_option: str = Field(default='fizz')\n\n    model_config = SettingsConfigDict(\n        cli_shortcuts={'option': 'option2', 'list_option': ['list_option2']}\n    )\n\n\n# Now you can use the shortcuts on the CLI:\n# --option2 sets 'option', --list_option2 sets 'list_option'\n```\n\n**Nested Example:**\n\n```\nfrom pydantic import BaseModel, Field\n\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass TwiceNested(BaseModel):\n    option: str = Field(default='foo')\n\n\nclass Nested(BaseModel):\n    twice_nested_option: TwiceNested = TwiceNested()\n    option: str = Field(default='foo')\n\n\nclass Settings(BaseSettings):\n    nested: Nested = Nested()\n    model_config = SettingsConfigDict(\n        cli_shortcuts={\n            'nested.option': 'option2',\n            'nested.twice_nested_option.option': 'twice_nested_option',\n        }\n    )\n\n\n# Now you can use --option2 to set nested.option and --twice_nested_option to set nested.twice_nested_option.option\n```\n\nIf a shortcut collides (is mapped to multiple fields), it will apply to the first matching field in the model.", "url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/index.html#customizing-the-cli-experienceindexhtmlcustomizing-the-cli-experience-permanent-link", "page": "concepts/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "Integrating with Existing Parsers[Â¶](index.html#integrating-with-existing-parsers \"Permanent link\")", "anchor": "integrating-with-existing-parsersindexhtmlintegrating-with-existing-parsers-permanent-link", "md_text": "A CLI settings source can be integrated with existing parsers by overriding the default CLI settings source with a user\ndefined one that specifies the `root_parser` object.\n\n```\nimport sys\nfrom argparse import ArgumentParser\n\nfrom pydantic_settings import BaseSettings, CliApp, CliSettingsSource\n\nparser = ArgumentParser()\nparser.add_argument('--food', choices=['pear', 'kiwi', 'lime'])\n\n\nclass Settings(BaseSettings):\n    name: str = 'Bob'\n\n\n# Set existing `parser` as the `root_parser` object for the user defined settings source\ncli_settings = CliSettingsSource(Settings, root_parser=parser)\n\n# Parse and load CLI settings from the command line into the settings source.\nsys.argv = ['example.py', '--food', 'kiwi', '--name', 'waldo']\ns = CliApp.run(Settings, cli_settings_source=cli_settings)\nprint(s.model_dump())\n#> {'name': 'waldo'}\n\n# Load CLI settings from pre-parsed arguments. i.e., the parsing occurs elsewhere and we\n# just need to load the pre-parsed args into the settings source.\nparsed_args = parser.parse_args(['--food', 'kiwi', '--name', 'ralph'])\ns = CliApp.run(Settings, cli_args=parsed_args, cli_settings_source=cli_settings)\nprint(s.model_dump())\n#> {'name': 'ralph'}\n```\n\nA `CliSettingsSource` connects with a `root_parser` object by using parser methods to add `settings_cls` fields as\ncommand line arguments. The `CliSettingsSource` internal parser representation is based on the `argparse` library, and\ntherefore, requires parser methods that support the same attributes as their `argparse` counterparts. The available\nparser methods that can be customised, along with their argparse counterparts (the defaults), are listed below:\n\n* `parse_args_method` - (`argparse.ArgumentParser.parse_args`)\n* `add_argument_method` - (`argparse.ArgumentParser.add_argument`)\n* `add_argument_group_method` - (`argparse.ArgumentParser.add_argument_group`)\n* `add_parser_method` - (`argparse._SubParsersAction.add_parser`)\n* `add_subparsers_method` - (`argparse.ArgumentParser.add_subparsers`)\n* `formatter_class` - (`argparse.RawDescriptionHelpFormatter`)\n\nFor a non-argparse parser the parser methods can be set to `None` if not supported. The CLI settings will only raise an\nerror when connecting to the root parser if a parser method is necessary but set to `None`.\n\nThe `formatter_class` is only applied to subcommands. The `CliSettingsSource` never touches or modifies any of the\nexternal parser settings to avoid breaking changes. Since subcommands reside on their own internal parser trees, we\ncan safely apply the `formatter_class` settings without breaking the external parser logic.", "url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/index.html#integrating-with-existing-parsersindexhtmlintegrating-with-existing-parsers-permanent-link", "page": "concepts/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "Secrets[Â¶](index.html#secrets \"Permanent link\")", "anchor": "secretsindexhtmlsecrets-permanent-link", "md_text": "Placing secret values in files is a common pattern to provide sensitive configuration to an application.\n\nA secret file follows the same principal as a dotenv file except it only contains a single value and the file name\nis used as the key. A secret file will look like the following:\n\n/var/run/database\\_password\n\n```\nsuper_secret_database_password\n```\n\nOnce you have your secret files, *pydantic* supports loading it in two ways:\n\n1. Setting the `secrets_dir` on `model_config` in a `BaseSettings` class to the directory where your secret files are stored.\n\n   ```\n   from pydantic_settings import BaseSettings, SettingsConfigDict\n\n\n   class Settings(BaseSettings):\n       model_config = SettingsConfigDict(secrets_dir='/var/run')\n\n       database_password: str\n   ```\n2. Instantiating the `BaseSettings` derived class with the `_secrets_dir` keyword argument:\n\n   ```\n   settings = Settings(_secrets_dir='/var/run')\n   ```\n\nIn either case, the value of the passed argument can be any valid directory, either absolute or relative to the\ncurrent working directory. **Note that a non existent directory will only generate a warning**.\nFrom there, *pydantic* will handle everything for you by loading in your variables and validating them.\n\nEven when using a secrets directory, *pydantic* will still read environment variables from a dotenv file or the environment,\n**a dotenv file and environment variables will always take priority over values loaded from the secrets directory**.\n\nPassing a file path via the `_secrets_dir` keyword argument on instantiation (method 2) will override\nthe value (if any) set on the `model_config` class.\n\nIf you need to load settings from multiple secrets directories, you can pass multiple paths as a tuple or list. Just like for `env_file`, values from subsequent paths override previous ones.\n\n```\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    # files in '/run/secrets' take priority over '/var/run'\n    model_config = SettingsConfigDict(secrets_dir=('/var/run', '/run/secrets'))\n\n    database_password: str\n```\n\nIf any of `secrets_dir` is missing, it is ignored, and warning is shown. If any of `secrets_dir` is a file, error is raised.", "url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/index.html#secretsindexhtmlsecrets-permanent-link", "page": "concepts/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "Use Case: Docker Secrets[Â¶](index.html#use-case-docker-secrets \"Permanent link\")", "anchor": "use-case-docker-secretsindexhtmluse-case-docker-secrets-permanent-link", "md_text": "Docker Secrets can be used to provide sensitive configuration to an application running in a Docker container.\nTo use these secrets in a *pydantic* application the process is simple. More information regarding creating, managing\nand using secrets in Docker see the official\n[Docker documentation](https://docs.docker.com/engine/reference/commandline/secret/).\n\nFirst, define your `Settings` class with a `SettingsConfigDict` that specifies the secrets directory.\n\n```\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(secrets_dir='/run/secrets')\n\n    my_secret_data: str\n```\n\nBy default [Docker uses `/run/secrets`](https://docs.docker.com/engine/swarm/secrets/#how-docker-manages-secrets)\nas the target mount point. If you want to use a different location, change `Config.secrets_dir` accordingly.\n\nThen, create your secret via the Docker CLI\n\n```\nprintf \"This is a secret\" | docker secret create my_secret_data -\n```\n\nLast, run your application inside a Docker container and supply your newly created secret\n\n```\ndocker service create --name pydantic-with-secrets --secret my_secret_data pydantic-app:latest\n```", "url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/index.html#use-case-docker-secretsindexhtmluse-case-docker-secrets-permanent-link", "page": "concepts/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "Nested Secrets[Â¶](index.html#nested-secrets \"Permanent link\")", "anchor": "nested-secretsindexhtmlnested-secrets-permanent-link", "md_text": "The default secrets implementation, `SecretsSettingsSource`, has behaviour that is not always desired or sufficient.\nFor example, the default implementation does not support secret fields in nested submodels.\n\n`NestedSecretsSettingsSource` can be used as a drop-in replacement to `SecretsSettingsSource` to adjust the default behaviour.\nAll differences are summarized in the table below.\n\n| `SecretsSettingsSource` | `NestedSecretsSettingsSourcee` |\n| --- | --- |\n| Secret fields must belong to a top level model. | Secrets can be fields of nested models. |\n| Secret files can be placed in `secrets_dir`s only. | Secret files can be placed in subdirectories for nested models. |\n| Secret files discovery is based on the same configuration options that are used by `EnvSettingsSource`: `case_sensitive`, `env_nested_delimiter`, `env_prefix`. | Default options are respected, but can be overridden with `secrets_case_sensitive`, `secrets_nested_delimiter`, `secrets_prefix`. |\n| When `secrets_dir` is missing on the file system, a warning is generated. | Use `secrets_dir_missing` options to choose whether to issue warning, raise error, or silently ignore. |", "url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/index.html#nested-secretsindexhtmlnested-secrets-permanent-link", "page": "concepts/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "Use Case: Plain Directory Layout[Â¶](index.html#use-case-plain-directory-layout \"Permanent link\")", "anchor": "use-case-plain-directory-layoutindexhtmluse-case-plain-directory-layout-permanent-link", "md_text": "```\nðŸ“‚ secrets\nâ”œâ”€â”€ ðŸ“„ app_key\nâ””â”€â”€ ðŸ“„ db_passwd\n```\n\nIn the example below, secrets nested delimiter `'_'` is different from env nested delimiter `'__'`.\nValue for `Settings.db.user` can be passed in env variable `MY_DB__USER`.\n\n```\nfrom pydantic import BaseModel, SecretStr\n\nfrom pydantic_settings import (\n    BaseSettings,\n    NestedSecretsSettingsSource,\n    SettingsConfigDict,\n)\n\n\nclass AppSettings(BaseModel):\n    key: SecretStr\n\n\nclass DbSettings(BaseModel):\n    user: str\n    passwd: SecretStr\n\n\nclass Settings(BaseSettings):\n    app: AppSettings\n    db: DbSettings\n\n    model_config = SettingsConfigDict(\n        env_prefix='MY_',\n        env_nested_delimiter='__',\n        secrets_dir='secrets',\n        secrets_nested_delimiter='_',\n    )\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls,\n        init_settings,\n        env_settings,\n        dotenv_settings,\n        file_secret_settings,\n    ):\n        return (\n            init_settings,\n            env_settings,\n            dotenv_settings,\n            NestedSecretsSettingsSource(file_secret_settings),\n        )\n```", "url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/index.html#use-case-plain-directory-layoutindexhtmluse-case-plain-directory-layout-permanent-link", "page": "concepts/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "Use Case: Nested Directory Layout[Â¶](index.html#use-case-nested-directory-layout \"Permanent link\")", "anchor": "use-case-nested-directory-layoutindexhtmluse-case-nested-directory-layout-permanent-link", "md_text": "```\nðŸ“‚ secrets\nâ”œâ”€â”€ ðŸ“‚ app\nâ”‚   â””â”€â”€ ðŸ“„ key\nâ””â”€â”€ ðŸ“‚ db\n    â””â”€â”€ ðŸ“„ passwd\n\nfrom pydantic import BaseModel, SecretStr\n\nfrom pydantic_settings import (\n    BaseSettings,\n    NestedSecretsSettingsSource,\n    SettingsConfigDict,\n)\n\n\nclass AppSettings(BaseModel):\n    key: SecretStr\n\n\nclass DbSettings(BaseModel):\n    user: str\n    passwd: SecretStr\n\n\nclass Settings(BaseSettings):\n    app: AppSettings\n    db: DbSettings\n\n    model_config = SettingsConfigDict(\n        env_prefix='MY_',\n        env_nested_delimiter='__',\n        secrets_dir='secrets',\n        secrets_nested_subdir=True,\n    )\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls,\n        init_settings,\n        env_settings,\n        dotenv_settings,\n        file_secret_settings,\n    ):\n        return (\n            init_settings,\n            env_settings,\n            dotenv_settings,\n            NestedSecretsSettingsSource(file_secret_settings),\n        )\n```", "url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/index.html#use-case-nested-directory-layoutindexhtmluse-case-nested-directory-layout-permanent-link", "page": "concepts/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "Use Case: Multiple Nested Directories[Â¶](index.html#use-case-multiple-nested-directories \"Permanent link\")", "anchor": "use-case-multiple-nested-directoriesindexhtmluse-case-multiple-nested-directories-permanent-link", "md_text": "```\nðŸ“‚ secrets\nâ”œâ”€â”€ ðŸ“‚ default\nâ”‚   â”œâ”€â”€ ðŸ“‚ app\nâ”‚   â”‚   â””â”€â”€ ðŸ“„ key\nâ”‚   â””â”€â”€ ðŸ“‚ db\nâ”‚       â””â”€â”€ ðŸ“„ passwd\nâ””â”€â”€ ðŸ“‚ override\n    â”œâ”€â”€ ðŸ“‚ app\n    â”‚   â””â”€â”€ ðŸ“„ key\n    â””â”€â”€ ðŸ“‚ db\n        â””â”€â”€ ðŸ“„ passwd\n\nfrom pydantic import BaseModel, SecretStr\n\nfrom pydantic_settings import (\n    BaseSettings,\n    NestedSecretsSettingsSource,\n    SettingsConfigDict,\n)\n\n\nclass AppSettings(BaseModel):\n    key: SecretStr\n\n\nclass DbSettings(BaseModel):\n    user: str\n    passwd: SecretStr\n\n\nclass Settings(BaseSettings):\n    app: AppSettings\n    db: DbSettings\n\n    model_config = SettingsConfigDict(\n        env_prefix='MY_',\n        env_nested_delimiter='__',\n        secrets_dir=['secrets/default', 'secrets/override'],\n        secrets_nested_subdir=True,\n    )\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls,\n        init_settings,\n        env_settings,\n        dotenv_settings,\n        file_secret_settings,\n    ):\n        return (\n            init_settings,\n            env_settings,\n            dotenv_settings,\n            NestedSecretsSettingsSource(file_secret_settings),\n        )\n```", "url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/index.html#use-case-multiple-nested-directoriesindexhtmluse-case-multiple-nested-directories-permanent-link", "page": "concepts/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "Configuration Options[Â¶](index.html#configuration-options \"Permanent link\")", "anchor": "configuration-optionsindexhtmlconfiguration-options-permanent-link", "md_text": "#### secrets\\_dir[Â¶](index.html#secrets_dir \"Permanent link\")\n\nPath to secrets directory, same as `SecretsSettingsSource.secrets_dir`. If `list`, the last match wins.\nIf `secrets_dir` is passed in both source constructor and model config, values are not merged (constructor wins).\n\n#### secrets\\_dir\\_missing[Â¶](index.html#secrets_dir_missing \"Permanent link\")\n\nIf `secrets_dir` does not exist, original `SecretsSettingsSource` issues a warning.\nHowever, this may be undesirable, for example if we don't mount Docker Secrets in e.g. dev environment.\nUse `secrets_dir_missing` to choose:\n\n* `'ok'` â€” do nothing if `secrets_dir` does not exist\n* `'warn'` (default) â€” print warning, same as `SecretsSettingsSource`\n* `'error'` â€” raise `SettingsError`\n\nIf multiple `secrets_dir` passed, the same `secrets_dir_missing` action applies to each of them.\n\n#### secrets\\_dir\\_max\\_size[Â¶](index.html#secrets_dir_max_size \"Permanent link\")\n\nLimit the size of `secrets_dir` for security reasons, defaults to `SECRETS_DIR_MAX_SIZE` equal to 16 MiB.\n\n`NestedSecretsSettingsSource` is a thin wrapper around `EnvSettingsSource`,\nwhich loads all potential secrets on initialization. This could lead to `MemoryError` if we mount\na large file under `secrets_dir`.\n\nIf multiple `secrets_dir` passed, the limit applies to each directory independently.\n\n#### secrets\\_case\\_sensitive[Â¶](index.html#secrets_case_sensitive \"Permanent link\")\n\nSame as `case_sensitive`, but works for secrets only. If not specified, defaults to `case_sensitive`.\n\n#### secrets\\_nested\\_delimiter[Â¶](index.html#secrets_nested_delimiter \"Permanent link\")\n\nSame as `env_nested_delimiter`, but works for secrets only. If not specified, defaults to `env_nested_delimiter`.\nThis option is used to implement *nested secrets directory* layout and allows to do even nasty things\nlike `/run/secrets/model/delim/nested1/delim/nested2`.\n\n#### secrets\\_nested\\_subdir[Â¶](index.html#secrets_nested_subdir \"Permanent link\")\n\nBoolean flag to turn on *nested secrets directory* mode, `False` by default. If `True`, sets `secrets_nested_delimiter`\nto `os.sep`. Raises `SettingsError` if `secrets_nested_delimiter` is already specified.\n\n#### secrets\\_prefix[Â¶](index.html#secrets_prefix \"Permanent link\")\n\nSecret path prefix, similar to `env_prefix`, but works for secrets only. Defaults to `env_prefix`\nif not specified. Works in both plain and nested directory modes, like\n`'/run/secrets/prefix_model__nested'` and `'/run/secrets/prefix_model/nested'`.", "url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/index.html#configuration-optionsindexhtmlconfiguration-options-permanent-link", "page": "concepts/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "AWS Secrets Manager[Â¶](index.html#aws-secrets-manager \"Permanent link\")", "anchor": "aws-secrets-managerindexhtmlaws-secrets-manager-permanent-link", "md_text": "You must set one parameter:\n\n* `secret_id`: The AWS secret id\n\nYou must have the same naming convention in the key value in secret as in the field name. For example, if the key in secret is named `SqlServerPassword`, the field name must be the same. You can use an alias too.\n\nIn AWS Secrets Manager, nested models are supported with the `--` separator in the key name. For example, `SqlServer--Password`.\n\nArrays (e.g. `MySecret--0`, `MySecret--1`) are not supported.\n\n```\nimport os\n\nfrom pydantic import BaseModel\n\nfrom pydantic_settings import (\n    AWSSecretsManagerSettingsSource,\n    BaseSettings,\n    PydanticBaseSettingsSource,\n)\n\n\nclass SubModel(BaseModel):\n    a: str\n\n\nclass AWSSecretsManagerSettings(BaseSettings):\n    foo: str\n    bar: int\n    sub: SubModel\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls: type[BaseSettings],\n        init_settings: PydanticBaseSettingsSource,\n        env_settings: PydanticBaseSettingsSource,\n        dotenv_settings: PydanticBaseSettingsSource,\n        file_secret_settings: PydanticBaseSettingsSource,\n    ) -> tuple[PydanticBaseSettingsSource, ...]:\n        aws_secrets_manager_settings = AWSSecretsManagerSettingsSource(\n            settings_cls,\n            os.environ['AWS_SECRETS_MANAGER_SECRET_ID'],\n        )\n        return (\n            init_settings,\n            env_settings,\n            dotenv_settings,\n            file_secret_settings,\n            aws_secrets_manager_settings,\n        )\n```", "url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/index.html#aws-secrets-managerindexhtmlaws-secrets-manager-permanent-link", "page": "concepts/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "Azure Key Vault[Â¶](index.html#azure-key-vault \"Permanent link\")", "anchor": "azure-key-vaultindexhtmlazure-key-vault-permanent-link", "md_text": "You must set two parameters:\n\n* `url`: For example, `https://my-resource.vault.azure.net/`.\n* `credential`: If you use `DefaultAzureCredential`, in local you can execute `az login` to get your identity credentials. The identity must have a role assignment (the recommended one is `Key Vault Secrets User`), so you can access the secrets.\n\nYou must have the same naming convention in the field name as in the Key Vault secret name. For example, if the secret is named `SqlServerPassword`, the field name must be the same. You can use an alias too.\n\nIn Key Vault, nested models are supported with the `--` separator. For example, `SqlServer--Password`.\n\nKey Vault arrays (e.g. `MySecret--0`, `MySecret--1`) are not supported.\n\n```\nimport os\n\nfrom azure.identity import DefaultAzureCredential\nfrom pydantic import BaseModel\n\nfrom pydantic_settings import (\n    AzureKeyVaultSettingsSource,\n    BaseSettings,\n    PydanticBaseSettingsSource,\n)\n\n\nclass SubModel(BaseModel):\n    a: str\n\n\nclass AzureKeyVaultSettings(BaseSettings):\n    foo: str\n    bar: int\n    sub: SubModel\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls: type[BaseSettings],\n        init_settings: PydanticBaseSettingsSource,\n        env_settings: PydanticBaseSettingsSource,\n        dotenv_settings: PydanticBaseSettingsSource,\n        file_secret_settings: PydanticBaseSettingsSource,\n    ) -> tuple[PydanticBaseSettingsSource, ...]:\n        az_key_vault_settings = AzureKeyVaultSettingsSource(\n            settings_cls,\n            os.environ['AZURE_KEY_VAULT_URL'],\n            DefaultAzureCredential(),\n        )\n        return (\n            init_settings,\n            env_settings,\n            dotenv_settings,\n            file_secret_settings,\n            az_key_vault_settings,\n        )\n```", "url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/index.html#azure-key-vaultindexhtmlazure-key-vault-permanent-link", "page": "concepts/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "Snake case conversion[Â¶](index.html#snake-case-conversion \"Permanent link\")", "anchor": "snake-case-conversionindexhtmlsnake-case-conversion-permanent-link", "md_text": "The Azure Key Vault source accepts a `snake_case_convertion` option, disabled by default, to convert Key Vault secret names by mapping them to Python's snake\\_case field names, without the need to use aliases.\n\n```\nimport os\n\nfrom azure.identity import DefaultAzureCredential\n\nfrom pydantic_settings import (\n    AzureKeyVaultSettingsSource,\n    BaseSettings,\n    PydanticBaseSettingsSource,\n)\n\n\nclass AzureKeyVaultSettings(BaseSettings):\n    my_setting: str\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls: type[BaseSettings],\n        init_settings: PydanticBaseSettingsSource,\n        env_settings: PydanticBaseSettingsSource,\n        dotenv_settings: PydanticBaseSettingsSource,\n        file_secret_settings: PydanticBaseSettingsSource,\n    ) -> tuple[PydanticBaseSettingsSource, ...]:\n        az_key_vault_settings = AzureKeyVaultSettingsSource(\n            settings_cls,\n            os.environ['AZURE_KEY_VAULT_URL'],\n            DefaultAzureCredential(),\n            snake_case_conversion=True,\n        )\n        return (az_key_vault_settings,)\n```\n\nThis setup will load Azure Key Vault secrets (e.g., `MySetting`, `mySetting`, `my-secret` or `MY-SECRET`), mapping them to the snake case version (`my_setting` in this case).", "url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/index.html#snake-case-conversionindexhtmlsnake-case-conversion-permanent-link", "page": "concepts/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "Dash to underscore mapping[Â¶](index.html#dash-to-underscore-mapping \"Permanent link\")", "anchor": "dash-to-underscore-mappingindexhtmldash-to-underscore-mapping-permanent-link", "md_text": "The Azure Key Vault source accepts a `dash_to_underscore` option, disabled by default, to support Key Vault kebab-case secret names by mapping them to Python's snake\\_case field names. When enabled, dashes (`-`) in secret names are mapped to underscores (`_`) in field names during validation.\n\nThis mapping applies only to *field names*, not to aliases.\n\n```\nimport os\n\nfrom azure.identity import DefaultAzureCredential\nfrom pydantic import Field\n\nfrom pydantic_settings import (\n    AzureKeyVaultSettingsSource,\n    BaseSettings,\n    PydanticBaseSettingsSource,\n)\n\n\nclass AzureKeyVaultSettings(BaseSettings):\n    field_with_underscore: str\n    field_with_alias: str = Field(..., alias='Alias-With-Dashes')\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls: type[BaseSettings],\n        init_settings: PydanticBaseSettingsSource,\n        env_settings: PydanticBaseSettingsSource,\n        dotenv_settings: PydanticBaseSettingsSource,\n        file_secret_settings: PydanticBaseSettingsSource,\n    ) -> tuple[PydanticBaseSettingsSource, ...]:\n        az_key_vault_settings = AzureKeyVaultSettingsSource(\n            settings_cls,\n            os.environ['AZURE_KEY_VAULT_URL'],\n            DefaultAzureCredential(),\n            dash_to_underscore=True,\n        )\n        return (az_key_vault_settings,)\n```\n\nThis setup will load Azure Key Vault secrets named `field-with-underscore` and `Alias-With-Dashes`, mapping them to the `field_with_underscore` and `field_with_alias` fields, respectively.\n\nAlternatively, you can configure an [alias\\_generator](../alias/index.html#using-alias-generators) to map PascalCase secrets.", "url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/index.html#dash-to-underscore-mappingindexhtmldash-to-underscore-mapping-permanent-link", "page": "concepts/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "Google Cloud Secret Manager[Â¶](index.html#google-cloud-secret-manager \"Permanent link\")", "anchor": "google-cloud-secret-managerindexhtmlgoogle-cloud-secret-manager-permanent-link", "md_text": "Google Cloud Secret Manager allows you to store, manage, and access sensitive information as secrets in Google Cloud Platform. This integration lets you retrieve secrets directly from GCP Secret Manager for use in your Pydantic settings.", "url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/index.html#google-cloud-secret-managerindexhtmlgoogle-cloud-secret-manager-permanent-link", "page": "concepts/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "Installation[Â¶](index.html#installation_1 \"Permanent link\")", "anchor": "installationindexhtmlinstallation1-permanent-link", "md_text": "The Google Cloud Secret Manager integration requires additional dependencies:\n\n```\npip install \"pydantic-settings[gcp-secret-manager]\"\n```", "url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/index.html#installationindexhtmlinstallation1-permanent-link", "page": "concepts/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "Basic Usage[Â¶](index.html#basic-usage \"Permanent link\")", "anchor": "basic-usageindexhtmlbasic-usage-permanent-link", "md_text": "To use Google Cloud Secret Manager, you need to:\n\n1. Create a `GoogleSecretManagerSettingsSource`. (See [GCP Authentication](index.html#gcp-authentication) for authentication options.)\n2. Add this source to your settings customization pipeline\n\n```\nfrom pydantic import BaseModel\n\nfrom pydantic_settings import (\n    BaseSettings,\n    GoogleSecretManagerSettingsSource,\n    PydanticBaseSettingsSource,\n    SettingsConfigDict,\n)\n\n\nclass Database(BaseModel):\n    password: str\n    user: str\n\n\nclass Settings(BaseSettings):\n    database: Database\n\n    model_config = SettingsConfigDict(env_nested_delimiter='__')\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls: type[BaseSettings],\n        init_settings: PydanticBaseSettingsSource,\n        env_settings: PydanticBaseSettingsSource,\n        dotenv_settings: PydanticBaseSettingsSource,\n        file_secret_settings: PydanticBaseSettingsSource,\n    ) -> tuple[PydanticBaseSettingsSource, ...]:\n        # Create the GCP Secret Manager settings source\n        gcp_settings = GoogleSecretManagerSettingsSource(\n            settings_cls,\n            # If not provided, will use google.auth.default()\n            # to get credentials from the environemnt\n            # credentials=your_credentials,\n            # If not provided, will use google.auth.default()\n            # to get project_id from the environemnt\n            project_id='your-gcp-project-id',\n        )\n\n        return (\n            init_settings,\n            env_settings,\n            dotenv_settings,\n            file_secret_settings,\n            gcp_settings,\n        )\n```", "url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/index.html#basic-usageindexhtmlbasic-usage-permanent-link", "page": "concepts/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "GCP Authentication[Â¶](index.html#gcp-authentication \"Permanent link\")", "anchor": "gcp-authenticationindexhtmlgcp-authentication-permanent-link", "md_text": "The `GoogleSecretManagerSettingsSource` supports several authentication methods:\n\n1. **Default credentials** - If you don't provide credentials or project ID, it will use [`google.auth.default()`](https://google-auth.readthedocs.io/en/master/reference/google.auth.html#google.auth.default) to obtain them. This works with:\n2. Service account credentials from `GOOGLE_APPLICATION_CREDENTIALS` environment variable\n3. User credentials from `gcloud auth application-default login`\n4. Compute Engine, GKE, Cloud Run, or Cloud Functions default service accounts\n5. **Explicit credentials** - You can also provide `credentials` directly. e.g. `sa_credentials = google.oauth2.service_account.Credentials.from_service_account_file('path/to/service-account.json')` and then `GoogleSecretManagerSettingsSource(credentials=sa_credentials)`", "url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/index.html#gcp-authenticationindexhtmlgcp-authentication-permanent-link", "page": "concepts/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "Nested Models[Â¶](index.html#nested-models \"Permanent link\")", "anchor": "nested-modelsindexhtmlnested-models-permanent-link", "md_text": "For nested models, Secret Manager supports the `env_nested_delimiter` setting as long as it complies with the [naming rules](https://cloud.google.com/secret-manager/docs/creating-and-accessing-secrets#create-a-secret). In the example above, you would create secrets named `database__password` and `database__user` in Secret Manager.", "url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/index.html#nested-modelsindexhtmlnested-models-permanent-link", "page": "concepts/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "Important Notes[Â¶](index.html#important-notes \"Permanent link\")", "anchor": "important-notesindexhtmlimportant-notes-permanent-link", "md_text": "1. **Case Sensitivity**: By default, secret names are case-sensitive.\n2. **Secret Naming**: Create secrets in Google Secret Manager with names that match your field names (including any prefix). According the [Secret Manager documentation](https://cloud.google.com/secret-manager/docs/creating-and-accessing-secrets#create-a-secret), a secret name can contain uppercase and lowercase letters, numerals, hyphens, and underscores. The maximum allowed length for a name is 255 characters.\n3. **Secret Versions**: The GoogleSecretManagerSettingsSource uses the \"latest\" version of secrets.\n\nFor more details on creating and managing secrets in Google Cloud Secret Manager, see the [official Google Cloud documentation](https://cloud.google.com/secret-manager/docs).", "url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/index.html#important-notesindexhtmlimportant-notes-permanent-link", "page": "concepts/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "Other settings source[Â¶](index.html#other-settings-source \"Permanent link\")", "anchor": "other-settings-sourceindexhtmlother-settings-source-permanent-link", "md_text": "Other settings sources are available for common configuration files:\n\n* `JsonConfigSettingsSource` using `json_file` and `json_file_encoding` arguments\n* `PyprojectTomlConfigSettingsSource` using *(optional)* `pyproject_toml_depth` and *(optional)* `pyproject_toml_table_header` arguments\n* `TomlConfigSettingsSource` using `toml_file` argument\n* `YamlConfigSettingsSource` using `yaml_file` and yaml\\_file\\_encoding arguments\n\nYou can also provide multiple files by providing a list of path:\n\n```\ntoml_file = ['config.default.toml', 'config.custom.toml']\n```\n\nTo use them, you can use the same mechanism described [here](index.html#customise-settings-sources)\n\n```\nfrom pydantic import BaseModel\n\nfrom pydantic_settings import (\n    BaseSettings,\n    PydanticBaseSettingsSource,\n    SettingsConfigDict,\n    TomlConfigSettingsSource,\n)\n\n\nclass Nested(BaseModel):\n    nested_field: str\n\n\nclass Settings(BaseSettings):\n    foobar: str\n    nested: Nested\n    model_config = SettingsConfigDict(toml_file='config.toml')\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls: type[BaseSettings],\n        init_settings: PydanticBaseSettingsSource,\n        env_settings: PydanticBaseSettingsSource,\n        dotenv_settings: PydanticBaseSettingsSource,\n        file_secret_settings: PydanticBaseSettingsSource,\n    ) -> tuple[PydanticBaseSettingsSource, ...]:\n        return (TomlConfigSettingsSource(settings_cls),)\n```\n\nThis will be able to read the following \"config.toml\" file, located in your working directory:\n\n```\nfoobar = \"Hello\"\n[nested]\nnested_field = \"world!\"\n```", "url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/index.html#other-settings-sourceindexhtmlother-settings-source-permanent-link", "page": "concepts/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "pyproject.toml[Â¶](index.html#pyprojecttoml \"Permanent link\")", "anchor": "pyprojecttomlindexhtmlpyprojecttoml-permanent-link", "md_text": "\"pyproject.toml\" is a standardized file for providing configuration values in Python projects.\n[PEP 518](https://peps.python.org/pep-0518/#tool-table) defines a `[tool]` table that can be used to provide arbitrary tool configuration.\nWhile encouraged to use the `[tool]` table, `PyprojectTomlConfigSettingsSource` can be used to load variables from any location with in \"pyproject.toml\" file.\n\nThis is controlled by providing `SettingsConfigDict(pyproject_toml_table_header=tuple[str, ...])` where the value is a tuple of header parts.\nBy default, `pyproject_toml_table_header=('tool', 'pydantic-settings')` which will load variables from the `[tool.pydantic-settings]` table.\n\n```\nfrom pydantic_settings import (\n    BaseSettings,\n    PydanticBaseSettingsSource,\n    PyprojectTomlConfigSettingsSource,\n    SettingsConfigDict,\n)\n\n\nclass Settings(BaseSettings):\n    \"\"\"Example loading values from the table used by default.\"\"\"\n\n    field: str\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls: type[BaseSettings],\n        init_settings: PydanticBaseSettingsSource,\n        env_settings: PydanticBaseSettingsSource,\n        dotenv_settings: PydanticBaseSettingsSource,\n        file_secret_settings: PydanticBaseSettingsSource,\n    ) -> tuple[PydanticBaseSettingsSource, ...]:\n        return (PyprojectTomlConfigSettingsSource(settings_cls),)\n\n\nclass SomeTableSettings(Settings):\n    \"\"\"Example loading values from a user defined table.\"\"\"\n\n    model_config = SettingsConfigDict(\n        pyproject_toml_table_header=('tool', 'some-table')\n    )\n\n\nclass RootSettings(Settings):\n    \"\"\"Example loading values from the root of a pyproject.toml file.\"\"\"\n\n    model_config = SettingsConfigDict(extra='ignore', pyproject_toml_table_header=())\n```\n\nThis will be able to read the following \"pyproject.toml\" file, located in your working directory, resulting in `Settings(field='default-table')`, `SomeTableSettings(field='some-table')`, & `RootSettings(field='root')`:\n\n```\nfield = \"root\"\n\n[tool.pydantic-settings]\nfield = \"default-table\"\n\n[tool.some-table]\nfield = \"some-table\"\n```\n\nBy default, `PyprojectTomlConfigSettingsSource` will only look for a \"pyproject.toml\" in the your current working directory.\nHowever, there are two options to change this behavior.\n\n* `SettingsConfigDict(pyproject_toml_depth=<int>)` can be provided to check `<int>` number of directories **up** in the directory tree for a \"pyproject.toml\" if one is not found in the current working directory.\n  By default, no parent directories are checked.\n* An explicit file path can be provided to the source when it is instantiated (e.g. `PyprojectTomlConfigSettingsSource(settings_cls, Path('~/.config').resolve() / 'pyproject.toml')`).\n  If a file path is provided this way, it will be treated as absolute (no other locations are checked).\n\n```\nfrom pathlib import Path\n\nfrom pydantic_settings import (\n    BaseSettings,\n    PydanticBaseSettingsSource,\n    PyprojectTomlConfigSettingsSource,\n    SettingsConfigDict,\n)\n\n\nclass DiscoverSettings(BaseSettings):\n    \"\"\"Example of discovering a pyproject.toml in parent directories in not in `Path.cwd()`.\"\"\"\n\n    model_config = SettingsConfigDict(pyproject_toml_depth=2)\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls: type[BaseSettings],\n        init_settings: PydanticBaseSettingsSource,\n        env_settings: PydanticBaseSettingsSource,\n        dotenv_settings: PydanticBaseSettingsSource,\n        file_secret_settings: PydanticBaseSettingsSource,\n    ) -> tuple[PydanticBaseSettingsSource, ...]:\n        return (PyprojectTomlConfigSettingsSource(settings_cls),)\n\n\nclass ExplicitFilePathSettings(BaseSettings):\n    \"\"\"Example of explicitly providing the path to the file to load.\"\"\"\n\n    field: str\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls: type[BaseSettings],\n        init_settings: PydanticBaseSettingsSource,\n        env_settings: PydanticBaseSettingsSource,\n        dotenv_settings: PydanticBaseSettingsSource,\n        file_secret_settings: PydanticBaseSettingsSource,\n    ) -> tuple[PydanticBaseSettingsSource, ...]:\n        return (\n            PyprojectTomlConfigSettingsSource(\n                settings_cls, Path('~/.config').resolve() / 'pyproject.toml'\n            ),\n        )\n```", "url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/index.html#pyprojecttomlindexhtmlpyprojecttoml-permanent-link", "page": "concepts/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "Field value priority[Â¶](index.html#field-value-priority \"Permanent link\")", "anchor": "field-value-priorityindexhtmlfield-value-priority-permanent-link", "md_text": "In the case where a value is specified for the same `Settings` field in multiple ways,\nthe selected value is determined as follows (in descending order of priority):\n\n1. If `cli_parse_args` is enabled, arguments passed in at the CLI.\n2. Arguments passed to the `Settings` class initialiser.\n3. Environment variables, e.g. `my_prefix_special_function` as described above.\n4. Variables loaded from a dotenv (`.env`) file.\n5. Variables loaded from the secrets directory.\n6. The default field values for the `Settings` model.", "url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/index.html#field-value-priorityindexhtmlfield-value-priority-permanent-link", "page": "concepts/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "Customise settings sources[Â¶](index.html#customise-settings-sources \"Permanent link\")", "anchor": "customise-settings-sourcesindexhtmlcustomise-settings-sources-permanent-link", "md_text": "If the default order of priority doesn't match your needs, it's possible to change it by overriding\nthe `settings_customise_sources` method of your `Settings` .\n\n`settings_customise_sources` takes four callables as arguments and returns any number of callables as a tuple.\nIn turn these callables are called to build the inputs to the fields of the settings class.\n\nEach callable should take an instance of the settings class as its sole argument and return a `dict`.", "url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/index.html#customise-settings-sourcesindexhtmlcustomise-settings-sources-permanent-link", "page": "concepts/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "Changing Priority[Â¶](index.html#changing-priority \"Permanent link\")", "anchor": "changing-priorityindexhtmlchanging-priority-permanent-link", "md_text": "The order of the returned callables decides the priority of inputs; first item is the highest priority.\n\n```\nfrom pydantic import PostgresDsn\n\nfrom pydantic_settings import BaseSettings, PydanticBaseSettingsSource\n\n\nclass Settings(BaseSettings):\n    database_dsn: PostgresDsn\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls: type[BaseSettings],\n        init_settings: PydanticBaseSettingsSource,\n        env_settings: PydanticBaseSettingsSource,\n        dotenv_settings: PydanticBaseSettingsSource,\n        file_secret_settings: PydanticBaseSettingsSource,\n    ) -> tuple[PydanticBaseSettingsSource, ...]:\n        return env_settings, init_settings, file_secret_settings\n\n\nprint(Settings(database_dsn='postgres://postgres@localhost:5432/kwargs_db'))\n#> database_dsn=PostgresDsn('postgres://postgres@localhost:5432/kwargs_db')\n```\n\nBy flipping `env_settings` and `init_settings`, environment variables now have precedence over `__init__` kwargs.", "url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/index.html#changing-priorityindexhtmlchanging-priority-permanent-link", "page": "concepts/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "Adding sources[Â¶](index.html#adding-sources \"Permanent link\")", "anchor": "adding-sourcesindexhtmladding-sources-permanent-link", "md_text": "As explained earlier, *pydantic* ships with multiples built-in settings sources. However, you may occasionally\nneed to add your own custom sources, `settings_customise_sources` makes this very easy:\n\n```\nimport json\nfrom pathlib import Path\nfrom typing import Any\n\nfrom pydantic.fields import FieldInfo\n\nfrom pydantic_settings import (\n    BaseSettings,\n    PydanticBaseSettingsSource,\n    SettingsConfigDict,\n)\n\n\nclass JsonConfigSettingsSource(PydanticBaseSettingsSource):\n    \"\"\"\n    A simple settings source class that loads variables from a JSON file\n    at the project's root.\n\n    Here we happen to choose to use the `env_file_encoding` from Config\n    when reading `config.json`\n    \"\"\"\n\n    def get_field_value(\n        self, field: FieldInfo, field_name: str\n    ) -> tuple[Any, str, bool]:\n        encoding = self.config.get('env_file_encoding')\n        file_content_json = json.loads(\n            Path('tests/example_test_config.json').read_text(encoding)\n        )\n        field_value = file_content_json.get(field_name)\n        return field_value, field_name, False\n\n    def prepare_field_value(\n        self, field_name: str, field: FieldInfo, value: Any, value_is_complex: bool\n    ) -> Any:\n        return value\n\n    def __call__(self) -> dict[str, Any]:\n        d: dict[str, Any] = {}\n\n        for field_name, field in self.settings_cls.model_fields.items():\n            field_value, field_key, value_is_complex = self.get_field_value(\n                field, field_name\n            )\n            field_value = self.prepare_field_value(\n                field_name, field, field_value, value_is_complex\n            )\n            if field_value is not None:\n                d[field_key] = field_value\n\n        return d\n\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(env_file_encoding='utf-8')\n\n    foobar: str\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls: type[BaseSettings],\n        init_settings: PydanticBaseSettingsSource,\n        env_settings: PydanticBaseSettingsSource,\n        dotenv_settings: PydanticBaseSettingsSource,\n        file_secret_settings: PydanticBaseSettingsSource,\n    ) -> tuple[PydanticBaseSettingsSource, ...]:\n        return (\n            init_settings,\n            JsonConfigSettingsSource(settings_cls),\n            env_settings,\n            file_secret_settings,\n        )\n\n\nprint(Settings())\n#> foobar='test'\n```\n\n#### Accessing the result of previous sources[Â¶](index.html#accessing-the-result-of-previous-sources \"Permanent link\")\n\nEach source of settings can access the output of the previous ones.\n\n```\nfrom typing import Any\n\nfrom pydantic.fields import FieldInfo\n\nfrom pydantic_settings import PydanticBaseSettingsSource\n\n\nclass MyCustomSource(PydanticBaseSettingsSource):\n    def get_field_value(\n        self, field: FieldInfo, field_name: str\n    ) -> tuple[Any, str, bool]: ...\n\n    def __call__(self) -> dict[str, Any]:\n        # Retrieve the aggregated settings from previous sources\n        current_state = self.current_state\n        current_state.get('some_setting')\n\n        # Retrive settings from all sources individually\n        # self.settings_sources_data[\"SettingsSourceName\"]: dict[str, Any]\n        settings_sources_data = self.settings_sources_data\n        settings_sources_data['SomeSettingsSource'].get('some_setting')\n\n        # Your code here...\n```", "url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/index.html#adding-sourcesindexhtmladding-sources-permanent-link", "page": "concepts/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "Removing sources[Â¶](index.html#removing-sources \"Permanent link\")", "anchor": "removing-sourcesindexhtmlremoving-sources-permanent-link", "md_text": "You might also want to disable a source:\n\n```\nfrom pydantic import ValidationError\n\nfrom pydantic_settings import BaseSettings, PydanticBaseSettingsSource\n\n\nclass Settings(BaseSettings):\n    my_api_key: str\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls: type[BaseSettings],\n        init_settings: PydanticBaseSettingsSource,\n        env_settings: PydanticBaseSettingsSource,\n        dotenv_settings: PydanticBaseSettingsSource,\n        file_secret_settings: PydanticBaseSettingsSource,\n    ) -> tuple[PydanticBaseSettingsSource, ...]:\n        # here we choose to ignore arguments from init_settings\n        return env_settings, file_secret_settings\n\n\ntry:\n    Settings(my_api_key='this is ignored')\nexcept ValidationError as exc_info:\n    print(exc_info)\n    \"\"\"\n    1 validation error for Settings\n    my_api_key\n      Field required [type=missing, input_value={}, input_type=dict]\n        For further information visit https://errors.pydantic.dev/2/v/missing\n    \"\"\"\n```", "url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/index.html#removing-sourcesindexhtmlremoving-sources-permanent-link", "page": "concepts/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "In-place reloading[Â¶](index.html#in-place-reloading \"Permanent link\")", "anchor": "in-place-reloadingindexhtmlin-place-reloading-permanent-link", "md_text": "In case you want to reload in-place an existing setting, you can do it by using its `__init__` method :\n\n```\nimport os\n\nfrom pydantic import Field\n\nfrom pydantic_settings import BaseSettings\n\n\nclass Settings(BaseSettings):\n    foo: str = Field('foo')\n\n\nmutable_settings = Settings()\n\nprint(mutable_settings.foo)\n#> foo\n\nos.environ['foo'] = 'bar'\nprint(mutable_settings.foo)\n#> foo\n\nmutable_settings.__init__()\nprint(mutable_settings.foo)\n#> bar\n\nos.environ.pop('foo')\nmutable_settings.__init__()\nprint(mutable_settings.foo)\n#> foo\n```\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/concepts/pydantic_settings/index.html#in-place-reloadingindexhtmlin-place-reloading-permanent-link", "page": "concepts/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "Configuration on Pydantic models[Â¶](index.html#configuration-on-pydantic-models \"Permanent link\")", "anchor": "configuration-on-pydantic-modelsindexhtmlconfiguration-on-pydantic-models-permanent-link", "md_text": "On Pydantic models, configuration can be specified in two ways:\n\n* Using the [`model_config`](../../api/base_model/index.html#pydantic.BaseModel.model_config) class attribute:\n\n  ```\n  from pydantic import BaseModel, ConfigDict, ValidationError\n\n\n  class Model(BaseModel):\n      model_config = ConfigDict(str_max_length=5)  # (1)!\n\n      v: str\n\n\n  try:\n      m = Model(v='abcdef')\n  except ValidationError as e:\n      print(e)\n      \"\"\"\n      1 validation error for Model\n      v\n        String should have at most 5 characters [type=string_too_long, input_value='abcdef', input_type=str]\n      \"\"\"\n  ```\n\n  1. A plain dictionary (i.e. `{'str_max_length': 5}`) can also be used.\n\n  In Pydantic V1, the `Config` class was used. This is still supported, but **deprecated**.\n* Using class arguments:\n\n  ```\n  from pydantic import BaseModel\n\n\n  class Model(BaseModel, frozen=True):\n      a: str\n  ```\n\nUnlike the [`model_config`](../../api/base_model/index.html#pydantic.BaseModel.model_config) class attribute,\nstatic type checkers will recognize class arguments. For `frozen`, any instance\nmutation will be flagged as an type checking error.", "url": "https://docs.pydantic.dev/latest/concepts/config/index.html#configuration-on-pydantic-modelsindexhtmlconfiguration-on-pydantic-models-permanent-link", "page": "concepts/config/index.html", "source_site": "pydantic"}
{"title": "Configuration on Pydantic dataclasses[Â¶](index.html#configuration-on-pydantic-dataclasses \"Permanent link\")", "anchor": "configuration-on-pydantic-dataclassesindexhtmlconfiguration-on-pydantic-dataclasses-permanent-link", "md_text": "[Pydantic dataclasses](../dataclasses/index.html) also support configuration (read more in the\n[dedicated section](../dataclasses/index.html#dataclass-config)).\n\n```\nfrom pydantic import ConfigDict, ValidationError\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass(config=ConfigDict(str_max_length=10, validate_assignment=True))\nclass User:\n    name: str\n\n\nuser = User(name='John Doe')\ntry:\n    user.name = 'x' * 20\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n    name\n      String should have at most 10 characters [type=string_too_long, input_value='xxxxxxxxxxxxxxxxxxxx', input_type=str]\n    \"\"\"\n```", "url": "https://docs.pydantic.dev/latest/concepts/config/index.html#configuration-on-pydantic-dataclassesindexhtmlconfiguration-on-pydantic-dataclasses-permanent-link", "page": "concepts/config/index.html", "source_site": "pydantic"}
{"title": "Configuration on `TypeAdapter`[Â¶](index.html#configuration-on-typeadapter \"Permanent link\")", "anchor": "configuration-on-typeadapterindexhtmlconfiguration-on-typeadapter-permanent-link", "md_text": "[Type adapters](../type_adapter/index.html) (using the [`TypeAdapter`](../../api/type_adapter/index.html#pydantic.type_adapter.TypeAdapter) class) support configuration,\nby providing the `config` argument.\n\n```\nfrom pydantic import ConfigDict, TypeAdapter\n\nta = TypeAdapter(list[str], config=ConfigDict(coerce_numbers_to_str=True))\n\nprint(ta.validate_python([1, 2]))\n#> ['1', '2']\n```\n\nConfiguration can't be provided if the type adapter directly wraps a type that support it, and a\n[usage error](../../errors/usage_errors/index.html) is raised in this case.\nThe [configuration propagation](index.html#configuration-propagation) rules also apply.", "url": "https://docs.pydantic.dev/latest/concepts/config/index.html#configuration-on-typeadapterindexhtmlconfiguration-on-typeadapter-permanent-link", "page": "concepts/config/index.html", "source_site": "pydantic"}
{"title": "Configuration on other supported types[Â¶](index.html#configuration-on-other-supported-types \"Permanent link\")", "anchor": "configuration-on-other-supported-typesindexhtmlconfiguration-on-other-supported-types-permanent-link", "md_text": "If you are using [standard library dataclasses](https://docs.python.org/3/library/dataclasses.html#module-dataclasses) or [`TypedDict`](https://docs.python.org/3/library/typing.html#typing.TypedDict) classes,\nthe configuration can be set in two ways:\n\n* Using the `__pydantic_config__` class attribute:\n\n  ```\n  from dataclasses import dataclass\n\n  from pydantic import ConfigDict\n\n\n  @dataclass\n  class User:\n      __pydantic_config__ = ConfigDict(strict=True)\n\n      id: int\n      name: str = 'John Doe'\n  ```\n* Using the [`@with_config`](../../api/config/index.html#pydantic.config.with_config) decorator (this avoids static type checking errors with\n  [`TypedDict`](https://docs.python.org/3/library/typing.html#typing.TypedDict)):\n\n  ```\n  from typing_extensions import TypedDict\n\n  from pydantic import ConfigDict, with_config\n\n\n  @with_config(ConfigDict(str_to_lower=True))\n  class Model(TypedDict):\n      x: str\n  ```", "url": "https://docs.pydantic.dev/latest/concepts/config/index.html#configuration-on-other-supported-typesindexhtmlconfiguration-on-other-supported-types-permanent-link", "page": "concepts/config/index.html", "source_site": "pydantic"}
{"title": "Configuration on the `@validate_call` decorator[Â¶](index.html#configuration-on-the-validate_call-decorator \"Permanent link\")", "anchor": "configuration-on-the-validatecall-decoratorindexhtmlconfiguration-on-the-validatecall-decorator-permanent-link", "md_text": "The [`@validate_call`](../validation_decorator/index.html) also supports setting custom configuration. See the\n[dedicated section](../validation_decorator/index.html#custom-configuration) for more details.", "url": "https://docs.pydantic.dev/latest/concepts/config/index.html#configuration-on-the-validatecall-decoratorindexhtmlconfiguration-on-the-validatecall-decorator-permanent-link", "page": "concepts/config/index.html", "source_site": "pydantic"}
{"title": "Change behaviour globally[Â¶](index.html#change-behaviour-globally \"Permanent link\")", "anchor": "change-behaviour-globallyindexhtmlchange-behaviour-globally-permanent-link", "md_text": "If you wish to change the behaviour of Pydantic globally, you can create your own custom parent class\nwith a custom configuration, as the configuration is inherited:\n\n```\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass Parent(BaseModel):\n    model_config = ConfigDict(extra='allow')\n\n\nclass Model(Parent):\n    x: str\n\n\nm = Model(x='foo', y='bar')\nprint(m.model_dump())\n#> {'x': 'foo', 'y': 'bar'}\n```\n\nIf you provide configuration to the subclasses, it will be *merged* with the parent configuration:\n\n```\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass Parent(BaseModel):\n    model_config = ConfigDict(extra='allow', str_to_lower=False)\n\n\nclass Model(Parent):\n    model_config = ConfigDict(str_to_lower=True)\n\n    x: str\n\n\nm = Model(x='FOO', y='bar')\nprint(m.model_dump())\n#> {'x': 'foo', 'y': 'bar'}\nprint(Model.model_config)\n#> {'extra': 'allow', 'str_to_lower': True}\n```\n\nIf your model inherits from multiple bases, Pydantic currently *doesn't* follow the\n[MRO](https://docs.python.org/3/glossary.html#term-method-resolution-order). For more details, see [this issue](https://github.com/pydantic/pydantic/issues/9992).", "url": "https://docs.pydantic.dev/latest/concepts/config/index.html#change-behaviour-globallyindexhtmlchange-behaviour-globally-permanent-link", "page": "concepts/config/index.html", "source_site": "pydantic"}
{"title": "Configuration propagation[Â¶](index.html#configuration-propagation \"Permanent link\")", "anchor": "configuration-propagationindexhtmlconfiguration-propagation-permanent-link", "md_text": "When using types that support configuration as field annotations, configuration may not be propagated:\n\n* For Pydantic models and dataclasses, configuration will *not* be propagated, each model has its own\n  \"configuration boundary\":\n\n  ```\n  from pydantic import BaseModel, ConfigDict\n\n\n  class User(BaseModel):\n      name: str\n\n\n  class Parent(BaseModel):\n      user: User\n\n      model_config = ConfigDict(str_to_lower=True)\n\n\n  print(Parent(user={'name': 'JOHN'}))\n  #> user=User(name='JOHN')\n  ```\n* For stdlib types (dataclasses and typed dictionaries), configuration will be propagated, unless\n  the type has its own configuration set:\n\n  ```\n  from dataclasses import dataclass\n\n  from pydantic import BaseModel, ConfigDict, with_config\n\n\n  @dataclass\n  class UserWithoutConfig:\n      name: str\n\n\n  @dataclass\n  @with_config(str_to_lower=False)\n  class UserWithConfig:\n      name: str\n\n\n  class Parent(BaseModel):\n      user_1: UserWithoutConfig\n      user_2: UserWithConfig\n\n      model_config = ConfigDict(str_to_lower=True)\n\n\n  print(Parent(user_1={'name': 'JOHN'}, user_2={'name': 'JOHN'}))\n  #> user_1=UserWithoutConfig(name='john') user_2=UserWithConfig(name='JOHN')\n  ```\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/concepts/config/index.html#configuration-propagationindexhtmlconfiguration-propagation-permanent-link", "page": "concepts/config/index.html", "source_site": "pydantic"}
{"title": "`AliasPath` and `AliasChoices`[Â¶](index.html#aliaspath-and-aliaschoices \"Permanent link\")", "anchor": "aliaspath-and-aliaschoicesindexhtmlaliaspath-and-aliaschoices-permanent-link", "md_text": "API Documentation\n\n[`pydantic.aliases.AliasPath`](../../api/aliases/index.html#pydantic.aliases.AliasPath)  \n[`pydantic.aliases.AliasChoices`](../../api/aliases/index.html#pydantic.aliases.AliasChoices)\n\nPydantic provides two special types for convenience when using `validation_alias`: `AliasPath` and `AliasChoices`.\n\nThe `AliasPath` is used to specify a path to a field using aliases. For example:\n\n```\nfrom pydantic import BaseModel, Field, AliasPath\n\n\nclass User(BaseModel):\n    first_name: str = Field(validation_alias=AliasPath('names', 0))\n    last_name: str = Field(validation_alias=AliasPath('names', 1))\n\nuser = User.model_validate({'names': ['John', 'Doe']})  # (1)!\nprint(user)\n#> first_name='John' last_name='Doe'\n```\n\n1. We are using `model_validate` to validate a dictionary using the field aliases.\n\n   You can see more details about [`model_validate`](../../api/base_model/index.html#pydantic.BaseModel.model_validate) in the API reference.\n\nIn the `'first_name'` field, we are using the alias `'names'` and the index `0` to specify the path to the first name.\nIn the `'last_name'` field, we are using the alias `'names'` and the index `1` to specify the path to the last name.\n\n`AliasChoices` is used to specify a choice of aliases. For example:\n\n```\nfrom pydantic import BaseModel, Field, AliasChoices\n\n\nclass User(BaseModel):\n    first_name: str = Field(validation_alias=AliasChoices('first_name', 'fname'))\n    last_name: str = Field(validation_alias=AliasChoices('last_name', 'lname'))\n\nuser = User.model_validate({'fname': 'John', 'lname': 'Doe'})  # (1)!\nprint(user)\n#> first_name='John' last_name='Doe'\nuser = User.model_validate({'first_name': 'John', 'lname': 'Doe'})  # (2)!\nprint(user)\n#> first_name='John' last_name='Doe'\n```\n\n1. We are using the second alias choice for both fields.\n2. We are using the first alias choice for the field `'first_name'` and the second alias choice\n   for the field `'last_name'`.\n\nYou can also use `AliasChoices` with `AliasPath`:\n\n```\nfrom pydantic import BaseModel, Field, AliasPath, AliasChoices\n\n\nclass User(BaseModel):\n    first_name: str = Field(validation_alias=AliasChoices('first_name', AliasPath('names', 0)))\n    last_name: str = Field(validation_alias=AliasChoices('last_name', AliasPath('names', 1)))\n\n\nuser = User.model_validate({'first_name': 'John', 'last_name': 'Doe'})\nprint(user)\n#> first_name='John' last_name='Doe'\nuser = User.model_validate({'names': ['John', 'Doe']})\nprint(user)\n#> first_name='John' last_name='Doe'\nuser = User.model_validate({'names': ['John'], 'last_name': 'Doe'})\nprint(user)\n#> first_name='John' last_name='Doe'\n```", "url": "https://docs.pydantic.dev/latest/concepts/alias/index.html#aliaspath-and-aliaschoicesindexhtmlaliaspath-and-aliaschoices-permanent-link", "page": "concepts/alias/index.html", "source_site": "pydantic"}
{"title": "Using alias generators[Â¶](index.html#using-alias-generators \"Permanent link\")", "anchor": "using-alias-generatorsindexhtmlusing-alias-generators-permanent-link", "md_text": "You can use the `alias_generator` parameter of [`Config`](../../api/config/index.html#pydantic.config.ConfigDict.alias_generator) to specify\na callable (or group of callables, via `AliasGenerator`) that will generate aliases for all fields in a model.\nThis is useful if you want to use a consistent naming convention for all fields in a model, but do not\nwant to specify the alias for each field individually.\n\nPydantic offers three built-in alias generators that you can use out of the box:\n\n[`to_pascal`](../../api/config/index.html#pydantic.alias_generators.to_pascal)  \n[`to_camel`](../../api/config/index.html#pydantic.alias_generators.to_camel)  \n[`to_snake`](../../api/config/index.html#pydantic.alias_generators.to_snake)", "url": "https://docs.pydantic.dev/latest/concepts/alias/index.html#using-alias-generatorsindexhtmlusing-alias-generators-permanent-link", "page": "concepts/alias/index.html", "source_site": "pydantic"}
{"title": "Using a callable[Â¶](index.html#using-a-callable \"Permanent link\")", "anchor": "using-a-callableindexhtmlusing-a-callable-permanent-link", "md_text": "Here's a basic example using a callable:\n\n```\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass Tree(BaseModel):\n    model_config = ConfigDict(\n        alias_generator=lambda field_name: field_name.upper()\n    )\n\n    age: int\n    height: float\n    kind: str\n\n\nt = Tree.model_validate({'AGE': 12, 'HEIGHT': 1.2, 'KIND': 'oak'})\nprint(t.model_dump(by_alias=True))\n#> {'AGE': 12, 'HEIGHT': 1.2, 'KIND': 'oak'}\n```", "url": "https://docs.pydantic.dev/latest/concepts/alias/index.html#using-a-callableindexhtmlusing-a-callable-permanent-link", "page": "concepts/alias/index.html", "source_site": "pydantic"}
{"title": "Using an `AliasGenerator`[Â¶](index.html#using-an-aliasgenerator \"Permanent link\")", "anchor": "using-an-aliasgeneratorindexhtmlusing-an-aliasgenerator-permanent-link", "md_text": "API Documentation\n\n[`pydantic.aliases.AliasGenerator`](../../api/aliases/index.html#pydantic.aliases.AliasGenerator)\n\n`AliasGenerator` is a class that allows you to specify multiple alias generators for a model.\nYou can use an `AliasGenerator` to specify different alias generators for validation and serialization.\n\nThis is particularly useful if you need to use different naming conventions for loading and saving data,\nbut you don't want to specify the validation and serialization aliases for each field individually.\n\nFor example:\n\n```\nfrom pydantic import AliasGenerator, BaseModel, ConfigDict\n\n\nclass Tree(BaseModel):\n    model_config = ConfigDict(\n        alias_generator=AliasGenerator(\n            validation_alias=lambda field_name: field_name.upper(),\n            serialization_alias=lambda field_name: field_name.title(),\n        )\n    )\n\n    age: int\n    height: float\n    kind: str\n\n\nt = Tree.model_validate({'AGE': 12, 'HEIGHT': 1.2, 'KIND': 'oak'})\nprint(t.model_dump(by_alias=True))\n#> {'Age': 12, 'Height': 1.2, 'Kind': 'oak'}\n```", "url": "https://docs.pydantic.dev/latest/concepts/alias/index.html#using-an-aliasgeneratorindexhtmlusing-an-aliasgenerator-permanent-link", "page": "concepts/alias/index.html", "source_site": "pydantic"}
{"title": "Alias Precedence[Â¶](index.html#alias-precedence \"Permanent link\")", "anchor": "alias-precedenceindexhtmlalias-precedence-permanent-link", "md_text": "If you specify an `alias` on the [`Field`](../../api/fields/index.html#pydantic.fields.Field), it will take precedence over the generated alias by default:\n\n```\nfrom pydantic import BaseModel, ConfigDict, Field\n\n\ndef to_camel(string: str) -> str:\n    return ''.join(word.capitalize() for word in string.split('_'))\n\n\nclass Voice(BaseModel):\n    model_config = ConfigDict(alias_generator=to_camel)\n\n    name: str\n    language_code: str = Field(alias='lang')\n\n\nvoice = Voice(Name='Filiz', lang='tr-TR')\nprint(voice.language_code)\n#> tr-TR\nprint(voice.model_dump(by_alias=True))\n#> {'Name': 'Filiz', 'lang': 'tr-TR'}\n```", "url": "https://docs.pydantic.dev/latest/concepts/alias/index.html#alias-precedenceindexhtmlalias-precedence-permanent-link", "page": "concepts/alias/index.html", "source_site": "pydantic"}
{"title": "Alias Priority[Â¶](index.html#alias-priority \"Permanent link\")", "anchor": "alias-priorityindexhtmlalias-priority-permanent-link", "md_text": "You may set `alias_priority` on a field to change this behavior:\n\n* `alias_priority=2` the alias will *not* be overridden by the alias generator.\n* `alias_priority=1` the alias *will* be overridden by the alias generator.\n* `alias_priority` not set:\n  + alias is set: the alias will *not* be overridden by the alias generator.\n  + alias is not set: the alias *will* be overridden by the alias generator.\n\nThe same precedence applies to `validation_alias` and `serialization_alias`.\nSee more about the different field aliases under [field aliases](../fields/index.html#field-aliases).", "url": "https://docs.pydantic.dev/latest/concepts/alias/index.html#alias-priorityindexhtmlalias-priority-permanent-link", "page": "concepts/alias/index.html", "source_site": "pydantic"}
{"title": "Alias Configuration[Â¶](index.html#alias-configuration \"Permanent link\")", "anchor": "alias-configurationindexhtmlalias-configuration-permanent-link", "md_text": "You can use [`ConfigDict`](../config/index.html) settings or runtime validation/serialization\nsettings to control whether or not aliases are used.", "url": "https://docs.pydantic.dev/latest/concepts/alias/index.html#alias-configurationindexhtmlalias-configuration-permanent-link", "page": "concepts/alias/index.html", "source_site": "pydantic"}
{"title": "`ConfigDict` Settings[Â¶](index.html#configdict-settings \"Permanent link\")", "anchor": "configdict-settingsindexhtmlconfigdict-settings-permanent-link", "md_text": "You can use [configuration settings](../config/index.html) to control, at the model level,\nwhether or not aliases are used for validation and serialization. If you would like to control\nthis behavior for nested models/surpassing the config-model boundary, use [runtime settings](index.html#runtime-settings).\n\n#### Validation[Â¶](index.html#validation \"Permanent link\")\n\nWhen validating data, you can enable population of attributes by attribute name, alias, or both.\n**By default**, Pydantic uses aliases for validation. Further configuration is available via:\n\n* [`ConfigDict.validate_by_alias`](../../api/config/index.html#pydantic.config.ConfigDict.validate_by_alias): `True` by default\n* [`ConfigDict.validate_by_name`](../../api/config/index.html#pydantic.config.ConfigDict.validate_by_name): `False` by default\n\n`validate_by_alias``validate_by_name``validate_by_alias` and `validate_by_name`\n\n```\nfrom pydantic import BaseModel, ConfigDict, Field\n\n\nclass Model(BaseModel):\n    my_field: str = Field(validation_alias='my_alias')\n\n    model_config = ConfigDict(validate_by_alias=True, validate_by_name=False)\n\n\nprint(repr(Model(my_alias='foo')))  # (1)!\n#> Model(my_field='foo')\n```\n\n1. The alias `my_alias` is used for validation.\n\n```\nfrom pydantic import BaseModel, ConfigDict, Field\n\n\nclass Model(BaseModel):\n    my_field: str = Field(validation_alias='my_alias')\n\n    model_config = ConfigDict(validate_by_alias=False, validate_by_name=True)\n\n\nprint(repr(Model(my_field='foo')))  # (1)!\n#> Model(my_field='foo')\n```\n\n1. the attribute identifier `my_field` is used for validation.\n\n```\nfrom pydantic import BaseModel, ConfigDict, Field\n\n\nclass Model(BaseModel):\n    my_field: str = Field(validation_alias='my_alias')\n\n    model_config = ConfigDict(validate_by_alias=True, validate_by_name=True)\n\n\nprint(repr(Model(my_alias='foo')))  # (1)!\n#> Model(my_field='foo')\n\nprint(repr(Model(my_field='foo')))  # (2)!\n#> Model(my_field='foo')\n```\n\n1. The alias `my_alias` is used for validation.\n2. the attribute identifier `my_field` is used for validation.\n\nYou cannot set both `validate_by_alias` and `validate_by_name` to `False`.\nA [user error](../../errors/usage_errors/index.html#validate-by-alias-and-name-false) is raised in this case.\n\n#### Serialization[Â¶](index.html#serialization \"Permanent link\")\n\nWhen serializing data, you can enable serialization by alias, which is disabled by default.\nSee the [`ConfigDict.serialize_by_alias`](../../api/config/index.html#pydantic.config.ConfigDict.serialize_by_alias) API documentation\nfor more details.\n\n```\nfrom pydantic import BaseModel, ConfigDict, Field\n\n\nclass Model(BaseModel):\n    my_field: str = Field(serialization_alias='my_alias')\n\n    model_config = ConfigDict(serialize_by_alias=True)\n\n\nm = Model(my_field='foo')\nprint(m.model_dump())  # (1)!\n#> {'my_alias': 'foo'}\n```\n\n1. The alias `my_alias` is used for serialization.\n\nThe fact that serialization by alias is disabled by default is notably inconsistent with the default for\nvalidation (where aliases are used by default). We anticipate changing this default in V3.", "url": "https://docs.pydantic.dev/latest/concepts/alias/index.html#configdict-settingsindexhtmlconfigdict-settings-permanent-link", "page": "concepts/alias/index.html", "source_site": "pydantic"}
{"title": "Runtime Settings[Â¶](index.html#runtime-settings \"Permanent link\")", "anchor": "runtime-settingsindexhtmlruntime-settings-permanent-link", "md_text": "You can use runtime alias flags to control alias use for validation and serialization\non a per-call basis. If you would like to control this behavior on a model level, use\n[`ConfigDict` settings](index.html#configdict-settings).\n\n#### Validation[Â¶](index.html#validation_1 \"Permanent link\")\n\nWhen validating data, you can enable population of attributes by attribute name, alias, or both.\n\nThe `by_alias` and `by_name` flags are available on the [`model_validate()`](../../api/base_model/index.html#pydantic.BaseModel.model_validate),\n[`model_validate_json()`](../../api/base_model/index.html#pydantic.BaseModel.model_validate_json), and [`model_validate_strings()`](../../api/base_model/index.html#pydantic.BaseModel.model_validate_strings) methods, as well as the [`TypeAdapter`](../../api/type_adapter/index.html#pydantic.type_adapter.TypeAdapter) validation methods.\n\nBy default:\n\n* `by_alias` is `True`\n* `by_name` is `False`\n\n`by_alias``by_name``validate_by_alias` and `validate_by_name`\n\n```\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    my_field: str = Field(validation_alias='my_alias')\n\n\nm = Model.model_validate(\n    {'my_alias': 'foo'},  # (1)!\n    by_alias=True,\n    by_name=False,\n)\nprint(repr(m))\n#> Model(my_field='foo')\n```\n\n1. The alias `my_alias` is used for validation.\n\n```\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    my_field: str = Field(validation_alias='my_alias')\n\n\nm = Model.model_validate(\n    {'my_field': 'foo'}, by_alias=False, by_name=True  # (1)!\n)\nprint(repr(m))\n#> Model(my_field='foo')\n```\n\n1. The attribute name `my_field` is used for validation.\n\n```\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    my_field: str = Field(validation_alias='my_alias')\n\n\nm = Model.model_validate(\n    {'my_alias': 'foo'}, by_alias=True, by_name=True  # (1)!\n)\nprint(repr(m))\n#> Model(my_field='foo')\n\nm = Model.model_validate(\n    {'my_field': 'foo'}, by_alias=True, by_name=True  # (2)!\n)\nprint(repr(m))\n#> Model(my_field='foo')\n```\n\n1. The alias `my_alias` is used for validation.\n2. The attribute name `my_field` is used for validation.\n\nYou cannot set both `by_alias` and `by_name` to `False`.\nA [user error](../../errors/usage_errors/index.html#validate-by-alias-and-name-false) is raised in this case.\n\n#### Serialization[Â¶](index.html#serialization_1 \"Permanent link\")\n\nWhen serializing data, you can enable serialization by alias via the `by_alias` flag\nwhich is available on the [`model_dump()`](../../api/base_model/index.html#pydantic.BaseModel.model_dump) and\n[`model_dump_json()`](../../api/base_model/index.html#pydantic.BaseModel.model_dump_json) methods, as well as\nthe [`TypeAdapter`](../../api/type_adapter/index.html#pydantic.type_adapter.TypeAdapter) ones.\n\nBy default, `by_alias` is `False`.\n\n```\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    my_field: str = Field(serialization_alias='my_alias')\n\n\nm = Model(my_field='foo')\nprint(m.model_dump(by_alias=True))  # (1)!\n#> {'my_alias': 'foo'}\n```\n\n1. The alias `my_alias` is used for serialization.\n\nThe fact that serialization by alias is disabled by default is notably inconsistent with the default for\nvalidation (where aliases are used by default). We anticipate changing this default in V3.\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/concepts/alias/index.html#runtime-settingsindexhtmlruntime-settings-permanent-link", "page": "concepts/alias/index.html", "source_site": "pydantic"}
{"title": "Parameter types[Â¶](index.html#parameter-types \"Permanent link\")", "anchor": "parameter-typesindexhtmlparameter-types-permanent-link", "md_text": "Parameter types are inferred from type annotations on the function, or as [`Any`](https://docs.python.org/3/library/typing.html#typing.Any) if not annotated. All types listed in [types](../types/index.html) can be validated, including Pydantic models and [custom types](../types/index.html#custom-types).\nAs with the rest of Pydantic, types are by default coerced by the decorator before they're passed to the actual function:\n\n```\nfrom datetime import date\n\nfrom pydantic import validate_call\n\n\n@validate_call\ndef greater_than(d1: date, d2: date, *, include_equal=False) -> date:  # (1)!\n    if include_equal:\n        return d1 >= d2\n    else:\n        return d1 > d2\n\n\nd1 = '2000-01-01'  # (2)!\nd2 = date(2001, 1, 1)\ngreater_than(d1, d2, include_equal=True)\n```\n\n1. Because `include_equal` has no type annotation, it will be inferred as [`Any`](https://docs.python.org/3/library/typing.html#typing.Any).\n2. Although `d1` is a string, it will be converted to a [`date`](https://docs.python.org/3/library/datetime.html#datetime.date) object.\n\nType coercion like this can be extremely helpful, but also confusing or not desired (see [model data conversion](../models/index.html#data-conversion)). [Strict mode](../strict_mode/index.html)\ncan be enabled by using a [custom configuration](index.html#custom-configuration).\n\nBy default, the return value of the function is **not** validated. To do so, the `validate_return` argument\nof the decorator can be set to `True`.", "url": "https://docs.pydantic.dev/latest/concepts/validation_decorator/index.html#parameter-typesindexhtmlparameter-types-permanent-link", "page": "concepts/validation_decorator/index.html", "source_site": "pydantic"}
{"title": "Function signatures[Â¶](index.html#function-signatures \"Permanent link\")", "anchor": "function-signaturesindexhtmlfunction-signatures-permanent-link", "md_text": "The [`validate_call()`](../../api/validate_call/index.html#pydantic.validate_call_decorator.validate_call) decorator is designed to work with functions\nusing all possible [parameter configurations](https://docs.python.org/3/glossary.html#term-parameter) and all possible combinations of these:\n\n* Positional or keyword parameters with or without defaults.\n* Keyword-only parameters: parameters after `*,`.\n* Positional-only parameters: parameters before `, /`.\n* Variable positional parameters defined via `*` (often `*args`).\n* Variable keyword parameters defined via `**` (often `**kwargs`).\n\nExample\n\n```\nfrom pydantic import validate_call\n\n\n@validate_call\ndef pos_or_kw(a: int, b: int = 2) -> str:\n    return f'a={a} b={b}'\n\n\nprint(pos_or_kw(1, b=3))\n#> a=1 b=3\n\n\n@validate_call\ndef kw_only(*, a: int, b: int = 2) -> str:\n    return f'a={a} b={b}'\n\n\nprint(kw_only(a=1))\n#> a=1 b=2\nprint(kw_only(a=1, b=3))\n#> a=1 b=3\n\n\n@validate_call\ndef pos_only(a: int, b: int = 2, /) -> str:\n    return f'a={a} b={b}'\n\n\nprint(pos_only(1))\n#> a=1 b=2\n\n\n@validate_call\ndef var_args(*args: int) -> str:\n    return str(args)\n\n\nprint(var_args(1))\n#> (1,)\nprint(var_args(1, 2, 3))\n#> (1, 2, 3)\n\n\n@validate_call\ndef var_kwargs(**kwargs: int) -> str:\n    return str(kwargs)\n\n\nprint(var_kwargs(a=1))\n#> {'a': 1}\nprint(var_kwargs(a=1, b=2))\n#> {'a': 1, 'b': 2}\n\n\n@validate_call\ndef armageddon(\n    a: int,\n    /,\n    b: int,\n    *c: int,\n    d: int,\n    e: int = None,\n    **f: int,\n) -> str:\n    return f'a={a} b={b} c={c} d={d} e={e} f={f}'\n\n\nprint(armageddon(1, 2, d=3))\n#> a=1 b=2 c=() d=3 e=None f={}\nprint(armageddon(1, 2, 3, 4, 5, 6, d=8, e=9, f=10, spam=11))\n#> a=1 b=2 c=(3, 4, 5, 6) d=8 e=9 f={'f': 10, 'spam': 11}\n```\n\n[`Unpack`](https://docs.python.org/3/library/typing.html#typing.Unpack) and typed dictionaries can be used to annotate the variable\nkeyword parameters of a function:\n\n```\nfrom typing_extensions import TypedDict, Unpack\n\nfrom pydantic import validate_call\n\n\nclass Point(TypedDict):\n    x: int\n    y: int\n\n\n@validate_call\ndef add_coords(**kwargs: Unpack[Point]) -> int:\n    return kwargs['x'] + kwargs['y']\n\n\nadd_coords(x=1, y=2)\n```\n\nFor reference, see the [related specification section](https://typing.readthedocs.io/en/latest/spec/callables.html#unpack-for-keyword-arguments) and [PEP 692](https://peps.python.org/pep-0692/).", "url": "https://docs.pydantic.dev/latest/concepts/validation_decorator/index.html#function-signaturesindexhtmlfunction-signatures-permanent-link", "page": "concepts/validation_decorator/index.html", "source_site": "pydantic"}
{"title": "Using the [`Field()`](../../api/fields/index.html#pydantic.fields.Field) function to describe function parameters[Â¶](index.html#using-the-field-function-to-describe-function-parameters \"Permanent link\")", "anchor": "using-the-fieldapifieldsindexhtmlpydanticfieldsfield-function-to-describe-function-parametersindexhtmlusing-the-field-function-to-describe-function-parameters-permanent-link", "md_text": "The [`Field()` function](../fields/index.html) can also be used with the decorator to provide extra information about\nthe field and validations. If you don't make use of the `default` or `default_factory` parameter, it is\nrecommended to use the [annotated pattern](../fields/index.html#the-annotated-pattern) (so that type checkers\ninfer the parameter as being required). Otherwise, the [`Field()`](../../api/fields/index.html#pydantic.fields.Field) function can be used\nas a default value (again, to trick type checkers into thinking a default value is provided for the parameter).\n\n```\nfrom typing import Annotated\n\nfrom pydantic import Field, ValidationError, validate_call\n\n\n@validate_call\ndef how_many(num: Annotated[int, Field(gt=10)]):\n    return num\n\n\ntry:\n    how_many(1)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for how_many\n    0\n      Input should be greater than 10 [type=greater_than, input_value=1, input_type=int]\n    \"\"\"\n\n\n@validate_call\ndef return_value(value: str = Field(default='default value')):\n    return value\n\n\nprint(return_value())\n#> default value\n```\n\n[Aliases](../fields/index.html#field-aliases) can be used with the decorator as normal:\n\n```\nfrom typing import Annotated\n\nfrom pydantic import Field, validate_call\n\n\n@validate_call\ndef how_many(num: Annotated[int, Field(gt=10, alias='number')]):\n    return num\n\n\nhow_many(number=42)\n```", "url": "https://docs.pydantic.dev/latest/concepts/validation_decorator/index.html#using-the-fieldapifieldsindexhtmlpydanticfieldsfield-function-to-describe-function-parametersindexhtmlusing-the-field-function-to-describe-function-parameters-permanent-link", "page": "concepts/validation_decorator/index.html", "source_site": "pydantic"}
{"title": "Accessing the original function[Â¶](index.html#accessing-the-original-function \"Permanent link\")", "anchor": "accessing-the-original-functionindexhtmlaccessing-the-original-function-permanent-link", "md_text": "The original function which was decorated can still be accessed by using the `raw_function` attribute.\nThis is useful if in some scenarios you trust your input arguments and want to call the function in the most efficient way (see [notes on performance](index.html#performance) below):\n\n```\nfrom pydantic import validate_call\n\n\n@validate_call\ndef repeat(s: str, count: int, *, separator: bytes = b'') -> bytes:\n    b = s.encode()\n    return separator.join(b for _ in range(count))\n\n\na = repeat('hello', 3)\nprint(a)\n#> b'hellohellohello'\n\nb = repeat.raw_function('good bye', 2, separator=b', ')\nprint(b)\n#> b'good bye, good bye'\n```", "url": "https://docs.pydantic.dev/latest/concepts/validation_decorator/index.html#accessing-the-original-functionindexhtmlaccessing-the-original-function-permanent-link", "page": "concepts/validation_decorator/index.html", "source_site": "pydantic"}
{"title": "Async functions[Â¶](index.html#async-functions \"Permanent link\")", "anchor": "async-functionsindexhtmlasync-functions-permanent-link", "md_text": "[`validate_call()`](../../api/validate_call/index.html#pydantic.validate_call_decorator.validate_call) can also be used on async functions:\n\n```\nclass Connection:\n    async def execute(self, sql, *args):\n        return '[emailÂ protected]'\n\n\nconn = Connection()\n# ignore-above\nimport asyncio\n\nfrom pydantic import PositiveInt, ValidationError, validate_call\n\n\n@validate_call\nasync def get_user_email(user_id: PositiveInt):\n    # `conn` is some fictional connection to a database\n    email = await conn.execute('select email from users where id=$1', user_id)\n    if email is None:\n        raise RuntimeError('user not found')\n    else:\n        return email\n\n\nasync def main():\n    email = await get_user_email(123)\n    print(email)\n    #> [emailÂ protected]\n    try:\n        await get_user_email(-4)\n    except ValidationError as exc:\n        print(exc.errors())\n        \"\"\"\n        [\n            {\n                'type': 'greater_than',\n                'loc': (0,),\n                'msg': 'Input should be greater than 0',\n                'input': -4,\n                'ctx': {'gt': 0},\n                'url': 'https://errors.pydantic.dev/2/v/greater_than',\n            }\n        ]\n        \"\"\"\n\n\nasyncio.run(main())\n# requires: `conn.execute()` that will return `'[emailÂ protected]'`\n```", "url": "https://docs.pydantic.dev/latest/concepts/validation_decorator/index.html#async-functionsindexhtmlasync-functions-permanent-link", "page": "concepts/validation_decorator/index.html", "source_site": "pydantic"}
{"title": "Compatibility with type checkers[Â¶](index.html#compatibility-with-type-checkers \"Permanent link\")", "anchor": "compatibility-with-type-checkersindexhtmlcompatibility-with-type-checkers-permanent-link", "md_text": "As the [`validate_call()`](../../api/validate_call/index.html#pydantic.validate_call_decorator.validate_call) decorator preserves the decorated function's signature,\nit should be compatible with type checkers (such as mypy and pyright). However, due to current limitations in the Python type system,\nthe [`raw_function`](index.html#accessing-the-original-function) or other attributes won't be recognized and you will\nneed to suppress the error using (usually with a `# type: ignore` comment).", "url": "https://docs.pydantic.dev/latest/concepts/validation_decorator/index.html#compatibility-with-type-checkersindexhtmlcompatibility-with-type-checkers-permanent-link", "page": "concepts/validation_decorator/index.html", "source_site": "pydantic"}
{"title": "Custom configuration[Â¶](index.html#custom-configuration \"Permanent link\")", "anchor": "custom-configurationindexhtmlcustom-configuration-permanent-link", "md_text": "Similarly to Pydantic models, the `config` parameter of the decorator can be used to specify a custom configuration:\n\n```\nfrom pydantic import ConfigDict, ValidationError, validate_call\n\n\nclass Foobar:\n    def __init__(self, v: str):\n        self.v = v\n\n    def __add__(self, other: 'Foobar') -> str:\n        return f'{self} + {other}'\n\n    def __str__(self) -> str:\n        return f'Foobar({self.v})'\n\n\n@validate_call(config=ConfigDict(arbitrary_types_allowed=True))\ndef add_foobars(a: Foobar, b: Foobar):\n    return a + b\n\n\nc = add_foobars(Foobar('a'), Foobar('b'))\nprint(c)\n#> Foobar(a) + Foobar(b)\n\ntry:\n    add_foobars(1, 2)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for add_foobars\n    0\n      Input should be an instance of Foobar [type=is_instance_of, input_value=1, input_type=int]\n    1\n      Input should be an instance of Foobar [type=is_instance_of, input_value=2, input_type=int]\n    \"\"\"\n```", "url": "https://docs.pydantic.dev/latest/concepts/validation_decorator/index.html#custom-configurationindexhtmlcustom-configuration-permanent-link", "page": "concepts/validation_decorator/index.html", "source_site": "pydantic"}
{"title": "Extension â€” validating arguments before calling a function[Â¶](index.html#extension-validating-arguments-before-calling-a-function \"Permanent link\")", "anchor": "extension--validating-arguments-before-calling-a-functionindexhtmlextension-validating-arguments-before-calling-a-function-permanent-link", "md_text": "In some cases, it may be helpful to separate validation of a function's arguments from the function call itself.\nThis might be useful when a particular function is costly/time consuming.\n\nHere's an example of a workaround you can use for that pattern:\n\n```\nfrom pydantic import validate_call\n\n\n@validate_call\ndef validate_foo(a: int, b: int):\n    def foo():\n        return a + b\n\n    return foo\n\n\nfoo = validate_foo(a=1, b=2)\nprint(foo())\n#> 3\n```", "url": "https://docs.pydantic.dev/latest/concepts/validation_decorator/index.html#extension--validating-arguments-before-calling-a-functionindexhtmlextension-validating-arguments-before-calling-a-function-permanent-link", "page": "concepts/validation_decorator/index.html", "source_site": "pydantic"}
{"title": "Limitations[Â¶](index.html#limitations \"Permanent link\")", "anchor": "limitationsindexhtmllimitations-permanent-link", "md_text": "", "url": "https://docs.pydantic.dev/latest/concepts/validation_decorator/index.html#limitationsindexhtmllimitations-permanent-link", "page": "concepts/validation_decorator/index.html", "source_site": "pydantic"}
{"title": "Validation exception[Â¶](index.html#validation-exception \"Permanent link\")", "anchor": "validation-exceptionindexhtmlvalidation-exception-permanent-link", "md_text": "Currently upon validation failure, a standard Pydantic [`ValidationError`](../../api/pydantic_core/index.html#pydantic_core.ValidationError) is raised\n(see [model error handling](../models/index.html#error-handling) for details). This is also true for missing required arguments,\nwhere Python normally raises a [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError).", "url": "https://docs.pydantic.dev/latest/concepts/validation_decorator/index.html#validation-exceptionindexhtmlvalidation-exception-permanent-link", "page": "concepts/validation_decorator/index.html", "source_site": "pydantic"}
{"title": "Performance[Â¶](index.html#performance \"Permanent link\")", "anchor": "performanceindexhtmlperformance-permanent-link", "md_text": "We've made a big effort to make Pydantic as performant as possible. While the inspection of the decorated\nfunction is only performed once, there will still be a performance impact when making calls to the function\ncompared to using the original function.\n\nIn many situations, this will have little or no noticeable effect. However, be aware that\n[`validate_call()`](../../api/validate_call/index.html#pydantic.validate_call_decorator.validate_call) is not an equivalent or alternative to function\ndefinitions in strongly typed languages, and it never will be.\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/concepts/validation_decorator/index.html#performanceindexhtmlperformance-permanent-link", "page": "concepts/validation_decorator/index.html", "source_site": "pydantic"}
{"title": "Configure VS Code[Â¶](index.html#configure-vs-code \"Permanent link\")", "anchor": "configure-vs-codeindexhtmlconfigure-vs-code-permanent-link", "md_text": "To take advantage of these features, you need to make sure you configure VS Code correctly, using the recommended settings.\n\nIn case you have a different configuration, here's a short overview of the steps.", "url": "https://docs.pydantic.dev/latest/integrations/visual_studio_code/index.html#configure-vs-codeindexhtmlconfigure-vs-code-permanent-link", "page": "integrations/visual_studio_code/index.html", "source_site": "pydantic"}
{"title": "Install Pylance[Â¶](index.html#install-pylance \"Permanent link\")", "anchor": "install-pylanceindexhtmlinstall-pylance-permanent-link", "md_text": "You should use the [Pylance](https://marketplace.visualstudio.com/items?itemName=ms-python.vscode-pylance) extension for VS Code. It is the recommended, next-generation, official VS Code plug-in for Python.\n\nPylance is installed as part of the [Python Extension for VS Code](https://marketplace.visualstudio.com/items?itemName=ms-python.python) by default, so it should probably just work. Otherwise, you can double check it's installed and enabled in your editor.", "url": "https://docs.pydantic.dev/latest/integrations/visual_studio_code/index.html#install-pylanceindexhtmlinstall-pylance-permanent-link", "page": "integrations/visual_studio_code/index.html", "source_site": "pydantic"}
{"title": "Configure your environment[Â¶](index.html#configure-your-environment \"Permanent link\")", "anchor": "configure-your-environmentindexhtmlconfigure-your-environment-permanent-link", "md_text": "Then you need to make sure your editor knows the [Python environment](https://code.visualstudio.com/docs/python/python-tutorial#_install-and-use-packages) (probably a virtual environment) for your Python project.\n\nThis would be the environment in where you installed Pydantic.", "url": "https://docs.pydantic.dev/latest/integrations/visual_studio_code/index.html#configure-your-environmentindexhtmlconfigure-your-environment-permanent-link", "page": "integrations/visual_studio_code/index.html", "source_site": "pydantic"}
{"title": "Configure Pylance[Â¶](index.html#configure-pylance \"Permanent link\")", "anchor": "configure-pylanceindexhtmlconfigure-pylance-permanent-link", "md_text": "With the default configurations, you will get support for autocompletion, but Pylance might not check for type errors.\n\nYou can enable type error checks from Pylance with these steps:\n\n* Open the \"User Settings\"\n* Search for `Type Checking Mode`\n* You will find an option under `Python â€º Analysis: Type Checking Mode`\n* Set it to `basic` or `strict` (by default it's `off`)\n\n![Type Checking Mode set to strict in VS Code](../../img/vs_code_02.png)\n\nNow you will not only get autocompletion when creating new Pydantic model instances but also error checks for **required arguments**.\n\n![Required arguments error checks in VS Code](../../img/vs_code_03.png)\n\nAnd you will also get error checks for **invalid data types**.\n\n![Invalid data types error checks in VS Code](../../img/vs_code_04.png)\n\nPylance is the VS Code extension, it's closed source, but free to use. Underneath, Pylance uses an open source tool (also from Microsoft) called [Pyright](https://github.com/microsoft/pyright) that does all the heavy lifting.\n\nYou can read more about it in the [Pylance Frequently Asked Questions](https://github.com/microsoft/pylance-release/blob/main/FAQ.md#what-is-the-relationship-between-pylance-pyright-and-the-python-extension).", "url": "https://docs.pydantic.dev/latest/integrations/visual_studio_code/index.html#configure-pylanceindexhtmlconfigure-pylance-permanent-link", "page": "integrations/visual_studio_code/index.html", "source_site": "pydantic"}
{"title": "Configure mypy[Â¶](index.html#configure-mypy \"Permanent link\")", "anchor": "configure-mypyindexhtmlconfigure-mypy-permanent-link", "md_text": "You might also want to configure mypy in VS Code to get mypy error checks inline in your editor (alternatively/additionally to Pylance).\n\nThis would include the errors detected by the [Pydantic mypy plugin](../mypy/index.html), if you configured it.\n\nTo enable mypy in VS Code, do the following:\n\n* Open the \"User Settings\"\n* Search for `Mypy Enabled`\n* You will find an option under `Python â€º Linting: Mypy Enabled`\n* Check the box (by default it's unchecked)\n\n![mypy enabled in VS Code](../../img/vs_code_05.png)", "url": "https://docs.pydantic.dev/latest/integrations/visual_studio_code/index.html#configure-mypyindexhtmlconfigure-mypy-permanent-link", "page": "integrations/visual_studio_code/index.html", "source_site": "pydantic"}
{"title": "Tips and tricks[Â¶](index.html#tips-and-tricks \"Permanent link\")", "anchor": "tips-and-tricksindexhtmltips-and-tricks-permanent-link", "md_text": "Here are some additional tips and tricks to improve your developer experience when using VS Code with Pydantic.", "url": "https://docs.pydantic.dev/latest/integrations/visual_studio_code/index.html#tips-and-tricksindexhtmltips-and-tricks-permanent-link", "page": "integrations/visual_studio_code/index.html", "source_site": "pydantic"}
{"title": "Strict errors[Â¶](index.html#strict-errors \"Permanent link\")", "anchor": "strict-errorsindexhtmlstrict-errors-permanent-link", "md_text": "The way this additional editor support works is that Pylance will treat your Pydantic models as if they were Python's pure `dataclasses`.\n\nAnd it will show **strict type error checks** about the data types passed in arguments when creating a new Pydantic model instance.\n\nIn this example you can see that it shows that a `str` of `'23'` is not a valid `int` for the argument `age`.\n\n![VS Code strict type errors](../../img/vs_code_06.png)\n\nIt would expect `age=23` instead of `age='23'`.\n\nNevertheless, the design, and one of the main features of Pydantic, is that it is very **lenient with data types**.\n\nIt will actually accept the `str` with value `'23'` and will convert it to an `int` with value `23`.\n\nThese strict error checks are **very useful** most of the time and can help you **detect many bugs early**. But there are cases, like with `age='23'`, where they could be inconvenient by reporting a \"false positive\" error.\n\n---\n\nThis example above with `age='23'` is intentionally simple, to show the error and the differences in types.\n\nBut more common cases where these strict errors would be inconvenient would be when using more sophisticated data types, like `int` values for `datetime` fields, or `dict` values for Pydantic sub-models.\n\nFor example, this is valid for Pydantic:\n\n```\nfrom pydantic import BaseModel\n\n\nclass Knight(BaseModel):\n    title: str\n    age: int\n    color: str = 'blue'\n\n\nclass Quest(BaseModel):\n    title: str\n    knight: Knight\n\n\nquest = Quest(\n    title='To seek the Holy Grail', knight={'title': 'Sir Lancelot', 'age': 23}\n)\n```\n\nThe type of the field `knight` is declared with the class `Knight` (a Pydantic model) and the code is passing a literal `dict` instead. This is still valid for Pydantic, and the `dict` would be automatically converted to a `Knight` instance.\n\nNevertheless, it would be detected as a type error:\n\n![VS Code strict type errors with model](../../img/vs_code_07.png)\n\nIn those cases, there are several ways to disable or ignore strict errors in very specific places, while still preserving them in the rest of the code.\n\nBelow are several techniques to achieve it.\n\n#### Disable type checks in a line[Â¶](index.html#disable-type-checks-in-a-line \"Permanent link\")\n\nYou can disable the errors for a specific line using a comment of:\n\n```\n# type: ignore\n```\n\nor (to be specific to pylance/pyright):\n\n```\n# pyright: ignore\n```\n\n([pyright](https://github.com/microsoft/pyright) is the language server used by Pylance.).\n\ncoming back to the example with `age='23'`, it would be:\n\n```\nfrom pydantic import BaseModel\n\n\nclass Knight(BaseModel):\n    title: str\n    age: int\n    color: str = 'blue'\n\n\nlancelot = Knight(title='Sir Lancelot', age='23')  # pyright: ignore\n```\n\nthat way Pylance and mypy will ignore errors in that line.\n\n**Pros**: it's a simple change in that line to remove errors there.\n\n**Cons**: any other error in that line will also be omitted, including type checks, misspelled arguments, required arguments not provided, etc.\n\n#### Override the type of a variable[Â¶](index.html#override-the-type-of-a-variable \"Permanent link\")\n\nYou can also create a variable with the value you want to use and declare its type explicitly with `Any`.\n\n```\nfrom typing import Any\n\nfrom pydantic import BaseModel\n\n\nclass Knight(BaseModel):\n    title: str\n    age: int\n    color: str = 'blue'\n\n\nage_str: Any = '23'\nlancelot = Knight(title='Sir Lancelot', age=age_str)\n```\n\nthat way Pylance and mypy will interpret the variable `age_str` as if they didn't know its type, instead of knowing it has a type of `str` when an `int` was expected (and then showing the corresponding error).\n\n**Pros**: errors will be ignored only for a specific value, and you will still see any additional errors for the other arguments.\n\n**Cons**: it requires importing `Any` and a new variable in a new line for each argument that needs ignoring errors.\n\n#### Override the type of a value with `cast`[Â¶](index.html#override-the-type-of-a-value-with-cast \"Permanent link\")\n\nThe same idea from the previous example can be put on the same line with the help of `cast()`.\n\nThis way, the type declaration of the value is overridden inline, without requiring another variable.\n\n```\nfrom typing import Any, cast\n\nfrom pydantic import BaseModel\n\n\nclass Knight(BaseModel):\n    title: str\n    age: int\n    color: str = 'blue'\n\n\nlancelot = Knight(title='Sir Lancelot', age=cast(Any, '23'))\n```\n\n`cast(Any, '23')` doesn't affect the value, it's still just `'23'`, but now Pylance and mypy will assume it is of type `Any`, which means, they will act as if they didn't know the type of the value.\n\nSo, this is the equivalent of the previous example, without the additional variable.\n\n**Pros**: errors will be ignored only for a specific value, and you will still see any additional errors for the other arguments. There's no need for additional variables.", "url": "https://docs.pydantic.dev/latest/integrations/visual_studio_code/index.html#strict-errorsindexhtmlstrict-errors-permanent-link", "page": "integrations/visual_studio_code/index.html", "source_site": "pydantic"}
{"title": "Strict errors[Â¶](index.html#strict-errors \"Permanent link\")", "anchor": "strict-errorsindexhtmlstrict-errors-permanent-link", "md_text": "**Cons**: it requires importing `Any` and `cast`, and if you are not used to using `cast()`, it could seem strange at first.", "url": "https://docs.pydantic.dev/latest/integrations/visual_studio_code/index.html#strict-errorsindexhtmlstrict-errors-permanent-link", "page": "integrations/visual_studio_code/index.html", "source_site": "pydantic"}
{"title": "Config in class arguments[Â¶](index.html#config-in-class-arguments \"Permanent link\")", "anchor": "config-in-class-argumentsindexhtmlconfig-in-class-arguments-permanent-link", "md_text": "Pydantic has a rich set of [Model Configurations](../../api/config/index.html#pydantic.config.ConfigDict) available.\n\nThese configurations can be set in an internal `class Config` on each model:\n\n```\nfrom pydantic import BaseModel\n\n\nclass Knight(BaseModel):\n    model_config = dict(frozen=True)\n    title: str\n    age: int\n    color: str = 'blue'\n```\n\nor passed as keyword arguments when defining the model class:\n\n```\nfrom pydantic import BaseModel\n\n\nclass Knight(BaseModel, frozen=True):\n    title: str\n    age: int\n    color: str = 'blue'\n```\n\nThe specific configuration **`frozen`** (in beta) has a special meaning.\n\nIt prevents other code from changing a model instance once it's created, keeping it **\"frozen\"**.\n\nWhen using the second version to declare `frozen=True` (with **keyword arguments** in the class definition),\nPylance can use it to help you check in your code and **detect errors** when something is trying to set values\nin a model that is \"frozen\".\n\n![VS Code strict type errors with model](../../img/vs_code_08.png)", "url": "https://docs.pydantic.dev/latest/integrations/visual_studio_code/index.html#config-in-class-argumentsindexhtmlconfig-in-class-arguments-permanent-link", "page": "integrations/visual_studio_code/index.html", "source_site": "pydantic"}
{"title": "Adding a default with `Field`[Â¶](index.html#adding-a-default-with-field \"Permanent link\")", "anchor": "adding-a-default-with-fieldindexhtmladding-a-default-with-field-permanent-link", "md_text": "Pylance/pyright requires `default` to be a keyword argument to `Field` in order to infer that the field is optional.\n\n```\nfrom pydantic import BaseModel, Field\n\n\nclass Knight(BaseModel):\n    title: str = Field(default='Sir Lancelot')  # this is okay\n    age: int = Field(\n        23\n    )  # this works fine at runtime but will case an error for pyright\n\n\nlance = Knight()  # error: Argument missing for parameter \"age\"\n```\n\nThis is a limitation of dataclass transforms and cannot be fixed in pydantic.", "url": "https://docs.pydantic.dev/latest/integrations/visual_studio_code/index.html#adding-a-default-with-fieldindexhtmladding-a-default-with-field-permanent-link", "page": "integrations/visual_studio_code/index.html", "source_site": "pydantic"}
{"title": "Technical Details[Â¶](index.html#technical-details \"Permanent link\")", "anchor": "technical-detailsindexhtmltechnical-details-permanent-link", "md_text": "As a Pydantic user, you don't need the details below. Feel free to skip the rest of this section.\n\nThese details are only useful for other library authors, etc.\n\nThis additional editor support works by making use of the [`@dataclass_transform` decorator](https://typing.python.org/en/latest/spec/dataclasses.html#the-dataclass-transform-decorator)\n(introduced by [PEP 681](https://peps.python.org/pep-0681/)).\n\nThe standard provides a way for libraries like Pydantic and others to tell editors and tools that they (the editors) should treat these libraries (e.g. Pydantic) as if they were [dataclasses](https://docs.python.org/3/library/dataclasses.html#module-dataclasses), providing autocompletion, type checks, etc.\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/integrations/visual_studio_code/index.html#technical-detailsindexhtmltechnical-details-permanent-link", "page": "integrations/visual_studio_code/index.html", "source_site": "pydantic"}
{"title": "Enabling the Plugin[Â¶](index.html#enabling-the-plugin \"Permanent link\")", "anchor": "enabling-the-pluginindexhtmlenabling-the-plugin-permanent-link", "md_text": "To enable the plugin, just add `pydantic.mypy` to the list of plugins in your\n[mypy config file](https://mypy.readthedocs.io/en/latest/config_file.html):\n\n`mypy.ini``pyproject.toml`\n\n```\n[mypy]\nplugins = pydantic.mypy\n\n[tool.mypy]\nplugins = ['pydantic.mypy']\n```\n\nIf you're using `pydantic.v1` models, you'll need to add `pydantic.v1.mypy` to your list of plugins.\n\nSee the [plugin configuration](index.html#configuring-the-plugin) for more details.", "url": "https://docs.pydantic.dev/latest/integrations/mypy/index.html#enabling-the-pluginindexhtmlenabling-the-plugin-permanent-link", "page": "integrations/mypy/index.html", "source_site": "pydantic"}
{"title": "Mypy plugin capabilities[Â¶](index.html#mypy-plugin-capabilities \"Permanent link\")", "anchor": "mypy-plugin-capabilitiesindexhtmlmypy-plugin-capabilities-permanent-link", "md_text": "", "url": "https://docs.pydantic.dev/latest/integrations/mypy/index.html#mypy-plugin-capabilitiesindexhtmlmypy-plugin-capabilities-permanent-link", "page": "integrations/mypy/index.html", "source_site": "pydantic"}
{"title": "Generate a `__init__` signature for Pydantic models[Â¶](index.html#generate-a-__init__-signature-for-pydantic-models \"Permanent link\")", "anchor": "generate-a-init-signature-for-pydantic-modelsindexhtmlgenerate-a-init-signature-for-pydantic-models-permanent-link", "md_text": "* Any required fields that don't have dynamically-determined aliases will be included as required\n  keyword arguments.\n* If the [`validate_by_name`](../../api/config/index.html#pydantic.config.ConfigDict.validate_by_name) model configuration value is set to\n  `True`, the generated signature will use the field names rather than aliases.\n* The [`init_forbid_extra`](index.html#init_forbid_extra) and [`init_typed`](index.html#init_typed) plugin configuration\n  values can further fine-tune the synthesized `__init__` method.", "url": "https://docs.pydantic.dev/latest/integrations/mypy/index.html#generate-a-init-signature-for-pydantic-modelsindexhtmlgenerate-a-init-signature-for-pydantic-models-permanent-link", "page": "integrations/mypy/index.html", "source_site": "pydantic"}
{"title": "Generate a typed signature for `model_construct`[Â¶](index.html#generate-a-typed-signature-for-model_construct \"Permanent link\")", "anchor": "generate-a-typed-signature-for-modelconstructindexhtmlgenerate-a-typed-signature-for-modelconstruct-permanent-link", "md_text": "* The [`model_construct`](../../api/base_model/index.html#pydantic.BaseModel.model_construct) method is an alternative to model validation when input data is\n  known to be valid and should not be parsed (see the [documentation](../../concepts/models/index.html#creating-models-without-validation)).\n  Because this method performs no runtime validation, static checking is important to detect errors.", "url": "https://docs.pydantic.dev/latest/integrations/mypy/index.html#generate-a-typed-signature-for-modelconstructindexhtmlgenerate-a-typed-signature-for-modelconstruct-permanent-link", "page": "integrations/mypy/index.html", "source_site": "pydantic"}
{"title": "Support for frozen models[Â¶](index.html#support-for-frozen-models \"Permanent link\")", "anchor": "support-for-frozen-modelsindexhtmlsupport-for-frozen-models-permanent-link", "md_text": "* If the [`frozen`](../../api/config/index.html#pydantic.config.ConfigDict.frozen) configuration is set to `True`, you will get\n  an error if you try mutating a model field (see [faux immutability](../../concepts/models/index.html#faux-immutability))", "url": "https://docs.pydantic.dev/latest/integrations/mypy/index.html#support-for-frozen-modelsindexhtmlsupport-for-frozen-models-permanent-link", "page": "integrations/mypy/index.html", "source_site": "pydantic"}
{"title": "Respect the type of the `Field`'s `default` and `default_factory`[Â¶](index.html#respect-the-type-of-the-fields-default-and-default_factory \"Permanent link\")", "anchor": "respect-the-type-of-the-fields-default-and-defaultfactoryindexhtmlrespect-the-type-of-the-fields-default-and-defaultfactory-permanent-link", "md_text": "* Field with both a `default` and a `default_factory` will result in an error during static checking.\n* The type of the `default` and `default_factory` value must be compatible with the one of the field.", "url": "https://docs.pydantic.dev/latest/integrations/mypy/index.html#respect-the-type-of-the-fields-default-and-defaultfactoryindexhtmlrespect-the-type-of-the-fields-default-and-defaultfactory-permanent-link", "page": "integrations/mypy/index.html", "source_site": "pydantic"}
{"title": "Warn about the use of untyped fields[Â¶](index.html#warn-about-the-use-of-untyped-fields \"Permanent link\")", "anchor": "warn-about-the-use-of-untyped-fieldsindexhtmlwarn-about-the-use-of-untyped-fields-permanent-link", "md_text": "* While defining a field without an annotation will result in a [runtime error](../../errors/usage_errors/index.html#model-field-missing-annotation),\n  the plugin will also emit a type checking error.", "url": "https://docs.pydantic.dev/latest/integrations/mypy/index.html#warn-about-the-use-of-untyped-fieldsindexhtmlwarn-about-the-use-of-untyped-fields-permanent-link", "page": "integrations/mypy/index.html", "source_site": "pydantic"}
{"title": "Prevent the use of required dynamic aliases[Â¶](index.html#prevent-the-use-of-required-dynamic-aliases \"Permanent link\")", "anchor": "prevent-the-use-of-required-dynamic-aliasesindexhtmlprevent-the-use-of-required-dynamic-aliases-permanent-link", "md_text": "See the documentation of the [`warn_required_dynamic_aliases`](index.html#warn_required_dynamic_aliases) plugin configuration value.", "url": "https://docs.pydantic.dev/latest/integrations/mypy/index.html#prevent-the-use-of-required-dynamic-aliasesindexhtmlprevent-the-use-of-required-dynamic-aliases-permanent-link", "page": "integrations/mypy/index.html", "source_site": "pydantic"}
{"title": "Configuring the Plugin[Â¶](index.html#configuring-the-plugin \"Permanent link\")", "anchor": "configuring-the-pluginindexhtmlconfiguring-the-plugin-permanent-link", "md_text": "To change the values of the plugin settings, create a section in your mypy config file called `[pydantic-mypy]`,\nand add any key-value pairs for settings you want to override.\n\nA configuration file with all plugin strictness flags enabled (and some other mypy strictness flags, too) might look like:\n\n`mypy.ini``pyproject.toml`\n\n```\n[mypy]\nplugins = pydantic.mypy\n\nfollow_imports = silent\nwarn_redundant_casts = True\nwarn_unused_ignores = True\ndisallow_any_generics = True\nno_implicit_reexport = True\ndisallow_untyped_defs = True\n\n[pydantic-mypy]\ninit_forbid_extra = True\ninit_typed = True\nwarn_required_dynamic_aliases = True\n\n[tool.mypy]\nplugins = [\"pydantic.mypy\"]\n\nfollow_imports = \"silent\"\nwarn_redundant_casts = true\nwarn_unused_ignores = true\ndisallow_any_generics = true\nno_implicit_reexport = true\ndisallow_untyped_defs = true\n\n[tool.pydantic-mypy]\ninit_forbid_extra = true\ninit_typed = true\nwarn_required_dynamic_aliases = true\n```", "url": "https://docs.pydantic.dev/latest/integrations/mypy/index.html#configuring-the-pluginindexhtmlconfiguring-the-plugin-permanent-link", "page": "integrations/mypy/index.html", "source_site": "pydantic"}
{"title": "`init_typed`[Â¶](index.html#init_typed \"Permanent link\")", "anchor": "inittypedindexhtmlinittyped-permanent-link", "md_text": "Because Pydantic performs [data conversion](../../concepts/models/index.html#data-conversion) by default, the following is still valid at runtime:\n\n```\nclass Model(BaseModel):\n    a: int\n\n\nModel(a='1')\n```\n\nFor this reason, the plugin will use [`Any`](https://docs.python.org/3/library/typing.html#typing.Any) for field annotations when synthesizing the `__init__` method,\nunless `init_typed` is set or [strict mode](../../concepts/strict_mode/index.html) is enabled on the model.", "url": "https://docs.pydantic.dev/latest/integrations/mypy/index.html#inittypedindexhtmlinittyped-permanent-link", "page": "integrations/mypy/index.html", "source_site": "pydantic"}
{"title": "`init_forbid_extra`[Â¶](index.html#init_forbid_extra \"Permanent link\")", "anchor": "initforbidextraindexhtmlinitforbidextra-permanent-link", "md_text": "By default, Pydantic allows (and ignores) any extra provided argument:\n\n```\nclass Model(BaseModel):\n    a: int = 1\n\n\nModel(unrelated=2)\n```\n\nFor this reason, the plugin will add an extra `**kwargs: Any` parameter when synthesizing the `__init__` method, unless\n`init_forbid_extra` is set or the [`extra`](../../api/config/index.html#pydantic.config.ConfigDict.extra) is set to `'forbid'`.", "url": "https://docs.pydantic.dev/latest/integrations/mypy/index.html#initforbidextraindexhtmlinitforbidextra-permanent-link", "page": "integrations/mypy/index.html", "source_site": "pydantic"}
{"title": "`warn_required_dynamic_aliases`[Â¶](index.html#warn_required_dynamic_aliases \"Permanent link\")", "anchor": "warnrequireddynamicaliasesindexhtmlwarnrequireddynamicaliases-permanent-link", "md_text": "Whether to error when using a dynamically-determined alias or alias generator on a model with\n[`validate_by_name`](../../api/config/index.html#pydantic.config.ConfigDict.validate_by_name) set to `False`. If such aliases are\npresent, mypy cannot properly type check calls to `__init__`. In this case, it will default to\ntreating all arguments as not required.\n\nSome mypy configuration options (such as [`disallow_any_explicit`](https://mypy.readthedocs.io/en/stable/config_file.html#confval-disallow_any_explicit))\nwill error because the synthesized `__init__` method contains [`Any`](https://docs.python.org/3/library/typing.html#typing.Any) annotations. To circumvent the issue, you will have\nto enable both `init_forbid_extra` and `init_typed`.\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/integrations/mypy/index.html#warnrequireddynamicaliasesindexhtmlwarnrequireddynamicaliases-permanent-link", "page": "integrations/mypy/index.html", "source_site": "pydantic"}
{"title": "Flake8 plugin[Â¶](index.html#flake8-plugin \"Permanent link\")", "anchor": "flake8-pluginindexhtmlflake8-plugin-permanent-link", "md_text": "If using Flake8 in your project, a [plugin](https://pypi.org/project/flake8-pydantic/) is available\nand can be installed using the following:\n\n```\npip install flake8-pydantic\n```\n\nThe lint errors provided by this plugin are namespaced under the `PYDXXX` code. To ignore some unwanted\nrules, the Flake8 configuration can be adapted:\n\n```\n[flake8]\nextend-ignore = PYD001,PYD002\n```\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/integrations/linting/index.html#flake8-pluginindexhtmlflake8-plugin-permanent-link", "page": "integrations/linting/index.html", "source_site": "pydantic"}
{"title": "Getting Started[Â¶](index.html#getting-started \"Permanent link\")", "anchor": "getting-startedindexhtmlgetting-started-permanent-link", "md_text": "Logfire has an out-of-the-box Pydantic integration that lets you understand the data passing through your Pydantic models and get analytics on validations. For existing Pydantic users, it delivers unparalleled insights into your usage of Pydantic models.\n\n[Getting started](https://logfire.pydantic.dev/docs/) with Logfire can be done in three simple steps:\n\n1. Set up your Logfire account.\n2. Install the Logfire SDK.\n3. Instrument your project.", "url": "https://docs.pydantic.dev/latest/integrations/logfire/index.html#getting-startedindexhtmlgetting-started-permanent-link", "page": "integrations/logfire/index.html", "source_site": "pydantic"}
{"title": "Basic Usage[Â¶](index.html#basic-usage \"Permanent link\")", "anchor": "basic-usageindexhtmlbasic-usage-permanent-link", "md_text": "Once you've got Logfire set up, you can start using it to monitor your Pydantic models and get insights into your data validation:\n\n```\nfrom datetime import date\n\nimport logfire\n\nfrom pydantic import BaseModel\n\nlogfire.configure()  # (1)!\n\n\nclass User(BaseModel):\n    name: str\n    country_code: str\n    dob: date\n\n\nuser = User(name='Anne', country_code='USA', dob='2000-01-01')\nlogfire.info('user processed: {user!r}', user=user)  # (2)!\n```\n\n1. The `logfire.configure()` call is all you need to instrument your project with Logfire.\n2. The `logfire.info()` call logs the `user` object to Logfire, with builtin support for Pydantic models.\n\n![basic pydantic logfire usage](../../img/basic_logfire.png)", "url": "https://docs.pydantic.dev/latest/integrations/logfire/index.html#basic-usageindexhtmlbasic-usage-permanent-link", "page": "integrations/logfire/index.html", "source_site": "pydantic"}
{"title": "Pydantic Instrumentation[Â¶](index.html#pydantic-instrumentation \"Permanent link\")", "anchor": "pydantic-instrumentationindexhtmlpydantic-instrumentation-permanent-link", "md_text": "You can even record information about the validation process automatically by\nusing the builtin [Pydantic integration](https://logfire.pydantic.dev/docs/why-logfire/pydantic/):\n\n```\nfrom datetime import date\n\nimport logfire\n\nfrom pydantic import BaseModel\n\nlogfire.configure()\nlogfire.instrument_pydantic()  # (1)!\n\n\nclass User(BaseModel):\n    name: str\n    country_code: str\n    dob: date\n\n\nUser(name='Anne', country_code='USA', dob='2000-01-01')\nUser(name='David', country_code='GBR', dob='invalid-dob')\n```\n\n1. The `logfire.instrument_pydantic()` call automatically logs validation information for all Pydantic models in your project.\n\nYou'll see each successful and failed validation logged in Logfire:\n\n![logfire instrumentation](../../img/logfire_instrument.png)\n\nAnd you can investigate each of the corresponding spans to get validation details:\n\n![logfire span details](../../img/logfire_span.png)\n\n\n\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/integrations/logfire/index.html#pydantic-instrumentationindexhtmlpydantic-instrumentation-permanent-link", "page": "integrations/logfire/index.html", "source_site": "pydantic"}
{"title": "Installing Python libraries for AWS Lambda functions[Â¶](index.html#installing-python-libraries-for-aws-lambda-functions \"Permanent link\")", "anchor": "installing-python-libraries-for-aws-lambda-functionsindexhtmlinstalling-python-libraries-for-aws-lambda-functions-permanent-link", "md_text": "There are many ways to utilize Python libraries in AWS Lambda functions. As outlined in the [AWS Lambda documentation](https://docs.aws.amazon.com/lambda/latest/dg/lambda-python.html), the most common approaches include:\n\n* Using a [`.zip` file archive](https://docs.aws.amazon.com/lambda/latest/dg/python-package.html) to package your code and dependencies\n* Using [AWS Lambda Layers](https://docs.aws.amazon.com/lambda/latest/dg/python-layers.html) to share libraries across multiple functions\n* Using a [container image](https://docs.aws.amazon.com/lambda/latest/dg/python-image.html) to package your code and dependencies\n\nAll of these approaches can be used with `pydantic`. The best approach for you will depend on your specific requirements and constraints. We'll cover the first two cases more in-depth here, as dependency management with\na container image is more straightforward. If you're using a container image, you might find [this comment](https://github.com/pydantic/pydantic/issues/6557#issuecomment-1699456562) helpful for installing `pydantic`.\n\nIf you use `pydantic` across multiple functions, you may want to consider AWS Lambda Layers, which support seamless sharing of libraries across multiple functions.\n\nRegardless of the dependencies management approach you choose, it's beneficial to adhere to these guidelines to ensure a smooth\ndependency management process.", "url": "https://docs.pydantic.dev/latest/integrations/aws_lambda/index.html#installing-python-libraries-for-aws-lambda-functionsindexhtmlinstalling-python-libraries-for-aws-lambda-functions-permanent-link", "page": "integrations/aws_lambda/index.html", "source_site": "pydantic"}
{"title": "Installing `pydantic` for AWS Lambda functions[Â¶](index.html#installing-pydantic-for-aws-lambda-functions \"Permanent link\")", "anchor": "installing-pydantic-for-aws-lambda-functionsindexhtmlinstalling-pydantic-for-aws-lambda-functions-permanent-link", "md_text": "When you're building your `.zip` file archive with your code and dependencies or organizing your `.zip` file for a Lambda Layer, you'll likely use a local virtual environment to install and manage your dependencies. This can be a bit tricky if you're using `pip` because `pip` installs wheels compiled for your local platform, which may not be compatible with the Lambda environment.\n\nThus, we suggest you use a command similar to the following:\n\n```\npip install \\\n    --platform manylinux2014_x86_64 \\  # (1)!\n    --target=<your_package_dir> \\  # (2)!\n    --implementation cp \\  # (3)!\n    --python-version 3.10 \\  # (4)!\n    --only-binary=:all: \\  # (5)!\n    --upgrade pydantic  # (6)!\n```\n\n1. Use the platform corresponding to your Lambda runtime.\n2. Specify the directory where you want to install the package (often `python` for Lambda Layers).\n3. Use the CPython implementation.\n4. The Python version must be compatible with the Lambda runtime.\n5. This flag ensures that the package is installed pre-built binary wheels.\n6. The latest version of `pydantic` will be installed.", "url": "https://docs.pydantic.dev/latest/integrations/aws_lambda/index.html#installing-pydantic-for-aws-lambda-functionsindexhtmlinstalling-pydantic-for-aws-lambda-functions-permanent-link", "page": "integrations/aws_lambda/index.html", "source_site": "pydantic"}
{"title": "Troubleshooting[Â¶](index.html#troubleshooting \"Permanent link\")", "anchor": "troubleshootingindexhtmltroubleshooting-permanent-link", "md_text": "", "url": "https://docs.pydantic.dev/latest/integrations/aws_lambda/index.html#troubleshootingindexhtmltroubleshooting-permanent-link", "page": "integrations/aws_lambda/index.html", "source_site": "pydantic"}
{"title": "Missing `pydantic_core` module[Â¶](index.html#missing-pydantic_core-module \"Permanent link\")", "anchor": "missing-pydanticcore-moduleindexhtmlmissing-pydanticcore-module-permanent-link", "md_text": "The\n\n```\nno module named `pydantic_core._pydantic_core`\n```\n\nerror is a common issue that indicates you have installed `pydantic` incorrectly. To debug this issue, you can try the following steps (before the failing import):\n\n1. Check the contents of the installed `pydantic-core` package. Are the compiled library and its type stubs both present?\n\n   ```\n   from importlib.metadata import files\n   print([file for file in files('pydantic-core') if file.name.startswith('_pydantic_core')])\n   \"\"\"\n   [PackagePath('pydantic_core/_pydantic_core.pyi'), PackagePath('pydantic_core/_pydantic_core.cpython-312-x86_64-linux-gnu.so')]\n   \"\"\"\n   ```\n\n   You should expect to see two files like those printed above. The compiled library file should have the `.so` or `.pyd` extension with a name that varies according to the OS and Python version.\n2. Check that your lambda's Python version is compatible with the compiled library version found above.\n\n   ```\n   import sysconfig\n   print(sysconfig.get_config_var(\"EXT_SUFFIX\"))\n   #> '.cpython-312-x86_64-linux-gnu.so'\n   ```\n\nYou should expect to see the same suffix here as the compiled library, for example here we see this suffix `.cpython-312-x86_64-linux-gnu.so` indeed matches `_pydantic_core.cpython-312-x86_64-linux-gnu.so`.\n\nIf these two checks do not match, your build steps have not installed the correct native code for your lambda's target platform. You should adjust your build steps to change the version of the installed library which gets installed.\n\nMost likely errors:\n\n* Your OS or CPU architecture is mismatched (e.g. darwin vs x86\\_64-linux-gnu). Try passing correct `--platform` argument to `pip install` when installing your lambda dependencies, or build inside a linux docker container for the correct platform. Possible platforms at the moment include `--platform manylinux2014_x86_64` or `--platform manylinux2014_aarch64`, but these may change with a future Pydantic major release.\n* Your Python version is mismatched (e.g. `cpython-310` vs `cpython-312`). Try passing correct `--python-version` argument to `pip install`, or otherwise change the Python version used on your build.", "url": "https://docs.pydantic.dev/latest/integrations/aws_lambda/index.html#missing-pydanticcore-moduleindexhtmlmissing-pydanticcore-module-permanent-link", "page": "integrations/aws_lambda/index.html", "source_site": "pydantic"}
{"title": "No package metadata was found for `email-validator`[Â¶](index.html#no-package-metadata-was-found-for-email-validator \"Permanent link\")", "anchor": "no-package-metadata-was-found-for-email-validatorindexhtmlno-package-metadata-was-found-for-email-validator-permanent-link", "md_text": "Pydantic uses `version` from `importlib.metadata` to [check what version](https://github.com/pydantic/pydantic/pull/6033) of `email-validator` is installed.\nThis package versioning mechanism is somewhat incompatible with AWS Lambda, even though it's the industry standard for versioning packages in Python. There\nare a few ways to fix this issue:\n\nIf you're deploying your lambda with the serverless framework, it's likely that the appropriate metadata for the `email-validator` package is not being included in your deployment package. Tools like [`serverless-python-requirements`](https://github.com/serverless/serverless-python-requirements/tree/master)\nremove metadata to reduce package size. You can fix this issue by setting the `slim` setting to false in your `serverless.yml` file:\n\n```\npythonRequirements:\n    dockerizePip: non-linux\n    slim: false\n    fileName: requirements.txt\n```\n\nYou can read more about this fix, and other `slim` settings that might be relevant in this [blog post](https://biercoff.com/how-to-fix-package-not-found-error-importlib-metadata/).\n\nIf you're using a `.zip` archive for your code and/or dependencies, make sure that your package contains the required version metadata. To do this, make sure you include the `dist-info` directory in your `.zip` archive for the `email-validator` package.\n\nThis issue has been reported for other popular python libraries like [`jsonschema`](https://github.com/python-jsonschema/jsonschema/issues/584), so you can\nread more about the issue and potential fixes there as well.", "url": "https://docs.pydantic.dev/latest/integrations/aws_lambda/index.html#no-package-metadata-was-found-for-email-validatorindexhtmlno-package-metadata-was-found-for-email-validator-permanent-link", "page": "integrations/aws_lambda/index.html", "source_site": "pydantic"}
{"title": "Extra Resources[Â¶](index.html#extra-resources \"Permanent link\")", "anchor": "extra-resourcesindexhtmlextra-resources-permanent-link", "md_text": "", "url": "https://docs.pydantic.dev/latest/integrations/aws_lambda/index.html#extra-resourcesindexhtmlextra-resources-permanent-link", "page": "integrations/aws_lambda/index.html", "source_site": "pydantic"}
{"title": "More Debugging Tips[Â¶](index.html#more-debugging-tips \"Permanent link\")", "anchor": "more-debugging-tipsindexhtmlmore-debugging-tips-permanent-link", "md_text": "If you're still struggling with installing `pydantic` for your AWS Lambda, you might consult with [this issue](https://github.com/pydantic/pydantic/issues/6557), which covers a variety of problems and solutions encountered by other developers.", "url": "https://docs.pydantic.dev/latest/integrations/aws_lambda/index.html#more-debugging-tipsindexhtmlmore-debugging-tips-permanent-link", "page": "integrations/aws_lambda/index.html", "source_site": "pydantic"}
{"title": "Validating `event` and `context` data[Â¶](index.html#validating-event-and-context-data \"Permanent link\")", "anchor": "validating-event-and-context-dataindexhtmlvalidating-event-and-context-data-permanent-link", "md_text": "Check out our [blog post](https://pydantic.dev/articles/lambda-intro) to learn more about how to use `pydantic` to validate `event` and `context` data in AWS Lambda functions.\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/integrations/aws_lambda/index.html#validating-event-and-context-dataindexhtmlvalidating-event-and-context-data-permanent-link", "page": "integrations/aws_lambda/index.html", "source_site": "pydantic"}
{"title": "Installation[Â¶](index.html#installation \"Permanent link\")", "anchor": "installationindexhtmlinstallation-permanent-link", "md_text": "```\npip install datamodel-code-generator\n```", "url": "https://docs.pydantic.dev/latest/integrations/datamodel_code_generator/index.html#installationindexhtmlinstallation-permanent-link", "page": "integrations/datamodel_code_generator/index.html", "source_site": "pydantic"}
{"title": "Example[Â¶](index.html#example \"Permanent link\")", "anchor": "exampleindexhtmlexample-permanent-link", "md_text": "In this case, datamodel-code-generator creates pydantic models from a JSON Schema file.\n\n```\ndatamodel-codegen  --input person.json --input-file-type jsonschema --output model.py\n```\n\nperson.json:\n\n```\n{\n  \"$id\": \"person.json\",\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Person\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"first_name\": {\n      \"type\": \"string\",\n      \"description\": \"The person's first name.\"\n    },\n    \"last_name\": {\n      \"type\": \"string\",\n      \"description\": \"The person's last name.\"\n    },\n    \"age\": {\n      \"description\": \"Age in years.\",\n      \"type\": \"integer\",\n      \"minimum\": 0\n    },\n    \"pets\": {\n      \"type\": \"array\",\n      \"items\": [\n        {\n          \"$ref\": \"#/definitions/Pet\"\n        }\n      ]\n    },\n    \"comment\": {\n      \"type\": \"null\"\n    }\n  },\n  \"required\": [\n      \"first_name\",\n      \"last_name\"\n  ],\n  \"definitions\": {\n    \"Pet\": {\n      \"properties\": {\n        \"name\": {\n          \"type\": \"string\"\n        },\n        \"age\": {\n          \"type\": \"integer\"\n        }\n      }\n    }\n  }\n}\n```\n\nmodel.py:\n\n```\n# generated by datamodel-codegen:\n#   filename:  person.json\n#   timestamp: 2020-05-19T15:07:31+00:00\nfrom __future__ import annotations\n\nfrom typing import Any\n\nfrom pydantic import BaseModel, Field, conint\n\n\nclass Pet(BaseModel):\n    name: str | None = None\n    age: int | None = None\n\n\nclass Person(BaseModel):\n    first_name: str = Field(description=\"The person's first name.\")\n    last_name: str = Field(description=\"The person's last name.\")\n    age: conint(ge=0) | None = Field(None, description='Age in years.')\n    pets: list[Pet] | None = None\n    comment: Any | None = None\n```\n\nMore information can be found on the\n[official documentation](https://koxudaxi.github.io/datamodel-code-generator/)\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/integrations/datamodel_code_generator/index.html#exampleindexhtmlexample-permanent-link", "page": "integrations/datamodel_code_generator/index.html", "source_site": "pydantic"}
{"title": "IDE extension[Â¶](index.html#ide-extension \"Permanent link\")", "anchor": "ide-extensionindexhtmlide-extension-permanent-link", "md_text": "Pyrefly gives you IDE features such as go-to-definition and autocomplete on your Pydantic models.\n\nHereâ€™s an example of signature help, powered by Pyreflyâ€™s understanding of the Pydantic-specific `validation_alias` keyword:\n\n![Signature help with the Pyrefly IDE extension](../../img/pyrefly.png)\n\nAs you type `Model()`, Pyrefly hints that you need to use the name `x_` to populate the `x` field.", "url": "https://docs.pydantic.dev/latest/integrations/pyrefly/index.html#ide-extensionindexhtmlide-extension-permanent-link", "page": "integrations/pyrefly/index.html", "source_site": "pydantic"}
{"title": "Type checker[Â¶](index.html#type-checker \"Permanent link\")", "anchor": "type-checkerindexhtmltype-checker-permanent-link", "md_text": "Pyrefly can also catch errors in your code before you run it. Consider the following example:\n\n|  |  |\n| --- | --- |\n| ```  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 ``` | ``` from pydantic import BaseModel, ConfigDict   class Model1(BaseModel, frozen=True):     x: int   class Model2(BaseModel):     model_config = ConfigDict(frozen=True)     x: int   model1 = Model1(x=0) model1.x = 1  # validation error: mutating a frozen field  model2 = Model2(x=0) model2.x = 1  # validation error: mutating a frozen field ``` |\n\nSince `Model1` declares that it is frozen using a [standard type system feature](https://typing.python.org/en/latest/spec/dataclasses.html#the-dataclass-transform-decorator), any type checker of your choice will catch the validation error from mutating `model1.x`. However, a type checker without special support for the Pydantic `ConfigDict` class will miss the validation error from mutating `model2.x`.\n\nPyrefly catches both errors:\n\n```\nERROR Cannot set field `x` [read-only]\n  --> foo.py:11:1\n   |\n11 | model1.x = 1  # validation error: mutating a frozen field\n   | ^^^^^^^^\n   |\n  This field belongs to a frozen Pydantic model\nERROR Cannot set field `x` [read-only]\n  --> foo.py:14:1\n   |\n14 | model2.x = 1  # validation error: mutating a frozen field\n   | ^^^^^^^^\n   |\n  This field belongs to a frozen Pydantic model\n```\n\nSee the [Pyrefly documentation](https://pyrefly.org/en/docs/pydantic/) for more information.\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/integrations/pyrefly/index.html#type-checkerindexhtmltype-checker-permanent-link", "page": "integrations/pyrefly/index.html", "source_site": "pydantic"}
{"title": "`httpx` requests[Â¶](index.html#httpx-requests \"Permanent link\")", "anchor": "httpx-requestsindexhtmlhttpx-requests-permanent-link", "md_text": "[`httpx`](https://www.python-httpx.org/) is an HTTP client for Python 3 with synchronous and asynchronous APIs.\nIn the below example, we query the [JSONPlaceholder API](https://jsonplaceholder.typicode.com/) to get a user's data and validate it with a Pydantic model.\n\n```\nimport httpx\n\nfrom pydantic import BaseModel, EmailStr\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    email: EmailStr\n\n\nurl = 'https://jsonplaceholder.typicode.com/users/1'\n\nresponse = httpx.get(url)\nresponse.raise_for_status()\n\nuser = User.model_validate(response.json())\nprint(repr(user))\n#> User(id=1, name='Leanne Graham', email='[emailÂ protected]')\n```\n\nThe [`TypeAdapter`](../../api/type_adapter/index.html#pydantic.type_adapter.TypeAdapter) tool from Pydantic often comes in quite\nhandy when working with HTTP requests. Consider a similar example where we are validating a list of users:\n\n```\nfrom pprint import pprint\n\nimport httpx\n\nfrom pydantic import BaseModel, EmailStr, TypeAdapter\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    email: EmailStr\n\n\nurl = 'https://jsonplaceholder.typicode.com/users/'  # (1)!\n\nresponse = httpx.get(url)\nresponse.raise_for_status()\n\nusers_list_adapter = TypeAdapter(list[User])\n\nusers = users_list_adapter.validate_python(response.json())\npprint([u.name for u in users])\n\"\"\"\n['Leanne Graham',\n 'Ervin Howell',\n 'Clementine Bauch',\n 'Patricia Lebsack',\n 'Chelsey Dietrich',\n 'Mrs. Dennis Schulist',\n 'Kurtis Weissnat',\n 'Nicholas Runolfsdottir V',\n 'Glenna Reichert',\n 'Clementina DuBuque']\n\"\"\"\n```\n\n1. Note, we're querying the `/users/` endpoint here to get a list of users.\n\n\n\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/examples/requests/index.html#httpx-requestsindexhtmlhttpx-requests-permanent-link", "page": "examples/requests/index.html", "source_site": "pydantic"}
{"title": "JSON data[Â¶](index.html#json-data \"Permanent link\")", "anchor": "json-dataindexhtmljson-data-permanent-link", "md_text": "`.json` files are a common way to store key / value data in a human-readable format.\nHere is an example of a `.json` file:\n\n```\n{\n    \"name\": \"John Doe\",\n    \"age\": 30,\n    \"email\": \"[emailÂ protected]\"\n}\n```\n\nTo validate this data, we can use a `pydantic` model:\n\n```\nimport pathlib\n\nfrom pydantic import BaseModel, EmailStr, PositiveInt\n\n\nclass Person(BaseModel):\n    name: str\n    age: PositiveInt\n    email: EmailStr\n\n\njson_string = pathlib.Path('person.json').read_text()\nperson = Person.model_validate_json(json_string)\nprint(person)\n#> name='John Doe' age=30 email='[emailÂ protected]'\n```\n\nIf the data in the file is not valid, `pydantic` will raise a [`ValidationError`](../../api/pydantic_core/index.html#pydantic_core.ValidationError).\nLet's say we have the following `.json` file:\n\n```\n{\n    \"age\": -30,\n    \"email\": \"not-an-email-address\"\n}\n```\n\nThis data is flawed for three reasons:\n\n1. It's missing the `name` field.\n2. The `age` field is negative.\n3. The `email` field is not a valid email address.\n\nWhen we try to validate this data, `pydantic` raises a [`ValidationError`](../../api/pydantic_core/index.html#pydantic_core.ValidationError) with all of the\nabove issues:\n\n```\nimport pathlib\n\nfrom pydantic import BaseModel, EmailStr, PositiveInt, ValidationError\n\n\nclass Person(BaseModel):\n    name: str\n    age: PositiveInt\n    email: EmailStr\n\n\njson_string = pathlib.Path('person.json').read_text()\ntry:\n    person = Person.model_validate_json(json_string)\nexcept ValidationError as err:\n    print(err)\n    \"\"\"\n    3 validation errors for Person\n    name\n    Field required [type=missing, input_value={'age': -30, 'email': 'not-an-email-address'}, input_type=dict]\n        For further information visit https://errors.pydantic.dev/2.10/v/missing\n    age\n    Input should be greater than 0 [type=greater_than, input_value=-30, input_type=int]\n        For further information visit https://errors.pydantic.dev/2.10/v/greater_than\n    email\n    value is not a valid email address: An email address must have an @-sign. [type=value_error, input_value='not-an-email-address', input_type=str]\n    \"\"\"\n```\n\nOften, it's the case that you have an abundance of a certain type of data within a `.json` file.\nFor example, you might have a list of people:\n\n```\n[\n    {\n        \"name\": \"John Doe\",\n        \"age\": 30,\n        \"email\": \"[emailÂ protected]\"\n    },\n    {\n        \"name\": \"Jane Doe\",\n        \"age\": 25,\n        \"email\": \"[emailÂ protected]\"\n    }\n]\n```\n\nIn this case, you can validate the data against a `list[Person]` model:\n\n```\nimport pathlib\n\nfrom pydantic import BaseModel, EmailStr, PositiveInt, TypeAdapter\n\n\nclass Person(BaseModel):\n    name: str\n    age: PositiveInt\n    email: EmailStr\n\n\nperson_list_adapter = TypeAdapter(list[Person])  # (1)!\n\njson_string = pathlib.Path('people.json').read_text()\npeople = person_list_adapter.validate_json(json_string)\nprint(people)\n#> [Person(name='John Doe', age=30, email='[emailÂ protected]'), Person(name='Jane Doe', age=25, email='[emailÂ protected]')]\n```\n\n1. We use [`TypeAdapter`](../../api/type_adapter/index.html#pydantic.type_adapter.TypeAdapter) to validate a list of `Person` objects.\n   [`TypeAdapter`](../../api/type_adapter/index.html#pydantic.type_adapter.TypeAdapter) is a Pydantic construct used to validate data against a single type.", "url": "https://docs.pydantic.dev/latest/examples/files/index.html#json-dataindexhtmljson-data-permanent-link", "page": "examples/files/index.html", "source_site": "pydantic"}
{"title": "JSON lines files[Â¶](index.html#json-lines-files \"Permanent link\")", "anchor": "json-lines-filesindexhtmljson-lines-files-permanent-link", "md_text": "Similar to validating a list of objects from a `.json` file, you can validate a list of objects from a `.jsonl` file.\n`.jsonl` files are a sequence of JSON objects separated by newlines.\n\nConsider the following `.jsonl` file:\n\n```\n{\"name\": \"John Doe\", \"age\": 30, \"email\": \"[emailÂ protected]\"}\n{\"name\": \"Jane Doe\", \"age\": 25, \"email\": \"[emailÂ protected]\"}\n```\n\nWe can validate this data with a similar approach to the one we used for `.json` files:\n\n```\nimport pathlib\n\nfrom pydantic import BaseModel, EmailStr, PositiveInt\n\n\nclass Person(BaseModel):\n    name: str\n    age: PositiveInt\n    email: EmailStr\n\n\njson_lines = pathlib.Path('people.jsonl').read_text().splitlines()\npeople = [Person.model_validate_json(line) for line in json_lines]\nprint(people)\n#> [Person(name='John Doe', age=30, email='[emailÂ protected]'), Person(name='Jane Doe', age=25, email='[emailÂ protected]')]\n```", "url": "https://docs.pydantic.dev/latest/examples/files/index.html#json-lines-filesindexhtmljson-lines-files-permanent-link", "page": "examples/files/index.html", "source_site": "pydantic"}
{"title": "CSV files[Â¶](index.html#csv-files \"Permanent link\")", "anchor": "csv-filesindexhtmlcsv-files-permanent-link", "md_text": "CSV is one of the most common file formats for storing tabular data.\nTo validate data from a CSV file, you can use the `csv` module from the Python standard library to load\nthe data and validate it against a Pydantic model.\n\nConsider the following CSV file:\n\n```\nname,age,email\nJohn Doe,30,[emailÂ protected]\nJane Doe,25,[emailÂ protected]\n```\n\nHere's how we validate that data:\n\n```\nimport csv\n\nfrom pydantic import BaseModel, EmailStr, PositiveInt\n\n\nclass Person(BaseModel):\n    name: str\n    age: PositiveInt\n    email: EmailStr\n\n\nwith open('people.csv') as f:\n    reader = csv.DictReader(f)\n    people = [Person.model_validate(row) for row in reader]\n\nprint(people)\n#> [Person(name='John Doe', age=30, email='[emailÂ protected]'), Person(name='Jane Doe', age=25, email='[emailÂ protected]')]\n```", "url": "https://docs.pydantic.dev/latest/examples/files/index.html#csv-filesindexhtmlcsv-files-permanent-link", "page": "examples/files/index.html", "source_site": "pydantic"}
{"title": "TOML files[Â¶](index.html#toml-files \"Permanent link\")", "anchor": "toml-filesindexhtmltoml-files-permanent-link", "md_text": "TOML files are often used for configuration due to their simplicity and readability.\n\nConsider the following TOML file:\n\n```\nname = \"John Doe\"\nage = 30\nemail = \"[emailÂ protected]\"\n```\n\nHere's how we validate that data:\n\n```\nimport tomllib\n\nfrom pydantic import BaseModel, EmailStr, PositiveInt\n\n\nclass Person(BaseModel):\n    name: str\n    age: PositiveInt\n    email: EmailStr\n\n\nwith open('person.toml', 'rb') as f:\n    data = tomllib.load(f)\n\nperson = Person.model_validate(data)\nprint(person)\n#> name='John Doe' age=30 email='[emailÂ protected]'\n```", "url": "https://docs.pydantic.dev/latest/examples/files/index.html#toml-filesindexhtmltoml-files-permanent-link", "page": "examples/files/index.html", "source_site": "pydantic"}
{"title": "YAML files[Â¶](index.html#yaml-files \"Permanent link\")", "anchor": "yaml-filesindexhtmlyaml-files-permanent-link", "md_text": "YAML (YAML Ain't Markup Language) is a human-readable data serialization format that is often used for configuration files.\n\nConsider the following YAML file:\n\n```\nname: John Doe\nage: 30\nemail: [emailÂ protected]\n```\n\nHere's how we validate that data:\n\n```\nimport yaml\n\nfrom pydantic import BaseModel, EmailStr, PositiveInt\n\n\nclass Person(BaseModel):\n    name: str\n    age: PositiveInt\n    email: EmailStr\n\n\nwith open('person.yaml') as f:\n    data = yaml.safe_load(f)\n\nperson = Person.model_validate(data)\nprint(person)\n#> name='John Doe' age=30 email='[emailÂ protected]'\n```", "url": "https://docs.pydantic.dev/latest/examples/files/index.html#yaml-filesindexhtmlyaml-files-permanent-link", "page": "examples/files/index.html", "source_site": "pydantic"}
{"title": "XML files[Â¶](index.html#xml-files \"Permanent link\")", "anchor": "xml-filesindexhtmlxml-files-permanent-link", "md_text": "XML (eXtensible Markup Language) is a markup language that defines a set of rules for encoding documents in a format that is both human-readable and machine-readable.\n\nConsider the following XML file:\n\n```\n<?xml version=\"1.0\"?>\n<person>\n    <name>John Doe</name>\n    <age>30</age>\n    <email>[emailÂ protected]</email>\n</person>\n```\n\nHere's how we validate that data:\n\n```\nimport xml.etree.ElementTree as ET\n\nfrom pydantic import BaseModel, EmailStr, PositiveInt\n\n\nclass Person(BaseModel):\n    name: str\n    age: PositiveInt\n    email: EmailStr\n\n\ntree = ET.parse('person.xml').getroot()\ndata = {child.tag: child.text for child in tree}\nperson = Person.model_validate(data)\nprint(person)\n#> name='John Doe' age=30 email='[emailÂ protected]'\n```", "url": "https://docs.pydantic.dev/latest/examples/files/index.html#xml-filesindexhtmlxml-files-permanent-link", "page": "examples/files/index.html", "source_site": "pydantic"}
{"title": "INI files[Â¶](index.html#ini-files \"Permanent link\")", "anchor": "ini-filesindexhtmlini-files-permanent-link", "md_text": "INI files are a simple configuration file format that uses sections and key-value pairs. They are commonly used in Windows applications and older software.\n\nConsider the following INI file:\n\n```\n[PERSON]\nname = John Doe\nage = 30\nemail = [emailÂ protected]\n```\n\nHere's how we validate that data:\n\n```\nimport configparser\n\nfrom pydantic import BaseModel, EmailStr, PositiveInt\n\n\nclass Person(BaseModel):\n    name: str\n    age: PositiveInt\n    email: EmailStr\n\n\nconfig = configparser.ConfigParser()\nconfig.read('person.ini')\nperson = Person.model_validate(config['PERSON'])\nprint(person)\n#> name='John Doe' age=30 email='[emailÂ protected]'\n```\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/examples/files/index.html#ini-filesindexhtmlini-files-permanent-link", "page": "examples/files/index.html", "source_site": "pydantic"}
{"title": "Redis queue[Â¶](index.html#redis-queue \"Permanent link\")", "anchor": "redis-queueindexhtmlredis-queue-permanent-link", "md_text": "Redis is a popular in-memory data structure store.\n\nIn order to run this example locally, you'll first need to [install Redis](https://redis.io/docs/latest/operate/oss_and_stack/install/install-redis/)\nand start your server up locally.\n\nHere's a simple example of how you can use Pydantic to:\n\n1. Serialize data to push to the queue\n2. Deserialize and validate data when it's popped from the queue\n\n```\nimport redis\n\nfrom pydantic import BaseModel, EmailStr\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    email: EmailStr\n\n\nr = redis.Redis(host='localhost', port=6379, db=0)\nQUEUE_NAME = 'user_queue'\n\n\ndef push_to_queue(user_data: User) -> None:\n    serialized_data = user_data.model_dump_json()\n    r.rpush(QUEUE_NAME, serialized_data)\n    print(f'Added to queue: {serialized_data}')\n\n\nuser1 = User(id=1, name='John Doe', email='[emailÂ protected]')\nuser2 = User(id=2, name='Jane Doe', email='[emailÂ protected]')\n\npush_to_queue(user1)\n#> Added to queue: {\"id\":1,\"name\":\"John Doe\",\"email\":\"[emailÂ protected]\"}\n\npush_to_queue(user2)\n#> Added to queue: {\"id\":2,\"name\":\"Jane Doe\",\"email\":\"[emailÂ protected]\"}\n\n\ndef pop_from_queue() -> None:\n    data = r.lpop(QUEUE_NAME)\n\n    if data:\n        user = User.model_validate_json(data)\n        print(f'Validated user: {repr(user)}')\n    else:\n        print('Queue is empty')\n\n\npop_from_queue()\n#> Validated user: User(id=1, name='John Doe', email='[emailÂ protected]')\n\npop_from_queue()\n#> Validated user: User(id=2, name='Jane Doe', email='[emailÂ protected]')\n\npop_from_queue()\n#> Queue is empty\n```", "url": "https://docs.pydantic.dev/latest/examples/queues/index.html#redis-queueindexhtmlredis-queue-permanent-link", "page": "examples/queues/index.html", "source_site": "pydantic"}
{"title": "RabbitMQ[Â¶](index.html#rabbitmq \"Permanent link\")", "anchor": "rabbitmqindexhtmlrabbitmq-permanent-link", "md_text": "RabbitMQ is a popular message broker that implements the AMQP protocol.\n\nIn order to run this example locally, you'll first need to [install RabbitMQ](https://www.rabbitmq.com/download.html) and start your server.\n\nHere's a simple example of how you can use Pydantic to:\n\n1. Serialize data to push to the queue\n2. Deserialize and validate data when it's popped from the queue\n\nFirst, let's create a sender script.\n\n```\nimport pika\n\nfrom pydantic import BaseModel, EmailStr\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    email: EmailStr\n\n\nconnection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))\nchannel = connection.channel()\nQUEUE_NAME = 'user_queue'\nchannel.queue_declare(queue=QUEUE_NAME)\n\n\ndef push_to_queue(user_data: User) -> None:\n    serialized_data = user_data.model_dump_json()\n    channel.basic_publish(\n        exchange='',\n        routing_key=QUEUE_NAME,\n        body=serialized_data,\n    )\n    print(f'Added to queue: {serialized_data}')\n\n\nuser1 = User(id=1, name='John Doe', email='[emailÂ protected]')\nuser2 = User(id=2, name='Jane Doe', email='[emailÂ protected]')\n\npush_to_queue(user1)\n#> Added to queue: {\"id\":1,\"name\":\"John Doe\",\"email\":\"[emailÂ protected]\"}\n\npush_to_queue(user2)\n#> Added to queue: {\"id\":2,\"name\":\"Jane Doe\",\"email\":\"[emailÂ protected]\"}\n\nconnection.close()\n```\n\nAnd here's the receiver script.\n\n```\nimport pika\n\nfrom pydantic import BaseModel, EmailStr\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    email: EmailStr\n\n\ndef main():\n    connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))\n    channel = connection.channel()\n    QUEUE_NAME = 'user_queue'\n    channel.queue_declare(queue=QUEUE_NAME)\n\n    def process_message(\n        ch: pika.channel.Channel,\n        method: pika.spec.Basic.Deliver,\n        properties: pika.spec.BasicProperties,\n        body: bytes,\n    ):\n        user = User.model_validate_json(body)\n        print(f'Validated user: {repr(user)}')\n        ch.basic_ack(delivery_tag=method.delivery_tag)\n\n    channel.basic_consume(queue=QUEUE_NAME, on_message_callback=process_message)\n    channel.start_consuming()\n\n\nif __name__ == '__main__':\n    try:\n        main()\n    except KeyboardInterrupt:\n        pass\n```\n\nTo test this example:\n\n1. Run the receiver script in one terminal to start the consumer.\n2. Run the sender script in another terminal to send messages.", "url": "https://docs.pydantic.dev/latest/examples/queues/index.html#rabbitmqindexhtmlrabbitmq-permanent-link", "page": "examples/queues/index.html", "source_site": "pydantic"}
{"title": "ARQ[Â¶](index.html#arq \"Permanent link\")", "anchor": "arqindexhtmlarq-permanent-link", "md_text": "ARQ is a fast Redis-based job queue for Python.\nIt's built on top of Redis and provides a simple way to handle background tasks.\n\nIn order to run this example locally, youâ€™ll need to [Install Redis](https://redis.io/docs/latest/operate/oss_and_stack/install/install-redis/) and start your server.\n\nHere's a simple example of how you can use Pydantic with ARQ to:\n\n1. Define a model for your job data\n2. Serialize data when enqueueing jobs\n3. Validate and deserialize data when processing jobs\n\n```\nimport asyncio\nfrom typing import Any\n\nfrom arq import create_pool\nfrom arq.connections import RedisSettings\n\nfrom pydantic import BaseModel, EmailStr\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    email: EmailStr\n\n\nREDIS_SETTINGS = RedisSettings()\n\n\nasync def process_user(ctx: dict[str, Any], user_data: dict[str, Any]) -> None:\n    user = User.model_validate(user_data)\n    print(f'Processing user: {repr(user)}')\n\n\nasync def enqueue_jobs(redis):\n    user1 = User(id=1, name='John Doe', email='[emailÂ protected]')\n    user2 = User(id=2, name='Jane Doe', email='[emailÂ protected]')\n\n    await redis.enqueue_job('process_user', user1.model_dump())\n    print(f'Enqueued user: {repr(user1)}')\n\n    await redis.enqueue_job('process_user', user2.model_dump())\n    print(f'Enqueued user: {repr(user2)}')\n\n\nclass WorkerSettings:\n    functions = [process_user]\n    redis_settings = REDIS_SETTINGS\n\n\nasync def main():\n    redis = await create_pool(REDIS_SETTINGS)\n    await enqueue_jobs(redis)\n\n\nif __name__ == '__main__':\n    asyncio.run(main())\n```\n\nThis script is complete.\nIt should run \"as is\" both to enqueue jobs and to process them.\n\n\n\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/examples/queues/index.html#arqindexhtmlarq-permanent-link", "page": "examples/queues/index.html", "source_site": "pydantic"}
{"title": "Custom `datetime` Validator via [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated) Metadata[Â¶](index.html#custom-datetime-validator-via-annotated-metadata \"Permanent link\")", "anchor": "custom-datetime-validator-via-annotatedhttpsdocspythonorg3librarytypinghtmltypingannotated-metadataindexhtmlcustom-datetime-validator-via-annotated-metadata-permanent-link", "md_text": "In this example, we'll construct a custom validator, attached to an [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated) type,\nthat ensures a [`datetime`](https://docs.python.org/3/library/datetime.html#datetime.datetime) object adheres to a given timezone constraint.\n\nThe custom validator supports string specification of the timezone, and will raise an error if the [`datetime`](https://docs.python.org/3/library/datetime.html#datetime.datetime) object does not have the correct timezone.\n\nWe use `__get_pydantic_core_schema__` in the validator to customize the schema of the annotated type (in this case, [`datetime`](https://docs.python.org/3/library/datetime.html#datetime.datetime)), which allows us to add custom validation logic. Notably, we use a `wrap` validator function so that we can perform operations both before and after the default `pydantic` validation of a [`datetime`](https://docs.python.org/3/library/datetime.html#datetime.datetime).\n\nPython 3.9 and abovePython 3.10 and above\n\n```\nimport datetime as dt\nfrom dataclasses import dataclass\nfrom pprint import pprint\nfrom typing import Annotated, Any, Callable, Optional\n\nimport pytz\nfrom pydantic_core import CoreSchema, core_schema\n\nfrom pydantic import (\n    GetCoreSchemaHandler,\n    PydanticUserError,\n    TypeAdapter,\n    ValidationError,\n)\n\n\n@dataclass(frozen=True)\nclass MyDatetimeValidator:\n    tz_constraint: Optional[str] = None\n\n    def tz_constraint_validator(\n        self,\n        value: dt.datetime,\n        handler: Callable,  # (1)!\n    ):\n        \"\"\"Validate tz_constraint and tz_info.\"\"\"\n        # handle naive datetimes\n        if self.tz_constraint is None:\n            assert (\n                value.tzinfo is None\n            ), 'tz_constraint is None, but provided value is tz-aware.'\n            return handler(value)\n\n        # validate tz_constraint and tz-aware tzinfo\n        if self.tz_constraint not in pytz.all_timezones:\n            raise PydanticUserError(\n                f'Invalid tz_constraint: {self.tz_constraint}',\n                code='unevaluable-type-annotation',\n            )\n        result = handler(value)  # (2)!\n        assert self.tz_constraint == str(\n            result.tzinfo\n        ), f'Invalid tzinfo: {str(result.tzinfo)}, expected: {self.tz_constraint}'\n\n        return result\n\n    def __get_pydantic_core_schema__(\n        self,\n        source_type: Any,\n        handler: GetCoreSchemaHandler,\n    ) -> CoreSchema:\n        return core_schema.no_info_wrap_validator_function(\n            self.tz_constraint_validator,\n            handler(source_type),\n        )\n\n\nLA = 'America/Los_Angeles'\nta = TypeAdapter(Annotated[dt.datetime, MyDatetimeValidator(LA)])\nprint(\n    ta.validate_python(dt.datetime(2023, 1, 1, 0, 0, tzinfo=pytz.timezone(LA)))\n)\n#> 2023-01-01 00:00:00-07:53\n\nLONDON = 'Europe/London'\ntry:\n    ta.validate_python(\n        dt.datetime(2023, 1, 1, 0, 0, tzinfo=pytz.timezone(LONDON))\n    )\nexcept ValidationError as ve:\n    pprint(ve.errors(), width=100)\n    \"\"\"\n    [{'ctx': {'error': AssertionError('Invalid tzinfo: Europe/London, expected: America/Los_Angeles')},\n    'input': datetime.datetime(2023, 1, 1, 0, 0, tzinfo=<DstTzInfo 'Europe/London' LMT-1 day, 23:59:00 STD>),\n    'loc': (),\n    'msg': 'Assertion failed, Invalid tzinfo: Europe/London, expected: America/Los_Angeles',\n    'type': 'assertion_error',\n    'url': 'https://errors.pydantic.dev/2.8/v/assertion_error'}]\n    \"\"\"\n```\n\n1. The `handler` function is what we call to validate the input with standard `pydantic` validation\n2. We call the `handler` function to validate the input with standard `pydantic` validation in this wrap validator\n\n```\nimport datetime as dt\nfrom dataclasses import dataclass\nfrom pprint import pprint\nfrom typing import Annotated, Any\nfrom collections.abc import Callable\n\nimport pytz\nfrom pydantic_core import CoreSchema, core_schema\n\nfrom pydantic import (\n    GetCoreSchemaHandler,\n    PydanticUserError,\n    TypeAdapter,\n    ValidationError,\n)\n\n\n@dataclass(frozen=True)\nclass MyDatetimeValidator:\n    tz_constraint: str | None = None\n\n    def tz_constraint_validator(\n        self,\n        value: dt.datetime,\n        handler: Callable,  # (1)!\n    ):\n        \"\"\"Validate tz_constraint and tz_info.\"\"\"\n        # handle naive datetimes\n        if self.tz_constraint is None:\n            assert (\n                value.tzinfo is None\n            ), 'tz_constraint is None, but provided value is tz-aware.'\n            return handler(value)\n\n        # validate tz_constraint and tz-aware tzinfo\n        if self.tz_constraint not in pytz.all_timezones:\n            raise PydanticUserError(\n                f'Invalid tz_constraint: {self.tz_constraint}',\n                code='unevaluable-type-annotation',\n            )\n        result = handler(value)  # (2)!\n        assert self.tz_constraint == str(\n            result.tzinfo\n        ), f'Invalid tzinfo: {str(result.tzinfo)}, expected: {self.tz_constraint}'\n\n        return result", "url": "https://docs.pydantic.dev/latest/examples/custom_validators/index.html#custom-datetime-validator-via-annotatedhttpsdocspythonorg3librarytypinghtmltypingannotated-metadataindexhtmlcustom-datetime-validator-via-annotated-metadata-permanent-link", "page": "examples/custom_validators/index.html", "source_site": "pydantic"}
{"title": "Custom `datetime` Validator via [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated) Metadata[Â¶](index.html#custom-datetime-validator-via-annotated-metadata \"Permanent link\")", "anchor": "custom-datetime-validator-via-annotatedhttpsdocspythonorg3librarytypinghtmltypingannotated-metadataindexhtmlcustom-datetime-validator-via-annotated-metadata-permanent-link", "md_text": "    def __get_pydantic_core_schema__(\n        self,\n        source_type: Any,\n        handler: GetCoreSchemaHandler,\n    ) -> CoreSchema:\n        return core_schema.no_info_wrap_validator_function(\n            self.tz_constraint_validator,\n            handler(source_type),\n        )\n\n\nLA = 'America/Los_Angeles'\nta = TypeAdapter(Annotated[dt.datetime, MyDatetimeValidator(LA)])\nprint(\n    ta.validate_python(dt.datetime(2023, 1, 1, 0, 0, tzinfo=pytz.timezone(LA)))\n)\n#> 2023-01-01 00:00:00-07:53\n\nLONDON = 'Europe/London'\ntry:\n    ta.validate_python(\n        dt.datetime(2023, 1, 1, 0, 0, tzinfo=pytz.timezone(LONDON))\n    )\nexcept ValidationError as ve:\n    pprint(ve.errors(), width=100)\n    \"\"\"\n    [{'ctx': {'error': AssertionError('Invalid tzinfo: Europe/London, expected: America/Los_Angeles')},\n    'input': datetime.datetime(2023, 1, 1, 0, 0, tzinfo=<DstTzInfo 'Europe/London' LMT-1 day, 23:59:00 STD>),\n    'loc': (),\n    'msg': 'Assertion failed, Invalid tzinfo: Europe/London, expected: America/Los_Angeles',\n    'type': 'assertion_error',\n    'url': 'https://errors.pydantic.dev/2.8/v/assertion_error'}]\n    \"\"\"\n```\n\n1. The `handler` function is what we call to validate the input with standard `pydantic` validation\n2. We call the `handler` function to validate the input with standard `pydantic` validation in this wrap validator\n\nWe can also enforce UTC offset constraints in a similar way. Assuming we have a `lower_bound` and an `upper_bound`, we can create a custom validator to ensure our `datetime` has a UTC offset that is inclusive within the boundary we define:\n\nPython 3.9 and abovePython 3.10 and above\n\n```\nimport datetime as dt\nfrom dataclasses import dataclass\nfrom pprint import pprint\nfrom typing import Annotated, Any, Callable\n\nimport pytz\nfrom pydantic_core import CoreSchema, core_schema\n\nfrom pydantic import GetCoreSchemaHandler, TypeAdapter, ValidationError\n\n\n@dataclass(frozen=True)\nclass MyDatetimeValidator:\n    lower_bound: int\n    upper_bound: int\n\n    def validate_tz_bounds(self, value: dt.datetime, handler: Callable):\n        \"\"\"Validate and test bounds\"\"\"\n        assert value.utcoffset() is not None, 'UTC offset must exist'\n        assert self.lower_bound <= self.upper_bound, 'Invalid bounds'\n\n        result = handler(value)\n\n        hours_offset = value.utcoffset().total_seconds() / 3600\n        assert (\n            self.lower_bound <= hours_offset <= self.upper_bound\n        ), 'Value out of bounds'\n\n        return result\n\n    def __get_pydantic_core_schema__(\n        self,\n        source_type: Any,\n        handler: GetCoreSchemaHandler,\n    ) -> CoreSchema:\n        return core_schema.no_info_wrap_validator_function(\n            self.validate_tz_bounds,\n            handler(source_type),\n        )\n\n\nLA = 'America/Los_Angeles'  # UTC-7 or UTC-8\nta = TypeAdapter(Annotated[dt.datetime, MyDatetimeValidator(-10, -5)])\nprint(\n    ta.validate_python(dt.datetime(2023, 1, 1, 0, 0, tzinfo=pytz.timezone(LA)))\n)\n#> 2023-01-01 00:00:00-07:53\n\nLONDON = 'Europe/London'\ntry:\n    print(\n        ta.validate_python(\n            dt.datetime(2023, 1, 1, 0, 0, tzinfo=pytz.timezone(LONDON))\n        )\n    )\nexcept ValidationError as e:\n    pprint(e.errors(), width=100)\n    \"\"\"\n    [{'ctx': {'error': AssertionError('Value out of bounds')},\n    'input': datetime.datetime(2023, 1, 1, 0, 0, tzinfo=<DstTzInfo 'Europe/London' LMT-1 day, 23:59:00 STD>),\n    'loc': (),\n    'msg': 'Assertion failed, Value out of bounds',\n    'type': 'assertion_error',\n    'url': 'https://errors.pydantic.dev/2.8/v/assertion_error'}]\n    \"\"\"\n\nimport datetime as dt\nfrom dataclasses import dataclass\nfrom pprint import pprint\nfrom typing import Annotated, Any\nfrom collections.abc import Callable\n\nimport pytz\nfrom pydantic_core import CoreSchema, core_schema\n\nfrom pydantic import GetCoreSchemaHandler, TypeAdapter, ValidationError\n\n\n@dataclass(frozen=True)\nclass MyDatetimeValidator:\n    lower_bound: int\n    upper_bound: int\n\n    def validate_tz_bounds(self, value: dt.datetime, handler: Callable):\n        \"\"\"Validate and test bounds\"\"\"\n        assert value.utcoffset() is not None, 'UTC offset must exist'\n        assert self.lower_bound <= self.upper_bound, 'Invalid bounds'\n\n        result = handler(value)\n\n        hours_offset = value.utcoffset().total_seconds() / 3600\n        assert (\n            self.lower_bound <= hours_offset <= self.upper_bound\n        ), 'Value out of bounds'\n\n        return result", "url": "https://docs.pydantic.dev/latest/examples/custom_validators/index.html#custom-datetime-validator-via-annotatedhttpsdocspythonorg3librarytypinghtmltypingannotated-metadataindexhtmlcustom-datetime-validator-via-annotated-metadata-permanent-link", "page": "examples/custom_validators/index.html", "source_site": "pydantic"}
{"title": "Custom `datetime` Validator via [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated) Metadata[Â¶](index.html#custom-datetime-validator-via-annotated-metadata \"Permanent link\")", "anchor": "custom-datetime-validator-via-annotatedhttpsdocspythonorg3librarytypinghtmltypingannotated-metadataindexhtmlcustom-datetime-validator-via-annotated-metadata-permanent-link", "md_text": "    def __get_pydantic_core_schema__(\n        self,\n        source_type: Any,\n        handler: GetCoreSchemaHandler,\n    ) -> CoreSchema:\n        return core_schema.no_info_wrap_validator_function(\n            self.validate_tz_bounds,\n            handler(source_type),\n        )\n\n\nLA = 'America/Los_Angeles'  # UTC-7 or UTC-8\nta = TypeAdapter(Annotated[dt.datetime, MyDatetimeValidator(-10, -5)])\nprint(\n    ta.validate_python(dt.datetime(2023, 1, 1, 0, 0, tzinfo=pytz.timezone(LA)))\n)\n#> 2023-01-01 00:00:00-07:53\n\nLONDON = 'Europe/London'\ntry:\n    print(\n        ta.validate_python(\n            dt.datetime(2023, 1, 1, 0, 0, tzinfo=pytz.timezone(LONDON))\n        )\n    )\nexcept ValidationError as e:\n    pprint(e.errors(), width=100)\n    \"\"\"\n    [{'ctx': {'error': AssertionError('Value out of bounds')},\n    'input': datetime.datetime(2023, 1, 1, 0, 0, tzinfo=<DstTzInfo 'Europe/London' LMT-1 day, 23:59:00 STD>),\n    'loc': (),\n    'msg': 'Assertion failed, Value out of bounds',\n    'type': 'assertion_error',\n    'url': 'https://errors.pydantic.dev/2.8/v/assertion_error'}]\n    \"\"\"\n```", "url": "https://docs.pydantic.dev/latest/examples/custom_validators/index.html#custom-datetime-validator-via-annotatedhttpsdocspythonorg3librarytypinghtmltypingannotated-metadataindexhtmlcustom-datetime-validator-via-annotated-metadata-permanent-link", "page": "examples/custom_validators/index.html", "source_site": "pydantic"}
{"title": "Validating Nested Model Fields[Â¶](index.html#validating-nested-model-fields \"Permanent link\")", "anchor": "validating-nested-model-fieldsindexhtmlvalidating-nested-model-fields-permanent-link", "md_text": "Here, we demonstrate two ways to validate a field of a nested model, where the validator utilizes data from the parent model.\n\nIn this example, we construct a validator that checks that each user's password is not in a list of forbidden passwords specified by the parent model.\n\nOne way to do this is to place a custom validator on the outer model:\n\nPython 3.9 and abovePython 3.11 and above\n\n```\nfrom typing_extensions import Self\n\nfrom pydantic import BaseModel, ValidationError, model_validator\n\n\nclass User(BaseModel):\n    username: str\n    password: str\n\n\nclass Organization(BaseModel):\n    forbidden_passwords: list[str]\n    users: list[User]\n\n    @model_validator(mode='after')\n    def validate_user_passwords(self) -> Self:\n        \"\"\"Check that user password is not in forbidden list. Raise a validation error if a forbidden password is encountered.\"\"\"\n        for user in self.users:\n            current_pw = user.password\n            if current_pw in self.forbidden_passwords:\n                raise ValueError(\n                    f'Password {current_pw} is forbidden. Please choose another password for user {user.username}.'\n                )\n        return self\n\n\ndata = {\n    'forbidden_passwords': ['123'],\n    'users': [\n        {'username': 'Spartacat', 'password': '123'},\n        {'username': 'Iceburgh', 'password': '87'},\n    ],\n}\ntry:\n    org = Organization(**data)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Organization\n      Value error, Password 123 is forbidden. Please choose another password for user Spartacat. [type=value_error, input_value={'forbidden_passwords': [...gh', 'password': '87'}]}, input_type=dict]\n    \"\"\"\n\nfrom typing import Self\n\nfrom pydantic import BaseModel, ValidationError, model_validator\n\n\nclass User(BaseModel):\n    username: str\n    password: str\n\n\nclass Organization(BaseModel):\n    forbidden_passwords: list[str]\n    users: list[User]\n\n    @model_validator(mode='after')\n    def validate_user_passwords(self) -> Self:\n        \"\"\"Check that user password is not in forbidden list. Raise a validation error if a forbidden password is encountered.\"\"\"\n        for user in self.users:\n            current_pw = user.password\n            if current_pw in self.forbidden_passwords:\n                raise ValueError(\n                    f'Password {current_pw} is forbidden. Please choose another password for user {user.username}.'\n                )\n        return self\n\n\ndata = {\n    'forbidden_passwords': ['123'],\n    'users': [\n        {'username': 'Spartacat', 'password': '123'},\n        {'username': 'Iceburgh', 'password': '87'},\n    ],\n}\ntry:\n    org = Organization(**data)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Organization\n      Value error, Password 123 is forbidden. Please choose another password for user Spartacat. [type=value_error, input_value={'forbidden_passwords': [...gh', 'password': '87'}]}, input_type=dict]\n    \"\"\"\n```\n\nAlternatively, a custom validator can be used in the nested model class (`User`), with the forbidden passwords data from the parent model being passed in via validation context.\n\nThe ability to mutate the context within a validator adds a lot of power to nested validation, but can also lead to confusing or hard-to-debug code. Use this approach at your own risk!\n\n```\nfrom pydantic import BaseModel, ValidationError, ValidationInfo, field_validator\n\n\nclass User(BaseModel):\n    username: str\n    password: str\n\n    @field_validator('password', mode='after')\n    @classmethod\n    def validate_user_passwords(\n        cls, password: str, info: ValidationInfo\n    ) -> str:\n        \"\"\"Check that user password is not in forbidden list.\"\"\"\n        forbidden_passwords = (\n            info.context.get('forbidden_passwords', []) if info.context else []\n        )\n        if password in forbidden_passwords:\n            raise ValueError(f'Password {password} is forbidden.')\n        return password\n\n\nclass Organization(BaseModel):\n    forbidden_passwords: list[str]\n    users: list[User]\n\n    @field_validator('forbidden_passwords', mode='after')\n    @classmethod\n    def add_context(cls, v: list[str], info: ValidationInfo) -> list[str]:\n        if info.context is not None:\n            info.context.update({'forbidden_passwords': v})\n        return v\n\n\ndata = {\n    'forbidden_passwords': ['123'],\n    'users': [\n        {'username': 'Spartacat', 'password': '123'},\n        {'username': 'Iceburgh', 'password': '87'},\n    ],\n}\n\ntry:\n    org = Organization.model_validate(data, context={})\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Organization\n    users.0.password\n      Value error, Password 123 is forbidden. [type=value_error, input_value='123', input_type=str]\n    \"\"\"\n```\n\nNote that if the context property is not included in `model_validate`, then `info.context` will be `None` and the forbidden passwords list will not get added to the context in the above implementation. As such, `validate_user_passwords` would not carry out the desired password validation.\n\nMore details about validation context can be found in the [validators documentation](../../concepts/validators/index.html#validation-context).\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/examples/custom_validators/index.html#validating-nested-model-fieldsindexhtmlvalidating-nested-model-fields-permanent-link", "page": "examples/custom_validators/index.html", "source_site": "pydantic"}
{"title": "SQLAlchemy[Â¶](index.html#sqlalchemy \"Permanent link\")", "anchor": "sqlalchemyindexhtmlsqlalchemy-permanent-link", "md_text": "Pydantic can pair with SQLAlchemy, as it can be used to define the schema of the database models.\n\nIf you use Pydantic with SQLAlchemy, you might experience some frustration with code duplication.\nIf you find yourself experiencing this difficulty, you might also consider [`SQLModel`](https://sqlmodel.tiangolo.com/) which integrates Pydantic with SQLAlchemy such that much of the code duplication is eliminated.\n\nIf you'd prefer to use pure Pydantic with SQLAlchemy, we recommend using Pydantic models alongside of SQLAlchemy models\nas shown in the example below. In this case, we take advantage of Pydantic's aliases feature to name a `Column` after a reserved SQLAlchemy field, thus avoiding conflicts.\n\n```\nimport sqlalchemy as sa\nfrom sqlalchemy.orm import declarative_base\n\nfrom pydantic import BaseModel, ConfigDict, Field\n\n\nclass MyModel(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n\n    metadata: dict[str, str] = Field(alias='metadata_')\n\n\nBase = declarative_base()\n\n\nclass MyTableModel(Base):\n    __tablename__ = 'my_table'\n    id = sa.Column('id', sa.Integer, primary_key=True)\n    # 'metadata' is reserved by SQLAlchemy, hence the '_'\n    metadata_ = sa.Column('metadata', sa.JSON)\n\n\nsql_model = MyTableModel(metadata_={'key': 'val'}, id=1)\npydantic_model = MyModel.model_validate(sql_model)\n\nprint(pydantic_model.model_dump())\n#> {'metadata': {'key': 'val'}}\nprint(pydantic_model.model_dump(by_alias=True))\n#> {'metadata_': {'key': 'val'}}\n```\n\nThe example above works because aliases have priority over field names for\nfield population. Accessing `SQLModel`'s `metadata` attribute would lead to a `ValidationError`.\n\n\n\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/examples/orms/index.html#sqlalchemyindexhtmlsqlalchemy-permanent-link", "page": "examples/orms/index.html", "source_site": "pydantic"}
{"title": "SemanticVersion [Â¶](index.html#pydantic_extra_types.semantic_version.SemanticVersion \"Permanent link\")", "anchor": "semanticversion-indexhtmlpydanticextratypessemanticversionsemanticversion-permanent-link", "md_text": "Bases: `Version`\n\nSemantic version based on the official [semver thread](https://python-semver.readthedocs.io/en/latest/advanced/combine-pydantic-and-semver.html).\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_semantic_version/index.html#semanticversion-indexhtmlpydanticextratypessemanticversionsemanticversion-permanent-link", "page": "api/pydantic_extra_types_semantic_version/index.html", "source_site": "pydantic"}
{"title": "ABARoutingNumber [Â¶](index.html#pydantic_extra_types.routing_number.ABARoutingNumber \"Permanent link\")", "anchor": "abaroutingnumber-indexhtmlpydanticextratypesroutingnumberabaroutingnumber-permanent-link", "md_text": "```\nABARoutingNumber(routing_number: str)\n```\n\nBases: `str`\n\nThe `ABARoutingNumber` data type is a string of 9 digits representing an ABA routing transit number.\n\nThe algorithm used to validate the routing number is described in the\n[ABA routing transit number](https://en.wikipedia.org/wiki/ABA_routing_transit_number#Check_digit)\nWikipedia article.\n\n```\nfrom pydantic import BaseModel\n\nfrom pydantic_extra_types.routing_number import ABARoutingNumber\n\n\nclass BankAccount(BaseModel):\n    routing_number: ABARoutingNumber\n\n\naccount = BankAccount(routing_number='122105155')\nprint(account)\n# > routing_number='122105155'\n```\n\nSource code in `pydantic_extra_types/routing_number.py`\n\n|  |  |\n| --- | --- |\n| ``` 41 42 43 ``` | ``` def __init__(self, routing_number: str):     self._validate_digits(routing_number)     self._routing_number = self._validate_routing_number(routing_number) ``` |\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_routing_numbers/index.html#abaroutingnumber-indexhtmlpydanticextratypesroutingnumberabaroutingnumber-permanent-link", "page": "api/pydantic_extra_types_routing_numbers/index.html", "source_site": "pydantic"}
{"title": "TimeZoneName [Â¶](index.html#pydantic_extra_types.timezone_name.TimeZoneName \"Permanent link\")", "anchor": "timezonename-indexhtmlpydanticextratypestimezonenametimezonename-permanent-link", "md_text": "Bases: `str`\n\nTimeZoneName is a custom string subclass for validating and serializing timezone names.\n\nThe TimeZoneName class uses the IANA Time Zone Database for validation.\nIt supports both strict and non-strict modes for timezone name validation.\n\n#### Examples:[Â¶](index.html#pydantic_extra_types.timezone_name.TimeZoneName--examples \"Permanent link\")\n\nSome examples of using the TimeZoneName class:\n\n##### Normal usage:[Â¶](index.html#pydantic_extra_types.timezone_name.TimeZoneName--normal-usage \"Permanent link\")\n\n```\nfrom pydantic_extra_types.timezone_name import TimeZoneName\nfrom pydantic import BaseModel\nclass Location(BaseModel):\n    city: str\n    timezone: TimeZoneName\n\nloc = Location(city=\"New York\", timezone=\"America/New_York\")\nprint(loc.timezone)\n\n>> America/New_York\n```\n\n##### Non-strict mode:[Â¶](index.html#pydantic_extra_types.timezone_name.TimeZoneName--non-strict-mode \"Permanent link\")\n\n```\nfrom pydantic_extra_types.timezone_name import TimeZoneName, timezone_name_settings\n\n@timezone_name_settings(strict=False)\nclass TZNonStrict(TimeZoneName):\n    pass\n\ntz = TZNonStrict(\"america/new_york\")\n\nprint(tz)\n\n>> america/new_york\n```", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_timezone_name/index.html#timezonename-indexhtmlpydanticextratypestimezonenametimezonename-permanent-link", "page": "api/pydantic_extra_types_timezone_name/index.html", "source_site": "pydantic"}
{"title": "get\\_timezones [Â¶](index.html#pydantic_extra_types.timezone_name.get_timezones \"Permanent link\")", "anchor": "gettimezones-indexhtmlpydanticextratypestimezonenamegettimezones-permanent-link", "md_text": "```\nget_timezones() -> set[str]\n```\n\nDetermine the timezone provider and return available timezones.\n\nSource code in `pydantic_extra_types/timezone_name.py`\n\n|  |  |\n| --- | --- |\n| ``` 45 46 47 48 49 50 51 52 53 54 55 56 57 ``` | ``` def get_timezones() -> set[str]:     \"\"\"Determine the timezone provider and return available timezones.\"\"\"     if _is_available('zoneinfo'):  # pragma: no cover         timezones = _tz_provider_from_zone_info()         if len(timezones) == 0:  # pragma: no cover             raise ImportError('No timezone provider found. Please install tzdata with \"pip install tzdata\"')         return timezones     elif _is_available('pytz'):  # pragma: no cover         return _tz_provider_from_pytz()     else:  # pragma: no cover         if sys.version_info[:2] == (3, 8):             raise ImportError('No pytz module found. Please install it with \"pip install pytz\"')         raise ImportError('No timezone provider found. Please install tzdata with \"pip install tzdata\"') ``` |\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_timezone_name/index.html#gettimezones-indexhtmlpydanticextratypestimezonenamegettimezones-permanent-link", "page": "api/pydantic_extra_types_timezone_name/index.html", "source_site": "pydantic"}
{"title": "ModelAfterValidatorWithoutInfo `module-attribute` [Â¶](index.html#pydantic.functional_validators.ModelAfterValidatorWithoutInfo \"Permanent link\")", "anchor": "modelaftervalidatorwithoutinfo-module-attribute-indexhtmlpydanticfunctionalvalidatorsmodelaftervalidatorwithoutinfo-permanent-link", "md_text": "```\nModelAfterValidatorWithoutInfo = Callable[\n    [_ModelType], _ModelType\n]\n```\n\nA `@model_validator` decorated function signature. This is used when `mode='after'` and the function does not\nhave info argument.", "url": "https://docs.pydantic.dev/latest/api/functional_validators/index.html#modelaftervalidatorwithoutinfo-module-attribute-indexhtmlpydanticfunctionalvalidatorsmodelaftervalidatorwithoutinfo-permanent-link", "page": "api/functional_validators/index.html", "source_site": "pydantic"}
{"title": "ModelAfterValidator `module-attribute` [Â¶](index.html#pydantic.functional_validators.ModelAfterValidator \"Permanent link\")", "anchor": "modelaftervalidator-module-attribute-indexhtmlpydanticfunctionalvalidatorsmodelaftervalidator-permanent-link", "md_text": "```\nModelAfterValidator = Callable[\n    [_ModelType, ValidationInfo[Any]], _ModelType\n]\n```\n\nA `@model_validator` decorated function signature. This is used when `mode='after'`.", "url": "https://docs.pydantic.dev/latest/api/functional_validators/index.html#modelaftervalidator-module-attribute-indexhtmlpydanticfunctionalvalidatorsmodelaftervalidator-permanent-link", "page": "api/functional_validators/index.html", "source_site": "pydantic"}
{"title": "AfterValidator `dataclass` [Â¶](index.html#pydantic.functional_validators.AfterValidator \"Permanent link\")", "anchor": "aftervalidator-dataclass-indexhtmlpydanticfunctionalvalidatorsaftervalidator-permanent-link", "md_text": "```\nAfterValidator(\n    func: (\n        NoInfoValidatorFunction | WithInfoValidatorFunction\n    ),\n)\n```\n\n[field *after* validators](../../concepts/validators/index.html#field-after-validator)\n\nA metadata class that indicates that a validation should be applied **after** the inner validation logic.\n\nAttributes:\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `func` | `NoInfoValidatorFunction | WithInfoValidatorFunction` | The validator function. |\n\nExample\n\n```\nfrom typing import Annotated\n\nfrom pydantic import AfterValidator, BaseModel, ValidationError\n\nMyInt = Annotated[int, AfterValidator(lambda v: v + 1)]\n\nclass Model(BaseModel):\n    a: MyInt\n\nprint(Model(a=1).a)\n#> 2\n\ntry:\n    Model(a='a')\nexcept ValidationError as e:\n    print(e.json(indent=2))\n    '''\n    [\n      {\n        \"type\": \"int_parsing\",\n        \"loc\": [\n          \"a\"\n        ],\n        \"msg\": \"Input should be a valid integer, unable to parse string as an integer\",\n        \"input\": \"a\",\n        \"url\": \"https://errors.pydantic.dev/2/v/int_parsing\"\n      }\n    ]\n    '''\n```", "url": "https://docs.pydantic.dev/latest/api/functional_validators/index.html#aftervalidator-dataclass-indexhtmlpydanticfunctionalvalidatorsaftervalidator-permanent-link", "page": "api/functional_validators/index.html", "source_site": "pydantic"}
{"title": "BeforeValidator `dataclass` [Â¶](index.html#pydantic.functional_validators.BeforeValidator \"Permanent link\")", "anchor": "beforevalidator-dataclass-indexhtmlpydanticfunctionalvalidatorsbeforevalidator-permanent-link", "md_text": "```\nBeforeValidator(\n    func: (\n        NoInfoValidatorFunction | WithInfoValidatorFunction\n    ),\n    json_schema_input_type: Any = PydanticUndefined,\n)\n```\n\n[field *before* validators](../../concepts/validators/index.html#field-before-validator)\n\nA metadata class that indicates that a validation should be applied **before** the inner validation logic.\n\nAttributes:\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `func` | `NoInfoValidatorFunction | WithInfoValidatorFunction` | The validator function. |\n| `json_schema_input_type` | `Any` | The input type used to generate the appropriate JSON Schema (in validation mode). The actual input type is `Any`. |\n\nExample\n\n```\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, BeforeValidator\n\nMyInt = Annotated[int, BeforeValidator(lambda v: v + 1)]\n\nclass Model(BaseModel):\n    a: MyInt\n\nprint(Model(a=1).a)\n#> 2\n\ntry:\n    Model(a='a')\nexcept TypeError as e:\n    print(e)\n    #> can only concatenate str (not \"int\") to str\n```", "url": "https://docs.pydantic.dev/latest/api/functional_validators/index.html#beforevalidator-dataclass-indexhtmlpydanticfunctionalvalidatorsbeforevalidator-permanent-link", "page": "api/functional_validators/index.html", "source_site": "pydantic"}
{"title": "PlainValidator `dataclass` [Â¶](index.html#pydantic.functional_validators.PlainValidator \"Permanent link\")", "anchor": "plainvalidator-dataclass-indexhtmlpydanticfunctionalvalidatorsplainvalidator-permanent-link", "md_text": "```\nPlainValidator(\n    func: (\n        NoInfoValidatorFunction | WithInfoValidatorFunction\n    ),\n    json_schema_input_type: Any = Any,\n)\n```\n\n[field *plain* validators](../../concepts/validators/index.html#field-plain-validator)\n\nA metadata class that indicates that a validation should be applied **instead** of the inner validation logic.\n\nBefore v2.9, `PlainValidator` wasn't always compatible with JSON Schema generation for `mode='validation'`.\nYou can now use the `json_schema_input_type` argument to specify the input type of the function\nto be used in the JSON schema when `mode='validation'` (the default). See the example below for more details.\n\nAttributes:\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `func` | `NoInfoValidatorFunction | WithInfoValidatorFunction` | The validator function. |\n| `json_schema_input_type` | `Any` | The input type used to generate the appropriate JSON Schema (in validation mode). The actual input type is `Any`. |\n\nExample\n\n```\nfrom typing import Annotated, Union\n\nfrom pydantic import BaseModel, PlainValidator\n\ndef validate(v: object) -> int:\n    if not isinstance(v, (int, str)):\n        raise ValueError(f'Expected int or str, go {type(v)}')\n\n    return int(v) + 1\n\nMyInt = Annotated[\n    int,\n    PlainValidator(validate, json_schema_input_type=Union[str, int]),  # (1)!\n]\n\nclass Model(BaseModel):\n    a: MyInt\n\nprint(Model(a='1').a)\n#> 2\n\nprint(Model(a=1).a)\n#> 2\n```\n\n1. In this example, we've specified the `json_schema_input_type` as `Union[str, int]` which indicates to the JSON schema\n   generator that in validation mode, the input type for the `a` field can be either a [`str`](https://docs.python.org/3/library/stdtypes.html#str) or an [`int`](https://docs.python.org/3/library/functions.html#int).", "url": "https://docs.pydantic.dev/latest/api/functional_validators/index.html#plainvalidator-dataclass-indexhtmlpydanticfunctionalvalidatorsplainvalidator-permanent-link", "page": "api/functional_validators/index.html", "source_site": "pydantic"}
{"title": "WrapValidator `dataclass` [Â¶](index.html#pydantic.functional_validators.WrapValidator \"Permanent link\")", "anchor": "wrapvalidator-dataclass-indexhtmlpydanticfunctionalvalidatorswrapvalidator-permanent-link", "md_text": "```\nWrapValidator(\n    func: (\n        NoInfoWrapValidatorFunction\n        | WithInfoWrapValidatorFunction\n    ),\n    json_schema_input_type: Any = PydanticUndefined,\n)\n```\n\n[field *wrap* validators](../../concepts/validators/index.html#field-wrap-validator)\n\nA metadata class that indicates that a validation should be applied **around** the inner validation logic.\n\nAttributes:\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `func` | `NoInfoWrapValidatorFunction | WithInfoWrapValidatorFunction` | The validator function. |\n| `json_schema_input_type` | `Any` | The input type used to generate the appropriate JSON Schema (in validation mode). The actual input type is `Any`. |\n\n```\nfrom datetime import datetime\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, ValidationError, WrapValidator\n\ndef validate_timestamp(v, handler):\n    if v == 'now':\n        # we don't want to bother with further validation, just return the new value\n        return datetime.now()\n    try:\n        return handler(v)\n    except ValidationError:\n        # validation failed, in this case we want to return a default value\n        return datetime(2000, 1, 1)\n\nMyTimestamp = Annotated[datetime, WrapValidator(validate_timestamp)]\n\nclass Model(BaseModel):\n    a: MyTimestamp\n\nprint(Model(a='now').a)\n#> 2032-01-02 03:04:05.000006\nprint(Model(a='invalid').a)\n#> 2000-01-01 00:00:00\n```", "url": "https://docs.pydantic.dev/latest/api/functional_validators/index.html#wrapvalidator-dataclass-indexhtmlpydanticfunctionalvalidatorswrapvalidator-permanent-link", "page": "api/functional_validators/index.html", "source_site": "pydantic"}
{"title": "ModelWrapValidatorHandler [Â¶](index.html#pydantic.functional_validators.ModelWrapValidatorHandler \"Permanent link\")", "anchor": "modelwrapvalidatorhandler-indexhtmlpydanticfunctionalvalidatorsmodelwrapvalidatorhandler-permanent-link", "md_text": "Bases: `ValidatorFunctionWrapHandler`, `Protocol[_ModelTypeCo]`\n\n`@model_validator` decorated function handler argument type. This is used when `mode='wrap'`.", "url": "https://docs.pydantic.dev/latest/api/functional_validators/index.html#modelwrapvalidatorhandler-indexhtmlpydanticfunctionalvalidatorsmodelwrapvalidatorhandler-permanent-link", "page": "api/functional_validators/index.html", "source_site": "pydantic"}
{"title": "ModelWrapValidatorWithoutInfo [Â¶](index.html#pydantic.functional_validators.ModelWrapValidatorWithoutInfo \"Permanent link\")", "anchor": "modelwrapvalidatorwithoutinfo-indexhtmlpydanticfunctionalvalidatorsmodelwrapvalidatorwithoutinfo-permanent-link", "md_text": "Bases: `Protocol[_ModelType]`\n\nA `@model_validator` decorated function signature.\nThis is used when `mode='wrap'` and the function does not have info argument.", "url": "https://docs.pydantic.dev/latest/api/functional_validators/index.html#modelwrapvalidatorwithoutinfo-indexhtmlpydanticfunctionalvalidatorsmodelwrapvalidatorwithoutinfo-permanent-link", "page": "api/functional_validators/index.html", "source_site": "pydantic"}
{"title": "ModelWrapValidator [Â¶](index.html#pydantic.functional_validators.ModelWrapValidator \"Permanent link\")", "anchor": "modelwrapvalidator-indexhtmlpydanticfunctionalvalidatorsmodelwrapvalidator-permanent-link", "md_text": "Bases: `Protocol[_ModelType]`\n\nA `@model_validator` decorated function signature. This is used when `mode='wrap'`.", "url": "https://docs.pydantic.dev/latest/api/functional_validators/index.html#modelwrapvalidator-indexhtmlpydanticfunctionalvalidatorsmodelwrapvalidator-permanent-link", "page": "api/functional_validators/index.html", "source_site": "pydantic"}
{"title": "FreeModelBeforeValidatorWithoutInfo [Â¶](index.html#pydantic.functional_validators.FreeModelBeforeValidatorWithoutInfo \"Permanent link\")", "anchor": "freemodelbeforevalidatorwithoutinfo-indexhtmlpydanticfunctionalvalidatorsfreemodelbeforevalidatorwithoutinfo-permanent-link", "md_text": "Bases: `Protocol`\n\nA `@model_validator` decorated function signature.\nThis is used when `mode='before'` and the function does not have info argument.", "url": "https://docs.pydantic.dev/latest/api/functional_validators/index.html#freemodelbeforevalidatorwithoutinfo-indexhtmlpydanticfunctionalvalidatorsfreemodelbeforevalidatorwithoutinfo-permanent-link", "page": "api/functional_validators/index.html", "source_site": "pydantic"}
{"title": "ModelBeforeValidatorWithoutInfo [Â¶](index.html#pydantic.functional_validators.ModelBeforeValidatorWithoutInfo \"Permanent link\")", "anchor": "modelbeforevalidatorwithoutinfo-indexhtmlpydanticfunctionalvalidatorsmodelbeforevalidatorwithoutinfo-permanent-link", "md_text": "Bases: `Protocol`\n\nA `@model_validator` decorated function signature.\nThis is used when `mode='before'` and the function does not have info argument.", "url": "https://docs.pydantic.dev/latest/api/functional_validators/index.html#modelbeforevalidatorwithoutinfo-indexhtmlpydanticfunctionalvalidatorsmodelbeforevalidatorwithoutinfo-permanent-link", "page": "api/functional_validators/index.html", "source_site": "pydantic"}
{"title": "FreeModelBeforeValidator [Â¶](index.html#pydantic.functional_validators.FreeModelBeforeValidator \"Permanent link\")", "anchor": "freemodelbeforevalidator-indexhtmlpydanticfunctionalvalidatorsfreemodelbeforevalidator-permanent-link", "md_text": "Bases: `Protocol`\n\nA `@model_validator` decorated function signature. This is used when `mode='before'`.", "url": "https://docs.pydantic.dev/latest/api/functional_validators/index.html#freemodelbeforevalidator-indexhtmlpydanticfunctionalvalidatorsfreemodelbeforevalidator-permanent-link", "page": "api/functional_validators/index.html", "source_site": "pydantic"}
{"title": "ModelBeforeValidator [Â¶](index.html#pydantic.functional_validators.ModelBeforeValidator \"Permanent link\")", "anchor": "modelbeforevalidator-indexhtmlpydanticfunctionalvalidatorsmodelbeforevalidator-permanent-link", "md_text": "Bases: `Protocol`\n\nA `@model_validator` decorated function signature. This is used when `mode='before'`.", "url": "https://docs.pydantic.dev/latest/api/functional_validators/index.html#modelbeforevalidator-indexhtmlpydanticfunctionalvalidatorsmodelbeforevalidator-permanent-link", "page": "api/functional_validators/index.html", "source_site": "pydantic"}
{"title": "InstanceOf `dataclass` [Â¶](index.html#pydantic.functional_validators.InstanceOf \"Permanent link\")", "anchor": "instanceof-dataclass-indexhtmlpydanticfunctionalvalidatorsinstanceof-permanent-link", "md_text": "```\nInstanceOf()\n```\n\nGeneric type for annotating a type that is an instance of a given class.\n\nExample\n\n```\nfrom pydantic import BaseModel, InstanceOf\n\nclass Foo:\n    ...\n\nclass Bar(BaseModel):\n    foo: InstanceOf[Foo]\n\nBar(foo=Foo())\ntry:\n    Bar(foo=42)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    [\n    â”‚   {\n    â”‚   â”‚   'type': 'is_instance_of',\n    â”‚   â”‚   'loc': ('foo',),\n    â”‚   â”‚   'msg': 'Input should be an instance of Foo',\n    â”‚   â”‚   'input': 42,\n    â”‚   â”‚   'ctx': {'class': 'Foo'},\n    â”‚   â”‚   'url': 'https://errors.pydantic.dev/0.38.0/v/is_instance_of'\n    â”‚   }\n    ]\n    \"\"\"\n```", "url": "https://docs.pydantic.dev/latest/api/functional_validators/index.html#instanceof-dataclass-indexhtmlpydanticfunctionalvalidatorsinstanceof-permanent-link", "page": "api/functional_validators/index.html", "source_site": "pydantic"}
{"title": "SkipValidation `dataclass` [Â¶](index.html#pydantic.functional_validators.SkipValidation \"Permanent link\")", "anchor": "skipvalidation-dataclass-indexhtmlpydanticfunctionalvalidatorsskipvalidation-permanent-link", "md_text": "```\nSkipValidation()\n```\n\nIf this is applied as an annotation (e.g., via `x: Annotated[int, SkipValidation]`), validation will be\nskipped. You can also use `SkipValidation[int]` as a shorthand for `Annotated[int, SkipValidation]`.\n\nThis can be useful if you want to use a type annotation for documentation/IDE/type-checking purposes,\nand know that it is safe to skip validation for one or more of the fields.\n\nBecause this converts the validation schema to `any_schema`, subsequent annotation-applied transformations\nmay not have the expected effects. Therefore, when used, this annotation should generally be the final\nannotation applied to a type.", "url": "https://docs.pydantic.dev/latest/api/functional_validators/index.html#skipvalidation-dataclass-indexhtmlpydanticfunctionalvalidatorsskipvalidation-permanent-link", "page": "api/functional_validators/index.html", "source_site": "pydantic"}
{"title": "ValidateAs [Â¶](index.html#pydantic.functional_validators.ValidateAs \"Permanent link\")", "anchor": "validateas-indexhtmlpydanticfunctionalvalidatorsvalidateas-permanent-link", "md_text": "```\nValidateAs(\n    from_type: type[_FromTypeT],\n    /,\n    instantiation_hook: Callable[[_FromTypeT], Any],\n)\n```\n\nA helper class to validate a custom type from a type that is natively supported by Pydantic.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `from_type` | `type[_FromTypeT]` | The type natively supported by Pydantic to use to perform validation. | *required* |\n| `instantiation_hook` | `Callable[[_FromTypeT], Any]` | A callable taking the validated type as an argument, and returning the populated custom type. | *required* |\n\nExample\n\n```\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, TypeAdapter, ValidateAs\n\nclass MyCls:\n    def __init__(self, a: int) -> None:\n        self.a = a\n\n    def __repr__(self) -> str:\n        return f\"MyCls(a={self.a})\"\n\nclass Model(BaseModel):\n    a: int\n\n\nta = TypeAdapter(\n    Annotated[MyCls, ValidateAs(Model, lambda v: MyCls(a=v.a))]\n)\n\nprint(ta.validate_python({'a': 1}))\n#> MyCls(a=1)\n```\n\n\nSource code in `pydantic/functional_validators.py`\n\n|  |  |\n| --- | --- |\n| ``` 884 885 886 ``` | ``` def __init__(self, from_type: type[_FromTypeT], /, instantiation_hook: Callable[[_FromTypeT], Any]) -> None:     self.from_type = from_type     self.instantiation_hook = instantiation_hook ``` |", "url": "https://docs.pydantic.dev/latest/api/functional_validators/index.html#validateas-indexhtmlpydanticfunctionalvalidatorsvalidateas-permanent-link", "page": "api/functional_validators/index.html", "source_site": "pydantic"}
{"title": "field\\_validator [Â¶](index.html#pydantic.functional_validators.field_validator \"Permanent link\")", "anchor": "fieldvalidator-indexhtmlpydanticfunctionalvalidatorsfieldvalidator-permanent-link", "md_text": "```\nfield_validator(\n    field: str,\n    /,\n    *fields: str,\n    mode: Literal[\"wrap\"],\n    check_fields: bool | None = ...,\n    json_schema_input_type: Any = ...,\n) -> Callable[[_V2WrapValidatorType], _V2WrapValidatorType]\n\nfield_validator(\n    field: str,\n    /,\n    *fields: str,\n    mode: Literal[\"before\", \"plain\"],\n    check_fields: bool | None = ...,\n    json_schema_input_type: Any = ...,\n) -> Callable[\n    [_V2BeforeAfterOrPlainValidatorType],\n    _V2BeforeAfterOrPlainValidatorType,\n]\n\nfield_validator(\n    field: str,\n    /,\n    *fields: str,\n    mode: Literal[\"after\"] = ...,\n    check_fields: bool | None = ...,\n) -> Callable[\n    [_V2BeforeAfterOrPlainValidatorType],\n    _V2BeforeAfterOrPlainValidatorType,\n]\n\nfield_validator(\n    field: str,\n    /,\n    *fields: str,\n    mode: FieldValidatorModes = \"after\",\n    check_fields: bool | None = None,\n    json_schema_input_type: Any = PydanticUndefined,\n) -> Callable[[Any], Any]\n```\n\n[field validators](../../concepts/validators/index.html#field-validators)\n\nDecorate methods on the class indicating that they should be used to validate fields.\n\nExample usage:\n\n```\nfrom typing import Any\n\nfrom pydantic import (\n    BaseModel,\n    ValidationError,\n    field_validator,\n)\n\nclass Model(BaseModel):\n    a: str\n\n    @field_validator('a')\n    @classmethod\n    def ensure_foobar(cls, v: Any):\n        if 'foobar' not in v:\n            raise ValueError('\"foobar\" not found in a')\n        return v\n\nprint(repr(Model(a='this is foobar good')))\n#> Model(a='this is foobar good')\n\ntry:\n    Model(a='snap')\nexcept ValidationError as exc_info:\n    print(exc_info)\n    '''\n    1 validation error for Model\n    a\n      Value error, \"foobar\" not found in a [type=value_error, input_value='snap', input_type=str]\n    '''\n```\n\nFor more in depth examples, see [Field Validators](../../concepts/validators/index.html#field-validators).\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `field` | `str` | The first field the `field_validator` should be called on; this is separate from `fields` to ensure an error is raised if you don't pass at least one. | *required* |\n| `*fields` | `str` | Additional field(s) the `field_validator` should be called on. | `()` |\n| `mode` | `FieldValidatorModes` | Specifies whether to validate the fields before or after validation. | `'after'` |\n| `check_fields` | `bool | None` | Whether to check that the fields actually exist on the model. | `None` |\n| `json_schema_input_type` | `Any` | The input type of the function. This is only used to generate the appropriate JSON Schema (in validation mode) and can only specified when `mode` is either `'before'`, `'plain'` or `'wrap'`. | `PydanticUndefined` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `Callable[[Any], Any]` | A decorator that can be used to decorate a function to be used as a field\\_validator. |\n\nRaises:\n\n| Type | Description |\n| --- | --- |\n| `PydanticUserError` | * If `@field_validator` is used bare (with no fields). * If the args passed to `@field_validator` as fields are not strings. * If `@field_validator` applied to instance methods. |\n\nSource code in `pydantic/functional_validators.py`", "url": "https://docs.pydantic.dev/latest/api/functional_validators/index.html#fieldvalidator-indexhtmlpydanticfunctionalvalidatorsfieldvalidator-permanent-link", "page": "api/functional_validators/index.html", "source_site": "pydantic"}
{"title": "field\\_validator [Â¶](index.html#pydantic.functional_validators.field_validator \"Permanent link\")", "anchor": "fieldvalidator-indexhtmlpydanticfunctionalvalidatorsfieldvalidator-permanent-link", "md_text": "|  |  |\n| --- | --- |\n| ``` 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 ``` | ``` def field_validator(     field: str,     /,     *fields: str,     mode: FieldValidatorModes = 'after',     check_fields: bool | None = None,     json_schema_input_type: Any = PydanticUndefined, ) -> Callable[[Any], Any]:     \"\"\"!!! abstract \"Usage Documentation\"         [field validators](../concepts/validators.md#field-validators)      Decorate methods on the class indicating that they should be used to validate fields.      Example usage:     ```python     from typing import Any      from pydantic import (         BaseModel,         ValidationError,         field_validator,     )      class Model(BaseModel):         a: str          @field_validator('a')         @classmethod         def ensure_foobar(cls, v: Any):             if 'foobar' not in v:                 raise ValueError('\"foobar\" not found in a')             return v      print(repr(Model(a='this is foobar good')))     #> Model(a='this is foobar good')      try:         Model(a='snap')     except ValidationError as exc_info:         print(exc_info)         '''         1 validation error for Model         a           Value error, \"foobar\" not found in a [type=value_error, input_value='snap', input_type=str]         '''     ```      For more in depth examples, see [Field Validators](../concepts/validators.md#field-validators).      Args:         field: The first field the `field_validator` should be called on; this is separate             from `fields` to ensure an error is raised if you don't pass at least one.         *fields: Additional field(s) the `field_validator` should be called on.         mode: Specifies whether to validate the fields before or after validation.         check_fields: Whether to check that the fields actually exist on the model.         json_schema_input_type: The input type of the function. This is only used to generate             the appropriate JSON Schema (in validation mode) and can only specified             when `mode` is either `'before'`, `'plain'` or `'wrap'`.      Returns:         A decorator that can be used to decorate a function to be used as a field_validator.      Raises:         PydanticUserError:             - If `@field_validator` is used bare (with no fields).             - If the args passed to `@field_validator` as fields are not strings.             - If `@field_validator` applied to instance methods.     \"\"\"     if isinstance(field, FunctionType):         raise PydanticUserError(             '`@field_validator` should be used with fields and keyword arguments, not bare. '             \"E.g. usage should be `@validator('<field_name>', ...)`\",             code='validator-no-fields',         )      if mode not in ('before', 'plain', 'wrap') and json_schema_input_type is not PydanticUndefined:         raise PydanticUserError(             f\"`json_schema_input_type` can't be used when mode is set to {mode!r}\",             code='validator-input-type',         )      if json_schema_input_type is PydanticUndefined and mode == 'plain':         json_schema_input_type = Any      fields = field, *fields     if not all(isinstance(field, str) for field in fields):         raise PydanticUserError(             '`@field_validator` fields should be passed as separate string args. '             \"E.g. usage should be `@validator('<field_name_1>', '<field_name_2>', ...)`\",             code='validator-invalid-fields',         )      def dec(         f: Callable[..., Any] | staticmethod[Any, Any] | classmethod[Any, Any, Any],     ) -> _decorators.PydanticDescriptorProxy[Any]:         if _decorators.is_instance_method_from_sig(f):             raise PydanticUserError(                 '`@field_validator` cannot be applied to instance methods', code='validator-instance-method'             )          # auto apply the @classmethod decorator         f = _decorators.ensure_classmethod_based_on_signature(f)          dec_info = _decorators.FieldValidatorDecoratorInfo(             fields=fields, mode=mode, check_fields=check_fields, json_schema_input_type=json_schema_input_type         )         return _decorators.PydanticDescriptorProxy(f, dec_info)      return dec ``` |", "url": "https://docs.pydantic.dev/latest/api/functional_validators/index.html#fieldvalidator-indexhtmlpydanticfunctionalvalidatorsfieldvalidator-permanent-link", "page": "api/functional_validators/index.html", "source_site": "pydantic"}
{"title": "model\\_validator [Â¶](index.html#pydantic.functional_validators.model_validator \"Permanent link\")", "anchor": "modelvalidator-indexhtmlpydanticfunctionalvalidatorsmodelvalidator-permanent-link", "md_text": "```\nmodel_validator(*, mode: Literal[\"wrap\"]) -> Callable[\n    [_AnyModelWrapValidator[_ModelType]],\n    PydanticDescriptorProxy[ModelValidatorDecoratorInfo],\n]\n\nmodel_validator(*, mode: Literal[\"before\"]) -> Callable[\n    [_AnyModelBeforeValidator],\n    PydanticDescriptorProxy[ModelValidatorDecoratorInfo],\n]\n\nmodel_validator(*, mode: Literal[\"after\"]) -> Callable[\n    [_AnyModelAfterValidator[_ModelType]],\n    PydanticDescriptorProxy[ModelValidatorDecoratorInfo],\n]\n\nmodel_validator(\n    *, mode: Literal[\"wrap\", \"before\", \"after\"]\n) -> Any\n```\n\n[Model Validators](../../concepts/validators/index.html#model-validators)\n\nDecorate model methods for validation purposes.\n\nExample usage:\n\n```\nfrom typing_extensions import Self\n\nfrom pydantic import BaseModel, ValidationError, model_validator\n\nclass Square(BaseModel):\n    width: float\n    height: float\n\n    @model_validator(mode='after')\n    def verify_square(self) -> Self:\n        if self.width != self.height:\n            raise ValueError('width and height do not match')\n        return self\n\ns = Square(width=1, height=1)\nprint(repr(s))\n#> Square(width=1.0, height=1.0)\n\ntry:\n    Square(width=1, height=2)\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for Square\n      Value error, width and height do not match [type=value_error, input_value={'width': 1, 'height': 2}, input_type=dict]\n    '''\n```\n\nFor more in depth examples, see [Model Validators](../../concepts/validators/index.html#model-validators).\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `mode` | `Literal['wrap', 'before', 'after']` | A required string literal that specifies the validation mode. It can be one of the following: 'wrap', 'before', or 'after'. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `Any` | A decorator that can be used to decorate a function to be used as a model validator. |\n\nSource code in `pydantic/functional_validators.py`\n\n|  |  |\n| --- | --- |\n| ``` 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 ``` | ``` def model_validator(     *,     mode: Literal['wrap', 'before', 'after'], ) -> Any:     \"\"\"!!! abstract \"Usage Documentation\"         [Model Validators](../concepts/validators.md#model-validators)      Decorate model methods for validation purposes.      Example usage:     ```python     from typing_extensions import Self      from pydantic import BaseModel, ValidationError, model_validator      class Square(BaseModel):         width: float         height: float          @model_validator(mode='after')         def verify_square(self) -> Self:             if self.width != self.height:                 raise ValueError('width and height do not match')             return self      s = Square(width=1, height=1)     print(repr(s))     #> Square(width=1.0, height=1.0)      try:         Square(width=1, height=2)     except ValidationError as e:         print(e)         '''         1 validation error for Square           Value error, width and height do not match [type=value_error, input_value={'width': 1, 'height': 2}, input_type=dict]         '''     ```      For more in depth examples, see [Model Validators](../concepts/validators.md#model-validators).      Args:         mode: A required string literal that specifies the validation mode.             It can be one of the following: 'wrap', 'before', or 'after'.      Returns:         A decorator that can be used to decorate a function to be used as a model validator.     \"\"\"      def dec(f: Any) -> _decorators.PydanticDescriptorProxy[Any]:         # auto apply the @classmethod decorator. NOTE: in V3, do not apply the conversion for 'after' validators:         f = _decorators.ensure_classmethod_based_on_signature(f)         if mode == 'after' and isinstance(f, classmethod):             warnings.warn(                 category=PydanticDeprecatedSince212,                 message=(                     \"Using `@model_validator` with mode='after' on a classmethod is deprecated. Instead, use an instance method. \"                     f'See the documentation at https://docs.pydantic.dev/{version_short()}/concepts/validators/#model-after-validator.'                 ),                 stacklevel=2,             )          dec_info = _decorators.ModelValidatorDecoratorInfo(mode=mode)         return _decorators.PydanticDescriptorProxy(f, dec_info)      return dec ``` |\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/api/functional_validators/index.html#modelvalidator-indexhtmlpydanticfunctionalvalidatorsmodelvalidator-permanent-link", "page": "api/functional_validators/index.html", "source_site": "pydantic"}
{"title": "RGBA [Â¶](index.html#pydantic_extra_types.color.RGBA \"Permanent link\")", "anchor": "rgba-indexhtmlpydanticextratypescolorrgba-permanent-link", "md_text": "```\nRGBA(r: float, g: float, b: float, alpha: float | None)\n```\n\nInternal use only as a representation of a color.\n\nSource code in `pydantic_extra_types/color.py`\n\n|  |  |\n| --- | --- |\n| ``` 32 33 34 35 36 37 38 ``` | ``` def __init__(self, r: float, g: float, b: float, alpha: float | None):     self.r = r     self.g = g     self.b = b     self.alpha = alpha      self._tuple: tuple[float, float, float, float | None] = (r, g, b, alpha) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_color/index.html#rgba-indexhtmlpydanticextratypescolorrgba-permanent-link", "page": "api/pydantic_extra_types_color/index.html", "source_site": "pydantic"}
{"title": "Color [Â¶](index.html#pydantic_extra_types.color.Color \"Permanent link\")", "anchor": "color-indexhtmlpydanticextratypescolorcolor-permanent-link", "md_text": "```\nColor(value: ColorType)\n```\n\nBases: `Representation`\n\nRepresents a color.\n\nSource code in `pydantic_extra_types/color.py`\n\n|  |  |\n| --- | --- |\n| ``` 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 ``` | ``` def __init__(self, value: ColorType) -> None:     self._rgba: RGBA     self._original: ColorType     if isinstance(value, (tuple, list)):         self._rgba = parse_tuple(value)     elif isinstance(value, str):         self._rgba = parse_str(value)     elif isinstance(value, Color):         self._rgba = value._rgba         value = value._original     else:         raise PydanticCustomError(             'color_error',             'value is not a valid color: value must be a tuple, list or string',         )      # if we've got here value must be a valid color     self._original = value ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_color/index.html#color-indexhtmlpydanticextratypescolorcolor-permanent-link", "page": "api/pydantic_extra_types_color/index.html", "source_site": "pydantic"}
{"title": "original [Â¶](index.html#pydantic_extra_types.color.Color.original \"Permanent link\")", "anchor": "original-indexhtmlpydanticextratypescolorcolororiginal-permanent-link", "md_text": "```\noriginal() -> ColorType\n```\n\nOriginal value passed to `Color`.\n\nSource code in `pydantic_extra_types/color.py`\n\n|  |  |\n| --- | --- |\n| ```  98  99 100 ``` | ``` def original(self) -> ColorType:     \"\"\"Original value passed to `Color`.\"\"\"     return self._original ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_color/index.html#original-indexhtmlpydanticextratypescolorcolororiginal-permanent-link", "page": "api/pydantic_extra_types_color/index.html", "source_site": "pydantic"}
{"title": "as\\_named [Â¶](index.html#pydantic_extra_types.color.Color.as_named \"Permanent link\")", "anchor": "asnamed-indexhtmlpydanticextratypescolorcolorasnamed-permanent-link", "md_text": "```\nas_named(*, fallback: bool = False) -> str\n```\n\nReturns the name of the color if it can be found in `COLORS_BY_VALUE` dictionary,\notherwise returns the hexadecimal representation of the color or raises `ValueError`.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `fallback` | `bool` | If True, falls back to returning the hexadecimal representation of the color instead of raising a ValueError when no named color is found. | `False` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `str` | The name of the color, or the hexadecimal representation of the color. |\n\nRaises:\n\n| Type | Description |\n| --- | --- |\n| `ValueError` | When no named color is found and fallback is `False`. |\n\nSource code in `pydantic_extra_types/color.py`\n\n|  |  |\n| --- | --- |\n| ``` 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 ``` | ``` def as_named(self, *, fallback: bool = False) -> str:     \"\"\"Returns the name of the color if it can be found in `COLORS_BY_VALUE` dictionary,     otherwise returns the hexadecimal representation of the color or raises `ValueError`.      Args:         fallback: If True, falls back to returning the hexadecimal representation of             the color instead of raising a ValueError when no named color is found.      Returns:         The name of the color, or the hexadecimal representation of the color.      Raises:         ValueError: When no named color is found and fallback is `False`.     \"\"\"     if self._rgba.alpha is not None:         return self.as_hex()     rgb = cast('tuple[int, int, int]', self.as_rgb_tuple())      if rgb in COLORS_BY_VALUE:         return COLORS_BY_VALUE[rgb]     else:         if fallback:             return self.as_hex()         else:             raise ValueError('no named color found, use fallback=True, as_hex() or as_rgb()') ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_color/index.html#asnamed-indexhtmlpydanticextratypescolorcolorasnamed-permanent-link", "page": "api/pydantic_extra_types_color/index.html", "source_site": "pydantic"}
{"title": "as\\_hex [Â¶](index.html#pydantic_extra_types.color.Color.as_hex \"Permanent link\")", "anchor": "ashex-indexhtmlpydanticextratypescolorcolorashex-permanent-link", "md_text": "```\nas_hex(format: Literal['short', 'long'] = 'short') -> str\n```\n\nReturns the hexadecimal representation of the color.\n\nHex string representing the color can be 3, 4, 6, or 8 characters depending on whether the string\na \"short\" representation of the color is possible and whether there's an alpha channel.\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `str` | The hexadecimal representation of the color. |\n\nSource code in `pydantic_extra_types/color.py`\n\n|  |  |\n| --- | --- |\n| ``` 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 ``` | ``` def as_hex(self, format: Literal['short', 'long'] = 'short') -> str:     \"\"\"Returns the hexadecimal representation of the color.      Hex string representing the color can be 3, 4, 6, or 8 characters depending on whether the string     a \"short\" representation of the color is possible and whether there's an alpha channel.      Returns:         The hexadecimal representation of the color.     \"\"\"     values = [float_to_255(c) for c in self._rgba[:3]]     if self._rgba.alpha is not None:         values.append(float_to_255(self._rgba.alpha))      as_hex = ''.join(f'{v:02x}' for v in values)     if format == 'short' and all(c in repeat_colors for c in values):         as_hex = ''.join(as_hex[c] for c in range(0, len(as_hex), 2))     return f'#{as_hex}' ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_color/index.html#ashex-indexhtmlpydanticextratypescolorcolorashex-permanent-link", "page": "api/pydantic_extra_types_color/index.html", "source_site": "pydantic"}
{"title": "as\\_rgb [Â¶](index.html#pydantic_extra_types.color.Color.as_rgb \"Permanent link\")", "anchor": "asrgb-indexhtmlpydanticextratypescolorcolorasrgb-permanent-link", "md_text": "```\nas_rgb() -> str\n```\n\nColor as an `rgb(<r>, <g>, <b>)` or `rgba(<r>, <g>, <b>, <a>)` string.\n\nSource code in `pydantic_extra_types/color.py`\n\n|  |  |\n| --- | --- |\n| ``` 146 147 148 149 150 151 152 153 154 ``` | ``` def as_rgb(self) -> str:     \"\"\"Color as an `rgb(<r>, <g>, <b>)` or `rgba(<r>, <g>, <b>, <a>)` string.\"\"\"     if self._rgba.alpha is None:         return f'rgb({float_to_255(self._rgba.r)}, {float_to_255(self._rgba.g)}, {float_to_255(self._rgba.b)})'     else:         return (             f'rgba({float_to_255(self._rgba.r)}, {float_to_255(self._rgba.g)}, {float_to_255(self._rgba.b)}, '             f'{round(self._alpha_float(), 2)})'         ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_color/index.html#asrgb-indexhtmlpydanticextratypescolorcolorasrgb-permanent-link", "page": "api/pydantic_extra_types_color/index.html", "source_site": "pydantic"}
{"title": "as\\_rgb\\_tuple [Â¶](index.html#pydantic_extra_types.color.Color.as_rgb_tuple \"Permanent link\")", "anchor": "asrgbtuple-indexhtmlpydanticextratypescolorcolorasrgbtuple-permanent-link", "md_text": "```\nas_rgb_tuple(*, alpha: bool | None = None) -> ColorTuple\n```\n\nReturns the color as an RGB or RGBA tuple.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `alpha` | `bool | None` | Whether to include the alpha channel. There are three options for this input:   * `None` (default): Include alpha only if it's set. (e.g. not `None`) * `True`: Always include alpha. * `False`: Always omit alpha. | `None` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `ColorTuple` | A tuple that contains the values of the red, green, and blue channels in the range 0 to 255. If alpha is included, it is in the range 0 to 1. |\n\nSource code in `pydantic_extra_types/color.py`\n\n|  |  |\n| --- | --- |\n| ``` 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 ``` | ``` def as_rgb_tuple(self, *, alpha: bool | None = None) -> ColorTuple:     \"\"\"Returns the color as an RGB or RGBA tuple.      Args:         alpha: Whether to include the alpha channel. There are three options for this input:              - `None` (default): Include alpha only if it's set. (e.g. not `None`)             - `True`: Always include alpha.             - `False`: Always omit alpha.      Returns:         A tuple that contains the values of the red, green, and blue channels in the range 0 to 255.             If alpha is included, it is in the range 0 to 1.     \"\"\"     r, g, b = (float_to_255(c) for c in self._rgba[:3])     if alpha is None and self._rgba.alpha is None or alpha is not None and not alpha:         return r, g, b     else:         return r, g, b, self._alpha_float() ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_color/index.html#asrgbtuple-indexhtmlpydanticextratypescolorcolorasrgbtuple-permanent-link", "page": "api/pydantic_extra_types_color/index.html", "source_site": "pydantic"}
{"title": "as\\_hsl [Â¶](index.html#pydantic_extra_types.color.Color.as_hsl \"Permanent link\")", "anchor": "ashsl-indexhtmlpydanticextratypescolorcolorashsl-permanent-link", "md_text": "```\nas_hsl() -> str\n```\n\nColor as an `hsl(<h>, <s>, <l>)` or `hsl(<h>, <s>, <l>, <a>)` string.\n\nSource code in `pydantic_extra_types/color.py`\n\n|  |  |\n| --- | --- |\n| ``` 176 177 178 179 180 181 182 183 ``` | ``` def as_hsl(self) -> str:     \"\"\"Color as an `hsl(<h>, <s>, <l>)` or `hsl(<h>, <s>, <l>, <a>)` string.\"\"\"     if self._rgba.alpha is None:         h, s, li = self.as_hsl_tuple(alpha=False)  # type: ignore         return f'hsl({h * 360:0.0f}, {s:0.0%}, {li:0.0%})'     else:         h, s, li, a = self.as_hsl_tuple(alpha=True)  # type: ignore         return f'hsl({h * 360:0.0f}, {s:0.0%}, {li:0.0%}, {round(a, 2)})' ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_color/index.html#ashsl-indexhtmlpydanticextratypescolorcolorashsl-permanent-link", "page": "api/pydantic_extra_types_color/index.html", "source_site": "pydantic"}
{"title": "as\\_hsl\\_tuple [Â¶](index.html#pydantic_extra_types.color.Color.as_hsl_tuple \"Permanent link\")", "anchor": "ashsltuple-indexhtmlpydanticextratypescolorcolorashsltuple-permanent-link", "md_text": "```\nas_hsl_tuple(*, alpha: bool | None = None) -> HslColorTuple\n```\n\nReturns the color as an HSL or HSLA tuple.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `alpha` | `bool | None` | Whether to include the alpha channel.   * `None` (default): Include the alpha channel only if it's set (e.g. not `None`). * `True`: Always include alpha. * `False`: Always omit alpha. | `None` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `HslColorTuple` | The color as a tuple of hue, saturation, lightness, and alpha (if included). All elements are in the range 0 to 1. |\n\nNote\n\nThis is HSL as used in HTML and most other places, not HLS as used in Python's `colorsys`.\n\n\nSource code in `pydantic_extra_types/color.py`\n\n|  |  |\n| --- | --- |\n| ``` 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 ``` | ``` def as_hsl_tuple(self, *, alpha: bool | None = None) -> HslColorTuple:     \"\"\"Returns the color as an HSL or HSLA tuple.      Args:         alpha: Whether to include the alpha channel.              - `None` (default): Include the alpha channel only if it's set (e.g. not `None`).             - `True`: Always include alpha.             - `False`: Always omit alpha.      Returns:         The color as a tuple of hue, saturation, lightness, and alpha (if included).             All elements are in the range 0 to 1.      Note:         This is HSL as used in HTML and most other places, not HLS as used in Python's `colorsys`.     \"\"\"     h, l, s = rgb_to_hls(self._rgba.r, self._rgba.g, self._rgba.b)     if alpha is None:         if self._rgba.alpha is None:             return h, s, l         else:             return h, s, l, self._alpha_float()     return (h, s, l, self._alpha_float()) if alpha else (h, s, l) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_color/index.html#ashsltuple-indexhtmlpydanticextratypescolorcolorashsltuple-permanent-link", "page": "api/pydantic_extra_types_color/index.html", "source_site": "pydantic"}
{"title": "parse\\_tuple [Â¶](index.html#pydantic_extra_types.color.parse_tuple \"Permanent link\")", "anchor": "parsetuple-indexhtmlpydanticextratypescolorparsetuple-permanent-link", "md_text": "```\nparse_tuple(value: tuple[Any, ...]) -> RGBA\n```\n\nParse a tuple or list to get RGBA values.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `value` | `tuple[Any, ...]` | A tuple or list. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `RGBA` | An `RGBA` tuple parsed from the input tuple. |\n\nRaises:\n\n| Type | Description |\n| --- | --- |\n| `PydanticCustomError` | If tuple is not valid. |\n\nSource code in `pydantic_extra_types/color.py`\n\n|  |  |\n| --- | --- |\n| ``` 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 ``` | ``` def parse_tuple(value: tuple[Any, ...]) -> RGBA:     \"\"\"Parse a tuple or list to get RGBA values.      Args:         value: A tuple or list.      Returns:         An `RGBA` tuple parsed from the input tuple.      Raises:         PydanticCustomError: If tuple is not valid.     \"\"\"     if len(value) == 3:         r, g, b = (parse_color_value(v) for v in value)         return RGBA(r, g, b, None)     elif len(value) == 4:         r, g, b = (parse_color_value(v) for v in value[:3])         return RGBA(r, g, b, parse_float_alpha(value[3]))     else:         raise PydanticCustomError('color_error', 'value is not a valid color: tuples must have length 3 or 4') ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_color/index.html#parsetuple-indexhtmlpydanticextratypescolorparsetuple-permanent-link", "page": "api/pydantic_extra_types_color/index.html", "source_site": "pydantic"}
{"title": "parse\\_str [Â¶](index.html#pydantic_extra_types.color.parse_str \"Permanent link\")", "anchor": "parsestr-indexhtmlpydanticextratypescolorparsestr-permanent-link", "md_text": "```\nparse_str(value: str) -> RGBA\n```\n\nParse a string representing a color to an RGBA tuple.\n\nPossible formats for the input string include:\n\n* named color, see `COLORS_BY_NAME`\n* hex short eg. `<prefix>fff` (prefix can be `#`, `0x` or nothing)\n* hex long eg. `<prefix>ffffff` (prefix can be `#`, `0x` or nothing)\n* `rgb(<r>, <g>, <b>)`\n* `rgba(<r>, <g>, <b>, <a>)`\n* `transparent`\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `value` | `str` | A string representing a color. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `RGBA` | An `RGBA` tuple parsed from the input string. |\n\nRaises:\n\n| Type | Description |\n| --- | --- |\n| `ValueError` | If the input string cannot be parsed to an RGBA tuple. |\n\nSource code in `pydantic_extra_types/color.py`\n\n|  |  |\n| --- | --- |\n| ``` 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 ``` | ``` def parse_str(value: str) -> RGBA:     \"\"\"Parse a string representing a color to an RGBA tuple.      Possible formats for the input string include:      * named color, see `COLORS_BY_NAME`     * hex short eg. `<prefix>fff` (prefix can be `#`, `0x` or nothing)     * hex long eg. `<prefix>ffffff` (prefix can be `#`, `0x` or nothing)     * `rgb(<r>, <g>, <b>)`     * `rgba(<r>, <g>, <b>, <a>)`     * `transparent`      Args:         value: A string representing a color.      Returns:         An `RGBA` tuple parsed from the input string.      Raises:         ValueError: If the input string cannot be parsed to an RGBA tuple.     \"\"\"     value_lower = value.lower()     if value_lower in COLORS_BY_NAME:         r, g, b = COLORS_BY_NAME[value_lower]         return ints_to_rgba(r, g, b, None)      m = re.fullmatch(r_hex_short, value_lower)     if m:         *rgb, a = m.groups()         r, g, b = (int(v * 2, 16) for v in rgb)         alpha = int(a * 2, 16) / 255 if a else None         return ints_to_rgba(r, g, b, alpha)      m = re.fullmatch(r_hex_long, value_lower)     if m:         *rgb, a = m.groups()         r, g, b = (int(v, 16) for v in rgb)         alpha = int(a, 16) / 255 if a else None         return ints_to_rgba(r, g, b, alpha)      m = re.fullmatch(r_rgb, value_lower) or re.fullmatch(r_rgb_v4_style, value_lower)     if m:         return ints_to_rgba(*m.groups())  # type: ignore      m = re.fullmatch(r_hsl, value_lower) or re.fullmatch(r_hsl_v4_style, value_lower)     if m:         return parse_hsl(*m.groups())  # type: ignore      if value_lower == 'transparent':         return RGBA(0, 0, 0, 0)      raise PydanticCustomError(         'color_error',         'value is not a valid color: string not recognised as a valid color',     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_color/index.html#parsestr-indexhtmlpydanticextratypescolorparsestr-permanent-link", "page": "api/pydantic_extra_types_color/index.html", "source_site": "pydantic"}
{"title": "ints\\_to\\_rgba [Â¶](index.html#pydantic_extra_types.color.ints_to_rgba \"Permanent link\")", "anchor": "intstorgba-indexhtmlpydanticextratypescolorintstorgba-permanent-link", "md_text": "```\nints_to_rgba(\n    r: int | str,\n    g: int | str,\n    b: int | str,\n    alpha: float | None = None,\n) -> RGBA\n```\n\nConverts integer or string values for RGB color and an optional alpha value to an `RGBA` object.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `r` | `int | str` | An integer or string representing the red color value. | *required* |\n| `g` | `int | str` | An integer or string representing the green color value. | *required* |\n| `b` | `int | str` | An integer or string representing the blue color value. | *required* |\n| `alpha` | `float | None` | A float representing the alpha value. Defaults to None. | `None` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `RGBA` | An instance of the `RGBA` class with the corresponding color and alpha values. |\n\nSource code in `pydantic_extra_types/color.py`\n\n|  |  |\n| --- | --- |\n| ``` 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 ``` | ``` def ints_to_rgba(     r: int | str,     g: int | str,     b: int | str,     alpha: float | None = None, ) -> RGBA:     \"\"\"Converts integer or string values for RGB color and an optional alpha value to an `RGBA` object.      Args:         r: An integer or string representing the red color value.         g: An integer or string representing the green color value.         b: An integer or string representing the blue color value.         alpha: A float representing the alpha value. Defaults to None.      Returns:         An instance of the `RGBA` class with the corresponding color and alpha values.     \"\"\"     return RGBA(         parse_color_value(r),         parse_color_value(g),         parse_color_value(b),         parse_float_alpha(alpha),     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_color/index.html#intstorgba-indexhtmlpydanticextratypescolorintstorgba-permanent-link", "page": "api/pydantic_extra_types_color/index.html", "source_site": "pydantic"}
{"title": "parse\\_color\\_value [Â¶](index.html#pydantic_extra_types.color.parse_color_value \"Permanent link\")", "anchor": "parsecolorvalue-indexhtmlpydanticextratypescolorparsecolorvalue-permanent-link", "md_text": "```\nparse_color_value(\n    value: int | str, max_val: int = 255\n) -> float\n```\n\nParse the color value provided and return a number between 0 and 1.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `value` | `int | str` | An integer or string color value. | *required* |\n| `max_val` | `int` | Maximum range value. Defaults to 255. | `255` |\n\nRaises:\n\n| Type | Description |\n| --- | --- |\n| `PydanticCustomError` | If the value is not a valid color. |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `float` | A number between 0 and 1. |\n\nSource code in `pydantic_extra_types/color.py`\n\n|  |  |\n| --- | --- |\n| ``` 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 ``` | ``` def parse_color_value(value: int | str, max_val: int = 255) -> float:     \"\"\"Parse the color value provided and return a number between 0 and 1.      Args:         value: An integer or string color value.         max_val: Maximum range value. Defaults to 255.      Raises:         PydanticCustomError: If the value is not a valid color.      Returns:         A number between 0 and 1.     \"\"\"     try:         color = float(value)     except (ValueError, TypeError) as e:         raise PydanticCustomError(             'color_error',             'value is not a valid color: color values must be a valid number',         ) from e     if 0 <= color <= max_val:         return color / max_val     else:         raise PydanticCustomError(             'color_error',             'value is not a valid color: color values must be in the range 0 to {max_val}',             {'max_val': max_val},         ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_color/index.html#parsecolorvalue-indexhtmlpydanticextratypescolorparsecolorvalue-permanent-link", "page": "api/pydantic_extra_types_color/index.html", "source_site": "pydantic"}
{"title": "parse\\_float\\_alpha [Â¶](index.html#pydantic_extra_types.color.parse_float_alpha \"Permanent link\")", "anchor": "parsefloatalpha-indexhtmlpydanticextratypescolorparsefloatalpha-permanent-link", "md_text": "```\nparse_float_alpha(\n    value: None | str | float | int,\n) -> float | None\n```\n\nParse an alpha value checking it's a valid float in the range 0 to 1.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `value` | `None | str | float | int` | The input value to parse. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `float | None` | The parsed value as a float, or `None` if the value was None or equal 1. |\n\nRaises:\n\n| Type | Description |\n| --- | --- |\n| `PydanticCustomError` | If the input value cannot be successfully parsed as a float in the expected range. |\n\nSource code in `pydantic_extra_types/color.py`\n\n|  |  |\n| --- | --- |\n| ``` 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 ``` | ``` def parse_float_alpha(value: None | str | float | int) -> float | None:     \"\"\"Parse an alpha value checking it's a valid float in the range 0 to 1.      Args:         value: The input value to parse.      Returns:         The parsed value as a float, or `None` if the value was None or equal 1.      Raises:         PydanticCustomError: If the input value cannot be successfully parsed as a float in the expected range.     \"\"\"     if value is None:         return None     try:         if isinstance(value, str) and value.endswith('%'):             alpha = float(value[:-1]) / 100         else:             alpha = float(value)     except ValueError as e:         raise PydanticCustomError(             'color_error',             'value is not a valid color: alpha values must be a valid float',         ) from e      if math.isclose(alpha, 1):         return None     elif 0 <= alpha <= 1:         return alpha     else:         raise PydanticCustomError(             'color_error',             'value is not a valid color: alpha values must be in the range 0 to 1',         ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_color/index.html#parsefloatalpha-indexhtmlpydanticextratypescolorparsefloatalpha-permanent-link", "page": "api/pydantic_extra_types_color/index.html", "source_site": "pydantic"}
{"title": "parse\\_hsl [Â¶](index.html#pydantic_extra_types.color.parse_hsl \"Permanent link\")", "anchor": "parsehsl-indexhtmlpydanticextratypescolorparsehsl-permanent-link", "md_text": "```\nparse_hsl(\n    h: str,\n    h_units: str,\n    sat: str,\n    light: str,\n    alpha: float | None = None,\n) -> RGBA\n```\n\nParse raw hue, saturation, lightness, and alpha values and convert to RGBA.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `h` | `str` | The hue value. | *required* |\n| `h_units` | `str` | The unit for hue value. | *required* |\n| `sat` | `str` | The saturation value. | *required* |\n| `light` | `str` | The lightness value. | *required* |\n| `alpha` | `float | None` | Alpha value. | `None` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `RGBA` | An instance of `RGBA`. |\n\nSource code in `pydantic_extra_types/color.py`\n\n|  |  |\n| --- | --- |\n| ``` 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 ``` | ``` def parse_hsl(h: str, h_units: str, sat: str, light: str, alpha: float | None = None) -> RGBA:     \"\"\"Parse raw hue, saturation, lightness, and alpha values and convert to RGBA.      Args:         h: The hue value.         h_units: The unit for hue value.         sat: The saturation value.         light: The lightness value.         alpha: Alpha value.      Returns:         An instance of `RGBA`.     \"\"\"     s_value, l_value = parse_color_value(sat, 100), parse_color_value(light, 100)      h_value = float(h)     if h_units in {None, 'deg'}:         h_value = h_value % 360 / 360     elif h_units == 'rad':         h_value = h_value % rads / rads     else:         # turns         h_value %= 1      r, g, b = hls_to_rgb(h_value, l_value, s_value)     return RGBA(r, g, b, parse_float_alpha(alpha)) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_color/index.html#parsehsl-indexhtmlpydanticextratypescolorparsehsl-permanent-link", "page": "api/pydantic_extra_types_color/index.html", "source_site": "pydantic"}
{"title": "float\\_to\\_255 [Â¶](index.html#pydantic_extra_types.color.float_to_255 \"Permanent link\")", "anchor": "floatto255-indexhtmlpydanticextratypescolorfloatto255-permanent-link", "md_text": "```\nfloat_to_255(c: float) -> int\n```\n\nConverts a float value between 0 and 1 (inclusive) to an integer between 0 and 255 (inclusive).\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `c` | `float` | The float value to be converted. Must be between 0 and 1 (inclusive). | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `int` | The integer equivalent of the given float value rounded to the nearest whole number. |\n\nSource code in `pydantic_extra_types/color.py`\n\n|  |  |\n| --- | --- |\n| ``` 436 437 438 439 440 441 442 443 444 445 ``` | ``` def float_to_255(c: float) -> int:     \"\"\"Converts a float value between 0 and 1 (inclusive) to an integer between 0 and 255 (inclusive).      Args:         c: The float value to be converted. Must be between 0 and 1 (inclusive).      Returns:         The integer equivalent of the given float value rounded to the nearest whole number.     \"\"\"     return round(c * 255) ``` |\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_color/index.html#floatto255-indexhtmlpydanticextratypescolorfloatto255-permanent-link", "page": "api/pydantic_extra_types_color/index.html", "source_site": "pydantic"}
{"title": "WhenUsed `module-attribute` [Â¶](index.html#pydantic_core.core_schema.WhenUsed \"Permanent link\")", "anchor": "whenused-module-attribute-indexhtmlpydanticcorecoreschemawhenused-permanent-link", "md_text": "```\nWhenUsed = Literal[\n    \"always\", \"unless-none\", \"json\", \"json-unless-none\"\n]\n```\n\nValues have the following meanings:\n\n* `'always'` means always use\n* `'unless-none'` means use unless the value is `None`\n* `'json'` means use when serializing to JSON\n* `'json-unless-none'` means use when serializing to JSON and the value is not `None`", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#whenused-module-attribute-indexhtmlpydanticcorecoreschemawhenused-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "CoreConfig [Â¶](index.html#pydantic_core.core_schema.CoreConfig \"Permanent link\")", "anchor": "coreconfig-indexhtmlpydanticcorecoreschemacoreconfig-permanent-link", "md_text": "Bases: `TypedDict`\n\nBase class for schema configuration options.\n\nAttributes:\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `title` | `str` | The name of the configuration. |\n| `strict` | `bool` | Whether the configuration should strictly adhere to specified rules. |\n| `extra_fields_behavior` | `ExtraBehavior` | The behavior for handling extra fields. |\n| `typed_dict_total` | `bool` | Whether the TypedDict should be considered total. Default is `True`. |\n| `from_attributes` | `bool` | Whether to use attributes for models, dataclasses, and tagged union keys. |\n| `loc_by_alias` | `bool` | Whether to use the used alias (or first alias for \"field required\" errors) instead of `field_names` to construct error `loc`s. Default is `True`. |\n| `revalidate_instances` | `Literal['always', 'never', 'subclass-instances']` | Whether instances of models and dataclasses should re-validate. Default is 'never'. |\n| `validate_default` | `bool` | Whether to validate default values during validation. Default is `False`. |\n| `str_max_length` | `int` | The maximum length for string fields. |\n| `str_min_length` | `int` | The minimum length for string fields. |\n| `str_strip_whitespace` | `bool` | Whether to strip whitespace from string fields. |\n| `str_to_lower` | `bool` | Whether to convert string fields to lowercase. |\n| `str_to_upper` | `bool` | Whether to convert string fields to uppercase. |\n| `allow_inf_nan` | `bool` | Whether to allow infinity and NaN values for float fields. Default is `True`. |\n| `ser_json_timedelta` | `Literal['iso8601', 'float']` | The serialization option for `timedelta` values. Default is 'iso8601'. Note that if ser\\_json\\_temporal is set, then this param will be ignored. |\n| `ser_json_temporal` | `Literal['iso8601', 'seconds', 'milliseconds']` | The serialization option for datetime like values. Default is 'iso8601'. The types this covers are datetime, date, time and timedelta. If this is set, it will take precedence over ser\\_json\\_timedelta |\n| `ser_json_bytes` | `Literal['utf8', 'base64', 'hex']` | The serialization option for `bytes` values. Default is 'utf8'. |\n| `ser_json_inf_nan` | `Literal['null', 'constants', 'strings']` | The serialization option for infinity and NaN values in float fields. Default is 'null'. |\n| `val_json_bytes` | `Literal['utf8', 'base64', 'hex']` | The validation option for `bytes` values, complementing ser\\_json\\_bytes. Default is 'utf8'. |\n| `hide_input_in_errors` | `bool` | Whether to hide input data from `ValidationError` representation. |\n| `validation_error_cause` | `bool` | Whether to add user-python excs to the **cause** of a ValidationError. Requires exceptiongroup backport pre Python 3.11. |\n| `coerce_numbers_to_str` | `bool` | Whether to enable coercion of any `Number` type to `str` (not applicable in `strict` mode). |\n| `regex_engine` | `Literal['rust-regex', 'python-re']` | The regex engine to use for regex pattern validation. Default is 'rust-regex'. See `StringSchema`. |\n| `cache_strings` | `Union[bool, Literal['all', 'keys', 'none']]` | Whether to cache strings. Default is `True`, `True` or `'all'` is required to cache strings during general validation since validators don't know if they're in a key or a value. |\n| `validate_by_alias` | `bool` | Whether to use the field's alias when validating against the provided input data. Default is `True`. |\n| `validate_by_name` | `bool` | Whether to use the field's name when validating against the provided input data. Default is `False`. Replacement for `populate_by_name`. |\n| `serialize_by_alias` | `bool` | Whether to serialize by alias. Default is `False`, expected to change to `True` in V3. |\n| `url_preserve_empty_path` | `bool` | Whether to preserve empty URL paths when validating values for a URL type. Defaults to `False`. |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#coreconfig-indexhtmlpydanticcorecoreschemacoreconfig-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "SerializationInfo [Â¶](index.html#pydantic_core.core_schema.SerializationInfo \"Permanent link\")", "anchor": "serializationinfo-indexhtmlpydanticcorecoreschemaserializationinfo-permanent-link", "md_text": "Bases: `Protocol[ContextT]`\n\nExtra data used during serialization.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#serializationinfo-indexhtmlpydanticcorecoreschemaserializationinfo-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "include `property` [Â¶](index.html#pydantic_core.core_schema.SerializationInfo.include \"Permanent link\")", "anchor": "include-property-indexhtmlpydanticcorecoreschemaserializationinfoinclude-permanent-link", "md_text": "```\ninclude: IncExCall\n```\n\nThe `include` argument set during serialization.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#include-property-indexhtmlpydanticcorecoreschemaserializationinfoinclude-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "exclude `property` [Â¶](index.html#pydantic_core.core_schema.SerializationInfo.exclude \"Permanent link\")", "anchor": "exclude-property-indexhtmlpydanticcorecoreschemaserializationinfoexclude-permanent-link", "md_text": "```\nexclude: IncExCall\n```\n\nThe `exclude` argument set during serialization.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#exclude-property-indexhtmlpydanticcorecoreschemaserializationinfoexclude-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "context `property` [Â¶](index.html#pydantic_core.core_schema.SerializationInfo.context \"Permanent link\")", "anchor": "context-property-indexhtmlpydanticcorecoreschemaserializationinfocontext-permanent-link", "md_text": "```\ncontext: ContextT\n```\n\nThe current serialization context.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#context-property-indexhtmlpydanticcorecoreschemaserializationinfocontext-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "mode `property` [Â¶](index.html#pydantic_core.core_schema.SerializationInfo.mode \"Permanent link\")", "anchor": "mode-property-indexhtmlpydanticcorecoreschemaserializationinfomode-permanent-link", "md_text": "```\nmode: Literal['python', 'json'] | str\n```\n\nThe serialization mode set during serialization.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#mode-property-indexhtmlpydanticcorecoreschemaserializationinfomode-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "by\\_alias `property` [Â¶](index.html#pydantic_core.core_schema.SerializationInfo.by_alias \"Permanent link\")", "anchor": "byalias-property-indexhtmlpydanticcorecoreschemaserializationinfobyalias-permanent-link", "md_text": "```\nby_alias: bool\n```\n\nThe `by_alias` argument set during serialization.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#byalias-property-indexhtmlpydanticcorecoreschemaserializationinfobyalias-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "exclude\\_unset `property` [Â¶](index.html#pydantic_core.core_schema.SerializationInfo.exclude_unset \"Permanent link\")", "anchor": "excludeunset-property-indexhtmlpydanticcorecoreschemaserializationinfoexcludeunset-permanent-link", "md_text": "```\nexclude_unset: bool\n```\n\nThe `exclude_unset` argument set during serialization.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#excludeunset-property-indexhtmlpydanticcorecoreschemaserializationinfoexcludeunset-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "exclude\\_defaults `property` [Â¶](index.html#pydantic_core.core_schema.SerializationInfo.exclude_defaults \"Permanent link\")", "anchor": "excludedefaults-property-indexhtmlpydanticcorecoreschemaserializationinfoexcludedefaults-permanent-link", "md_text": "```\nexclude_defaults: bool\n```\n\nThe `exclude_defaults` argument set during serialization.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#excludedefaults-property-indexhtmlpydanticcorecoreschemaserializationinfoexcludedefaults-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "exclude\\_none `property` [Â¶](index.html#pydantic_core.core_schema.SerializationInfo.exclude_none \"Permanent link\")", "anchor": "excludenone-property-indexhtmlpydanticcorecoreschemaserializationinfoexcludenone-permanent-link", "md_text": "```\nexclude_none: bool\n```\n\nThe `exclude_none` argument set during serialization.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#excludenone-property-indexhtmlpydanticcorecoreschemaserializationinfoexcludenone-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "exclude\\_computed\\_fields `property` [Â¶](index.html#pydantic_core.core_schema.SerializationInfo.exclude_computed_fields \"Permanent link\")", "anchor": "excludecomputedfields-property-indexhtmlpydanticcorecoreschemaserializationinfoexcludecomputedfields-permanent-link", "md_text": "```\nexclude_computed_fields: bool\n```\n\nThe `exclude_computed_fields` argument set during serialization.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#excludecomputedfields-property-indexhtmlpydanticcorecoreschemaserializationinfoexcludecomputedfields-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "serialize\\_as\\_any `property` [Â¶](index.html#pydantic_core.core_schema.SerializationInfo.serialize_as_any \"Permanent link\")", "anchor": "serializeasany-property-indexhtmlpydanticcorecoreschemaserializationinfoserializeasany-permanent-link", "md_text": "```\nserialize_as_any: bool\n```\n\nThe `serialize_as_any` argument set during serialization.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#serializeasany-property-indexhtmlpydanticcorecoreschemaserializationinfoserializeasany-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "round\\_trip `property` [Â¶](index.html#pydantic_core.core_schema.SerializationInfo.round_trip \"Permanent link\")", "anchor": "roundtrip-property-indexhtmlpydanticcorecoreschemaserializationinforoundtrip-permanent-link", "md_text": "```\nround_trip: bool\n```\n\nThe `round_trip` argument set during serialization.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#roundtrip-property-indexhtmlpydanticcorecoreschemaserializationinforoundtrip-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "FieldSerializationInfo [Â¶](index.html#pydantic_core.core_schema.FieldSerializationInfo \"Permanent link\")", "anchor": "fieldserializationinfo-indexhtmlpydanticcorecoreschemafieldserializationinfo-permanent-link", "md_text": "Bases: `SerializationInfo[ContextT]`, `Protocol`\n\nExtra data used during field serialization.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#fieldserializationinfo-indexhtmlpydanticcorecoreschemafieldserializationinfo-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "field\\_name `property` [Â¶](index.html#pydantic_core.core_schema.FieldSerializationInfo.field_name \"Permanent link\")", "anchor": "fieldname-property-indexhtmlpydanticcorecoreschemafieldserializationinfofieldname-permanent-link", "md_text": "```\nfield_name: str\n```\n\nThe name of the current field being serialized.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#fieldname-property-indexhtmlpydanticcorecoreschemafieldserializationinfofieldname-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "ValidationInfo [Â¶](index.html#pydantic_core.core_schema.ValidationInfo \"Permanent link\")", "anchor": "validationinfo-indexhtmlpydanticcorecoreschemavalidationinfo-permanent-link", "md_text": "Bases: `Protocol[ContextT]`\n\nExtra data used during validation.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#validationinfo-indexhtmlpydanticcorecoreschemavalidationinfo-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "context `property` [Â¶](index.html#pydantic_core.core_schema.ValidationInfo.context \"Permanent link\")", "anchor": "context-property-indexhtmlpydanticcorecoreschemavalidationinfocontext-permanent-link", "md_text": "```\ncontext: ContextT\n```\n\nThe current validation context.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#context-property-indexhtmlpydanticcorecoreschemavalidationinfocontext-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "config `property` [Â¶](index.html#pydantic_core.core_schema.ValidationInfo.config \"Permanent link\")", "anchor": "config-property-indexhtmlpydanticcorecoreschemavalidationinfoconfig-permanent-link", "md_text": "```\nconfig: CoreConfig | None\n```\n\nThe CoreConfig that applies to this validation.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#config-property-indexhtmlpydanticcorecoreschemavalidationinfoconfig-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "mode `property` [Â¶](index.html#pydantic_core.core_schema.ValidationInfo.mode \"Permanent link\")", "anchor": "mode-property-indexhtmlpydanticcorecoreschemavalidationinfomode-permanent-link", "md_text": "```\nmode: Literal['python', 'json']\n```\n\nThe type of input data we are currently validating.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#mode-property-indexhtmlpydanticcorecoreschemavalidationinfomode-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "data `property` [Â¶](index.html#pydantic_core.core_schema.ValidationInfo.data \"Permanent link\")", "anchor": "data-property-indexhtmlpydanticcorecoreschemavalidationinfodata-permanent-link", "md_text": "```\ndata: dict[str, Any]\n```\n\nThe data being validated for this model.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#data-property-indexhtmlpydanticcorecoreschemavalidationinfodata-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "field\\_name `property` [Â¶](index.html#pydantic_core.core_schema.ValidationInfo.field_name \"Permanent link\")", "anchor": "fieldname-property-indexhtmlpydanticcorecoreschemavalidationinfofieldname-permanent-link", "md_text": "```\nfield_name: str | None\n```\n\nThe name of the current field being validated if this validator is\nattached to a model field.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#fieldname-property-indexhtmlpydanticcorecoreschemavalidationinfofieldname-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "simple\\_ser\\_schema [Â¶](index.html#pydantic_core.core_schema.simple_ser_schema \"Permanent link\")", "anchor": "simpleserschema-indexhtmlpydanticcorecoreschemasimpleserschema-permanent-link", "md_text": "```\nsimple_ser_schema(\n    type: ExpectedSerializationTypes,\n) -> SimpleSerSchema\n```\n\nReturns a schema for serialization with a custom type.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `type` | `ExpectedSerializationTypes` | The type to use for serialization | *required* |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 267 268 269 270 271 272 273 274 ``` | ``` def simple_ser_schema(type: ExpectedSerializationTypes) -> SimpleSerSchema:     \"\"\"     Returns a schema for serialization with a custom type.      Args:         type: The type to use for serialization     \"\"\"     return SimpleSerSchema(type=type) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#simpleserschema-indexhtmlpydanticcorecoreschemasimpleserschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "plain\\_serializer\\_function\\_ser\\_schema [Â¶](index.html#pydantic_core.core_schema.plain_serializer_function_ser_schema \"Permanent link\")", "anchor": "plainserializerfunctionserschema-indexhtmlpydanticcorecoreschemaplainserializerfunctionserschema-permanent-link", "md_text": "```\nplain_serializer_function_ser_schema(\n    function: SerializerFunction,\n    *,\n    is_field_serializer: bool | None = None,\n    info_arg: bool | None = None,\n    return_schema: CoreSchema | None = None,\n    when_used: WhenUsed = \"always\"\n) -> PlainSerializerFunctionSerSchema\n```\n\nReturns a schema for serialization with a function, can be either a \"general\" or \"field\" function.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `function` | `SerializerFunction` | The function to use for serialization | *required* |\n| `is_field_serializer` | `bool | None` | Whether the serializer is for a field, e.g. takes `model` as the first argument, and `info` includes `field_name` | `None` |\n| `info_arg` | `bool | None` | Whether the function takes an `info` argument | `None` |\n| `return_schema` | `CoreSchema | None` | Schema to use for serializing return value | `None` |\n| `when_used` | `WhenUsed` | When the function should be called | `'always'` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 ``` | ``` def plain_serializer_function_ser_schema(     function: SerializerFunction,     *,     is_field_serializer: bool | None = None,     info_arg: bool | None = None,     return_schema: CoreSchema | None = None,     when_used: WhenUsed = 'always', ) -> PlainSerializerFunctionSerSchema:     \"\"\"     Returns a schema for serialization with a function, can be either a \"general\" or \"field\" function.      Args:         function: The function to use for serialization         is_field_serializer: Whether the serializer is for a field, e.g. takes `model` as the first argument,             and `info` includes `field_name`         info_arg: Whether the function takes an `info` argument         return_schema: Schema to use for serializing return value         when_used: When the function should be called     \"\"\"     if when_used == 'always':         # just to avoid extra elements in schema, and to use the actual default defined in rust         when_used = None  # type: ignore     return _dict_not_none(         type='function-plain',         function=function,         is_field_serializer=is_field_serializer,         info_arg=info_arg,         return_schema=return_schema,         when_used=when_used,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#plainserializerfunctionserschema-indexhtmlpydanticcorecoreschemaplainserializerfunctionserschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "wrap\\_serializer\\_function\\_ser\\_schema [Â¶](index.html#pydantic_core.core_schema.wrap_serializer_function_ser_schema \"Permanent link\")", "anchor": "wrapserializerfunctionserschema-indexhtmlpydanticcorecoreschemawrapserializerfunctionserschema-permanent-link", "md_text": "```\nwrap_serializer_function_ser_schema(\n    function: WrapSerializerFunction,\n    *,\n    is_field_serializer: bool | None = None,\n    info_arg: bool | None = None,\n    schema: CoreSchema | None = None,\n    return_schema: CoreSchema | None = None,\n    when_used: WhenUsed = \"always\"\n) -> WrapSerializerFunctionSerSchema\n```\n\nReturns a schema for serialization with a wrap function, can be either a \"general\" or \"field\" function.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `function` | `WrapSerializerFunction` | The function to use for serialization | *required* |\n| `is_field_serializer` | `bool | None` | Whether the serializer is for a field, e.g. takes `model` as the first argument, and `info` includes `field_name` | `None` |\n| `info_arg` | `bool | None` | Whether the function takes an `info` argument | `None` |\n| `schema` | `CoreSchema | None` | The schema to use for the inner serialization | `None` |\n| `return_schema` | `CoreSchema | None` | Schema to use for serializing return value | `None` |\n| `when_used` | `WhenUsed` | When the function should be called | `'always'` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 ``` | ``` def wrap_serializer_function_ser_schema(     function: WrapSerializerFunction,     *,     is_field_serializer: bool | None = None,     info_arg: bool | None = None,     schema: CoreSchema | None = None,     return_schema: CoreSchema | None = None,     when_used: WhenUsed = 'always', ) -> WrapSerializerFunctionSerSchema:     \"\"\"     Returns a schema for serialization with a wrap function, can be either a \"general\" or \"field\" function.      Args:         function: The function to use for serialization         is_field_serializer: Whether the serializer is for a field, e.g. takes `model` as the first argument,             and `info` includes `field_name`         info_arg: Whether the function takes an `info` argument         schema: The schema to use for the inner serialization         return_schema: Schema to use for serializing return value         when_used: When the function should be called     \"\"\"     if when_used == 'always':         # just to avoid extra elements in schema, and to use the actual default defined in rust         when_used = None  # type: ignore     return _dict_not_none(         type='function-wrap',         function=function,         is_field_serializer=is_field_serializer,         info_arg=info_arg,         schema=schema,         return_schema=return_schema,         when_used=when_used,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#wrapserializerfunctionserschema-indexhtmlpydanticcorecoreschemawrapserializerfunctionserschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "format\\_ser\\_schema [Â¶](index.html#pydantic_core.core_schema.format_ser_schema \"Permanent link\")", "anchor": "formatserschema-indexhtmlpydanticcorecoreschemaformatserschema-permanent-link", "md_text": "```\nformat_ser_schema(\n    formatting_string: str,\n    *,\n    when_used: WhenUsed = \"json-unless-none\"\n) -> FormatSerSchema\n```\n\nReturns a schema for serialization using python's `format` method.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `formatting_string` | `str` | String defining the format to use | *required* |\n| `when_used` | `WhenUsed` | Same meaning as for [general\\_function\\_plain\\_ser\\_schema], but with a different default | `'json-unless-none'` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 415 416 417 418 419 420 421 422 423 424 425 426 ``` | ``` def format_ser_schema(formatting_string: str, *, when_used: WhenUsed = 'json-unless-none') -> FormatSerSchema:     \"\"\"     Returns a schema for serialization using python's `format` method.      Args:         formatting_string: String defining the format to use         when_used: Same meaning as for [general_function_plain_ser_schema], but with a different default     \"\"\"     if when_used == 'json-unless-none':         # just to avoid extra elements in schema, and to use the actual default defined in rust         when_used = None  # type: ignore     return _dict_not_none(type='format', formatting_string=formatting_string, when_used=when_used) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#formatserschema-indexhtmlpydanticcorecoreschemaformatserschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "to\\_string\\_ser\\_schema [Â¶](index.html#pydantic_core.core_schema.to_string_ser_schema \"Permanent link\")", "anchor": "tostringserschema-indexhtmlpydanticcorecoreschematostringserschema-permanent-link", "md_text": "```\nto_string_ser_schema(\n    *, when_used: WhenUsed = \"json-unless-none\"\n) -> ToStringSerSchema\n```\n\nReturns a schema for serialization using python's `str()` / `__str__` method.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `when_used` | `WhenUsed` | Same meaning as for [general\\_function\\_plain\\_ser\\_schema], but with a different default | `'json-unless-none'` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 434 435 436 437 438 439 440 441 442 443 444 445 ``` | ``` def to_string_ser_schema(*, when_used: WhenUsed = 'json-unless-none') -> ToStringSerSchema:     \"\"\"     Returns a schema for serialization using python's `str()` / `__str__` method.      Args:         when_used: Same meaning as for [general_function_plain_ser_schema], but with a different default     \"\"\"     s = dict(type='to-string')     if when_used != 'json-unless-none':         # just to avoid extra elements in schema, and to use the actual default defined in rust         s['when_used'] = when_used     return s  # type: ignore ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#tostringserschema-indexhtmlpydanticcorecoreschematostringserschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "model\\_ser\\_schema [Â¶](index.html#pydantic_core.core_schema.model_ser_schema \"Permanent link\")", "anchor": "modelserschema-indexhtmlpydanticcorecoreschemamodelserschema-permanent-link", "md_text": "```\nmodel_ser_schema(\n    cls: type[Any], schema: CoreSchema\n) -> ModelSerSchema\n```\n\nReturns a schema for serialization using a model.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `cls` | `type[Any]` | The expected class type, used to generate warnings if the wrong type is passed | *required* |\n| `schema` | `CoreSchema` | Internal schema to use to serialize the model dict | *required* |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 454 455 456 457 458 459 460 461 462 ``` | ``` def model_ser_schema(cls: type[Any], schema: CoreSchema) -> ModelSerSchema:     \"\"\"     Returns a schema for serialization using a model.      Args:         cls: The expected class type, used to generate warnings if the wrong type is passed         schema: Internal schema to use to serialize the model dict     \"\"\"     return ModelSerSchema(type='model', cls=cls, schema=schema) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#modelserschema-indexhtmlpydanticcorecoreschemamodelserschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "invalid\\_schema [Â¶](index.html#pydantic_core.core_schema.invalid_schema \"Permanent link\")", "anchor": "invalidschema-indexhtmlpydanticcorecoreschemainvalidschema-permanent-link", "md_text": "```\ninvalid_schema(\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n) -> InvalidSchema\n```\n\nReturns an invalid schema, used to indicate that a schema is invalid.\n\n```\nReturns a schema that matches any value, e.g.:\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 484 485 486 487 488 489 490 491 492 493 494 495 ``` | ``` def invalid_schema(ref: str | None = None, metadata: dict[str, Any] | None = None) -> InvalidSchema:     \"\"\"     Returns an invalid schema, used to indicate that a schema is invalid.          Returns a schema that matches any value, e.g.:      Args:         ref: optional unique identifier of the schema, used to reference the schema in other places         metadata: Any other information you want to include with the schema, not used by pydantic-core     \"\"\"      return _dict_not_none(type='invalid', ref=ref, metadata=metadata) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#invalidschema-indexhtmlpydanticcorecoreschemainvalidschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "computed\\_field [Â¶](index.html#pydantic_core.core_schema.computed_field \"Permanent link\")", "anchor": "computedfield-indexhtmlpydanticcorecoreschemacomputedfield-permanent-link", "md_text": "```\ncomputed_field(\n    property_name: str,\n    return_schema: CoreSchema,\n    *,\n    alias: str | None = None,\n    metadata: dict[str, Any] | None = None\n) -> ComputedField\n```\n\nComputedFields are properties of a model or dataclass that are included in serialization.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `property_name` | `str` | The name of the property on the model or dataclass | *required* |\n| `return_schema` | `CoreSchema` | The schema used for the type returned by the computed field | *required* |\n| `alias` | `str | None` | The name to use in the serialized output | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 ``` | ``` def computed_field(     property_name: str, return_schema: CoreSchema, *, alias: str | None = None, metadata: dict[str, Any] | None = None ) -> ComputedField:     \"\"\"     ComputedFields are properties of a model or dataclass that are included in serialization.      Args:         property_name: The name of the property on the model or dataclass         return_schema: The schema used for the type returned by the computed field         alias: The name to use in the serialized output         metadata: Any other information you want to include with the schema, not used by pydantic-core     \"\"\"     return _dict_not_none(         type='computed-field', property_name=property_name, return_schema=return_schema, alias=alias, metadata=metadata     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#computedfield-indexhtmlpydanticcorecoreschemacomputedfield-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "any\\_schema [Â¶](index.html#pydantic_core.core_schema.any_schema \"Permanent link\")", "anchor": "anyschema-indexhtmlpydanticcorecoreschemaanyschema-permanent-link", "md_text": "```\nany_schema(\n    *,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None\n) -> AnySchema\n```\n\nReturns a schema that matches any value, e.g.:\n\n```\nfrom pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.any_schema()\nv = SchemaValidator(schema)\nassert v.validate_python(1) == 1\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 ``` | ``` def any_schema(     *, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None ) -> AnySchema:     \"\"\"     Returns a schema that matches any value, e.g.:      ```py     from pydantic_core import SchemaValidator, core_schema      schema = core_schema.any_schema()     v = SchemaValidator(schema)     assert v.validate_python(1) == 1     ```      Args:         ref: optional unique identifier of the schema, used to reference the schema in other places         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     return _dict_not_none(type='any', ref=ref, metadata=metadata, serialization=serialization) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#anyschema-indexhtmlpydanticcorecoreschemaanyschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "none\\_schema [Â¶](index.html#pydantic_core.core_schema.none_schema \"Permanent link\")", "anchor": "noneschema-indexhtmlpydanticcorecoreschemanoneschema-permanent-link", "md_text": "```\nnone_schema(\n    *,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None\n) -> NoneSchema\n```\n\nReturns a schema that matches a None value, e.g.:\n\n```\nfrom pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.none_schema()\nv = SchemaValidator(schema)\nassert v.validate_python(None) is None\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 ``` | ``` def none_schema(     *, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None ) -> NoneSchema:     \"\"\"     Returns a schema that matches a None value, e.g.:      ```py     from pydantic_core import SchemaValidator, core_schema      schema = core_schema.none_schema()     v = SchemaValidator(schema)     assert v.validate_python(None) is None     ```      Args:         ref: optional unique identifier of the schema, used to reference the schema in other places         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     return _dict_not_none(type='none', ref=ref, metadata=metadata, serialization=serialization) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#noneschema-indexhtmlpydanticcorecoreschemanoneschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "bool\\_schema [Â¶](index.html#pydantic_core.core_schema.bool_schema \"Permanent link\")", "anchor": "boolschema-indexhtmlpydanticcorecoreschemaboolschema-permanent-link", "md_text": "```\nbool_schema(\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n) -> BoolSchema\n```\n\nReturns a schema that matches a bool value, e.g.:\n\n```\nfrom pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.bool_schema()\nv = SchemaValidator(schema)\nassert v.validate_python('True') is True\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `strict` | `bool | None` | Whether the value should be a bool or a value that can be converted to a bool | `None` |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 ``` | ``` def bool_schema(     strict: bool | None = None,     ref: str | None = None,     metadata: dict[str, Any] | None = None,     serialization: SerSchema | None = None, ) -> BoolSchema:     \"\"\"     Returns a schema that matches a bool value, e.g.:      ```py     from pydantic_core import SchemaValidator, core_schema      schema = core_schema.bool_schema()     v = SchemaValidator(schema)     assert v.validate_python('True') is True     ```      Args:         strict: Whether the value should be a bool or a value that can be converted to a bool         ref: optional unique identifier of the schema, used to reference the schema in other places         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     return _dict_not_none(type='bool', strict=strict, ref=ref, metadata=metadata, serialization=serialization) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#boolschema-indexhtmlpydanticcorecoreschemaboolschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "int\\_schema [Â¶](index.html#pydantic_core.core_schema.int_schema \"Permanent link\")", "anchor": "intschema-indexhtmlpydanticcorecoreschemaintschema-permanent-link", "md_text": "```\nint_schema(\n    *,\n    multiple_of: int | None = None,\n    le: int | None = None,\n    ge: int | None = None,\n    lt: int | None = None,\n    gt: int | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None\n) -> IntSchema\n```\n\nReturns a schema that matches a int value, e.g.:\n\n```\nfrom pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.int_schema(multiple_of=2, le=6, ge=2)\nv = SchemaValidator(schema)\nassert v.validate_python('4') == 4\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `multiple_of` | `int | None` | The value must be a multiple of this number | `None` |\n| `le` | `int | None` | The value must be less than or equal to this number | `None` |\n| `ge` | `int | None` | The value must be greater than or equal to this number | `None` |\n| `lt` | `int | None` | The value must be strictly less than this number | `None` |\n| `gt` | `int | None` | The value must be strictly greater than this number | `None` |\n| `strict` | `bool | None` | Whether the value should be a int or a value that can be converted to a int | `None` |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 ``` | ``` def int_schema(     *,     multiple_of: int | None = None,     le: int | None = None,     ge: int | None = None,     lt: int | None = None,     gt: int | None = None,     strict: bool | None = None,     ref: str | None = None,     metadata: dict[str, Any] | None = None,     serialization: SerSchema | None = None, ) -> IntSchema:     \"\"\"     Returns a schema that matches a int value, e.g.:      ```py     from pydantic_core import SchemaValidator, core_schema      schema = core_schema.int_schema(multiple_of=2, le=6, ge=2)     v = SchemaValidator(schema)     assert v.validate_python('4') == 4     ```      Args:         multiple_of: The value must be a multiple of this number         le: The value must be less than or equal to this number         ge: The value must be greater than or equal to this number         lt: The value must be strictly less than this number         gt: The value must be strictly greater than this number         strict: Whether the value should be a int or a value that can be converted to a int         ref: optional unique identifier of the schema, used to reference the schema in other places         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     return _dict_not_none(         type='int',         multiple_of=multiple_of,         le=le,         ge=ge,         lt=lt,         gt=gt,         strict=strict,         ref=ref,         metadata=metadata,         serialization=serialization,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#intschema-indexhtmlpydanticcorecoreschemaintschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "float\\_schema [Â¶](index.html#pydantic_core.core_schema.float_schema \"Permanent link\")", "anchor": "floatschema-indexhtmlpydanticcorecoreschemafloatschema-permanent-link", "md_text": "```\nfloat_schema(\n    *,\n    allow_inf_nan: bool | None = None,\n    multiple_of: float | None = None,\n    le: float | None = None,\n    ge: float | None = None,\n    lt: float | None = None,\n    gt: float | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None\n) -> FloatSchema\n```\n\nReturns a schema that matches a float value, e.g.:\n\n```\nfrom pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.float_schema(le=0.8, ge=0.2)\nv = SchemaValidator(schema)\nassert v.validate_python('0.5') == 0.5\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `allow_inf_nan` | `bool | None` | Whether to allow inf and nan values | `None` |\n| `multiple_of` | `float | None` | The value must be a multiple of this number | `None` |\n| `le` | `float | None` | The value must be less than or equal to this number | `None` |\n| `ge` | `float | None` | The value must be greater than or equal to this number | `None` |\n| `lt` | `float | None` | The value must be strictly less than this number | `None` |\n| `gt` | `float | None` | The value must be strictly greater than this number | `None` |\n| `strict` | `bool | None` | Whether the value should be a float or a value that can be converted to a float | `None` |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 ``` | ``` def float_schema(     *,     allow_inf_nan: bool | None = None,     multiple_of: float | None = None,     le: float | None = None,     ge: float | None = None,     lt: float | None = None,     gt: float | None = None,     strict: bool | None = None,     ref: str | None = None,     metadata: dict[str, Any] | None = None,     serialization: SerSchema | None = None, ) -> FloatSchema:     \"\"\"     Returns a schema that matches a float value, e.g.:      ```py     from pydantic_core import SchemaValidator, core_schema      schema = core_schema.float_schema(le=0.8, ge=0.2)     v = SchemaValidator(schema)     assert v.validate_python('0.5') == 0.5     ```      Args:         allow_inf_nan: Whether to allow inf and nan values         multiple_of: The value must be a multiple of this number         le: The value must be less than or equal to this number         ge: The value must be greater than or equal to this number         lt: The value must be strictly less than this number         gt: The value must be strictly greater than this number         strict: Whether the value should be a float or a value that can be converted to a float         ref: optional unique identifier of the schema, used to reference the schema in other places         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     return _dict_not_none(         type='float',         allow_inf_nan=allow_inf_nan,         multiple_of=multiple_of,         le=le,         ge=ge,         lt=lt,         gt=gt,         strict=strict,         ref=ref,         metadata=metadata,         serialization=serialization,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#floatschema-indexhtmlpydanticcorecoreschemafloatschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "decimal\\_schema [Â¶](index.html#pydantic_core.core_schema.decimal_schema \"Permanent link\")", "anchor": "decimalschema-indexhtmlpydanticcorecoreschemadecimalschema-permanent-link", "md_text": "```\ndecimal_schema(\n    *,\n    allow_inf_nan: bool | None = None,\n    multiple_of: Decimal | None = None,\n    le: Decimal | None = None,\n    ge: Decimal | None = None,\n    lt: Decimal | None = None,\n    gt: Decimal | None = None,\n    max_digits: int | None = None,\n    decimal_places: int | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None\n) -> DecimalSchema\n```\n\nReturns a schema that matches a decimal value, e.g.:\n\n```\nfrom decimal import Decimal\nfrom pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.decimal_schema(le=0.8, ge=0.2)\nv = SchemaValidator(schema)\nassert v.validate_python('0.5') == Decimal('0.5')\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `allow_inf_nan` | `bool | None` | Whether to allow inf and nan values | `None` |\n| `multiple_of` | `Decimal | None` | The value must be a multiple of this number | `None` |\n| `le` | `Decimal | None` | The value must be less than or equal to this number | `None` |\n| `ge` | `Decimal | None` | The value must be greater than or equal to this number | `None` |\n| `lt` | `Decimal | None` | The value must be strictly less than this number | `None` |\n| `gt` | `Decimal | None` | The value must be strictly greater than this number | `None` |\n| `max_digits` | `int | None` | The maximum number of decimal digits allowed | `None` |\n| `decimal_places` | `int | None` | The maximum number of decimal places allowed | `None` |\n| `strict` | `bool | None` | Whether the value should be a float or a value that can be converted to a float | `None` |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 ``` | ``` def decimal_schema(     *,     allow_inf_nan: bool | None = None,     multiple_of: Decimal | None = None,     le: Decimal | None = None,     ge: Decimal | None = None,     lt: Decimal | None = None,     gt: Decimal | None = None,     max_digits: int | None = None,     decimal_places: int | None = None,     strict: bool | None = None,     ref: str | None = None,     metadata: dict[str, Any] | None = None,     serialization: SerSchema | None = None, ) -> DecimalSchema:     \"\"\"     Returns a schema that matches a decimal value, e.g.:      ```py     from decimal import Decimal     from pydantic_core import SchemaValidator, core_schema      schema = core_schema.decimal_schema(le=0.8, ge=0.2)     v = SchemaValidator(schema)     assert v.validate_python('0.5') == Decimal('0.5')     ```      Args:         allow_inf_nan: Whether to allow inf and nan values         multiple_of: The value must be a multiple of this number         le: The value must be less than or equal to this number         ge: The value must be greater than or equal to this number         lt: The value must be strictly less than this number         gt: The value must be strictly greater than this number         max_digits: The maximum number of decimal digits allowed         decimal_places: The maximum number of decimal places allowed         strict: Whether the value should be a float or a value that can be converted to a float         ref: optional unique identifier of the schema, used to reference the schema in other places         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     return _dict_not_none(         type='decimal',         gt=gt,         ge=ge,         lt=lt,         le=le,         max_digits=max_digits,         decimal_places=decimal_places,         multiple_of=multiple_of,         allow_inf_nan=allow_inf_nan,         strict=strict,         ref=ref,         metadata=metadata,         serialization=serialization,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#decimalschema-indexhtmlpydanticcorecoreschemadecimalschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "complex\\_schema [Â¶](index.html#pydantic_core.core_schema.complex_schema \"Permanent link\")", "anchor": "complexschema-indexhtmlpydanticcorecoreschemacomplexschema-permanent-link", "md_text": "```\ncomplex_schema(\n    *,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None\n) -> ComplexSchema\n```\n\nReturns a schema that matches a complex value, e.g.:\n\n```\nfrom pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.complex_schema()\nv = SchemaValidator(schema)\nassert v.validate_python('1+2j') == complex(1, 2)\nassert v.validate_python(complex(1, 2)) == complex(1, 2)\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `strict` | `bool | None` | Whether the value should be a complex object instance or a value that can be converted to a complex object | `None` |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 ``` | ``` def complex_schema(     *,     strict: bool | None = None,     ref: str | None = None,     metadata: dict[str, Any] | None = None,     serialization: SerSchema | None = None, ) -> ComplexSchema:     \"\"\"     Returns a schema that matches a complex value, e.g.:      ```py     from pydantic_core import SchemaValidator, core_schema      schema = core_schema.complex_schema()     v = SchemaValidator(schema)     assert v.validate_python('1+2j') == complex(1, 2)     assert v.validate_python(complex(1, 2)) == complex(1, 2)     ```      Args:         strict: Whether the value should be a complex object instance or a value that can be converted to a complex object         ref: optional unique identifier of the schema, used to reference the schema in other places         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     return _dict_not_none(         type='complex',         strict=strict,         ref=ref,         metadata=metadata,         serialization=serialization,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#complexschema-indexhtmlpydanticcorecoreschemacomplexschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "str\\_schema [Â¶](index.html#pydantic_core.core_schema.str_schema \"Permanent link\")", "anchor": "strschema-indexhtmlpydanticcorecoreschemastrschema-permanent-link", "md_text": "```\nstr_schema(\n    *,\n    pattern: str | Pattern[str] | None = None,\n    max_length: int | None = None,\n    min_length: int | None = None,\n    strip_whitespace: bool | None = None,\n    to_lower: bool | None = None,\n    to_upper: bool | None = None,\n    regex_engine: (\n        Literal[\"rust-regex\", \"python-re\"] | None\n    ) = None,\n    strict: bool | None = None,\n    coerce_numbers_to_str: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None\n) -> StringSchema\n```\n\nReturns a schema that matches a string value, e.g.:\n\n```\nfrom pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.str_schema(max_length=10, min_length=2)\nv = SchemaValidator(schema)\nassert v.validate_python('hello') == 'hello'\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `pattern` | `str | Pattern[str] | None` | A regex pattern that the value must match | `None` |\n| `max_length` | `int | None` | The value must be at most this length | `None` |\n| `min_length` | `int | None` | The value must be at least this length | `None` |\n| `strip_whitespace` | `bool | None` | Whether to strip whitespace from the value | `None` |\n| `to_lower` | `bool | None` | Whether to convert the value to lowercase | `None` |\n| `to_upper` | `bool | None` | Whether to convert the value to uppercase | `None` |\n| `regex_engine` | `Literal['rust-regex', 'python-re'] | None` | The regex engine to use for pattern validation. Default is 'rust-regex'. - `rust-regex` uses the [`regex`](https://docs.rs/regex) Rust crate, which is non-backtracking and therefore more DDoS resistant, but does not support all regex features. - `python-re` use the [`re`](https://docs.python.org/3/library/re.html) module, which supports all regex features, but may be slower. | `None` |\n| `strict` | `bool | None` | Whether the value should be a string or a value that can be converted to a string | `None` |\n| `coerce_numbers_to_str` | `bool | None` | Whether to enable coercion of any `Number` type to `str` (not applicable in `strict` mode). | `None` |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#strschema-indexhtmlpydanticcorecoreschemastrschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "str\\_schema [Â¶](index.html#pydantic_core.core_schema.str_schema \"Permanent link\")", "anchor": "strschema-indexhtmlpydanticcorecoreschemastrschema-permanent-link", "md_text": "|  |  |\n| --- | --- |\n| ``` 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 ``` | ``` def str_schema(     *,     pattern: str | Pattern[str] | None = None,     max_length: int | None = None,     min_length: int | None = None,     strip_whitespace: bool | None = None,     to_lower: bool | None = None,     to_upper: bool | None = None,     regex_engine: Literal['rust-regex', 'python-re'] | None = None,     strict: bool | None = None,     coerce_numbers_to_str: bool | None = None,     ref: str | None = None,     metadata: dict[str, Any] | None = None,     serialization: SerSchema | None = None, ) -> StringSchema:     \"\"\"     Returns a schema that matches a string value, e.g.:      ```py     from pydantic_core import SchemaValidator, core_schema      schema = core_schema.str_schema(max_length=10, min_length=2)     v = SchemaValidator(schema)     assert v.validate_python('hello') == 'hello'     ```      Args:         pattern: A regex pattern that the value must match         max_length: The value must be at most this length         min_length: The value must be at least this length         strip_whitespace: Whether to strip whitespace from the value         to_lower: Whether to convert the value to lowercase         to_upper: Whether to convert the value to uppercase         regex_engine: The regex engine to use for pattern validation. Default is 'rust-regex'.             - `rust-regex` uses the [`regex`](https://docs.rs/regex) Rust               crate, which is non-backtracking and therefore more DDoS               resistant, but does not support all regex features.             - `python-re` use the [`re`](https://docs.python.org/3/library/re.html) module,               which supports all regex features, but may be slower.         strict: Whether the value should be a string or a value that can be converted to a string         coerce_numbers_to_str: Whether to enable coercion of any `Number` type to `str` (not applicable in `strict` mode).         ref: optional unique identifier of the schema, used to reference the schema in other places         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     return _dict_not_none(         type='str',         pattern=pattern,         max_length=max_length,         min_length=min_length,         strip_whitespace=strip_whitespace,         to_lower=to_lower,         to_upper=to_upper,         regex_engine=regex_engine,         strict=strict,         coerce_numbers_to_str=coerce_numbers_to_str,         ref=ref,         metadata=metadata,         serialization=serialization,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#strschema-indexhtmlpydanticcorecoreschemastrschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "bytes\\_schema [Â¶](index.html#pydantic_core.core_schema.bytes_schema \"Permanent link\")", "anchor": "bytesschema-indexhtmlpydanticcorecoreschemabytesschema-permanent-link", "md_text": "```\nbytes_schema(\n    *,\n    max_length: int | None = None,\n    min_length: int | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None\n) -> BytesSchema\n```\n\nReturns a schema that matches a bytes value, e.g.:\n\n```\nfrom pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.bytes_schema(max_length=10, min_length=2)\nv = SchemaValidator(schema)\nassert v.validate_python(b'hello') == b'hello'\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `max_length` | `int | None` | The value must be at most this length | `None` |\n| `min_length` | `int | None` | The value must be at least this length | `None` |\n| `strict` | `bool | None` | Whether the value should be a bytes or a value that can be converted to a bytes | `None` |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 ``` | ``` def bytes_schema(     *,     max_length: int | None = None,     min_length: int | None = None,     strict: bool | None = None,     ref: str | None = None,     metadata: dict[str, Any] | None = None,     serialization: SerSchema | None = None, ) -> BytesSchema:     \"\"\"     Returns a schema that matches a bytes value, e.g.:      ```py     from pydantic_core import SchemaValidator, core_schema      schema = core_schema.bytes_schema(max_length=10, min_length=2)     v = SchemaValidator(schema)     assert v.validate_python(b'hello') == b'hello'     ```      Args:         max_length: The value must be at most this length         min_length: The value must be at least this length         strict: Whether the value should be a bytes or a value that can be converted to a bytes         ref: optional unique identifier of the schema, used to reference the schema in other places         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     return _dict_not_none(         type='bytes',         max_length=max_length,         min_length=min_length,         strict=strict,         ref=ref,         metadata=metadata,         serialization=serialization,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#bytesschema-indexhtmlpydanticcorecoreschemabytesschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "date\\_schema [Â¶](index.html#pydantic_core.core_schema.date_schema \"Permanent link\")", "anchor": "dateschema-indexhtmlpydanticcorecoreschemadateschema-permanent-link", "md_text": "```\ndate_schema(\n    *,\n    strict: bool | None = None,\n    le: date | None = None,\n    ge: date | None = None,\n    lt: date | None = None,\n    gt: date | None = None,\n    now_op: Literal[\"past\", \"future\"] | None = None,\n    now_utc_offset: int | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None\n) -> DateSchema\n```\n\nReturns a schema that matches a date value, e.g.:\n\n```\nfrom datetime import date\nfrom pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.date_schema(le=date(2020, 1, 1), ge=date(2019, 1, 1))\nv = SchemaValidator(schema)\nassert v.validate_python(date(2019, 6, 1)) == date(2019, 6, 1)\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `strict` | `bool | None` | Whether the value should be a date or a value that can be converted to a date | `None` |\n| `le` | `date | None` | The value must be less than or equal to this date | `None` |\n| `ge` | `date | None` | The value must be greater than or equal to this date | `None` |\n| `lt` | `date | None` | The value must be strictly less than this date | `None` |\n| `gt` | `date | None` | The value must be strictly greater than this date | `None` |\n| `now_op` | `Literal['past', 'future'] | None` | The value must be in the past or future relative to the current date | `None` |\n| `now_utc_offset` | `int | None` | The value must be in the past or future relative to the current date with this utc offset | `None` |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 ``` | ``` def date_schema(     *,     strict: bool | None = None,     le: date | None = None,     ge: date | None = None,     lt: date | None = None,     gt: date | None = None,     now_op: Literal['past', 'future'] | None = None,     now_utc_offset: int | None = None,     ref: str | None = None,     metadata: dict[str, Any] | None = None,     serialization: SerSchema | None = None, ) -> DateSchema:     \"\"\"     Returns a schema that matches a date value, e.g.:      ```py     from datetime import date     from pydantic_core import SchemaValidator, core_schema      schema = core_schema.date_schema(le=date(2020, 1, 1), ge=date(2019, 1, 1))     v = SchemaValidator(schema)     assert v.validate_python(date(2019, 6, 1)) == date(2019, 6, 1)     ```      Args:         strict: Whether the value should be a date or a value that can be converted to a date         le: The value must be less than or equal to this date         ge: The value must be greater than or equal to this date         lt: The value must be strictly less than this date         gt: The value must be strictly greater than this date         now_op: The value must be in the past or future relative to the current date         now_utc_offset: The value must be in the past or future relative to the current date with this utc offset         ref: optional unique identifier of the schema, used to reference the schema in other places         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     return _dict_not_none(         type='date',         strict=strict,         le=le,         ge=ge,         lt=lt,         gt=gt,         now_op=now_op,         now_utc_offset=now_utc_offset,         ref=ref,         metadata=metadata,         serialization=serialization,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#dateschema-indexhtmlpydanticcorecoreschemadateschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "time\\_schema [Â¶](index.html#pydantic_core.core_schema.time_schema \"Permanent link\")", "anchor": "timeschema-indexhtmlpydanticcorecoreschematimeschema-permanent-link", "md_text": "```\ntime_schema(\n    *,\n    strict: bool | None = None,\n    le: time | None = None,\n    ge: time | None = None,\n    lt: time | None = None,\n    gt: time | None = None,\n    tz_constraint: (\n        Literal[\"aware\", \"naive\"] | int | None\n    ) = None,\n    microseconds_precision: Literal[\n        \"truncate\", \"error\"\n    ] = \"truncate\",\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None\n) -> TimeSchema\n```\n\nReturns a schema that matches a time value, e.g.:\n\n```\nfrom datetime import time\nfrom pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.time_schema(le=time(12, 0, 0), ge=time(6, 0, 0))\nv = SchemaValidator(schema)\nassert v.validate_python(time(9, 0, 0)) == time(9, 0, 0)\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `strict` | `bool | None` | Whether the value should be a time or a value that can be converted to a time | `None` |\n| `le` | `time | None` | The value must be less than or equal to this time | `None` |\n| `ge` | `time | None` | The value must be greater than or equal to this time | `None` |\n| `lt` | `time | None` | The value must be strictly less than this time | `None` |\n| `gt` | `time | None` | The value must be strictly greater than this time | `None` |\n| `tz_constraint` | `Literal['aware', 'naive'] | int | None` | The value must be timezone aware or naive, or an int to indicate required tz offset | `None` |\n| `microseconds_precision` | `Literal['truncate', 'error']` | The behavior when seconds have more than 6 digits or microseconds is too large | `'truncate'` |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 ``` | ``` def time_schema(     *,     strict: bool | None = None,     le: time | None = None,     ge: time | None = None,     lt: time | None = None,     gt: time | None = None,     tz_constraint: Literal['aware', 'naive'] | int | None = None,     microseconds_precision: Literal['truncate', 'error'] = 'truncate',     ref: str | None = None,     metadata: dict[str, Any] | None = None,     serialization: SerSchema | None = None, ) -> TimeSchema:     \"\"\"     Returns a schema that matches a time value, e.g.:      ```py     from datetime import time     from pydantic_core import SchemaValidator, core_schema      schema = core_schema.time_schema(le=time(12, 0, 0), ge=time(6, 0, 0))     v = SchemaValidator(schema)     assert v.validate_python(time(9, 0, 0)) == time(9, 0, 0)     ```      Args:         strict: Whether the value should be a time or a value that can be converted to a time         le: The value must be less than or equal to this time         ge: The value must be greater than or equal to this time         lt: The value must be strictly less than this time         gt: The value must be strictly greater than this time         tz_constraint: The value must be timezone aware or naive, or an int to indicate required tz offset         microseconds_precision: The behavior when seconds have more than 6 digits or microseconds is too large         ref: optional unique identifier of the schema, used to reference the schema in other places         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     return _dict_not_none(         type='time',         strict=strict,         le=le,         ge=ge,         lt=lt,         gt=gt,         tz_constraint=tz_constraint,         microseconds_precision=microseconds_precision,         ref=ref,         metadata=metadata,         serialization=serialization,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#timeschema-indexhtmlpydanticcorecoreschematimeschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "datetime\\_schema [Â¶](index.html#pydantic_core.core_schema.datetime_schema \"Permanent link\")", "anchor": "datetimeschema-indexhtmlpydanticcorecoreschemadatetimeschema-permanent-link", "md_text": "```\ndatetime_schema(\n    *,\n    strict: bool | None = None,\n    le: datetime | None = None,\n    ge: datetime | None = None,\n    lt: datetime | None = None,\n    gt: datetime | None = None,\n    now_op: Literal[\"past\", \"future\"] | None = None,\n    tz_constraint: (\n        Literal[\"aware\", \"naive\"] | int | None\n    ) = None,\n    now_utc_offset: int | None = None,\n    microseconds_precision: Literal[\n        \"truncate\", \"error\"\n    ] = \"truncate\",\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None\n) -> DatetimeSchema\n```\n\nReturns a schema that matches a datetime value, e.g.:\n\n```\nfrom datetime import datetime\nfrom pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.datetime_schema()\nv = SchemaValidator(schema)\nnow = datetime.now()\nassert v.validate_python(str(now)) == now\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `strict` | `bool | None` | Whether the value should be a datetime or a value that can be converted to a datetime | `None` |\n| `le` | `datetime | None` | The value must be less than or equal to this datetime | `None` |\n| `ge` | `datetime | None` | The value must be greater than or equal to this datetime | `None` |\n| `lt` | `datetime | None` | The value must be strictly less than this datetime | `None` |\n| `gt` | `datetime | None` | The value must be strictly greater than this datetime | `None` |\n| `now_op` | `Literal['past', 'future'] | None` | The value must be in the past or future relative to the current datetime | `None` |\n| `tz_constraint` | `Literal['aware', 'naive'] | int | None` | The value must be timezone aware or naive, or an int to indicate required tz offset TODO: use of a tzinfo where offset changes based on the datetime is not yet supported | `None` |\n| `now_utc_offset` | `int | None` | The value must be in the past or future relative to the current datetime with this utc offset | `None` |\n| `microseconds_precision` | `Literal['truncate', 'error']` | The behavior when seconds have more than 6 digits or microseconds is too large | `'truncate'` |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#datetimeschema-indexhtmlpydanticcorecoreschemadatetimeschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "datetime\\_schema [Â¶](index.html#pydantic_core.core_schema.datetime_schema \"Permanent link\")", "anchor": "datetimeschema-indexhtmlpydanticcorecoreschemadatetimeschema-permanent-link", "md_text": "|  |  |\n| --- | --- |\n| ``` 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 ``` | ``` def datetime_schema(     *,     strict: bool | None = None,     le: datetime | None = None,     ge: datetime | None = None,     lt: datetime | None = None,     gt: datetime | None = None,     now_op: Literal['past', 'future'] | None = None,     tz_constraint: Literal['aware', 'naive'] | int | None = None,     now_utc_offset: int | None = None,     microseconds_precision: Literal['truncate', 'error'] = 'truncate',     ref: str | None = None,     metadata: dict[str, Any] | None = None,     serialization: SerSchema | None = None, ) -> DatetimeSchema:     \"\"\"     Returns a schema that matches a datetime value, e.g.:      ```py     from datetime import datetime     from pydantic_core import SchemaValidator, core_schema      schema = core_schema.datetime_schema()     v = SchemaValidator(schema)     now = datetime.now()     assert v.validate_python(str(now)) == now     ```      Args:         strict: Whether the value should be a datetime or a value that can be converted to a datetime         le: The value must be less than or equal to this datetime         ge: The value must be greater than or equal to this datetime         lt: The value must be strictly less than this datetime         gt: The value must be strictly greater than this datetime         now_op: The value must be in the past or future relative to the current datetime         tz_constraint: The value must be timezone aware or naive, or an int to indicate required tz offset             TODO: use of a tzinfo where offset changes based on the datetime is not yet supported         now_utc_offset: The value must be in the past or future relative to the current datetime with this utc offset         microseconds_precision: The behavior when seconds have more than 6 digits or microseconds is too large         ref: optional unique identifier of the schema, used to reference the schema in other places         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     return _dict_not_none(         type='datetime',         strict=strict,         le=le,         ge=ge,         lt=lt,         gt=gt,         now_op=now_op,         tz_constraint=tz_constraint,         now_utc_offset=now_utc_offset,         microseconds_precision=microseconds_precision,         ref=ref,         metadata=metadata,         serialization=serialization,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#datetimeschema-indexhtmlpydanticcorecoreschemadatetimeschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "timedelta\\_schema [Â¶](index.html#pydantic_core.core_schema.timedelta_schema \"Permanent link\")", "anchor": "timedeltaschema-indexhtmlpydanticcorecoreschematimedeltaschema-permanent-link", "md_text": "```\ntimedelta_schema(\n    *,\n    strict: bool | None = None,\n    le: timedelta | None = None,\n    ge: timedelta | None = None,\n    lt: timedelta | None = None,\n    gt: timedelta | None = None,\n    microseconds_precision: Literal[\n        \"truncate\", \"error\"\n    ] = \"truncate\",\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None\n) -> TimedeltaSchema\n```\n\nReturns a schema that matches a timedelta value, e.g.:\n\n```\nfrom datetime import timedelta\nfrom pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.timedelta_schema(le=timedelta(days=1), ge=timedelta(days=0))\nv = SchemaValidator(schema)\nassert v.validate_python(timedelta(hours=12)) == timedelta(hours=12)\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `strict` | `bool | None` | Whether the value should be a timedelta or a value that can be converted to a timedelta | `None` |\n| `le` | `timedelta | None` | The value must be less than or equal to this timedelta | `None` |\n| `ge` | `timedelta | None` | The value must be greater than or equal to this timedelta | `None` |\n| `lt` | `timedelta | None` | The value must be strictly less than this timedelta | `None` |\n| `gt` | `timedelta | None` | The value must be strictly greater than this timedelta | `None` |\n| `microseconds_precision` | `Literal['truncate', 'error']` | The behavior when seconds have more than 6 digits or microseconds is too large | `'truncate'` |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 ``` | ``` def timedelta_schema(     *,     strict: bool | None = None,     le: timedelta | None = None,     ge: timedelta | None = None,     lt: timedelta | None = None,     gt: timedelta | None = None,     microseconds_precision: Literal['truncate', 'error'] = 'truncate',     ref: str | None = None,     metadata: dict[str, Any] | None = None,     serialization: SerSchema | None = None, ) -> TimedeltaSchema:     \"\"\"     Returns a schema that matches a timedelta value, e.g.:      ```py     from datetime import timedelta     from pydantic_core import SchemaValidator, core_schema      schema = core_schema.timedelta_schema(le=timedelta(days=1), ge=timedelta(days=0))     v = SchemaValidator(schema)     assert v.validate_python(timedelta(hours=12)) == timedelta(hours=12)     ```      Args:         strict: Whether the value should be a timedelta or a value that can be converted to a timedelta         le: The value must be less than or equal to this timedelta         ge: The value must be greater than or equal to this timedelta         lt: The value must be strictly less than this timedelta         gt: The value must be strictly greater than this timedelta         microseconds_precision: The behavior when seconds have more than 6 digits or microseconds is too large         ref: optional unique identifier of the schema, used to reference the schema in other places         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     return _dict_not_none(         type='timedelta',         strict=strict,         le=le,         ge=ge,         lt=lt,         gt=gt,         microseconds_precision=microseconds_precision,         ref=ref,         metadata=metadata,         serialization=serialization,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#timedeltaschema-indexhtmlpydanticcorecoreschematimedeltaschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "literal\\_schema [Â¶](index.html#pydantic_core.core_schema.literal_schema \"Permanent link\")", "anchor": "literalschema-indexhtmlpydanticcorecoreschemaliteralschema-permanent-link", "md_text": "```\nliteral_schema(\n    expected: list[Any],\n    *,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None\n) -> LiteralSchema\n```\n\nReturns a schema that matches a literal value, e.g.:\n\n```\nfrom pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.literal_schema(['hello', 'world'])\nv = SchemaValidator(schema)\nassert v.validate_python('hello') == 'hello'\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `expected` | `list[Any]` | The value must be one of these values | *required* |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 ``` | ``` def literal_schema(     expected: list[Any],     *,     ref: str | None = None,     metadata: dict[str, Any] | None = None,     serialization: SerSchema | None = None, ) -> LiteralSchema:     \"\"\"     Returns a schema that matches a literal value, e.g.:      ```py     from pydantic_core import SchemaValidator, core_schema      schema = core_schema.literal_schema(['hello', 'world'])     v = SchemaValidator(schema)     assert v.validate_python('hello') == 'hello'     ```      Args:         expected: The value must be one of these values         ref: optional unique identifier of the schema, used to reference the schema in other places         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     return _dict_not_none(type='literal', expected=expected, ref=ref, metadata=metadata, serialization=serialization) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#literalschema-indexhtmlpydanticcorecoreschemaliteralschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "enum\\_schema [Â¶](index.html#pydantic_core.core_schema.enum_schema \"Permanent link\")", "anchor": "enumschema-indexhtmlpydanticcorecoreschemaenumschema-permanent-link", "md_text": "```\nenum_schema(\n    cls: Any,\n    members: list[Any],\n    *,\n    sub_type: Literal[\"str\", \"int\", \"float\"] | None = None,\n    missing: Callable[[Any], Any] | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None\n) -> EnumSchema\n```\n\nReturns a schema that matches an enum value, e.g.:\n\n```\nfrom enum import Enum\nfrom pydantic_core import SchemaValidator, core_schema\n\nclass Color(Enum):\n    RED = 1\n    GREEN = 2\n    BLUE = 3\n\nschema = core_schema.enum_schema(Color, list(Color.__members__.values()))\nv = SchemaValidator(schema)\nassert v.validate_python(2) is Color.GREEN\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `cls` | `Any` | The enum class | *required* |\n| `members` | `list[Any]` | The members of the enum, generally `list(MyEnum.__members__.values())` | *required* |\n| `sub_type` | `Literal['str', 'int', 'float'] | None` | The type of the enum, either 'str' or 'int' or None for plain enums | `None` |\n| `missing` | `Callable[[Any], Any] | None` | A function to use when the value is not found in the enum, from `_missing_` | `None` |\n| `strict` | `bool | None` | Whether to use strict mode, defaults to False | `None` |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 ``` | ``` def enum_schema(     cls: Any,     members: list[Any],     *,     sub_type: Literal['str', 'int', 'float'] | None = None,     missing: Callable[[Any], Any] | None = None,     strict: bool | None = None,     ref: str | None = None,     metadata: dict[str, Any] | None = None,     serialization: SerSchema | None = None, ) -> EnumSchema:     \"\"\"     Returns a schema that matches an enum value, e.g.:      ```py     from enum import Enum     from pydantic_core import SchemaValidator, core_schema      class Color(Enum):         RED = 1         GREEN = 2         BLUE = 3      schema = core_schema.enum_schema(Color, list(Color.__members__.values()))     v = SchemaValidator(schema)     assert v.validate_python(2) is Color.GREEN     ```      Args:         cls: The enum class         members: The members of the enum, generally `list(MyEnum.__members__.values())`         sub_type: The type of the enum, either 'str' or 'int' or None for plain enums         missing: A function to use when the value is not found in the enum, from `_missing_`         strict: Whether to use strict mode, defaults to False         ref: optional unique identifier of the schema, used to reference the schema in other places         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     return _dict_not_none(         type='enum',         cls=cls,         members=members,         sub_type=sub_type,         missing=missing,         strict=strict,         ref=ref,         metadata=metadata,         serialization=serialization,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#enumschema-indexhtmlpydanticcorecoreschemaenumschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "missing\\_sentinel\\_schema [Â¶](index.html#pydantic_core.core_schema.missing_sentinel_schema \"Permanent link\")", "anchor": "missingsentinelschema-indexhtmlpydanticcorecoreschemamissingsentinelschema-permanent-link", "md_text": "```\nmissing_sentinel_schema(\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n) -> MissingSentinelSchema\n```\n\nReturns a schema for the `MISSING` sentinel.\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 ``` | ``` def missing_sentinel_schema(     metadata: dict[str, Any] | None = None,     serialization: SerSchema | None = None, ) -> MissingSentinelSchema:     \"\"\"Returns a schema for the `MISSING` sentinel.\"\"\"      return _dict_not_none(         type='missing-sentinel',         metadata=metadata,         serialization=serialization,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#missingsentinelschema-indexhtmlpydanticcorecoreschemamissingsentinelschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "is\\_instance\\_schema [Â¶](index.html#pydantic_core.core_schema.is_instance_schema \"Permanent link\")", "anchor": "isinstanceschema-indexhtmlpydanticcorecoreschemaisinstanceschema-permanent-link", "md_text": "```\nis_instance_schema(\n    cls: Any,\n    *,\n    cls_repr: str | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None\n) -> IsInstanceSchema\n```\n\nReturns a schema that checks if a value is an instance of a class, equivalent to python's `isinstance` method, e.g.:\n\n```\nfrom pydantic_core import SchemaValidator, core_schema\n\nclass A:\n    pass\n\nschema = core_schema.is_instance_schema(cls=A)\nv = SchemaValidator(schema)\nv.validate_python(A())\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `cls` | `Any` | The value must be an instance of this class | *required* |\n| `cls_repr` | `str | None` | If provided this string is used in the validator name instead of `repr(cls)` | `None` |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 ``` | ``` def is_instance_schema(     cls: Any,     *,     cls_repr: str | None = None,     ref: str | None = None,     metadata: dict[str, Any] | None = None,     serialization: SerSchema | None = None, ) -> IsInstanceSchema:     \"\"\"     Returns a schema that checks if a value is an instance of a class, equivalent to python's `isinstance` method, e.g.:      ```py     from pydantic_core import SchemaValidator, core_schema      class A:         pass      schema = core_schema.is_instance_schema(cls=A)     v = SchemaValidator(schema)     v.validate_python(A())     ```      Args:         cls: The value must be an instance of this class         cls_repr: If provided this string is used in the validator name instead of `repr(cls)`         ref: optional unique identifier of the schema, used to reference the schema in other places         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     return _dict_not_none(         type='is-instance', cls=cls, cls_repr=cls_repr, ref=ref, metadata=metadata, serialization=serialization     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#isinstanceschema-indexhtmlpydanticcorecoreschemaisinstanceschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "is\\_subclass\\_schema [Â¶](index.html#pydantic_core.core_schema.is_subclass_schema \"Permanent link\")", "anchor": "issubclassschema-indexhtmlpydanticcorecoreschemaissubclassschema-permanent-link", "md_text": "```\nis_subclass_schema(\n    cls: type[Any],\n    *,\n    cls_repr: str | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None\n) -> IsInstanceSchema\n```\n\nReturns a schema that checks if a value is a subtype of a class, equivalent to python's `issubclass` method, e.g.:\n\n```\nfrom pydantic_core import SchemaValidator, core_schema\n\nclass A:\n    pass\n\nclass B(A):\n    pass\n\nschema = core_schema.is_subclass_schema(cls=A)\nv = SchemaValidator(schema)\nv.validate_python(B)\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `cls` | `type[Any]` | The value must be a subclass of this class | *required* |\n| `cls_repr` | `str | None` | If provided this string is used in the validator name instead of `repr(cls)` | `None` |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 ``` | ``` def is_subclass_schema(     cls: type[Any],     *,     cls_repr: str | None = None,     ref: str | None = None,     metadata: dict[str, Any] | None = None,     serialization: SerSchema | None = None, ) -> IsInstanceSchema:     \"\"\"     Returns a schema that checks if a value is a subtype of a class, equivalent to python's `issubclass` method, e.g.:      ```py     from pydantic_core import SchemaValidator, core_schema      class A:         pass      class B(A):         pass      schema = core_schema.is_subclass_schema(cls=A)     v = SchemaValidator(schema)     v.validate_python(B)     ```      Args:         cls: The value must be a subclass of this class         cls_repr: If provided this string is used in the validator name instead of `repr(cls)`         ref: optional unique identifier of the schema, used to reference the schema in other places         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     return _dict_not_none(         type='is-subclass', cls=cls, cls_repr=cls_repr, ref=ref, metadata=metadata, serialization=serialization     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#issubclassschema-indexhtmlpydanticcorecoreschemaissubclassschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "callable\\_schema [Â¶](index.html#pydantic_core.core_schema.callable_schema \"Permanent link\")", "anchor": "callableschema-indexhtmlpydanticcorecoreschemacallableschema-permanent-link", "md_text": "```\ncallable_schema(\n    *,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None\n) -> CallableSchema\n```\n\nReturns a schema that checks if a value is callable, equivalent to python's `callable` method, e.g.:\n\n```\nfrom pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.callable_schema()\nv = SchemaValidator(schema)\nv.validate_python(min)\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 1492 1493 1494 ``` | ``` def callable_schema(     *, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None ) -> CallableSchema:     \"\"\"     Returns a schema that checks if a value is callable, equivalent to python's `callable` method, e.g.:      ```py     from pydantic_core import SchemaValidator, core_schema      schema = core_schema.callable_schema()     v = SchemaValidator(schema)     v.validate_python(min)     ```      Args:         ref: optional unique identifier of the schema, used to reference the schema in other places         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     return _dict_not_none(type='callable', ref=ref, metadata=metadata, serialization=serialization) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#callableschema-indexhtmlpydanticcorecoreschemacallableschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "list\\_schema [Â¶](index.html#pydantic_core.core_schema.list_schema \"Permanent link\")", "anchor": "listschema-indexhtmlpydanticcorecoreschemalistschema-permanent-link", "md_text": "```\nlist_schema(\n    items_schema: CoreSchema | None = None,\n    *,\n    min_length: int | None = None,\n    max_length: int | None = None,\n    fail_fast: bool | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: IncExSeqOrElseSerSchema | None = None\n) -> ListSchema\n```\n\nReturns a schema that matches a list value, e.g.:\n\n```\nfrom pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.list_schema(core_schema.int_schema(), min_length=0, max_length=10)\nv = SchemaValidator(schema)\nassert v.validate_python(['4']) == [4]\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `items_schema` | `CoreSchema | None` | The value must be a list of items that match this schema | `None` |\n| `min_length` | `int | None` | The value must be a list with at least this many items | `None` |\n| `max_length` | `int | None` | The value must be a list with at most this many items | `None` |\n| `fail_fast` | `bool | None` | Stop validation on the first error | `None` |\n| `strict` | `bool | None` | The value must be a list with exactly this many items | `None` |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `IncExSeqOrElseSerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1544 1545 1546 1547 1548 1549 1550 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 ``` | ``` def list_schema(     items_schema: CoreSchema | None = None,     *,     min_length: int | None = None,     max_length: int | None = None,     fail_fast: bool | None = None,     strict: bool | None = None,     ref: str | None = None,     metadata: dict[str, Any] | None = None,     serialization: IncExSeqOrElseSerSchema | None = None, ) -> ListSchema:     \"\"\"     Returns a schema that matches a list value, e.g.:      ```py     from pydantic_core import SchemaValidator, core_schema      schema = core_schema.list_schema(core_schema.int_schema(), min_length=0, max_length=10)     v = SchemaValidator(schema)     assert v.validate_python(['4']) == [4]     ```      Args:         items_schema: The value must be a list of items that match this schema         min_length: The value must be a list with at least this many items         max_length: The value must be a list with at most this many items         fail_fast: Stop validation on the first error         strict: The value must be a list with exactly this many items         ref: optional unique identifier of the schema, used to reference the schema in other places         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     return _dict_not_none(         type='list',         items_schema=items_schema,         min_length=min_length,         max_length=max_length,         fail_fast=fail_fast,         strict=strict,         ref=ref,         metadata=metadata,         serialization=serialization,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#listschema-indexhtmlpydanticcorecoreschemalistschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "tuple\\_positional\\_schema [Â¶](index.html#pydantic_core.core_schema.tuple_positional_schema \"Permanent link\")", "anchor": "tuplepositionalschema-indexhtmlpydanticcorecoreschematuplepositionalschema-permanent-link", "md_text": "```\ntuple_positional_schema(\n    items_schema: list[CoreSchema],\n    *,\n    extras_schema: CoreSchema | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: IncExSeqOrElseSerSchema | None = None\n) -> TupleSchema\n```\n\nReturns a schema that matches a tuple of schemas, e.g.:\n\n```\nfrom pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.tuple_positional_schema(\n    [core_schema.int_schema(), core_schema.str_schema()]\n)\nv = SchemaValidator(schema)\nassert v.validate_python((1, 'hello')) == (1, 'hello')\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `items_schema` | `list[CoreSchema]` | The value must be a tuple with items that match these schemas | *required* |\n| `extras_schema` | `CoreSchema | None` | The value must be a tuple with items that match this schema This was inspired by JSON schema's `prefixItems` and `items` fields. In python's `typing.Tuple`, you can't specify a type for \"extra\" items -- they must all be the same type if the length is variable. So this field won't be set from a `typing.Tuple` annotation on a pydantic model. | `None` |\n| `strict` | `bool | None` | The value must be a tuple with exactly this many items | `None` |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `IncExSeqOrElseSerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 1635 ``` | ``` def tuple_positional_schema(     items_schema: list[CoreSchema],     *,     extras_schema: CoreSchema | None = None,     strict: bool | None = None,     ref: str | None = None,     metadata: dict[str, Any] | None = None,     serialization: IncExSeqOrElseSerSchema | None = None, ) -> TupleSchema:     \"\"\"     Returns a schema that matches a tuple of schemas, e.g.:      ```py     from pydantic_core import SchemaValidator, core_schema      schema = core_schema.tuple_positional_schema(         [core_schema.int_schema(), core_schema.str_schema()]     )     v = SchemaValidator(schema)     assert v.validate_python((1, 'hello')) == (1, 'hello')     ```      Args:         items_schema: The value must be a tuple with items that match these schemas         extras_schema: The value must be a tuple with items that match this schema             This was inspired by JSON schema's `prefixItems` and `items` fields.             In python's `typing.Tuple`, you can't specify a type for \"extra\" items -- they must all be the same type             if the length is variable. So this field won't be set from a `typing.Tuple` annotation on a pydantic model.         strict: The value must be a tuple with exactly this many items         ref: optional unique identifier of the schema, used to reference the schema in other places         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     if extras_schema is not None:         variadic_item_index = len(items_schema)         items_schema = items_schema + [extras_schema]     else:         variadic_item_index = None     return tuple_schema(         items_schema=items_schema,         variadic_item_index=variadic_item_index,         strict=strict,         ref=ref,         metadata=metadata,         serialization=serialization,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#tuplepositionalschema-indexhtmlpydanticcorecoreschematuplepositionalschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "tuple\\_variable\\_schema [Â¶](index.html#pydantic_core.core_schema.tuple_variable_schema \"Permanent link\")", "anchor": "tuplevariableschema-indexhtmlpydanticcorecoreschematuplevariableschema-permanent-link", "md_text": "```\ntuple_variable_schema(\n    items_schema: CoreSchema | None = None,\n    *,\n    min_length: int | None = None,\n    max_length: int | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: IncExSeqOrElseSerSchema | None = None\n) -> TupleSchema\n```\n\nReturns a schema that matches a tuple of a given schema, e.g.:\n\n```\nfrom pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.tuple_variable_schema(\n    items_schema=core_schema.int_schema(), min_length=0, max_length=10\n)\nv = SchemaValidator(schema)\nassert v.validate_python(('1', 2, 3)) == (1, 2, 3)\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `items_schema` | `CoreSchema | None` | The value must be a tuple with items that match this schema | `None` |\n| `min_length` | `int | None` | The value must be a tuple with at least this many items | `None` |\n| `max_length` | `int | None` | The value must be a tuple with at most this many items | `None` |\n| `strict` | `bool | None` | The value must be a tuple with exactly this many items | `None` |\n| `ref` | `str | None` | Optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `IncExSeqOrElseSerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 ``` | ``` def tuple_variable_schema(     items_schema: CoreSchema | None = None,     *,     min_length: int | None = None,     max_length: int | None = None,     strict: bool | None = None,     ref: str | None = None,     metadata: dict[str, Any] | None = None,     serialization: IncExSeqOrElseSerSchema | None = None, ) -> TupleSchema:     \"\"\"     Returns a schema that matches a tuple of a given schema, e.g.:      ```py     from pydantic_core import SchemaValidator, core_schema      schema = core_schema.tuple_variable_schema(         items_schema=core_schema.int_schema(), min_length=0, max_length=10     )     v = SchemaValidator(schema)     assert v.validate_python(('1', 2, 3)) == (1, 2, 3)     ```      Args:         items_schema: The value must be a tuple with items that match this schema         min_length: The value must be a tuple with at least this many items         max_length: The value must be a tuple with at most this many items         strict: The value must be a tuple with exactly this many items         ref: Optional unique identifier of the schema, used to reference the schema in other places         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     return tuple_schema(         items_schema=[items_schema or any_schema()],         variadic_item_index=0,         min_length=min_length,         max_length=max_length,         strict=strict,         ref=ref,         metadata=metadata,         serialization=serialization,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#tuplevariableschema-indexhtmlpydanticcorecoreschematuplevariableschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "tuple\\_schema [Â¶](index.html#pydantic_core.core_schema.tuple_schema \"Permanent link\")", "anchor": "tupleschema-indexhtmlpydanticcorecoreschematupleschema-permanent-link", "md_text": "```\ntuple_schema(\n    items_schema: list[CoreSchema],\n    *,\n    variadic_item_index: int | None = None,\n    min_length: int | None = None,\n    max_length: int | None = None,\n    fail_fast: bool | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: IncExSeqOrElseSerSchema | None = None\n) -> TupleSchema\n```\n\nReturns a schema that matches a tuple of schemas, with an optional variadic item, e.g.:\n\n```\nfrom pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.tuple_schema(\n    [core_schema.int_schema(), core_schema.str_schema(), core_schema.float_schema()],\n    variadic_item_index=1,\n)\nv = SchemaValidator(schema)\nassert v.validate_python((1, 'hello', 'world', 1.5)) == (1, 'hello', 'world', 1.5)\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `items_schema` | `list[CoreSchema]` | The value must be a tuple with items that match these schemas | *required* |\n| `variadic_item_index` | `int | None` | The index of the schema in `items_schema` to be treated as variadic (following PEP 646) | `None` |\n| `min_length` | `int | None` | The value must be a tuple with at least this many items | `None` |\n| `max_length` | `int | None` | The value must be a tuple with at most this many items | `None` |\n| `fail_fast` | `bool | None` | Stop validation on the first error | `None` |\n| `strict` | `bool | None` | The value must be a tuple with exactly this many items | `None` |\n| `ref` | `str | None` | Optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `IncExSeqOrElseSerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711 1712 1713 1714 1715 1716 1717 1718 1719 1720 1721 1722 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1738 1739 1740 1741 1742 1743 1744 ``` | ``` def tuple_schema(     items_schema: list[CoreSchema],     *,     variadic_item_index: int | None = None,     min_length: int | None = None,     max_length: int | None = None,     fail_fast: bool | None = None,     strict: bool | None = None,     ref: str | None = None,     metadata: dict[str, Any] | None = None,     serialization: IncExSeqOrElseSerSchema | None = None, ) -> TupleSchema:     \"\"\"     Returns a schema that matches a tuple of schemas, with an optional variadic item, e.g.:      ```py     from pydantic_core import SchemaValidator, core_schema      schema = core_schema.tuple_schema(         [core_schema.int_schema(), core_schema.str_schema(), core_schema.float_schema()],         variadic_item_index=1,     )     v = SchemaValidator(schema)     assert v.validate_python((1, 'hello', 'world', 1.5)) == (1, 'hello', 'world', 1.5)     ```      Args:         items_schema: The value must be a tuple with items that match these schemas         variadic_item_index: The index of the schema in `items_schema` to be treated as variadic (following PEP 646)         min_length: The value must be a tuple with at least this many items         max_length: The value must be a tuple with at most this many items         fail_fast: Stop validation on the first error         strict: The value must be a tuple with exactly this many items         ref: Optional unique identifier of the schema, used to reference the schema in other places         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     return _dict_not_none(         type='tuple',         items_schema=items_schema,         variadic_item_index=variadic_item_index,         min_length=min_length,         max_length=max_length,         fail_fast=fail_fast,         strict=strict,         ref=ref,         metadata=metadata,         serialization=serialization,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#tupleschema-indexhtmlpydanticcorecoreschematupleschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "set\\_schema [Â¶](index.html#pydantic_core.core_schema.set_schema \"Permanent link\")", "anchor": "setschema-indexhtmlpydanticcorecoreschemasetschema-permanent-link", "md_text": "```\nset_schema(\n    items_schema: CoreSchema | None = None,\n    *,\n    min_length: int | None = None,\n    max_length: int | None = None,\n    fail_fast: bool | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None\n) -> SetSchema\n```\n\nReturns a schema that matches a set of a given schema, e.g.:\n\n```\nfrom pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.set_schema(\n    items_schema=core_schema.int_schema(), min_length=0, max_length=10\n)\nv = SchemaValidator(schema)\nassert v.validate_python({1, '2', 3}) == {1, 2, 3}\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `items_schema` | `CoreSchema | None` | The value must be a set with items that match this schema | `None` |\n| `min_length` | `int | None` | The value must be a set with at least this many items | `None` |\n| `max_length` | `int | None` | The value must be a set with at most this many items | `None` |\n| `fail_fast` | `bool | None` | Stop validation on the first error | `None` |\n| `strict` | `bool | None` | The value must be a set with exactly this many items | `None` |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1759 1760 1761 1762 1763 1764 1765 1766 1767 1768 1769 1770 1771 1772 1773 1774 1775 1776 1777 1778 1779 1780 1781 1782 1783 1784 1785 1786 1787 1788 1789 1790 1791 1792 1793 1794 1795 1796 1797 1798 1799 1800 1801 1802 1803 ``` | ``` def set_schema(     items_schema: CoreSchema | None = None,     *,     min_length: int | None = None,     max_length: int | None = None,     fail_fast: bool | None = None,     strict: bool | None = None,     ref: str | None = None,     metadata: dict[str, Any] | None = None,     serialization: SerSchema | None = None, ) -> SetSchema:     \"\"\"     Returns a schema that matches a set of a given schema, e.g.:      ```py     from pydantic_core import SchemaValidator, core_schema      schema = core_schema.set_schema(         items_schema=core_schema.int_schema(), min_length=0, max_length=10     )     v = SchemaValidator(schema)     assert v.validate_python({1, '2', 3}) == {1, 2, 3}     ```      Args:         items_schema: The value must be a set with items that match this schema         min_length: The value must be a set with at least this many items         max_length: The value must be a set with at most this many items         fail_fast: Stop validation on the first error         strict: The value must be a set with exactly this many items         ref: optional unique identifier of the schema, used to reference the schema in other places         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     return _dict_not_none(         type='set',         items_schema=items_schema,         min_length=min_length,         max_length=max_length,         fail_fast=fail_fast,         strict=strict,         ref=ref,         metadata=metadata,         serialization=serialization,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#setschema-indexhtmlpydanticcorecoreschemasetschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "frozenset\\_schema [Â¶](index.html#pydantic_core.core_schema.frozenset_schema \"Permanent link\")", "anchor": "frozensetschema-indexhtmlpydanticcorecoreschemafrozensetschema-permanent-link", "md_text": "```\nfrozenset_schema(\n    items_schema: CoreSchema | None = None,\n    *,\n    min_length: int | None = None,\n    max_length: int | None = None,\n    fail_fast: bool | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None\n) -> FrozenSetSchema\n```\n\nReturns a schema that matches a frozenset of a given schema, e.g.:\n\n```\nfrom pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.frozenset_schema(\n    items_schema=core_schema.int_schema(), min_length=0, max_length=10\n)\nv = SchemaValidator(schema)\nassert v.validate_python(frozenset(range(3))) == frozenset({0, 1, 2})\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `items_schema` | `CoreSchema | None` | The value must be a frozenset with items that match this schema | `None` |\n| `min_length` | `int | None` | The value must be a frozenset with at least this many items | `None` |\n| `max_length` | `int | None` | The value must be a frozenset with at most this many items | `None` |\n| `fail_fast` | `bool | None` | Stop validation on the first error | `None` |\n| `strict` | `bool | None` | The value must be a frozenset with exactly this many items | `None` |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1818 1819 1820 1821 1822 1823 1824 1825 1826 1827 1828 1829 1830 1831 1832 1833 1834 1835 1836 1837 1838 1839 1840 1841 1842 1843 1844 1845 1846 1847 1848 1849 1850 1851 1852 1853 1854 1855 1856 1857 1858 1859 1860 1861 1862 ``` | ``` def frozenset_schema(     items_schema: CoreSchema | None = None,     *,     min_length: int | None = None,     max_length: int | None = None,     fail_fast: bool | None = None,     strict: bool | None = None,     ref: str | None = None,     metadata: dict[str, Any] | None = None,     serialization: SerSchema | None = None, ) -> FrozenSetSchema:     \"\"\"     Returns a schema that matches a frozenset of a given schema, e.g.:      ```py     from pydantic_core import SchemaValidator, core_schema      schema = core_schema.frozenset_schema(         items_schema=core_schema.int_schema(), min_length=0, max_length=10     )     v = SchemaValidator(schema)     assert v.validate_python(frozenset(range(3))) == frozenset({0, 1, 2})     ```      Args:         items_schema: The value must be a frozenset with items that match this schema         min_length: The value must be a frozenset with at least this many items         max_length: The value must be a frozenset with at most this many items         fail_fast: Stop validation on the first error         strict: The value must be a frozenset with exactly this many items         ref: optional unique identifier of the schema, used to reference the schema in other places         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     return _dict_not_none(         type='frozenset',         items_schema=items_schema,         min_length=min_length,         max_length=max_length,         fail_fast=fail_fast,         strict=strict,         ref=ref,         metadata=metadata,         serialization=serialization,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#frozensetschema-indexhtmlpydanticcorecoreschemafrozensetschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "generator\\_schema [Â¶](index.html#pydantic_core.core_schema.generator_schema \"Permanent link\")", "anchor": "generatorschema-indexhtmlpydanticcorecoreschemageneratorschema-permanent-link", "md_text": "```\ngenerator_schema(\n    items_schema: CoreSchema | None = None,\n    *,\n    min_length: int | None = None,\n    max_length: int | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: IncExSeqOrElseSerSchema | None = None\n) -> GeneratorSchema\n```\n\nReturns a schema that matches a generator value, e.g.:\n\n```\nfrom typing import Iterator\nfrom pydantic_core import SchemaValidator, core_schema\n\ndef gen() -> Iterator[int]:\n    yield 1\n\nschema = core_schema.generator_schema(items_schema=core_schema.int_schema())\nv = SchemaValidator(schema)\nv.validate_python(gen())\n```\n\nUnlike other types, validated generators do not raise ValidationErrors eagerly,\nbut instead will raise a ValidationError when a violating value is actually read from the generator.\nThis is to ensure that \"validated\" generators retain the benefit of lazy evaluation.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `items_schema` | `CoreSchema | None` | The value must be a generator with items that match this schema | `None` |\n| `min_length` | `int | None` | The value must be a generator that yields at least this many items | `None` |\n| `max_length` | `int | None` | The value must be a generator that yields at most this many items | `None` |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `IncExSeqOrElseSerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1875 1876 1877 1878 1879 1880 1881 1882 1883 1884 1885 1886 1887 1888 1889 1890 1891 1892 1893 1894 1895 1896 1897 1898 1899 1900 1901 1902 1903 1904 1905 1906 1907 1908 1909 1910 1911 1912 1913 1914 1915 1916 1917 1918 1919 ``` | ``` def generator_schema(     items_schema: CoreSchema | None = None,     *,     min_length: int | None = None,     max_length: int | None = None,     ref: str | None = None,     metadata: dict[str, Any] | None = None,     serialization: IncExSeqOrElseSerSchema | None = None, ) -> GeneratorSchema:     \"\"\"     Returns a schema that matches a generator value, e.g.:      ```py     from typing import Iterator     from pydantic_core import SchemaValidator, core_schema      def gen() -> Iterator[int]:         yield 1      schema = core_schema.generator_schema(items_schema=core_schema.int_schema())     v = SchemaValidator(schema)     v.validate_python(gen())     ```      Unlike other types, validated generators do not raise ValidationErrors eagerly,     but instead will raise a ValidationError when a violating value is actually read from the generator.     This is to ensure that \"validated\" generators retain the benefit of lazy evaluation.      Args:         items_schema: The value must be a generator with items that match this schema         min_length: The value must be a generator that yields at least this many items         max_length: The value must be a generator that yields at most this many items         ref: optional unique identifier of the schema, used to reference the schema in other places         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     return _dict_not_none(         type='generator',         items_schema=items_schema,         min_length=min_length,         max_length=max_length,         ref=ref,         metadata=metadata,         serialization=serialization,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#generatorschema-indexhtmlpydanticcorecoreschemageneratorschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "dict\\_schema [Â¶](index.html#pydantic_core.core_schema.dict_schema \"Permanent link\")", "anchor": "dictschema-indexhtmlpydanticcorecoreschemadictschema-permanent-link", "md_text": "```\ndict_schema(\n    keys_schema: CoreSchema | None = None,\n    values_schema: CoreSchema | None = None,\n    *,\n    min_length: int | None = None,\n    max_length: int | None = None,\n    fail_fast: bool | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None\n) -> DictSchema\n```\n\nReturns a schema that matches a dict value, e.g.:\n\n```\nfrom pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.dict_schema(\n    keys_schema=core_schema.str_schema(), values_schema=core_schema.int_schema()\n)\nv = SchemaValidator(schema)\nassert v.validate_python({'a': '1', 'b': 2}) == {'a': 1, 'b': 2}\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `keys_schema` | `CoreSchema | None` | The value must be a dict with keys that match this schema | `None` |\n| `values_schema` | `CoreSchema | None` | The value must be a dict with values that match this schema | `None` |\n| `min_length` | `int | None` | The value must be a dict with at least this many items | `None` |\n| `max_length` | `int | None` | The value must be a dict with at most this many items | `None` |\n| `fail_fast` | `bool | None` | Stop validation on the first error | `None` |\n| `strict` | `bool | None` | Whether the keys and values should be validated with strict mode | `None` |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 ``` | ``` def dict_schema(     keys_schema: CoreSchema | None = None,     values_schema: CoreSchema | None = None,     *,     min_length: int | None = None,     max_length: int | None = None,     fail_fast: bool | None = None,     strict: bool | None = None,     ref: str | None = None,     metadata: dict[str, Any] | None = None,     serialization: SerSchema | None = None, ) -> DictSchema:     \"\"\"     Returns a schema that matches a dict value, e.g.:      ```py     from pydantic_core import SchemaValidator, core_schema      schema = core_schema.dict_schema(         keys_schema=core_schema.str_schema(), values_schema=core_schema.int_schema()     )     v = SchemaValidator(schema)     assert v.validate_python({'a': '1', 'b': 2}) == {'a': 1, 'b': 2}     ```      Args:         keys_schema: The value must be a dict with keys that match this schema         values_schema: The value must be a dict with values that match this schema         min_length: The value must be a dict with at least this many items         max_length: The value must be a dict with at most this many items         fail_fast: Stop validation on the first error         strict: Whether the keys and values should be validated with strict mode         ref: optional unique identifier of the schema, used to reference the schema in other places         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     return _dict_not_none(         type='dict',         keys_schema=keys_schema,         values_schema=values_schema,         min_length=min_length,         max_length=max_length,         fail_fast=fail_fast,         strict=strict,         ref=ref,         metadata=metadata,         serialization=serialization,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#dictschema-indexhtmlpydanticcorecoreschemadictschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "no\\_info\\_before\\_validator\\_function [Â¶](index.html#pydantic_core.core_schema.no_info_before_validator_function \"Permanent link\")", "anchor": "noinfobeforevalidatorfunction-indexhtmlpydanticcorecoreschemanoinfobeforevalidatorfunction-permanent-link", "md_text": "```\nno_info_before_validator_function(\n    function: NoInfoValidatorFunction,\n    schema: CoreSchema,\n    *,\n    ref: str | None = None,\n    json_schema_input_schema: CoreSchema | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None\n) -> BeforeValidatorFunctionSchema\n```\n\nReturns a schema that calls a validator function before validating, no `info` argument is provided, e.g.:\n\n```\nfrom pydantic_core import SchemaValidator, core_schema\n\ndef fn(v: bytes) -> str:\n    return v.decode() + 'world'\n\nfunc_schema = core_schema.no_info_before_validator_function(\n    function=fn, schema=core_schema.str_schema()\n)\nschema = core_schema.typed_dict_schema({'a': core_schema.typed_dict_field(func_schema)})\n\nv = SchemaValidator(schema)\nassert v.validate_python({'a': b'hello '}) == {'a': 'hello world'}\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `function` | `NoInfoValidatorFunction` | The validator function to call | *required* |\n| `schema` | `CoreSchema` | The schema to validate the output of the validator function | *required* |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `json_schema_input_schema` | `CoreSchema | None` | The core schema to be used to generate the corresponding JSON Schema input type | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 2036 2037 2038 2039 2040 2041 2042 2043 2044 2045 2046 2047 2048 2049 2050 2051 2052 2053 2054 2055 2056 2057 2058 2059 2060 2061 2062 2063 2064 2065 2066 2067 2068 2069 2070 2071 2072 2073 2074 2075 2076 2077 2078 2079 ``` | ``` def no_info_before_validator_function(     function: NoInfoValidatorFunction,     schema: CoreSchema,     *,     ref: str | None = None,     json_schema_input_schema: CoreSchema | None = None,     metadata: dict[str, Any] | None = None,     serialization: SerSchema | None = None, ) -> BeforeValidatorFunctionSchema:     \"\"\"     Returns a schema that calls a validator function before validating, no `info` argument is provided, e.g.:      ```py     from pydantic_core import SchemaValidator, core_schema      def fn(v: bytes) -> str:         return v.decode() + 'world'      func_schema = core_schema.no_info_before_validator_function(         function=fn, schema=core_schema.str_schema()     )     schema = core_schema.typed_dict_schema({'a': core_schema.typed_dict_field(func_schema)})      v = SchemaValidator(schema)     assert v.validate_python({'a': b'hello '}) == {'a': 'hello world'}     ```      Args:         function: The validator function to call         schema: The schema to validate the output of the validator function         ref: optional unique identifier of the schema, used to reference the schema in other places         json_schema_input_schema: The core schema to be used to generate the corresponding JSON Schema input type         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     return _dict_not_none(         type='function-before',         function={'type': 'no-info', 'function': function},         schema=schema,         ref=ref,         json_schema_input_schema=json_schema_input_schema,         metadata=metadata,         serialization=serialization,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#noinfobeforevalidatorfunction-indexhtmlpydanticcorecoreschemanoinfobeforevalidatorfunction-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "with\\_info\\_before\\_validator\\_function [Â¶](index.html#pydantic_core.core_schema.with_info_before_validator_function \"Permanent link\")", "anchor": "withinfobeforevalidatorfunction-indexhtmlpydanticcorecoreschemawithinfobeforevalidatorfunction-permanent-link", "md_text": "```\nwith_info_before_validator_function(\n    function: WithInfoValidatorFunction,\n    schema: CoreSchema,\n    *,\n    field_name: str | None = None,\n    ref: str | None = None,\n    json_schema_input_schema: CoreSchema | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None\n) -> BeforeValidatorFunctionSchema\n```\n\nReturns a schema that calls a validator function before validation, the function is called with\nan `info` argument, e.g.:\n\n```\nfrom pydantic_core import SchemaValidator, core_schema\n\ndef fn(v: bytes, info: core_schema.ValidationInfo) -> str:\n    assert info.data is not None\n    assert info.field_name is not None\n    return v.decode() + 'world'\n\nfunc_schema = core_schema.with_info_before_validator_function(\n    function=fn, schema=core_schema.str_schema()\n)\nschema = core_schema.typed_dict_schema({'a': core_schema.typed_dict_field(func_schema)})\n\nv = SchemaValidator(schema)\nassert v.validate_python({'a': b'hello '}) == {'a': 'hello world'}\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `function` | `WithInfoValidatorFunction` | The validator function to call | *required* |\n| `field_name` | `str | None` | The name of the field this validator is applied to, if any (deprecated) | `None` |\n| `schema` | `CoreSchema` | The schema to validate the output of the validator function | *required* |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `json_schema_input_schema` | `CoreSchema | None` | The core schema to be used to generate the corresponding JSON Schema input type | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 2082 2083 2084 2085 2086 2087 2088 2089 2090 2091 2092 2093 2094 2095 2096 2097 2098 2099 2100 2101 2102 2103 2104 2105 2106 2107 2108 2109 2110 2111 2112 2113 2114 2115 2116 2117 2118 2119 2120 2121 2122 2123 2124 2125 2126 2127 2128 2129 2130 2131 2132 2133 2134 2135 2136 2137 ``` | ``` def with_info_before_validator_function(     function: WithInfoValidatorFunction,     schema: CoreSchema,     *,     field_name: str | None = None,     ref: str | None = None,     json_schema_input_schema: CoreSchema | None = None,     metadata: dict[str, Any] | None = None,     serialization: SerSchema | None = None, ) -> BeforeValidatorFunctionSchema:     \"\"\"     Returns a schema that calls a validator function before validation, the function is called with     an `info` argument, e.g.:      ```py     from pydantic_core import SchemaValidator, core_schema      def fn(v: bytes, info: core_schema.ValidationInfo) -> str:         assert info.data is not None         assert info.field_name is not None         return v.decode() + 'world'      func_schema = core_schema.with_info_before_validator_function(         function=fn, schema=core_schema.str_schema()     )     schema = core_schema.typed_dict_schema({'a': core_schema.typed_dict_field(func_schema)})      v = SchemaValidator(schema)     assert v.validate_python({'a': b'hello '}) == {'a': 'hello world'}     ```      Args:         function: The validator function to call         field_name: The name of the field this validator is applied to, if any (deprecated)         schema: The schema to validate the output of the validator function         ref: optional unique identifier of the schema, used to reference the schema in other places         json_schema_input_schema: The core schema to be used to generate the corresponding JSON Schema input type         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     if field_name is not None:         warnings.warn(             'The `field_name` argument on `with_info_before_validator_function` is deprecated, it will be passed to the function through `ValidationState` instead.',             DeprecationWarning,             stacklevel=2,         )      return _dict_not_none(         type='function-before',         function=_dict_not_none(type='with-info', function=function, field_name=field_name),         schema=schema,         ref=ref,         json_schema_input_schema=json_schema_input_schema,         metadata=metadata,         serialization=serialization,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#withinfobeforevalidatorfunction-indexhtmlpydanticcorecoreschemawithinfobeforevalidatorfunction-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "no\\_info\\_after\\_validator\\_function [Â¶](index.html#pydantic_core.core_schema.no_info_after_validator_function \"Permanent link\")", "anchor": "noinfoaftervalidatorfunction-indexhtmlpydanticcorecoreschemanoinfoaftervalidatorfunction-permanent-link", "md_text": "```\nno_info_after_validator_function(\n    function: NoInfoValidatorFunction,\n    schema: CoreSchema,\n    *,\n    ref: str | None = None,\n    json_schema_input_schema: CoreSchema | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None\n) -> AfterValidatorFunctionSchema\n```\n\nReturns a schema that calls a validator function after validating, no `info` argument is provided, e.g.:\n\n```\nfrom pydantic_core import SchemaValidator, core_schema\n\ndef fn(v: str) -> str:\n    return v + 'world'\n\nfunc_schema = core_schema.no_info_after_validator_function(fn, core_schema.str_schema())\nschema = core_schema.typed_dict_schema({'a': core_schema.typed_dict_field(func_schema)})\n\nv = SchemaValidator(schema)\nassert v.validate_python({'a': b'hello '}) == {'a': 'hello world'}\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `function` | `NoInfoValidatorFunction` | The validator function to call after the schema is validated | *required* |\n| `schema` | `CoreSchema` | The schema to validate before the validator function | *required* |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `json_schema_input_schema` | `CoreSchema | None` | The core schema to be used to generate the corresponding JSON Schema input type | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 2144 2145 2146 2147 2148 2149 2150 2151 2152 2153 2154 2155 2156 2157 2158 2159 2160 2161 2162 2163 2164 2165 2166 2167 2168 2169 2170 2171 2172 2173 2174 2175 2176 2177 2178 2179 2180 2181 2182 2183 2184 2185 ``` | ``` def no_info_after_validator_function(     function: NoInfoValidatorFunction,     schema: CoreSchema,     *,     ref: str | None = None,     json_schema_input_schema: CoreSchema | None = None,     metadata: dict[str, Any] | None = None,     serialization: SerSchema | None = None, ) -> AfterValidatorFunctionSchema:     \"\"\"     Returns a schema that calls a validator function after validating, no `info` argument is provided, e.g.:      ```py     from pydantic_core import SchemaValidator, core_schema      def fn(v: str) -> str:         return v + 'world'      func_schema = core_schema.no_info_after_validator_function(fn, core_schema.str_schema())     schema = core_schema.typed_dict_schema({'a': core_schema.typed_dict_field(func_schema)})      v = SchemaValidator(schema)     assert v.validate_python({'a': b'hello '}) == {'a': 'hello world'}     ```      Args:         function: The validator function to call after the schema is validated         schema: The schema to validate before the validator function         ref: optional unique identifier of the schema, used to reference the schema in other places         json_schema_input_schema: The core schema to be used to generate the corresponding JSON Schema input type         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     return _dict_not_none(         type='function-after',         function={'type': 'no-info', 'function': function},         schema=schema,         ref=ref,         json_schema_input_schema=json_schema_input_schema,         metadata=metadata,         serialization=serialization,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#noinfoaftervalidatorfunction-indexhtmlpydanticcorecoreschemanoinfoaftervalidatorfunction-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "with\\_info\\_after\\_validator\\_function [Â¶](index.html#pydantic_core.core_schema.with_info_after_validator_function \"Permanent link\")", "anchor": "withinfoaftervalidatorfunction-indexhtmlpydanticcorecoreschemawithinfoaftervalidatorfunction-permanent-link", "md_text": "```\nwith_info_after_validator_function(\n    function: WithInfoValidatorFunction,\n    schema: CoreSchema,\n    *,\n    field_name: str | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None\n) -> AfterValidatorFunctionSchema\n```\n\nReturns a schema that calls a validator function after validation, the function is called with\nan `info` argument, e.g.:\n\n```\nfrom pydantic_core import SchemaValidator, core_schema\n\ndef fn(v: str, info: core_schema.ValidationInfo) -> str:\n    assert info.data is not None\n    assert info.field_name is not None\n    return v + 'world'\n\nfunc_schema = core_schema.with_info_after_validator_function(\n    function=fn, schema=core_schema.str_schema()\n)\nschema = core_schema.typed_dict_schema({'a': core_schema.typed_dict_field(func_schema)})\n\nv = SchemaValidator(schema)\nassert v.validate_python({'a': b'hello '}) == {'a': 'hello world'}\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `function` | `WithInfoValidatorFunction` | The validator function to call after the schema is validated | *required* |\n| `schema` | `CoreSchema` | The schema to validate before the validator function | *required* |\n| `field_name` | `str | None` | The name of the field this validator is applied to, if any (deprecated) | `None` |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 2188 2189 2190 2191 2192 2193 2194 2195 2196 2197 2198 2199 2200 2201 2202 2203 2204 2205 2206 2207 2208 2209 2210 2211 2212 2213 2214 2215 2216 2217 2218 2219 2220 2221 2222 2223 2224 2225 2226 2227 2228 2229 2230 2231 2232 2233 2234 2235 2236 2237 2238 2239 2240 ``` | ``` def with_info_after_validator_function(     function: WithInfoValidatorFunction,     schema: CoreSchema,     *,     field_name: str | None = None,     ref: str | None = None,     metadata: dict[str, Any] | None = None,     serialization: SerSchema | None = None, ) -> AfterValidatorFunctionSchema:     \"\"\"     Returns a schema that calls a validator function after validation, the function is called with     an `info` argument, e.g.:      ```py     from pydantic_core import SchemaValidator, core_schema      def fn(v: str, info: core_schema.ValidationInfo) -> str:         assert info.data is not None         assert info.field_name is not None         return v + 'world'      func_schema = core_schema.with_info_after_validator_function(         function=fn, schema=core_schema.str_schema()     )     schema = core_schema.typed_dict_schema({'a': core_schema.typed_dict_field(func_schema)})      v = SchemaValidator(schema)     assert v.validate_python({'a': b'hello '}) == {'a': 'hello world'}     ```      Args:         function: The validator function to call after the schema is validated         schema: The schema to validate before the validator function         field_name: The name of the field this validator is applied to, if any (deprecated)         ref: optional unique identifier of the schema, used to reference the schema in other places         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     if field_name is not None:         warnings.warn(             'The `field_name` argument on `with_info_after_validator_function` is deprecated, it will be passed to the function through `ValidationState` instead.',             DeprecationWarning,             stacklevel=2,         )      return _dict_not_none(         type='function-after',         function=_dict_not_none(type='with-info', function=function, field_name=field_name),         schema=schema,         ref=ref,         metadata=metadata,         serialization=serialization,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#withinfoaftervalidatorfunction-indexhtmlpydanticcorecoreschemawithinfoaftervalidatorfunction-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "no\\_info\\_wrap\\_validator\\_function [Â¶](index.html#pydantic_core.core_schema.no_info_wrap_validator_function \"Permanent link\")", "anchor": "noinfowrapvalidatorfunction-indexhtmlpydanticcorecoreschemanoinfowrapvalidatorfunction-permanent-link", "md_text": "```\nno_info_wrap_validator_function(\n    function: NoInfoWrapValidatorFunction,\n    schema: CoreSchema,\n    *,\n    ref: str | None = None,\n    json_schema_input_schema: CoreSchema | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None\n) -> WrapValidatorFunctionSchema\n```\n\nReturns a schema which calls a function with a `validator` callable argument which can\noptionally be used to call inner validation with the function logic, this is much like the\n\"onion\" implementation of middleware in many popular web frameworks, no `info` argument is passed, e.g.:\n\n```\nfrom pydantic_core import SchemaValidator, core_schema\n\ndef fn(\n    v: str,\n    validator: core_schema.ValidatorFunctionWrapHandler,\n) -> str:\n    return validator(input_value=v) + 'world'\n\nschema = core_schema.no_info_wrap_validator_function(\n    function=fn, schema=core_schema.str_schema()\n)\nv = SchemaValidator(schema)\nassert v.validate_python('hello ') == 'hello world'\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `function` | `NoInfoWrapValidatorFunction` | The validator function to call | *required* |\n| `schema` | `CoreSchema` | The schema to validate the output of the validator function | *required* |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `json_schema_input_schema` | `CoreSchema | None` | The core schema to be used to generate the corresponding JSON Schema input type | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 2280 2281 2282 2283 2284 2285 2286 2287 2288 2289 2290 2291 2292 2293 2294 2295 2296 2297 2298 2299 2300 2301 2302 2303 2304 2305 2306 2307 2308 2309 2310 2311 2312 2313 2314 2315 2316 2317 2318 2319 2320 2321 2322 2323 2324 2325 2326 ``` | ``` def no_info_wrap_validator_function(     function: NoInfoWrapValidatorFunction,     schema: CoreSchema,     *,     ref: str | None = None,     json_schema_input_schema: CoreSchema | None = None,     metadata: dict[str, Any] | None = None,     serialization: SerSchema | None = None, ) -> WrapValidatorFunctionSchema:     \"\"\"     Returns a schema which calls a function with a `validator` callable argument which can     optionally be used to call inner validation with the function logic, this is much like the     \"onion\" implementation of middleware in many popular web frameworks, no `info` argument is passed, e.g.:      ```py     from pydantic_core import SchemaValidator, core_schema      def fn(         v: str,         validator: core_schema.ValidatorFunctionWrapHandler,     ) -> str:         return validator(input_value=v) + 'world'      schema = core_schema.no_info_wrap_validator_function(         function=fn, schema=core_schema.str_schema()     )     v = SchemaValidator(schema)     assert v.validate_python('hello ') == 'hello world'     ```      Args:         function: The validator function to call         schema: The schema to validate the output of the validator function         ref: optional unique identifier of the schema, used to reference the schema in other places         json_schema_input_schema: The core schema to be used to generate the corresponding JSON Schema input type         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     return _dict_not_none(         type='function-wrap',         function={'type': 'no-info', 'function': function},         schema=schema,         json_schema_input_schema=json_schema_input_schema,         ref=ref,         metadata=metadata,         serialization=serialization,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#noinfowrapvalidatorfunction-indexhtmlpydanticcorecoreschemanoinfowrapvalidatorfunction-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "with\\_info\\_wrap\\_validator\\_function [Â¶](index.html#pydantic_core.core_schema.with_info_wrap_validator_function \"Permanent link\")", "anchor": "withinfowrapvalidatorfunction-indexhtmlpydanticcorecoreschemawithinfowrapvalidatorfunction-permanent-link", "md_text": "```\nwith_info_wrap_validator_function(\n    function: WithInfoWrapValidatorFunction,\n    schema: CoreSchema,\n    *,\n    field_name: str | None = None,\n    json_schema_input_schema: CoreSchema | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None\n) -> WrapValidatorFunctionSchema\n```\n\nReturns a schema which calls a function with a `validator` callable argument which can\noptionally be used to call inner validation with the function logic, this is much like the\n\"onion\" implementation of middleware in many popular web frameworks, an `info` argument is also passed, e.g.:\n\n```\nfrom pydantic_core import SchemaValidator, core_schema\n\ndef fn(\n    v: str,\n    validator: core_schema.ValidatorFunctionWrapHandler,\n    info: core_schema.ValidationInfo,\n) -> str:\n    return validator(input_value=v) + 'world'\n\nschema = core_schema.with_info_wrap_validator_function(\n    function=fn, schema=core_schema.str_schema()\n)\nv = SchemaValidator(schema)\nassert v.validate_python('hello ') == 'hello world'\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `function` | `WithInfoWrapValidatorFunction` | The validator function to call | *required* |\n| `schema` | `CoreSchema` | The schema to validate the output of the validator function | *required* |\n| `field_name` | `str | None` | The name of the field this validator is applied to, if any (deprecated) | `None` |\n| `json_schema_input_schema` | `CoreSchema | None` | The core schema to be used to generate the corresponding JSON Schema input type | `None` |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 2329 2330 2331 2332 2333 2334 2335 2336 2337 2338 2339 2340 2341 2342 2343 2344 2345 2346 2347 2348 2349 2350 2351 2352 2353 2354 2355 2356 2357 2358 2359 2360 2361 2362 2363 2364 2365 2366 2367 2368 2369 2370 2371 2372 2373 2374 2375 2376 2377 2378 2379 2380 2381 2382 2383 2384 2385 ``` | ``` def with_info_wrap_validator_function(     function: WithInfoWrapValidatorFunction,     schema: CoreSchema,     *,     field_name: str | None = None,     json_schema_input_schema: CoreSchema | None = None,     ref: str | None = None,     metadata: dict[str, Any] | None = None,     serialization: SerSchema | None = None, ) -> WrapValidatorFunctionSchema:     \"\"\"     Returns a schema which calls a function with a `validator` callable argument which can     optionally be used to call inner validation with the function logic, this is much like the     \"onion\" implementation of middleware in many popular web frameworks, an `info` argument is also passed, e.g.:      ```py     from pydantic_core import SchemaValidator, core_schema      def fn(         v: str,         validator: core_schema.ValidatorFunctionWrapHandler,         info: core_schema.ValidationInfo,     ) -> str:         return validator(input_value=v) + 'world'      schema = core_schema.with_info_wrap_validator_function(         function=fn, schema=core_schema.str_schema()     )     v = SchemaValidator(schema)     assert v.validate_python('hello ') == 'hello world'     ```      Args:         function: The validator function to call         schema: The schema to validate the output of the validator function         field_name: The name of the field this validator is applied to, if any (deprecated)         json_schema_input_schema: The core schema to be used to generate the corresponding JSON Schema input type         ref: optional unique identifier of the schema, used to reference the schema in other places         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     if field_name is not None:         warnings.warn(             'The `field_name` argument on `with_info_wrap_validator_function` is deprecated, it will be passed to the function through `ValidationState` instead.',             DeprecationWarning,             stacklevel=2,         )      return _dict_not_none(         type='function-wrap',         function=_dict_not_none(type='with-info', function=function, field_name=field_name),         schema=schema,         json_schema_input_schema=json_schema_input_schema,         ref=ref,         metadata=metadata,         serialization=serialization,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#withinfowrapvalidatorfunction-indexhtmlpydanticcorecoreschemawithinfowrapvalidatorfunction-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "no\\_info\\_plain\\_validator\\_function [Â¶](index.html#pydantic_core.core_schema.no_info_plain_validator_function \"Permanent link\")", "anchor": "noinfoplainvalidatorfunction-indexhtmlpydanticcorecoreschemanoinfoplainvalidatorfunction-permanent-link", "md_text": "```\nno_info_plain_validator_function(\n    function: NoInfoValidatorFunction,\n    *,\n    ref: str | None = None,\n    json_schema_input_schema: CoreSchema | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None\n) -> PlainValidatorFunctionSchema\n```\n\nReturns a schema that uses the provided function for validation, no `info` argument is passed, e.g.:\n\n```\nfrom pydantic_core import SchemaValidator, core_schema\n\ndef fn(v: str) -> str:\n    assert 'hello' in v\n    return v + 'world'\n\nschema = core_schema.no_info_plain_validator_function(function=fn)\nv = SchemaValidator(schema)\nassert v.validate_python('hello ') == 'hello world'\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `function` | `NoInfoValidatorFunction` | The validator function to call | *required* |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `json_schema_input_schema` | `CoreSchema | None` | The core schema to be used to generate the corresponding JSON Schema input type | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 2397 2398 2399 2400 2401 2402 2403 2404 2405 2406 2407 2408 2409 2410 2411 2412 2413 2414 2415 2416 2417 2418 2419 2420 2421 2422 2423 2424 2425 2426 2427 2428 2429 2430 2431 2432 2433 2434 ``` | ``` def no_info_plain_validator_function(     function: NoInfoValidatorFunction,     *,     ref: str | None = None,     json_schema_input_schema: CoreSchema | None = None,     metadata: dict[str, Any] | None = None,     serialization: SerSchema | None = None, ) -> PlainValidatorFunctionSchema:     \"\"\"     Returns a schema that uses the provided function for validation, no `info` argument is passed, e.g.:      ```py     from pydantic_core import SchemaValidator, core_schema      def fn(v: str) -> str:         assert 'hello' in v         return v + 'world'      schema = core_schema.no_info_plain_validator_function(function=fn)     v = SchemaValidator(schema)     assert v.validate_python('hello ') == 'hello world'     ```      Args:         function: The validator function to call         ref: optional unique identifier of the schema, used to reference the schema in other places         json_schema_input_schema: The core schema to be used to generate the corresponding JSON Schema input type         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     return _dict_not_none(         type='function-plain',         function={'type': 'no-info', 'function': function},         ref=ref,         json_schema_input_schema=json_schema_input_schema,         metadata=metadata,         serialization=serialization,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#noinfoplainvalidatorfunction-indexhtmlpydanticcorecoreschemanoinfoplainvalidatorfunction-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "with\\_info\\_plain\\_validator\\_function [Â¶](index.html#pydantic_core.core_schema.with_info_plain_validator_function \"Permanent link\")", "anchor": "withinfoplainvalidatorfunction-indexhtmlpydanticcorecoreschemawithinfoplainvalidatorfunction-permanent-link", "md_text": "```\nwith_info_plain_validator_function(\n    function: WithInfoValidatorFunction,\n    *,\n    field_name: str | None = None,\n    ref: str | None = None,\n    json_schema_input_schema: CoreSchema | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None\n) -> PlainValidatorFunctionSchema\n```\n\nReturns a schema that uses the provided function for validation, an `info` argument is passed, e.g.:\n\n```\nfrom pydantic_core import SchemaValidator, core_schema\n\ndef fn(v: str, info: core_schema.ValidationInfo) -> str:\n    assert 'hello' in v\n    return v + 'world'\n\nschema = core_schema.with_info_plain_validator_function(function=fn)\nv = SchemaValidator(schema)\nassert v.validate_python('hello ') == 'hello world'\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `function` | `WithInfoValidatorFunction` | The validator function to call | *required* |\n| `field_name` | `str | None` | The name of the field this validator is applied to, if any (deprecated) | `None` |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `json_schema_input_schema` | `CoreSchema | None` | The core schema to be used to generate the corresponding JSON Schema input type | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 2437 2438 2439 2440 2441 2442 2443 2444 2445 2446 2447 2448 2449 2450 2451 2452 2453 2454 2455 2456 2457 2458 2459 2460 2461 2462 2463 2464 2465 2466 2467 2468 2469 2470 2471 2472 2473 2474 2475 2476 2477 2478 2479 2480 2481 2482 2483 ``` | ``` def with_info_plain_validator_function(     function: WithInfoValidatorFunction,     *,     field_name: str | None = None,     ref: str | None = None,     json_schema_input_schema: CoreSchema | None = None,     metadata: dict[str, Any] | None = None,     serialization: SerSchema | None = None, ) -> PlainValidatorFunctionSchema:     \"\"\"     Returns a schema that uses the provided function for validation, an `info` argument is passed, e.g.:      ```py     from pydantic_core import SchemaValidator, core_schema      def fn(v: str, info: core_schema.ValidationInfo) -> str:         assert 'hello' in v         return v + 'world'      schema = core_schema.with_info_plain_validator_function(function=fn)     v = SchemaValidator(schema)     assert v.validate_python('hello ') == 'hello world'     ```      Args:         function: The validator function to call         field_name: The name of the field this validator is applied to, if any (deprecated)         ref: optional unique identifier of the schema, used to reference the schema in other places         json_schema_input_schema: The core schema to be used to generate the corresponding JSON Schema input type         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     if field_name is not None:         warnings.warn(             'The `field_name` argument on `with_info_plain_validator_function` is deprecated, it will be passed to the function through `ValidationState` instead.',             DeprecationWarning,             stacklevel=2,         )      return _dict_not_none(         type='function-plain',         function=_dict_not_none(type='with-info', function=function, field_name=field_name),         ref=ref,         json_schema_input_schema=json_schema_input_schema,         metadata=metadata,         serialization=serialization,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#withinfoplainvalidatorfunction-indexhtmlpydanticcorecoreschemawithinfoplainvalidatorfunction-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "with\\_default\\_schema [Â¶](index.html#pydantic_core.core_schema.with_default_schema \"Permanent link\")", "anchor": "withdefaultschema-indexhtmlpydanticcorecoreschemawithdefaultschema-permanent-link", "md_text": "```\nwith_default_schema(\n    schema: CoreSchema,\n    *,\n    default: Any = PydanticUndefined,\n    default_factory: Union[\n        Callable[[], Any],\n        Callable[[dict[str, Any]], Any],\n        None,\n    ] = None,\n    default_factory_takes_data: bool | None = None,\n    on_error: (\n        Literal[\"raise\", \"omit\", \"default\"] | None\n    ) = None,\n    validate_default: bool | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None\n) -> WithDefaultSchema\n```\n\nReturns a schema that adds a default value to the given schema, e.g.:\n\n```\nfrom pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.with_default_schema(core_schema.str_schema(), default='hello')\nwrapper_schema = core_schema.typed_dict_schema(\n    {'a': core_schema.typed_dict_field(schema)}\n)\nv = SchemaValidator(wrapper_schema)\nassert v.validate_python({}) == v.validate_python({'a': 'hello'})\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `CoreSchema` | The schema to add a default value to | *required* |\n| `default` | `Any` | The default value to use | `PydanticUndefined` |\n| `default_factory` | `Union[Callable[[], Any], Callable[[dict[str, Any]], Any], None]` | A callable that returns the default value to use | `None` |\n| `default_factory_takes_data` | `bool | None` | Whether the default factory takes a validated data argument | `None` |\n| `on_error` | `Literal['raise', 'omit', 'default'] | None` | What to do if the schema validation fails. One of 'raise', 'omit', 'default' | `None` |\n| `validate_default` | `bool | None` | Whether the default value should be validated | `None` |\n| `strict` | `bool | None` | Whether the underlying schema should be validated with strict mode | `None` |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#withdefaultschema-indexhtmlpydanticcorecoreschemawithdefaultschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "with\\_default\\_schema [Â¶](index.html#pydantic_core.core_schema.with_default_schema \"Permanent link\")", "anchor": "withdefaultschema-indexhtmlpydanticcorecoreschemawithdefaultschema-permanent-link", "md_text": "|  |  |\n| --- | --- |\n| ``` 2500 2501 2502 2503 2504 2505 2506 2507 2508 2509 2510 2511 2512 2513 2514 2515 2516 2517 2518 2519 2520 2521 2522 2523 2524 2525 2526 2527 2528 2529 2530 2531 2532 2533 2534 2535 2536 2537 2538 2539 2540 2541 2542 2543 2544 2545 2546 2547 2548 2549 2550 2551 2552 2553 ``` | ``` def with_default_schema(     schema: CoreSchema,     *,     default: Any = PydanticUndefined,     default_factory: Union[Callable[[], Any], Callable[[dict[str, Any]], Any], None] = None,     default_factory_takes_data: bool | None = None,     on_error: Literal['raise', 'omit', 'default'] | None = None,     validate_default: bool | None = None,     strict: bool | None = None,     ref: str | None = None,     metadata: dict[str, Any] | None = None,     serialization: SerSchema | None = None, ) -> WithDefaultSchema:     \"\"\"     Returns a schema that adds a default value to the given schema, e.g.:      ```py     from pydantic_core import SchemaValidator, core_schema      schema = core_schema.with_default_schema(core_schema.str_schema(), default='hello')     wrapper_schema = core_schema.typed_dict_schema(         {'a': core_schema.typed_dict_field(schema)}     )     v = SchemaValidator(wrapper_schema)     assert v.validate_python({}) == v.validate_python({'a': 'hello'})     ```      Args:         schema: The schema to add a default value to         default: The default value to use         default_factory: A callable that returns the default value to use         default_factory_takes_data: Whether the default factory takes a validated data argument         on_error: What to do if the schema validation fails. One of 'raise', 'omit', 'default'         validate_default: Whether the default value should be validated         strict: Whether the underlying schema should be validated with strict mode         ref: optional unique identifier of the schema, used to reference the schema in other places         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     s = _dict_not_none(         type='default',         schema=schema,         default_factory=default_factory,         default_factory_takes_data=default_factory_takes_data,         on_error=on_error,         validate_default=validate_default,         strict=strict,         ref=ref,         metadata=metadata,         serialization=serialization,     )     if default is not PydanticUndefined:         s['default'] = default     return s ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#withdefaultschema-indexhtmlpydanticcorecoreschemawithdefaultschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "nullable\\_schema [Â¶](index.html#pydantic_core.core_schema.nullable_schema \"Permanent link\")", "anchor": "nullableschema-indexhtmlpydanticcorecoreschemanullableschema-permanent-link", "md_text": "```\nnullable_schema(\n    schema: CoreSchema,\n    *,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None\n) -> NullableSchema\n```\n\nReturns a schema that matches a nullable value, e.g.:\n\n```\nfrom pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.nullable_schema(core_schema.str_schema())\nv = SchemaValidator(schema)\nassert v.validate_python(None) is None\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `CoreSchema` | The schema to wrap | *required* |\n| `strict` | `bool | None` | Whether the underlying schema should be validated with strict mode | `None` |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 2565 2566 2567 2568 2569 2570 2571 2572 2573 2574 2575 2576 2577 2578 2579 2580 2581 2582 2583 2584 2585 2586 2587 2588 2589 2590 2591 2592 2593 ``` | ``` def nullable_schema(     schema: CoreSchema,     *,     strict: bool | None = None,     ref: str | None = None,     metadata: dict[str, Any] | None = None,     serialization: SerSchema | None = None, ) -> NullableSchema:     \"\"\"     Returns a schema that matches a nullable value, e.g.:      ```py     from pydantic_core import SchemaValidator, core_schema      schema = core_schema.nullable_schema(core_schema.str_schema())     v = SchemaValidator(schema)     assert v.validate_python(None) is None     ```      Args:         schema: The schema to wrap         strict: Whether the underlying schema should be validated with strict mode         ref: optional unique identifier of the schema, used to reference the schema in other places         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     return _dict_not_none(         type='nullable', schema=schema, strict=strict, ref=ref, metadata=metadata, serialization=serialization     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#nullableschema-indexhtmlpydanticcorecoreschemanullableschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "union\\_schema [Â¶](index.html#pydantic_core.core_schema.union_schema \"Permanent link\")", "anchor": "unionschema-indexhtmlpydanticcorecoreschemaunionschema-permanent-link", "md_text": "```\nunion_schema(\n    choices: list[CoreSchema | tuple[CoreSchema, str]],\n    *,\n    auto_collapse: bool | None = None,\n    custom_error_type: str | None = None,\n    custom_error_message: str | None = None,\n    custom_error_context: (\n        dict[str, str | int] | None\n    ) = None,\n    mode: Literal[\"smart\", \"left_to_right\"] | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None\n) -> UnionSchema\n```\n\nReturns a schema that matches a union value, e.g.:\n\n```\nfrom pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.union_schema([core_schema.str_schema(), core_schema.int_schema()])\nv = SchemaValidator(schema)\nassert v.validate_python('hello') == 'hello'\nassert v.validate_python(1) == 1\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `choices` | `list[CoreSchema | tuple[CoreSchema, str]]` | The schemas to match. If a tuple, the second item is used as the label for the case. | *required* |\n| `auto_collapse` | `bool | None` | whether to automatically collapse unions with one element to the inner validator, default true | `None` |\n| `custom_error_type` | `str | None` | The custom error type to use if the validation fails | `None` |\n| `custom_error_message` | `str | None` | The custom error message to use if the validation fails | `None` |\n| `custom_error_context` | `dict[str, str | int] | None` | The custom error context to use if the validation fails | `None` |\n| `mode` | `Literal['smart', 'left_to_right'] | None` | How to select which choice to return \\* `smart` (default) will try to return the choice which is the closest match to the input value \\* `left_to_right` will return the first choice in `choices` which succeeds validation | `None` |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#unionschema-indexhtmlpydanticcorecoreschemaunionschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "union\\_schema [Â¶](index.html#pydantic_core.core_schema.union_schema \"Permanent link\")", "anchor": "unionschema-indexhtmlpydanticcorecoreschemaunionschema-permanent-link", "md_text": "|  |  |\n| --- | --- |\n| ``` 2611 2612 2613 2614 2615 2616 2617 2618 2619 2620 2621 2622 2623 2624 2625 2626 2627 2628 2629 2630 2631 2632 2633 2634 2635 2636 2637 2638 2639 2640 2641 2642 2643 2644 2645 2646 2647 2648 2649 2650 2651 2652 2653 2654 2655 2656 2657 2658 2659 ``` | ``` def union_schema(     choices: list[CoreSchema | tuple[CoreSchema, str]],     *,     auto_collapse: bool | None = None,     custom_error_type: str | None = None,     custom_error_message: str | None = None,     custom_error_context: dict[str, str | int] | None = None,     mode: Literal['smart', 'left_to_right'] | None = None,     ref: str | None = None,     metadata: dict[str, Any] | None = None,     serialization: SerSchema | None = None, ) -> UnionSchema:     \"\"\"     Returns a schema that matches a union value, e.g.:      ```py     from pydantic_core import SchemaValidator, core_schema      schema = core_schema.union_schema([core_schema.str_schema(), core_schema.int_schema()])     v = SchemaValidator(schema)     assert v.validate_python('hello') == 'hello'     assert v.validate_python(1) == 1     ```      Args:         choices: The schemas to match. If a tuple, the second item is used as the label for the case.         auto_collapse: whether to automatically collapse unions with one element to the inner validator, default true         custom_error_type: The custom error type to use if the validation fails         custom_error_message: The custom error message to use if the validation fails         custom_error_context: The custom error context to use if the validation fails         mode: How to select which choice to return             * `smart` (default) will try to return the choice which is the closest match to the input value             * `left_to_right` will return the first choice in `choices` which succeeds validation         ref: optional unique identifier of the schema, used to reference the schema in other places         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     return _dict_not_none(         type='union',         choices=choices,         auto_collapse=auto_collapse,         custom_error_type=custom_error_type,         custom_error_message=custom_error_message,         custom_error_context=custom_error_context,         mode=mode,         ref=ref,         metadata=metadata,         serialization=serialization,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#unionschema-indexhtmlpydanticcorecoreschemaunionschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "tagged\\_union\\_schema [Â¶](index.html#pydantic_core.core_schema.tagged_union_schema \"Permanent link\")", "anchor": "taggedunionschema-indexhtmlpydanticcorecoreschemataggedunionschema-permanent-link", "md_text": "```\ntagged_union_schema(\n    choices: dict[Any, CoreSchema],\n    discriminator: (\n        str\n        | list[str | int]\n        | list[list[str | int]]\n        | Callable[[Any], Any]\n    ),\n    *,\n    custom_error_type: str | None = None,\n    custom_error_message: str | None = None,\n    custom_error_context: (\n        dict[str, int | str | float] | None\n    ) = None,\n    strict: bool | None = None,\n    from_attributes: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None\n) -> TaggedUnionSchema\n```\n\nReturns a schema that matches a tagged union value, e.g.:\n\n```\nfrom pydantic_core import SchemaValidator, core_schema\n\napple_schema = core_schema.typed_dict_schema(\n    {\n        'foo': core_schema.typed_dict_field(core_schema.str_schema()),\n        'bar': core_schema.typed_dict_field(core_schema.int_schema()),\n    }\n)\nbanana_schema = core_schema.typed_dict_schema(\n    {\n        'foo': core_schema.typed_dict_field(core_schema.str_schema()),\n        'spam': core_schema.typed_dict_field(\n            core_schema.list_schema(items_schema=core_schema.int_schema())\n        ),\n    }\n)\nschema = core_schema.tagged_union_schema(\n    choices={\n        'apple': apple_schema,\n        'banana': banana_schema,\n    },\n    discriminator='foo',\n)\nv = SchemaValidator(schema)\nassert v.validate_python({'foo': 'apple', 'bar': '123'}) == {'foo': 'apple', 'bar': 123}\nassert v.validate_python({'foo': 'banana', 'spam': [1, 2, 3]}) == {\n    'foo': 'banana',\n    'spam': [1, 2, 3],\n}\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `choices` | `dict[Any, CoreSchema]` | The schemas to match When retrieving a schema from `choices` using the discriminator value, if the value is a str, it should be fed back into the `choices` map until a schema is obtained (This approach is to prevent multiple ownership of a single schema in Rust) | *required* |\n| `discriminator` | `str | list[str | int] | list[list[str | int]] | Callable[[Any], Any]` | The discriminator to use to determine the schema to use \\* If `discriminator` is a str, it is the name of the attribute to use as the discriminator \\* If `discriminator` is a list of int/str, it should be used as a \"path\" to access the discriminator \\* If `discriminator` is a list of lists, each inner list is a path, and the first path that exists is used \\* If `discriminator` is a callable, it should return the discriminator when called on the value to validate; the callable can return `None` to indicate that there is no matching discriminator present on the input | *required* |\n| `custom_error_type` | `str | None` | The custom error type to use if the validation fails | `None` |\n| `custom_error_message` | `str | None` | The custom error message to use if the validation fails | `None` |\n| `custom_error_context` | `dict[str, int | str | float] | None` | The custom error context to use if the validation fails | `None` |\n| `strict` | `bool | None` | Whether the underlying schemas should be validated with strict mode | `None` |\n| `from_attributes` | `bool | None` | Whether to use the attributes of the object to retrieve the discriminator value | `None` |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#taggedunionschema-indexhtmlpydanticcorecoreschemataggedunionschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "tagged\\_union\\_schema [Â¶](index.html#pydantic_core.core_schema.tagged_union_schema \"Permanent link\")", "anchor": "taggedunionschema-indexhtmlpydanticcorecoreschemataggedunionschema-permanent-link", "md_text": "|  |  |\n| --- | --- |\n| ``` 2676 2677 2678 2679 2680 2681 2682 2683 2684 2685 2686 2687 2688 2689 2690 2691 2692 2693 2694 2695 2696 2697 2698 2699 2700 2701 2702 2703 2704 2705 2706 2707 2708 2709 2710 2711 2712 2713 2714 2715 2716 2717 2718 2719 2720 2721 2722 2723 2724 2725 2726 2727 2728 2729 2730 2731 2732 2733 2734 2735 2736 2737 2738 2739 2740 2741 2742 2743 2744 2745 2746 2747 2748 2749 2750 2751 2752 2753 2754 2755 2756 ``` | ``` def tagged_union_schema(     choices: dict[Any, CoreSchema],     discriminator: str | list[str | int] | list[list[str | int]] | Callable[[Any], Any],     *,     custom_error_type: str | None = None,     custom_error_message: str | None = None,     custom_error_context: dict[str, int | str | float] | None = None,     strict: bool | None = None,     from_attributes: bool | None = None,     ref: str | None = None,     metadata: dict[str, Any] | None = None,     serialization: SerSchema | None = None, ) -> TaggedUnionSchema:     \"\"\"     Returns a schema that matches a tagged union value, e.g.:      ```py     from pydantic_core import SchemaValidator, core_schema      apple_schema = core_schema.typed_dict_schema(         {             'foo': core_schema.typed_dict_field(core_schema.str_schema()),             'bar': core_schema.typed_dict_field(core_schema.int_schema()),         }     )     banana_schema = core_schema.typed_dict_schema(         {             'foo': core_schema.typed_dict_field(core_schema.str_schema()),             'spam': core_schema.typed_dict_field(                 core_schema.list_schema(items_schema=core_schema.int_schema())             ),         }     )     schema = core_schema.tagged_union_schema(         choices={             'apple': apple_schema,             'banana': banana_schema,         },         discriminator='foo',     )     v = SchemaValidator(schema)     assert v.validate_python({'foo': 'apple', 'bar': '123'}) == {'foo': 'apple', 'bar': 123}     assert v.validate_python({'foo': 'banana', 'spam': [1, 2, 3]}) == {         'foo': 'banana',         'spam': [1, 2, 3],     }     ```      Args:         choices: The schemas to match             When retrieving a schema from `choices` using the discriminator value, if the value is a str,             it should be fed back into the `choices` map until a schema is obtained             (This approach is to prevent multiple ownership of a single schema in Rust)         discriminator: The discriminator to use to determine the schema to use             * If `discriminator` is a str, it is the name of the attribute to use as the discriminator             * If `discriminator` is a list of int/str, it should be used as a \"path\" to access the discriminator             * If `discriminator` is a list of lists, each inner list is a path, and the first path that exists is used             * If `discriminator` is a callable, it should return the discriminator when called on the value to validate;               the callable can return `None` to indicate that there is no matching discriminator present on the input         custom_error_type: The custom error type to use if the validation fails         custom_error_message: The custom error message to use if the validation fails         custom_error_context: The custom error context to use if the validation fails         strict: Whether the underlying schemas should be validated with strict mode         from_attributes: Whether to use the attributes of the object to retrieve the discriminator value         ref: optional unique identifier of the schema, used to reference the schema in other places         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     return _dict_not_none(         type='tagged-union',         choices=choices,         discriminator=discriminator,         custom_error_type=custom_error_type,         custom_error_message=custom_error_message,         custom_error_context=custom_error_context,         strict=strict,         from_attributes=from_attributes,         ref=ref,         metadata=metadata,         serialization=serialization,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#taggedunionschema-indexhtmlpydanticcorecoreschemataggedunionschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "chain\\_schema [Â¶](index.html#pydantic_core.core_schema.chain_schema \"Permanent link\")", "anchor": "chainschema-indexhtmlpydanticcorecoreschemachainschema-permanent-link", "md_text": "```\nchain_schema(\n    steps: list[CoreSchema],\n    *,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None\n) -> ChainSchema\n```\n\nReturns a schema that chains the provided validation schemas, e.g.:\n\n```\nfrom pydantic_core import SchemaValidator, core_schema\n\ndef fn(v: str, info: core_schema.ValidationInfo) -> str:\n    assert 'hello' in v\n    return v + ' world'\n\nfn_schema = core_schema.with_info_plain_validator_function(function=fn)\nschema = core_schema.chain_schema(\n    [fn_schema, fn_schema, fn_schema, core_schema.str_schema()]\n)\nv = SchemaValidator(schema)\nassert v.validate_python('hello') == 'hello world world world'\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `steps` | `list[CoreSchema]` | The schemas to chain | *required* |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 2767 2768 2769 2770 2771 2772 2773 2774 2775 2776 2777 2778 2779 2780 2781 2782 2783 2784 2785 2786 2787 2788 2789 2790 2791 2792 2793 2794 2795 2796 2797 2798 ``` | ``` def chain_schema(     steps: list[CoreSchema],     *,     ref: str | None = None,     metadata: dict[str, Any] | None = None,     serialization: SerSchema | None = None, ) -> ChainSchema:     \"\"\"     Returns a schema that chains the provided validation schemas, e.g.:      ```py     from pydantic_core import SchemaValidator, core_schema      def fn(v: str, info: core_schema.ValidationInfo) -> str:         assert 'hello' in v         return v + ' world'      fn_schema = core_schema.with_info_plain_validator_function(function=fn)     schema = core_schema.chain_schema(         [fn_schema, fn_schema, fn_schema, core_schema.str_schema()]     )     v = SchemaValidator(schema)     assert v.validate_python('hello') == 'hello world world world'     ```      Args:         steps: The schemas to chain         ref: optional unique identifier of the schema, used to reference the schema in other places         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     return _dict_not_none(type='chain', steps=steps, ref=ref, metadata=metadata, serialization=serialization) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#chainschema-indexhtmlpydanticcorecoreschemachainschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "lax\\_or\\_strict\\_schema [Â¶](index.html#pydantic_core.core_schema.lax_or_strict_schema \"Permanent link\")", "anchor": "laxorstrictschema-indexhtmlpydanticcorecoreschemalaxorstrictschema-permanent-link", "md_text": "```\nlax_or_strict_schema(\n    lax_schema: CoreSchema,\n    strict_schema: CoreSchema,\n    *,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None\n) -> LaxOrStrictSchema\n```\n\nReturns a schema that uses the lax or strict schema, e.g.:\n\n```\nfrom pydantic_core import SchemaValidator, core_schema\n\ndef fn(v: str, info: core_schema.ValidationInfo) -> str:\n    assert 'hello' in v\n    return v + ' world'\n\nlax_schema = core_schema.int_schema(strict=False)\nstrict_schema = core_schema.int_schema(strict=True)\n\nschema = core_schema.lax_or_strict_schema(\n    lax_schema=lax_schema, strict_schema=strict_schema, strict=True\n)\nv = SchemaValidator(schema)\nassert v.validate_python(123) == 123\n\nschema = core_schema.lax_or_strict_schema(\n    lax_schema=lax_schema, strict_schema=strict_schema, strict=False\n)\nv = SchemaValidator(schema)\nassert v.validate_python('123') == 123\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `lax_schema` | `CoreSchema` | The lax schema to use | *required* |\n| `strict_schema` | `CoreSchema` | The strict schema to use | *required* |\n| `strict` | `bool | None` | Whether the strict schema should be used | `None` |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 2811 2812 2813 2814 2815 2816 2817 2818 2819 2820 2821 2822 2823 2824 2825 2826 2827 2828 2829 2830 2831 2832 2833 2834 2835 2836 2837 2838 2839 2840 2841 2842 2843 2844 2845 2846 2847 2848 2849 2850 2851 2852 2853 2854 2855 2856 2857 2858 2859 2860 2861 2862 ``` | ``` def lax_or_strict_schema(     lax_schema: CoreSchema,     strict_schema: CoreSchema,     *,     strict: bool | None = None,     ref: str | None = None,     metadata: dict[str, Any] | None = None,     serialization: SerSchema | None = None, ) -> LaxOrStrictSchema:     \"\"\"     Returns a schema that uses the lax or strict schema, e.g.:      ```py     from pydantic_core import SchemaValidator, core_schema      def fn(v: str, info: core_schema.ValidationInfo) -> str:         assert 'hello' in v         return v + ' world'      lax_schema = core_schema.int_schema(strict=False)     strict_schema = core_schema.int_schema(strict=True)      schema = core_schema.lax_or_strict_schema(         lax_schema=lax_schema, strict_schema=strict_schema, strict=True     )     v = SchemaValidator(schema)     assert v.validate_python(123) == 123      schema = core_schema.lax_or_strict_schema(         lax_schema=lax_schema, strict_schema=strict_schema, strict=False     )     v = SchemaValidator(schema)     assert v.validate_python('123') == 123     ```      Args:         lax_schema: The lax schema to use         strict_schema: The strict schema to use         strict: Whether the strict schema should be used         ref: optional unique identifier of the schema, used to reference the schema in other places         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     return _dict_not_none(         type='lax-or-strict',         lax_schema=lax_schema,         strict_schema=strict_schema,         strict=strict,         ref=ref,         metadata=metadata,         serialization=serialization,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#laxorstrictschema-indexhtmlpydanticcorecoreschemalaxorstrictschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "json\\_or\\_python\\_schema [Â¶](index.html#pydantic_core.core_schema.json_or_python_schema \"Permanent link\")", "anchor": "jsonorpythonschema-indexhtmlpydanticcorecoreschemajsonorpythonschema-permanent-link", "md_text": "```\njson_or_python_schema(\n    json_schema: CoreSchema,\n    python_schema: CoreSchema,\n    *,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None\n) -> JsonOrPythonSchema\n```\n\nReturns a schema that uses the Json or Python schema depending on the input:\n\n```\nfrom pydantic_core import SchemaValidator, ValidationError, core_schema\n\nv = SchemaValidator(\n    core_schema.json_or_python_schema(\n        json_schema=core_schema.int_schema(),\n        python_schema=core_schema.int_schema(strict=True),\n    )\n)\n\nassert v.validate_json('\"123\"') == 123\n\ntry:\n    v.validate_python('123')\nexcept ValidationError:\n    pass\nelse:\n    raise AssertionError('Validation should have failed')\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `json_schema` | `CoreSchema` | The schema to use for Json inputs | *required* |\n| `python_schema` | `CoreSchema` | The schema to use for Python inputs | *required* |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 2874 2875 2876 2877 2878 2879 2880 2881 2882 2883 2884 2885 2886 2887 2888 2889 2890 2891 2892 2893 2894 2895 2896 2897 2898 2899 2900 2901 2902 2903 2904 2905 2906 2907 2908 2909 2910 2911 2912 2913 2914 2915 2916 2917 2918 2919 ``` | ``` def json_or_python_schema(     json_schema: CoreSchema,     python_schema: CoreSchema,     *,     ref: str | None = None,     metadata: dict[str, Any] | None = None,     serialization: SerSchema | None = None, ) -> JsonOrPythonSchema:     \"\"\"     Returns a schema that uses the Json or Python schema depending on the input:      ```py     from pydantic_core import SchemaValidator, ValidationError, core_schema      v = SchemaValidator(         core_schema.json_or_python_schema(             json_schema=core_schema.int_schema(),             python_schema=core_schema.int_schema(strict=True),         )     )      assert v.validate_json('\"123\"') == 123      try:         v.validate_python('123')     except ValidationError:         pass     else:         raise AssertionError('Validation should have failed')     ```      Args:         json_schema: The schema to use for Json inputs         python_schema: The schema to use for Python inputs         ref: optional unique identifier of the schema, used to reference the schema in other places         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     return _dict_not_none(         type='json-or-python',         json_schema=json_schema,         python_schema=python_schema,         ref=ref,         metadata=metadata,         serialization=serialization,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#jsonorpythonschema-indexhtmlpydanticcorecoreschemajsonorpythonschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "typed\\_dict\\_field [Â¶](index.html#pydantic_core.core_schema.typed_dict_field \"Permanent link\")", "anchor": "typeddictfield-indexhtmlpydanticcorecoreschematypeddictfield-permanent-link", "md_text": "```\ntyped_dict_field(\n    schema: CoreSchema,\n    *,\n    required: bool | None = None,\n    validation_alias: (\n        str | list[str | int] | list[list[str | int]] | None\n    ) = None,\n    serialization_alias: str | None = None,\n    serialization_exclude: bool | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization_exclude_if: (\n        Callable[[Any], bool] | None\n    ) = None\n) -> TypedDictField\n```\n\nReturns a schema that matches a typed dict field, e.g.:\n\n```\nfrom pydantic_core import core_schema\n\nfield = core_schema.typed_dict_field(schema=core_schema.int_schema(), required=True)\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `CoreSchema` | The schema to use for the field | *required* |\n| `required` | `bool | None` | Whether the field is required, otherwise uses the value from `total` on the typed dict | `None` |\n| `validation_alias` | `str | list[str | int] | list[list[str | int]] | None` | The alias(es) to use to find the field in the validation data | `None` |\n| `serialization_alias` | `str | None` | The alias to use as a key when serializing | `None` |\n| `serialization_exclude` | `bool | None` | Whether to exclude the field when serializing | `None` |\n| `serialization_exclude_if` | `Callable[[Any], bool] | None` | A callable that determines whether to exclude the field when serializing based on its value. | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 2933 2934 2935 2936 2937 2938 2939 2940 2941 2942 2943 2944 2945 2946 2947 2948 2949 2950 2951 2952 2953 2954 2955 2956 2957 2958 2959 2960 2961 2962 2963 2964 2965 2966 2967 2968 2969 2970 ``` | ``` def typed_dict_field(     schema: CoreSchema,     *,     required: bool | None = None,     validation_alias: str | list[str | int] | list[list[str | int]] | None = None,     serialization_alias: str | None = None,     serialization_exclude: bool | None = None,     metadata: dict[str, Any] | None = None,     serialization_exclude_if: Callable[[Any], bool] | None = None, ) -> TypedDictField:     \"\"\"     Returns a schema that matches a typed dict field, e.g.:      ```py     from pydantic_core import core_schema      field = core_schema.typed_dict_field(schema=core_schema.int_schema(), required=True)     ```      Args:         schema: The schema to use for the field         required: Whether the field is required, otherwise uses the value from `total` on the typed dict         validation_alias: The alias(es) to use to find the field in the validation data         serialization_alias: The alias to use as a key when serializing         serialization_exclude: Whether to exclude the field when serializing         serialization_exclude_if: A callable that determines whether to exclude the field when serializing based on its value.         metadata: Any other information you want to include with the schema, not used by pydantic-core     \"\"\"     return _dict_not_none(         type='typed-dict-field',         schema=schema,         required=required,         validation_alias=validation_alias,         serialization_alias=serialization_alias,         serialization_exclude=serialization_exclude,         serialization_exclude_if=serialization_exclude_if,         metadata=metadata,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#typeddictfield-indexhtmlpydanticcorecoreschematypeddictfield-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "typed\\_dict\\_schema [Â¶](index.html#pydantic_core.core_schema.typed_dict_schema \"Permanent link\")", "anchor": "typeddictschema-indexhtmlpydanticcorecoreschematypeddictschema-permanent-link", "md_text": "```\ntyped_dict_schema(\n    fields: dict[str, TypedDictField],\n    *,\n    cls: type[Any] | None = None,\n    cls_name: str | None = None,\n    computed_fields: list[ComputedField] | None = None,\n    strict: bool | None = None,\n    extras_schema: CoreSchema | None = None,\n    extra_behavior: ExtraBehavior | None = None,\n    total: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n    config: CoreConfig | None = None\n) -> TypedDictSchema\n```\n\nReturns a schema that matches a typed dict, e.g.:\n\n```\nfrom typing_extensions import TypedDict\n\nfrom pydantic_core import SchemaValidator, core_schema\n\nclass MyTypedDict(TypedDict):\n    a: str\n\nwrapper_schema = core_schema.typed_dict_schema(\n    {'a': core_schema.typed_dict_field(core_schema.str_schema())}, cls=MyTypedDict\n)\nv = SchemaValidator(wrapper_schema)\nassert v.validate_python({'a': 'hello'}) == {'a': 'hello'}\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `fields` | `dict[str, TypedDictField]` | The fields to use for the typed dict | *required* |\n| `cls` | `type[Any] | None` | The class to use for the typed dict | `None` |\n| `cls_name` | `str | None` | The name to use in error locations. Falls back to `cls.__name__`, or the validator name if no class is provided. | `None` |\n| `computed_fields` | `list[ComputedField] | None` | Computed fields to use when serializing the model, only applies when directly inside a model | `None` |\n| `strict` | `bool | None` | Whether the typed dict is strict | `None` |\n| `extras_schema` | `CoreSchema | None` | The extra validator to use for the typed dict | `None` |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `extra_behavior` | `ExtraBehavior | None` | The extra behavior to use for the typed dict | `None` |\n| `total` | `bool | None` | Whether the typed dict is total, otherwise uses `typed_dict_total` from config | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#typeddictschema-indexhtmlpydanticcorecoreschematypeddictschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "typed\\_dict\\_schema [Â¶](index.html#pydantic_core.core_schema.typed_dict_schema \"Permanent link\")", "anchor": "typeddictschema-indexhtmlpydanticcorecoreschematypeddictschema-permanent-link", "md_text": "|  |  |\n| --- | --- |\n| ``` 2990 2991 2992 2993 2994 2995 2996 2997 2998 2999 3000 3001 3002 3003 3004 3005 3006 3007 3008 3009 3010 3011 3012 3013 3014 3015 3016 3017 3018 3019 3020 3021 3022 3023 3024 3025 3026 3027 3028 3029 3030 3031 3032 3033 3034 3035 3036 3037 3038 3039 3040 3041 3042 3043 3044 3045 3046 3047 3048 3049 3050 3051 ``` | ``` def typed_dict_schema(     fields: dict[str, TypedDictField],     *,     cls: type[Any] | None = None,     cls_name: str | None = None,     computed_fields: list[ComputedField] | None = None,     strict: bool | None = None,     extras_schema: CoreSchema | None = None,     extra_behavior: ExtraBehavior | None = None,     total: bool | None = None,     ref: str | None = None,     metadata: dict[str, Any] | None = None,     serialization: SerSchema | None = None,     config: CoreConfig | None = None, ) -> TypedDictSchema:     \"\"\"     Returns a schema that matches a typed dict, e.g.:      ```py     from typing_extensions import TypedDict      from pydantic_core import SchemaValidator, core_schema      class MyTypedDict(TypedDict):         a: str      wrapper_schema = core_schema.typed_dict_schema(         {'a': core_schema.typed_dict_field(core_schema.str_schema())}, cls=MyTypedDict     )     v = SchemaValidator(wrapper_schema)     assert v.validate_python({'a': 'hello'}) == {'a': 'hello'}     ```      Args:         fields: The fields to use for the typed dict         cls: The class to use for the typed dict         cls_name: The name to use in error locations. Falls back to `cls.__name__`, or the validator name if no class             is provided.         computed_fields: Computed fields to use when serializing the model, only applies when directly inside a model         strict: Whether the typed dict is strict         extras_schema: The extra validator to use for the typed dict         ref: optional unique identifier of the schema, used to reference the schema in other places         metadata: Any other information you want to include with the schema, not used by pydantic-core         extra_behavior: The extra behavior to use for the typed dict         total: Whether the typed dict is total, otherwise uses `typed_dict_total` from config         serialization: Custom serialization schema     \"\"\"     return _dict_not_none(         type='typed-dict',         fields=fields,         cls=cls,         cls_name=cls_name,         computed_fields=computed_fields,         strict=strict,         extras_schema=extras_schema,         extra_behavior=extra_behavior,         total=total,         ref=ref,         metadata=metadata,         serialization=serialization,         config=config,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#typeddictschema-indexhtmlpydanticcorecoreschematypeddictschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "model\\_field [Â¶](index.html#pydantic_core.core_schema.model_field \"Permanent link\")", "anchor": "modelfield-indexhtmlpydanticcorecoreschemamodelfield-permanent-link", "md_text": "```\nmodel_field(\n    schema: CoreSchema,\n    *,\n    validation_alias: (\n        str | list[str | int] | list[list[str | int]] | None\n    ) = None,\n    serialization_alias: str | None = None,\n    serialization_exclude: bool | None = None,\n    serialization_exclude_if: (\n        Callable[[Any], bool] | None\n    ) = None,\n    frozen: bool | None = None,\n    metadata: dict[str, Any] | None = None\n) -> ModelField\n```\n\nReturns a schema for a model field, e.g.:\n\n```\nfrom pydantic_core import core_schema\n\nfield = core_schema.model_field(schema=core_schema.int_schema())\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `CoreSchema` | The schema to use for the field | *required* |\n| `validation_alias` | `str | list[str | int] | list[list[str | int]] | None` | The alias(es) to use to find the field in the validation data | `None` |\n| `serialization_alias` | `str | None` | The alias to use as a key when serializing | `None` |\n| `serialization_exclude` | `bool | None` | Whether to exclude the field when serializing | `None` |\n| `serialization_exclude_if` | `Callable[[Any], bool] | None` | A Callable that determines whether to exclude a field during serialization based on its value. | `None` |\n| `frozen` | `bool | None` | Whether the field is frozen | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 3065 3066 3067 3068 3069 3070 3071 3072 3073 3074 3075 3076 3077 3078 3079 3080 3081 3082 3083 3084 3085 3086 3087 3088 3089 3090 3091 3092 3093 3094 3095 3096 3097 3098 3099 3100 3101 3102 ``` | ``` def model_field(     schema: CoreSchema,     *,     validation_alias: str | list[str | int] | list[list[str | int]] | None = None,     serialization_alias: str | None = None,     serialization_exclude: bool | None = None,     serialization_exclude_if: Callable[[Any], bool] | None = None,     frozen: bool | None = None,     metadata: dict[str, Any] | None = None, ) -> ModelField:     \"\"\"     Returns a schema for a model field, e.g.:      ```py     from pydantic_core import core_schema      field = core_schema.model_field(schema=core_schema.int_schema())     ```      Args:         schema: The schema to use for the field         validation_alias: The alias(es) to use to find the field in the validation data         serialization_alias: The alias to use as a key when serializing         serialization_exclude: Whether to exclude the field when serializing         serialization_exclude_if: A Callable that determines whether to exclude a field during serialization based on its value.         frozen: Whether the field is frozen         metadata: Any other information you want to include with the schema, not used by pydantic-core     \"\"\"     return _dict_not_none(         type='model-field',         schema=schema,         validation_alias=validation_alias,         serialization_alias=serialization_alias,         serialization_exclude=serialization_exclude,         serialization_exclude_if=serialization_exclude_if,         frozen=frozen,         metadata=metadata,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#modelfield-indexhtmlpydanticcorecoreschemamodelfield-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "model\\_fields\\_schema [Â¶](index.html#pydantic_core.core_schema.model_fields_schema \"Permanent link\")", "anchor": "modelfieldsschema-indexhtmlpydanticcorecoreschemamodelfieldsschema-permanent-link", "md_text": "```\nmodel_fields_schema(\n    fields: dict[str, ModelField],\n    *,\n    model_name: str | None = None,\n    computed_fields: list[ComputedField] | None = None,\n    strict: bool | None = None,\n    extras_schema: CoreSchema | None = None,\n    extras_keys_schema: CoreSchema | None = None,\n    extra_behavior: ExtraBehavior | None = None,\n    from_attributes: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None\n) -> ModelFieldsSchema\n```\n\nReturns a schema that matches the fields of a Pydantic model, e.g.:\n\n```\nfrom pydantic_core import SchemaValidator, core_schema\n\nwrapper_schema = core_schema.model_fields_schema(\n    {'a': core_schema.model_field(core_schema.str_schema())}\n)\nv = SchemaValidator(wrapper_schema)\nprint(v.validate_python({'a': 'hello'}))\n#> ({'a': 'hello'}, None, {'a'})\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `fields` | `dict[str, ModelField]` | The fields of the model | *required* |\n| `model_name` | `str | None` | The name of the model, used for error messages, defaults to \"Model\" | `None` |\n| `computed_fields` | `list[ComputedField] | None` | Computed fields to use when serializing the model, only applies when directly inside a model | `None` |\n| `strict` | `bool | None` | Whether the model is strict | `None` |\n| `extras_schema` | `CoreSchema | None` | The schema to use when validating extra input data | `None` |\n| `extras_keys_schema` | `CoreSchema | None` | The schema to use when validating the keys of extra input data | `None` |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `extra_behavior` | `ExtraBehavior | None` | The extra behavior to use for the model fields | `None` |\n| `from_attributes` | `bool | None` | Whether the model fields should be populated from attributes | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#modelfieldsschema-indexhtmlpydanticcorecoreschemamodelfieldsschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "model\\_fields\\_schema [Â¶](index.html#pydantic_core.core_schema.model_fields_schema \"Permanent link\")", "anchor": "modelfieldsschema-indexhtmlpydanticcorecoreschemamodelfieldsschema-permanent-link", "md_text": "|  |  |\n| --- | --- |\n| ``` 3120 3121 3122 3123 3124 3125 3126 3127 3128 3129 3130 3131 3132 3133 3134 3135 3136 3137 3138 3139 3140 3141 3142 3143 3144 3145 3146 3147 3148 3149 3150 3151 3152 3153 3154 3155 3156 3157 3158 3159 3160 3161 3162 3163 3164 3165 3166 3167 3168 3169 3170 3171 3172 3173 3174 ``` | ``` def model_fields_schema(     fields: dict[str, ModelField],     *,     model_name: str | None = None,     computed_fields: list[ComputedField] | None = None,     strict: bool | None = None,     extras_schema: CoreSchema | None = None,     extras_keys_schema: CoreSchema | None = None,     extra_behavior: ExtraBehavior | None = None,     from_attributes: bool | None = None,     ref: str | None = None,     metadata: dict[str, Any] | None = None,     serialization: SerSchema | None = None, ) -> ModelFieldsSchema:     \"\"\"     Returns a schema that matches the fields of a Pydantic model, e.g.:      ```py     from pydantic_core import SchemaValidator, core_schema      wrapper_schema = core_schema.model_fields_schema(         {'a': core_schema.model_field(core_schema.str_schema())}     )     v = SchemaValidator(wrapper_schema)     print(v.validate_python({'a': 'hello'}))     #> ({'a': 'hello'}, None, {'a'})     ```      Args:         fields: The fields of the model         model_name: The name of the model, used for error messages, defaults to \"Model\"         computed_fields: Computed fields to use when serializing the model, only applies when directly inside a model         strict: Whether the model is strict         extras_schema: The schema to use when validating extra input data         extras_keys_schema: The schema to use when validating the keys of extra input data         ref: optional unique identifier of the schema, used to reference the schema in other places         metadata: Any other information you want to include with the schema, not used by pydantic-core         extra_behavior: The extra behavior to use for the model fields         from_attributes: Whether the model fields should be populated from attributes         serialization: Custom serialization schema     \"\"\"     return _dict_not_none(         type='model-fields',         fields=fields,         model_name=model_name,         computed_fields=computed_fields,         strict=strict,         extras_schema=extras_schema,         extras_keys_schema=extras_keys_schema,         extra_behavior=extra_behavior,         from_attributes=from_attributes,         ref=ref,         metadata=metadata,         serialization=serialization,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#modelfieldsschema-indexhtmlpydanticcorecoreschemamodelfieldsschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "model\\_schema [Â¶](index.html#pydantic_core.core_schema.model_schema \"Permanent link\")", "anchor": "modelschema-indexhtmlpydanticcorecoreschemamodelschema-permanent-link", "md_text": "```\nmodel_schema(\n    cls: type[Any],\n    schema: CoreSchema,\n    *,\n    generic_origin: type[Any] | None = None,\n    custom_init: bool | None = None,\n    root_model: bool | None = None,\n    post_init: str | None = None,\n    revalidate_instances: (\n        Literal[\"always\", \"never\", \"subclass-instances\"]\n        | None\n    ) = None,\n    strict: bool | None = None,\n    frozen: bool | None = None,\n    extra_behavior: ExtraBehavior | None = None,\n    config: CoreConfig | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None\n) -> ModelSchema\n```\n\nA model schema generally contains a typed-dict schema.\nIt will run the typed dict validator, then create a new class\nand set the dict and fields set returned from the typed dict validator\nto `__dict__` and `__pydantic_fields_set__` respectively.\n\nExample:\n\n```\nfrom pydantic_core import CoreConfig, SchemaValidator, core_schema\n\nclass MyModel:\n    __slots__ = (\n        '__dict__',\n        '__pydantic_fields_set__',\n        '__pydantic_extra__',\n        '__pydantic_private__',\n    )\n\nschema = core_schema.model_schema(\n    cls=MyModel,\n    config=CoreConfig(str_max_length=5),\n    schema=core_schema.model_fields_schema(\n        fields={'a': core_schema.model_field(core_schema.str_schema())},\n    ),\n)\nv = SchemaValidator(schema)\nassert v.isinstance_python({'a': 'hello'}) is True\nassert v.isinstance_python({'a': 'too long'}) is False\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `cls` | `type[Any]` | The class to use for the model | *required* |\n| `schema` | `CoreSchema` | The schema to use for the model | *required* |\n| `generic_origin` | `type[Any] | None` | The origin type used for this model, if it's a parametrized generic. Ex, if this model schema represents `SomeModel[int]`, generic\\_origin is `SomeModel` | `None` |\n| `custom_init` | `bool | None` | Whether the model has a custom init method | `None` |\n| `root_model` | `bool | None` | Whether the model is a `RootModel` | `None` |\n| `post_init` | `str | None` | The call after init to use for the model | `None` |\n| `revalidate_instances` | `Literal['always', 'never', 'subclass-instances'] | None` | whether instances of models and dataclasses (including subclass instances) should re-validate defaults to config.revalidate\\_instances, else 'never' | `None` |\n| `strict` | `bool | None` | Whether the model is strict | `None` |\n| `frozen` | `bool | None` | Whether the model is frozen | `None` |\n| `extra_behavior` | `ExtraBehavior | None` | The extra behavior to use for the model, used in serialization | `None` |\n| `config` | `CoreConfig | None` | The config to use for the model | `None` |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#modelschema-indexhtmlpydanticcorecoreschemamodelschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "model\\_schema [Â¶](index.html#pydantic_core.core_schema.model_schema \"Permanent link\")", "anchor": "modelschema-indexhtmlpydanticcorecoreschemamodelschema-permanent-link", "md_text": "|  |  |\n| --- | --- |\n| ``` 3195 3196 3197 3198 3199 3200 3201 3202 3203 3204 3205 3206 3207 3208 3209 3210 3211 3212 3213 3214 3215 3216 3217 3218 3219 3220 3221 3222 3223 3224 3225 3226 3227 3228 3229 3230 3231 3232 3233 3234 3235 3236 3237 3238 3239 3240 3241 3242 3243 3244 3245 3246 3247 3248 3249 3250 3251 3252 3253 3254 3255 3256 3257 3258 3259 3260 3261 3262 3263 3264 3265 3266 3267 3268 3269 3270 3271 3272 3273 3274 3275 3276 3277 ``` | ``` def model_schema(     cls: type[Any],     schema: CoreSchema,     *,     generic_origin: type[Any] | None = None,     custom_init: bool | None = None,     root_model: bool | None = None,     post_init: str | None = None,     revalidate_instances: Literal['always', 'never', 'subclass-instances'] | None = None,     strict: bool | None = None,     frozen: bool | None = None,     extra_behavior: ExtraBehavior | None = None,     config: CoreConfig | None = None,     ref: str | None = None,     metadata: dict[str, Any] | None = None,     serialization: SerSchema | None = None, ) -> ModelSchema:     \"\"\"     A model schema generally contains a typed-dict schema.     It will run the typed dict validator, then create a new class     and set the dict and fields set returned from the typed dict validator     to `__dict__` and `__pydantic_fields_set__` respectively.      Example:      ```py     from pydantic_core import CoreConfig, SchemaValidator, core_schema      class MyModel:         __slots__ = (             '__dict__',             '__pydantic_fields_set__',             '__pydantic_extra__',             '__pydantic_private__',         )      schema = core_schema.model_schema(         cls=MyModel,         config=CoreConfig(str_max_length=5),         schema=core_schema.model_fields_schema(             fields={'a': core_schema.model_field(core_schema.str_schema())},         ),     )     v = SchemaValidator(schema)     assert v.isinstance_python({'a': 'hello'}) is True     assert v.isinstance_python({'a': 'too long'}) is False     ```      Args:         cls: The class to use for the model         schema: The schema to use for the model         generic_origin: The origin type used for this model, if it's a parametrized generic. Ex,             if this model schema represents `SomeModel[int]`, generic_origin is `SomeModel`         custom_init: Whether the model has a custom init method         root_model: Whether the model is a `RootModel`         post_init: The call after init to use for the model         revalidate_instances: whether instances of models and dataclasses (including subclass instances)             should re-validate defaults to config.revalidate_instances, else 'never'         strict: Whether the model is strict         frozen: Whether the model is frozen         extra_behavior: The extra behavior to use for the model, used in serialization         config: The config to use for the model         ref: optional unique identifier of the schema, used to reference the schema in other places         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     return _dict_not_none(         type='model',         cls=cls,         generic_origin=generic_origin,         schema=schema,         custom_init=custom_init,         root_model=root_model,         post_init=post_init,         revalidate_instances=revalidate_instances,         strict=strict,         frozen=frozen,         extra_behavior=extra_behavior,         config=config,         ref=ref,         metadata=metadata,         serialization=serialization,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#modelschema-indexhtmlpydanticcorecoreschemamodelschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "dataclass\\_field [Â¶](index.html#pydantic_core.core_schema.dataclass_field \"Permanent link\")", "anchor": "dataclassfield-indexhtmlpydanticcorecoreschemadataclassfield-permanent-link", "md_text": "```\ndataclass_field(\n    name: str,\n    schema: CoreSchema,\n    *,\n    kw_only: bool | None = None,\n    init: bool | None = None,\n    init_only: bool | None = None,\n    validation_alias: (\n        str | list[str | int] | list[list[str | int]] | None\n    ) = None,\n    serialization_alias: str | None = None,\n    serialization_exclude: bool | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization_exclude_if: (\n        Callable[[Any], bool] | None\n    ) = None,\n    frozen: bool | None = None\n) -> DataclassField\n```\n\nReturns a schema for a dataclass field, e.g.:\n\n```\nfrom pydantic_core import SchemaValidator, core_schema\n\nfield = core_schema.dataclass_field(\n    name='a', schema=core_schema.str_schema(), kw_only=False\n)\nschema = core_schema.dataclass_args_schema('Foobar', [field])\nv = SchemaValidator(schema)\nassert v.validate_python({'a': 'hello'}) == ({'a': 'hello'}, None)\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `name` | `str` | The name to use for the argument parameter | *required* |\n| `schema` | `CoreSchema` | The schema to use for the argument parameter | *required* |\n| `kw_only` | `bool | None` | Whether the field can be set with a positional argument as well as a keyword argument | `None` |\n| `init` | `bool | None` | Whether the field should be validated during initialization | `None` |\n| `init_only` | `bool | None` | Whether the field should be omitted from `__dict__` and passed to `__post_init__` | `None` |\n| `validation_alias` | `str | list[str | int] | list[list[str | int]] | None` | The alias(es) to use to find the field in the validation data | `None` |\n| `serialization_alias` | `str | None` | The alias to use as a key when serializing | `None` |\n| `serialization_exclude` | `bool | None` | Whether to exclude the field when serializing | `None` |\n| `serialization_exclude_if` | `Callable[[Any], bool] | None` | A callable that determines whether to exclude the field when serializing based on its value. | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `frozen` | `bool | None` | Whether the field is frozen | `None` |\n\nSource code in `pydantic_core/core_schema.py`", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#dataclassfield-indexhtmlpydanticcorecoreschemadataclassfield-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "dataclass\\_field [Â¶](index.html#pydantic_core.core_schema.dataclass_field \"Permanent link\")", "anchor": "dataclassfield-indexhtmlpydanticcorecoreschemadataclassfield-permanent-link", "md_text": "|  |  |\n| --- | --- |\n| ``` 3295 3296 3297 3298 3299 3300 3301 3302 3303 3304 3305 3306 3307 3308 3309 3310 3311 3312 3313 3314 3315 3316 3317 3318 3319 3320 3321 3322 3323 3324 3325 3326 3327 3328 3329 3330 3331 3332 3333 3334 3335 3336 3337 3338 3339 3340 3341 3342 3343 3344 3345 3346 3347 3348 3349 ``` | ``` def dataclass_field(     name: str,     schema: CoreSchema,     *,     kw_only: bool | None = None,     init: bool | None = None,     init_only: bool | None = None,     validation_alias: str | list[str | int] | list[list[str | int]] | None = None,     serialization_alias: str | None = None,     serialization_exclude: bool | None = None,     metadata: dict[str, Any] | None = None,     serialization_exclude_if: Callable[[Any], bool] | None = None,     frozen: bool | None = None, ) -> DataclassField:     \"\"\"     Returns a schema for a dataclass field, e.g.:      ```py     from pydantic_core import SchemaValidator, core_schema      field = core_schema.dataclass_field(         name='a', schema=core_schema.str_schema(), kw_only=False     )     schema = core_schema.dataclass_args_schema('Foobar', [field])     v = SchemaValidator(schema)     assert v.validate_python({'a': 'hello'}) == ({'a': 'hello'}, None)     ```      Args:         name: The name to use for the argument parameter         schema: The schema to use for the argument parameter         kw_only: Whether the field can be set with a positional argument as well as a keyword argument         init: Whether the field should be validated during initialization         init_only: Whether the field should be omitted  from `__dict__` and passed to `__post_init__`         validation_alias: The alias(es) to use to find the field in the validation data         serialization_alias: The alias to use as a key when serializing         serialization_exclude: Whether to exclude the field when serializing         serialization_exclude_if: A callable that determines whether to exclude the field when serializing based on its value.         metadata: Any other information you want to include with the schema, not used by pydantic-core         frozen: Whether the field is frozen     \"\"\"     return _dict_not_none(         type='dataclass-field',         name=name,         schema=schema,         kw_only=kw_only,         init=init,         init_only=init_only,         validation_alias=validation_alias,         serialization_alias=serialization_alias,         serialization_exclude=serialization_exclude,         serialization_exclude_if=serialization_exclude_if,         metadata=metadata,         frozen=frozen,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#dataclassfield-indexhtmlpydanticcorecoreschemadataclassfield-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "dataclass\\_args\\_schema [Â¶](index.html#pydantic_core.core_schema.dataclass_args_schema \"Permanent link\")", "anchor": "dataclassargsschema-indexhtmlpydanticcorecoreschemadataclassargsschema-permanent-link", "md_text": "```\ndataclass_args_schema(\n    dataclass_name: str,\n    fields: list[DataclassField],\n    *,\n    computed_fields: list[ComputedField] | None = None,\n    collect_init_only: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n    extra_behavior: ExtraBehavior | None = None\n) -> DataclassArgsSchema\n```\n\nReturns a schema for validating dataclass arguments, e.g.:\n\n```\nfrom pydantic_core import SchemaValidator, core_schema\n\nfield_a = core_schema.dataclass_field(\n    name='a', schema=core_schema.str_schema(), kw_only=False\n)\nfield_b = core_schema.dataclass_field(\n    name='b', schema=core_schema.bool_schema(), kw_only=False\n)\nschema = core_schema.dataclass_args_schema('Foobar', [field_a, field_b])\nv = SchemaValidator(schema)\nassert v.validate_python({'a': 'hello', 'b': True}) == ({'a': 'hello', 'b': True}, None)\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `dataclass_name` | `str` | The name of the dataclass being validated | *required* |\n| `fields` | `list[DataclassField]` | The fields to use for the dataclass | *required* |\n| `computed_fields` | `list[ComputedField] | None` | Computed fields to use when serializing the dataclass | `None` |\n| `collect_init_only` | `bool | None` | Whether to collect init only fields into a dict to pass to `__post_init__` | `None` |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema | `None` |\n| `extra_behavior` | `ExtraBehavior | None` | How to handle extra fields | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 3364 3365 3366 3367 3368 3369 3370 3371 3372 3373 3374 3375 3376 3377 3378 3379 3380 3381 3382 3383 3384 3385 3386 3387 3388 3389 3390 3391 3392 3393 3394 3395 3396 3397 3398 3399 3400 3401 3402 3403 3404 3405 3406 3407 3408 3409 3410 3411 3412 ``` | ``` def dataclass_args_schema(     dataclass_name: str,     fields: list[DataclassField],     *,     computed_fields: list[ComputedField] | None = None,     collect_init_only: bool | None = None,     ref: str | None = None,     metadata: dict[str, Any] | None = None,     serialization: SerSchema | None = None,     extra_behavior: ExtraBehavior | None = None, ) -> DataclassArgsSchema:     \"\"\"     Returns a schema for validating dataclass arguments, e.g.:      ```py     from pydantic_core import SchemaValidator, core_schema      field_a = core_schema.dataclass_field(         name='a', schema=core_schema.str_schema(), kw_only=False     )     field_b = core_schema.dataclass_field(         name='b', schema=core_schema.bool_schema(), kw_only=False     )     schema = core_schema.dataclass_args_schema('Foobar', [field_a, field_b])     v = SchemaValidator(schema)     assert v.validate_python({'a': 'hello', 'b': True}) == ({'a': 'hello', 'b': True}, None)     ```      Args:         dataclass_name: The name of the dataclass being validated         fields: The fields to use for the dataclass         computed_fields: Computed fields to use when serializing the dataclass         collect_init_only: Whether to collect init only fields into a dict to pass to `__post_init__`         ref: optional unique identifier of the schema, used to reference the schema in other places         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema         extra_behavior: How to handle extra fields     \"\"\"     return _dict_not_none(         type='dataclass-args',         dataclass_name=dataclass_name,         fields=fields,         computed_fields=computed_fields,         collect_init_only=collect_init_only,         ref=ref,         metadata=metadata,         serialization=serialization,         extra_behavior=extra_behavior,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#dataclassargsschema-indexhtmlpydanticcorecoreschemadataclassargsschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "dataclass\\_schema [Â¶](index.html#pydantic_core.core_schema.dataclass_schema \"Permanent link\")", "anchor": "dataclassschema-indexhtmlpydanticcorecoreschemadataclassschema-permanent-link", "md_text": "```\ndataclass_schema(\n    cls: type[Any],\n    schema: CoreSchema,\n    fields: list[str],\n    *,\n    generic_origin: type[Any] | None = None,\n    cls_name: str | None = None,\n    post_init: bool | None = None,\n    revalidate_instances: (\n        Literal[\"always\", \"never\", \"subclass-instances\"]\n        | None\n    ) = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n    frozen: bool | None = None,\n    slots: bool | None = None,\n    config: CoreConfig | None = None\n) -> DataclassSchema\n```\n\nReturns a schema for a dataclass. As with `ModelSchema`, this schema can only be used as a field within\nanother schema, not as the root type.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `cls` | `type[Any]` | The dataclass type, used to perform subclass checks | *required* |\n| `schema` | `CoreSchema` | The schema to use for the dataclass fields | *required* |\n| `fields` | `list[str]` | Fields of the dataclass, this is used in serialization and in validation during re-validation and while validating assignment | *required* |\n| `generic_origin` | `type[Any] | None` | The origin type used for this dataclass, if it's a parametrized generic. Ex, if this model schema represents `SomeDataclass[int]`, generic\\_origin is `SomeDataclass` | `None` |\n| `cls_name` | `str | None` | The name to use in error locs, etc; this is useful for generics (default: `cls.__name__`) | `None` |\n| `post_init` | `bool | None` | Whether to call `__post_init__` after validation | `None` |\n| `revalidate_instances` | `Literal['always', 'never', 'subclass-instances'] | None` | whether instances of models and dataclasses (including subclass instances) should re-validate defaults to config.revalidate\\_instances, else 'never' | `None` |\n| `strict` | `bool | None` | Whether to require an exact instance of `cls` | `None` |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema | `None` |\n| `frozen` | `bool | None` | Whether the dataclass is frozen | `None` |\n| `slots` | `bool | None` | Whether `slots=True` on the dataclass, means each field is assigned independently, rather than simply setting `__dict__`, default false | `None` |\n\nSource code in `pydantic_core/core_schema.py`", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#dataclassschema-indexhtmlpydanticcorecoreschemadataclassschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "dataclass\\_schema [Â¶](index.html#pydantic_core.core_schema.dataclass_schema \"Permanent link\")", "anchor": "dataclassschema-indexhtmlpydanticcorecoreschemadataclassschema-permanent-link", "md_text": "|  |  |\n| --- | --- |\n| ``` 3433 3434 3435 3436 3437 3438 3439 3440 3441 3442 3443 3444 3445 3446 3447 3448 3449 3450 3451 3452 3453 3454 3455 3456 3457 3458 3459 3460 3461 3462 3463 3464 3465 3466 3467 3468 3469 3470 3471 3472 3473 3474 3475 3476 3477 3478 3479 3480 3481 3482 3483 3484 3485 3486 3487 3488 3489 ``` | ``` def dataclass_schema(     cls: type[Any],     schema: CoreSchema,     fields: list[str],     *,     generic_origin: type[Any] | None = None,     cls_name: str | None = None,     post_init: bool | None = None,     revalidate_instances: Literal['always', 'never', 'subclass-instances'] | None = None,     strict: bool | None = None,     ref: str | None = None,     metadata: dict[str, Any] | None = None,     serialization: SerSchema | None = None,     frozen: bool | None = None,     slots: bool | None = None,     config: CoreConfig | None = None, ) -> DataclassSchema:     \"\"\"     Returns a schema for a dataclass. As with `ModelSchema`, this schema can only be used as a field within     another schema, not as the root type.      Args:         cls: The dataclass type, used to perform subclass checks         schema: The schema to use for the dataclass fields         fields: Fields of the dataclass, this is used in serialization and in validation during re-validation             and while validating assignment         generic_origin: The origin type used for this dataclass, if it's a parametrized generic. Ex,             if this model schema represents `SomeDataclass[int]`, generic_origin is `SomeDataclass`         cls_name: The name to use in error locs, etc; this is useful for generics (default: `cls.__name__`)         post_init: Whether to call `__post_init__` after validation         revalidate_instances: whether instances of models and dataclasses (including subclass instances)             should re-validate defaults to config.revalidate_instances, else 'never'         strict: Whether to require an exact instance of `cls`         ref: optional unique identifier of the schema, used to reference the schema in other places         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema         frozen: Whether the dataclass is frozen         slots: Whether `slots=True` on the dataclass, means each field is assigned independently, rather than             simply setting `__dict__`, default false     \"\"\"     return _dict_not_none(         type='dataclass',         cls=cls,         generic_origin=generic_origin,         fields=fields,         cls_name=cls_name,         schema=schema,         post_init=post_init,         revalidate_instances=revalidate_instances,         strict=strict,         ref=ref,         metadata=metadata,         serialization=serialization,         frozen=frozen,         slots=slots,         config=config,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#dataclassschema-indexhtmlpydanticcorecoreschemadataclassschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "arguments\\_parameter [Â¶](index.html#pydantic_core.core_schema.arguments_parameter \"Permanent link\")", "anchor": "argumentsparameter-indexhtmlpydanticcorecoreschemaargumentsparameter-permanent-link", "md_text": "```\narguments_parameter(\n    name: str,\n    schema: CoreSchema,\n    *,\n    mode: (\n        Literal[\n            \"positional_only\",\n            \"positional_or_keyword\",\n            \"keyword_only\",\n        ]\n        | None\n    ) = None,\n    alias: (\n        str | list[str | int] | list[list[str | int]] | None\n    ) = None\n) -> ArgumentsParameter\n```\n\nReturns a schema that matches an argument parameter, e.g.:\n\n```\nfrom pydantic_core import SchemaValidator, core_schema\n\nparam = core_schema.arguments_parameter(\n    name='a', schema=core_schema.str_schema(), mode='positional_only'\n)\nschema = core_schema.arguments_schema([param])\nv = SchemaValidator(schema)\nassert v.validate_python(('hello',)) == (('hello',), {})\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `name` | `str` | The name to use for the argument parameter | *required* |\n| `schema` | `CoreSchema` | The schema to use for the argument parameter | *required* |\n| `mode` | `Literal['positional_only', 'positional_or_keyword', 'keyword_only'] | None` | The mode to use for the argument parameter | `None` |\n| `alias` | `str | list[str | int] | list[list[str | int]] | None` | The alias to use for the argument parameter | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 3499 3500 3501 3502 3503 3504 3505 3506 3507 3508 3509 3510 3511 3512 3513 3514 3515 3516 3517 3518 3519 3520 3521 3522 3523 3524 3525 3526 ``` | ``` def arguments_parameter(     name: str,     schema: CoreSchema,     *,     mode: Literal['positional_only', 'positional_or_keyword', 'keyword_only'] | None = None,     alias: str | list[str | int] | list[list[str | int]] | None = None, ) -> ArgumentsParameter:     \"\"\"     Returns a schema that matches an argument parameter, e.g.:      ```py     from pydantic_core import SchemaValidator, core_schema      param = core_schema.arguments_parameter(         name='a', schema=core_schema.str_schema(), mode='positional_only'     )     schema = core_schema.arguments_schema([param])     v = SchemaValidator(schema)     assert v.validate_python(('hello',)) == (('hello',), {})     ```      Args:         name: The name to use for the argument parameter         schema: The schema to use for the argument parameter         mode: The mode to use for the argument parameter         alias: The alias to use for the argument parameter     \"\"\"     return _dict_not_none(name=name, schema=schema, mode=mode, alias=alias) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#argumentsparameter-indexhtmlpydanticcorecoreschemaargumentsparameter-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "arguments\\_schema [Â¶](index.html#pydantic_core.core_schema.arguments_schema \"Permanent link\")", "anchor": "argumentsschema-indexhtmlpydanticcorecoreschemaargumentsschema-permanent-link", "md_text": "```\narguments_schema(\n    arguments: list[ArgumentsParameter],\n    *,\n    validate_by_name: bool | None = None,\n    validate_by_alias: bool | None = None,\n    var_args_schema: CoreSchema | None = None,\n    var_kwargs_mode: VarKwargsMode | None = None,\n    var_kwargs_schema: CoreSchema | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None\n) -> ArgumentsSchema\n```\n\nReturns a schema that matches an arguments schema, e.g.:\n\n```\nfrom pydantic_core import SchemaValidator, core_schema\n\nparam_a = core_schema.arguments_parameter(\n    name='a', schema=core_schema.str_schema(), mode='positional_only'\n)\nparam_b = core_schema.arguments_parameter(\n    name='b', schema=core_schema.bool_schema(), mode='positional_only'\n)\nschema = core_schema.arguments_schema([param_a, param_b])\nv = SchemaValidator(schema)\nassert v.validate_python(('hello', True)) == (('hello', True), {})\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `arguments` | `list[ArgumentsParameter]` | The arguments to use for the arguments schema | *required* |\n| `validate_by_name` | `bool | None` | Whether to populate by the parameter names, defaults to `False`. | `None` |\n| `validate_by_alias` | `bool | None` | Whether to populate by the parameter aliases, defaults to `True`. | `None` |\n| `var_args_schema` | `CoreSchema | None` | The variable args schema to use for the arguments schema | `None` |\n| `var_kwargs_mode` | `VarKwargsMode | None` | The validation mode to use for variadic keyword arguments. If `'uniform'`, every value of the keyword arguments will be validated against the `var_kwargs_schema` schema. If `'unpacked-typed-dict'`, the `var_kwargs_schema` argument must be a [`typed_dict_schema`](index.html#pydantic_core.core_schema.typed_dict_schema) | `None` |\n| `var_kwargs_schema` | `CoreSchema | None` | The variable kwargs schema to use for the arguments schema | `None` |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#argumentsschema-indexhtmlpydanticcorecoreschemaargumentsschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "arguments\\_schema [Â¶](index.html#pydantic_core.core_schema.arguments_schema \"Permanent link\")", "anchor": "argumentsschema-indexhtmlpydanticcorecoreschemaargumentsschema-permanent-link", "md_text": "|  |  |\n| --- | --- |\n| ``` 3545 3546 3547 3548 3549 3550 3551 3552 3553 3554 3555 3556 3557 3558 3559 3560 3561 3562 3563 3564 3565 3566 3567 3568 3569 3570 3571 3572 3573 3574 3575 3576 3577 3578 3579 3580 3581 3582 3583 3584 3585 3586 3587 3588 3589 3590 3591 3592 3593 3594 3595 3596 3597 3598 ``` | ``` def arguments_schema(     arguments: list[ArgumentsParameter],     *,     validate_by_name: bool | None = None,     validate_by_alias: bool | None = None,     var_args_schema: CoreSchema | None = None,     var_kwargs_mode: VarKwargsMode | None = None,     var_kwargs_schema: CoreSchema | None = None,     ref: str | None = None,     metadata: dict[str, Any] | None = None,     serialization: SerSchema | None = None, ) -> ArgumentsSchema:     \"\"\"     Returns a schema that matches an arguments schema, e.g.:      ```py     from pydantic_core import SchemaValidator, core_schema      param_a = core_schema.arguments_parameter(         name='a', schema=core_schema.str_schema(), mode='positional_only'     )     param_b = core_schema.arguments_parameter(         name='b', schema=core_schema.bool_schema(), mode='positional_only'     )     schema = core_schema.arguments_schema([param_a, param_b])     v = SchemaValidator(schema)     assert v.validate_python(('hello', True)) == (('hello', True), {})     ```      Args:         arguments: The arguments to use for the arguments schema         validate_by_name: Whether to populate by the parameter names, defaults to `False`.         validate_by_alias: Whether to populate by the parameter aliases, defaults to `True`.         var_args_schema: The variable args schema to use for the arguments schema         var_kwargs_mode: The validation mode to use for variadic keyword arguments. If `'uniform'`, every value of the             keyword arguments will be validated against the `var_kwargs_schema` schema. If `'unpacked-typed-dict'`,             the `var_kwargs_schema` argument must be a [`typed_dict_schema`][pydantic_core.core_schema.typed_dict_schema]         var_kwargs_schema: The variable kwargs schema to use for the arguments schema         ref: optional unique identifier of the schema, used to reference the schema in other places         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     return _dict_not_none(         type='arguments',         arguments_schema=arguments,         validate_by_name=validate_by_name,         validate_by_alias=validate_by_alias,         var_args_schema=var_args_schema,         var_kwargs_mode=var_kwargs_mode,         var_kwargs_schema=var_kwargs_schema,         ref=ref,         metadata=metadata,         serialization=serialization,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#argumentsschema-indexhtmlpydanticcorecoreschemaargumentsschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "arguments\\_v3\\_parameter [Â¶](index.html#pydantic_core.core_schema.arguments_v3_parameter \"Permanent link\")", "anchor": "argumentsv3parameter-indexhtmlpydanticcorecoreschemaargumentsv3parameter-permanent-link", "md_text": "```\narguments_v3_parameter(\n    name: str,\n    schema: CoreSchema,\n    *,\n    mode: (\n        Literal[\n            \"positional_only\",\n            \"positional_or_keyword\",\n            \"keyword_only\",\n            \"var_args\",\n            \"var_kwargs_uniform\",\n            \"var_kwargs_unpacked_typed_dict\",\n        ]\n        | None\n    ) = None,\n    alias: (\n        str | list[str | int] | list[list[str | int]] | None\n    ) = None\n) -> ArgumentsV3Parameter\n```\n\nReturns a schema that matches an argument parameter, e.g.:\n\n```\nfrom pydantic_core import SchemaValidator, core_schema\n\nparam = core_schema.arguments_v3_parameter(\n    name='a', schema=core_schema.str_schema(), mode='positional_only'\n)\nschema = core_schema.arguments_v3_schema([param])\nv = SchemaValidator(schema)\nassert v.validate_python({'a': 'hello'}) == (('hello',), {})\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `name` | `str` | The name to use for the argument parameter | *required* |\n| `schema` | `CoreSchema` | The schema to use for the argument parameter | *required* |\n| `mode` | `Literal['positional_only', 'positional_or_keyword', 'keyword_only', 'var_args', 'var_kwargs_uniform', 'var_kwargs_unpacked_typed_dict'] | None` | The mode to use for the argument parameter | `None` |\n| `alias` | `str | list[str | int] | list[list[str | int]] | None` | The alias to use for the argument parameter | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 3615 3616 3617 3618 3619 3620 3621 3622 3623 3624 3625 3626 3627 3628 3629 3630 3631 3632 3633 3634 3635 3636 3637 3638 3639 3640 3641 3642 3643 3644 3645 3646 3647 3648 3649 3650 ``` | ``` def arguments_v3_parameter(     name: str,     schema: CoreSchema,     *,     mode: Literal[         'positional_only',         'positional_or_keyword',         'keyword_only',         'var_args',         'var_kwargs_uniform',         'var_kwargs_unpacked_typed_dict',     ]     | None = None,     alias: str | list[str | int] | list[list[str | int]] | None = None, ) -> ArgumentsV3Parameter:     \"\"\"     Returns a schema that matches an argument parameter, e.g.:      ```py     from pydantic_core import SchemaValidator, core_schema      param = core_schema.arguments_v3_parameter(         name='a', schema=core_schema.str_schema(), mode='positional_only'     )     schema = core_schema.arguments_v3_schema([param])     v = SchemaValidator(schema)     assert v.validate_python({'a': 'hello'}) == (('hello',), {})     ```      Args:         name: The name to use for the argument parameter         schema: The schema to use for the argument parameter         mode: The mode to use for the argument parameter         alias: The alias to use for the argument parameter     \"\"\"     return _dict_not_none(name=name, schema=schema, mode=mode, alias=alias) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#argumentsv3parameter-indexhtmlpydanticcorecoreschemaargumentsv3parameter-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "arguments\\_v3\\_schema [Â¶](index.html#pydantic_core.core_schema.arguments_v3_schema \"Permanent link\")", "anchor": "argumentsv3schema-indexhtmlpydanticcorecoreschemaargumentsv3schema-permanent-link", "md_text": "```\narguments_v3_schema(\n    arguments: list[ArgumentsV3Parameter],\n    *,\n    validate_by_name: bool | None = None,\n    validate_by_alias: bool | None = None,\n    extra_behavior: (\n        Literal[\"forbid\", \"ignore\"] | None\n    ) = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None\n) -> ArgumentsV3Schema\n```\n\nReturns a schema that matches an arguments schema, e.g.:\n\n```\nfrom pydantic_core import SchemaValidator, core_schema\n\nparam_a = core_schema.arguments_v3_parameter(\n    name='a', schema=core_schema.str_schema(), mode='positional_only'\n)\nparam_b = core_schema.arguments_v3_parameter(\n    name='kwargs', schema=core_schema.bool_schema(), mode='var_kwargs_uniform'\n)\nschema = core_schema.arguments_v3_schema([param_a, param_b])\nv = SchemaValidator(schema)\nassert v.validate_python({'a': 'hi', 'kwargs': {'b': True}}) == (('hi',), {'b': True})\n```\n\nThis schema is currently not used by other Pydantic components. In V3, it will most likely\nbecome the default arguments schema for the `'call'` schema.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `arguments` | `list[ArgumentsV3Parameter]` | The arguments to use for the arguments schema. | *required* |\n| `validate_by_name` | `bool | None` | Whether to populate by the parameter names, defaults to `False`. | `None` |\n| `validate_by_alias` | `bool | None` | Whether to populate by the parameter aliases, defaults to `True`. | `None` |\n| `extra_behavior` | `Literal['forbid', 'ignore'] | None` | The extra behavior to use. | `None` |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places. | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core. | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema. | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 3664 3665 3666 3667 3668 3669 3670 3671 3672 3673 3674 3675 3676 3677 3678 3679 3680 3681 3682 3683 3684 3685 3686 3687 3688 3689 3690 3691 3692 3693 3694 3695 3696 3697 3698 3699 3700 3701 3702 3703 3704 3705 3706 3707 3708 3709 3710 3711 3712 ``` | ``` def arguments_v3_schema(     arguments: list[ArgumentsV3Parameter],     *,     validate_by_name: bool | None = None,     validate_by_alias: bool | None = None,     extra_behavior: Literal['forbid', 'ignore'] | None = None,     ref: str | None = None,     metadata: dict[str, Any] | None = None,     serialization: SerSchema | None = None, ) -> ArgumentsV3Schema:     \"\"\"     Returns a schema that matches an arguments schema, e.g.:      ```py     from pydantic_core import SchemaValidator, core_schema      param_a = core_schema.arguments_v3_parameter(         name='a', schema=core_schema.str_schema(), mode='positional_only'     )     param_b = core_schema.arguments_v3_parameter(         name='kwargs', schema=core_schema.bool_schema(), mode='var_kwargs_uniform'     )     schema = core_schema.arguments_v3_schema([param_a, param_b])     v = SchemaValidator(schema)     assert v.validate_python({'a': 'hi', 'kwargs': {'b': True}}) == (('hi',), {'b': True})     ```      This schema is currently not used by other Pydantic components. In V3, it will most likely     become the default arguments schema for the `'call'` schema.      Args:         arguments: The arguments to use for the arguments schema.         validate_by_name: Whether to populate by the parameter names, defaults to `False`.         validate_by_alias: Whether to populate by the parameter aliases, defaults to `True`.         extra_behavior: The extra behavior to use.         ref: optional unique identifier of the schema, used to reference the schema in other places.         metadata: Any other information you want to include with the schema, not used by pydantic-core.         serialization: Custom serialization schema.     \"\"\"     return _dict_not_none(         type='arguments-v3',         arguments_schema=arguments,         validate_by_name=validate_by_name,         validate_by_alias=validate_by_alias,         extra_behavior=extra_behavior,         ref=ref,         metadata=metadata,         serialization=serialization,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#argumentsv3schema-indexhtmlpydanticcorecoreschemaargumentsv3schema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "call\\_schema [Â¶](index.html#pydantic_core.core_schema.call_schema \"Permanent link\")", "anchor": "callschema-indexhtmlpydanticcorecoreschemacallschema-permanent-link", "md_text": "```\ncall_schema(\n    arguments: CoreSchema,\n    function: Callable[..., Any],\n    *,\n    function_name: str | None = None,\n    return_schema: CoreSchema | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None\n) -> CallSchema\n```\n\nReturns a schema that matches an arguments schema, then calls a function, e.g.:\n\n```\nfrom pydantic_core import SchemaValidator, core_schema\n\nparam_a = core_schema.arguments_parameter(\n    name='a', schema=core_schema.str_schema(), mode='positional_only'\n)\nparam_b = core_schema.arguments_parameter(\n    name='b', schema=core_schema.bool_schema(), mode='positional_only'\n)\nargs_schema = core_schema.arguments_schema([param_a, param_b])\n\nschema = core_schema.call_schema(\n    arguments=args_schema,\n    function=lambda a, b: a + str(not b),\n    return_schema=core_schema.str_schema(),\n)\nv = SchemaValidator(schema)\nassert v.validate_python((('hello', True))) == 'helloFalse'\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `arguments` | `CoreSchema` | The arguments to use for the arguments schema | *required* |\n| `function` | `Callable[..., Any]` | The function to use for the call schema | *required* |\n| `function_name` | `str | None` | The function name to use for the call schema, if not provided `function.__name__` is used | `None` |\n| `return_schema` | `CoreSchema | None` | The return schema to use for the call schema | `None` |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 3726 3727 3728 3729 3730 3731 3732 3733 3734 3735 3736 3737 3738 3739 3740 3741 3742 3743 3744 3745 3746 3747 3748 3749 3750 3751 3752 3753 3754 3755 3756 3757 3758 3759 3760 3761 3762 3763 3764 3765 3766 3767 3768 3769 3770 3771 3772 3773 3774 3775 3776 3777 ``` | ``` def call_schema(     arguments: CoreSchema,     function: Callable[..., Any],     *,     function_name: str | None = None,     return_schema: CoreSchema | None = None,     ref: str | None = None,     metadata: dict[str, Any] | None = None,     serialization: SerSchema | None = None, ) -> CallSchema:     \"\"\"     Returns a schema that matches an arguments schema, then calls a function, e.g.:      ```py     from pydantic_core import SchemaValidator, core_schema      param_a = core_schema.arguments_parameter(         name='a', schema=core_schema.str_schema(), mode='positional_only'     )     param_b = core_schema.arguments_parameter(         name='b', schema=core_schema.bool_schema(), mode='positional_only'     )     args_schema = core_schema.arguments_schema([param_a, param_b])      schema = core_schema.call_schema(         arguments=args_schema,         function=lambda a, b: a + str(not b),         return_schema=core_schema.str_schema(),     )     v = SchemaValidator(schema)     assert v.validate_python((('hello', True))) == 'helloFalse'     ```      Args:         arguments: The arguments to use for the arguments schema         function: The function to use for the call schema         function_name: The function name to use for the call schema, if not provided `function.__name__` is used         return_schema: The return schema to use for the call schema         ref: optional unique identifier of the schema, used to reference the schema in other places         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     return _dict_not_none(         type='call',         arguments_schema=arguments,         function=function,         function_name=function_name,         return_schema=return_schema,         ref=ref,         metadata=metadata,         serialization=serialization,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#callschema-indexhtmlpydanticcorecoreschemacallschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "custom\\_error\\_schema [Â¶](index.html#pydantic_core.core_schema.custom_error_schema \"Permanent link\")", "anchor": "customerrorschema-indexhtmlpydanticcorecoreschemacustomerrorschema-permanent-link", "md_text": "```\ncustom_error_schema(\n    schema: CoreSchema,\n    custom_error_type: str,\n    *,\n    custom_error_message: str | None = None,\n    custom_error_context: dict[str, Any] | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None\n) -> CustomErrorSchema\n```\n\nReturns a schema that matches a custom error value, e.g.:\n\n```\nfrom pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.custom_error_schema(\n    schema=core_schema.int_schema(),\n    custom_error_type='MyError',\n    custom_error_message='Error msg',\n)\nv = SchemaValidator(schema)\nv.validate_python(1)\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `CoreSchema` | The schema to use for the custom error schema | *required* |\n| `custom_error_type` | `str` | The custom error type to use for the custom error schema | *required* |\n| `custom_error_message` | `str | None` | The custom error message to use for the custom error schema | `None` |\n| `custom_error_context` | `dict[str, Any] | None` | The custom error context to use for the custom error schema | `None` |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 3791 3792 3793 3794 3795 3796 3797 3798 3799 3800 3801 3802 3803 3804 3805 3806 3807 3808 3809 3810 3811 3812 3813 3814 3815 3816 3817 3818 3819 3820 3821 3822 3823 3824 3825 3826 3827 3828 3829 3830 3831 3832 3833 3834 ``` | ``` def custom_error_schema(     schema: CoreSchema,     custom_error_type: str,     *,     custom_error_message: str | None = None,     custom_error_context: dict[str, Any] | None = None,     ref: str | None = None,     metadata: dict[str, Any] | None = None,     serialization: SerSchema | None = None, ) -> CustomErrorSchema:     \"\"\"     Returns a schema that matches a custom error value, e.g.:      ```py     from pydantic_core import SchemaValidator, core_schema      schema = core_schema.custom_error_schema(         schema=core_schema.int_schema(),         custom_error_type='MyError',         custom_error_message='Error msg',     )     v = SchemaValidator(schema)     v.validate_python(1)     ```      Args:         schema: The schema to use for the custom error schema         custom_error_type: The custom error type to use for the custom error schema         custom_error_message: The custom error message to use for the custom error schema         custom_error_context: The custom error context to use for the custom error schema         ref: optional unique identifier of the schema, used to reference the schema in other places         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     return _dict_not_none(         type='custom-error',         schema=schema,         custom_error_type=custom_error_type,         custom_error_message=custom_error_message,         custom_error_context=custom_error_context,         ref=ref,         metadata=metadata,         serialization=serialization,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#customerrorschema-indexhtmlpydanticcorecoreschemacustomerrorschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "json\\_schema [Â¶](index.html#pydantic_core.core_schema.json_schema \"Permanent link\")", "anchor": "jsonschema-indexhtmlpydanticcorecoreschemajsonschema-permanent-link", "md_text": "```\njson_schema(\n    schema: CoreSchema | None = None,\n    *,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None\n) -> JsonSchema\n```\n\nReturns a schema that matches a JSON value, e.g.:\n\n```\nfrom pydantic_core import SchemaValidator, core_schema\n\ndict_schema = core_schema.model_fields_schema(\n    {\n        'field_a': core_schema.model_field(core_schema.str_schema()),\n        'field_b': core_schema.model_field(core_schema.bool_schema()),\n    },\n)\n\nclass MyModel:\n    __slots__ = (\n        '__dict__',\n        '__pydantic_fields_set__',\n        '__pydantic_extra__',\n        '__pydantic_private__',\n    )\n    field_a: str\n    field_b: bool\n\njson_schema = core_schema.json_schema(schema=dict_schema)\nschema = core_schema.model_schema(cls=MyModel, schema=json_schema)\nv = SchemaValidator(schema)\nm = v.validate_python('{\"field_a\": \"hello\", \"field_b\": true}')\nassert isinstance(m, MyModel)\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `CoreSchema | None` | The schema to use for the JSON schema | `None` |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 3845 3846 3847 3848 3849 3850 3851 3852 3853 3854 3855 3856 3857 3858 3859 3860 3861 3862 3863 3864 3865 3866 3867 3868 3869 3870 3871 3872 3873 3874 3875 3876 3877 3878 3879 3880 3881 3882 3883 3884 3885 3886 3887 3888 ``` | ``` def json_schema(     schema: CoreSchema | None = None,     *,     ref: str | None = None,     metadata: dict[str, Any] | None = None,     serialization: SerSchema | None = None, ) -> JsonSchema:     \"\"\"     Returns a schema that matches a JSON value, e.g.:      ```py     from pydantic_core import SchemaValidator, core_schema      dict_schema = core_schema.model_fields_schema(         {             'field_a': core_schema.model_field(core_schema.str_schema()),             'field_b': core_schema.model_field(core_schema.bool_schema()),         },     )      class MyModel:         __slots__ = (             '__dict__',             '__pydantic_fields_set__',             '__pydantic_extra__',             '__pydantic_private__',         )         field_a: str         field_b: bool      json_schema = core_schema.json_schema(schema=dict_schema)     schema = core_schema.model_schema(cls=MyModel, schema=json_schema)     v = SchemaValidator(schema)     m = v.validate_python('{\"field_a\": \"hello\", \"field_b\": true}')     assert isinstance(m, MyModel)     ```      Args:         schema: The schema to use for the JSON schema         ref: optional unique identifier of the schema, used to reference the schema in other places         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     return _dict_not_none(type='json', schema=schema, ref=ref, metadata=metadata, serialization=serialization) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#jsonschema-indexhtmlpydanticcorecoreschemajsonschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "url\\_schema [Â¶](index.html#pydantic_core.core_schema.url_schema \"Permanent link\")", "anchor": "urlschema-indexhtmlpydanticcorecoreschemaurlschema-permanent-link", "md_text": "```\nurl_schema(\n    *,\n    max_length: int | None = None,\n    allowed_schemes: list[str] | None = None,\n    host_required: bool | None = None,\n    default_host: str | None = None,\n    default_port: int | None = None,\n    default_path: str | None = None,\n    preserve_empty_path: bool | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None\n) -> UrlSchema\n```\n\nReturns a schema that matches a URL value, e.g.:\n\n```\nfrom pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.url_schema()\nv = SchemaValidator(schema)\nprint(v.validate_python('https://example.com'))\n#> https://example.com/\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `max_length` | `int | None` | The maximum length of the URL | `None` |\n| `allowed_schemes` | `list[str] | None` | The allowed URL schemes | `None` |\n| `host_required` | `bool | None` | Whether the URL must have a host | `None` |\n| `default_host` | `str | None` | The default host to use if the URL does not have a host | `None` |\n| `default_port` | `int | None` | The default port to use if the URL does not have a port | `None` |\n| `default_path` | `str | None` | The default path to use if the URL does not have a path | `None` |\n| `preserve_empty_path` | `bool | None` | Whether to preserve an empty path or convert it to '/', default False | `None` |\n| `strict` | `bool | None` | Whether to use strict URL parsing | `None` |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 3905 3906 3907 3908 3909 3910 3911 3912 3913 3914 3915 3916 3917 3918 3919 3920 3921 3922 3923 3924 3925 3926 3927 3928 3929 3930 3931 3932 3933 3934 3935 3936 3937 3938 3939 3940 3941 3942 3943 3944 3945 3946 3947 3948 3949 3950 3951 3952 3953 3954 3955 3956 3957 ``` | ``` def url_schema(     *,     max_length: int | None = None,     allowed_schemes: list[str] | None = None,     host_required: bool | None = None,     default_host: str | None = None,     default_port: int | None = None,     default_path: str | None = None,     preserve_empty_path: bool | None = None,     strict: bool | None = None,     ref: str | None = None,     metadata: dict[str, Any] | None = None,     serialization: SerSchema | None = None, ) -> UrlSchema:     \"\"\"     Returns a schema that matches a URL value, e.g.:      ```py     from pydantic_core import SchemaValidator, core_schema      schema = core_schema.url_schema()     v = SchemaValidator(schema)     print(v.validate_python('https://example.com'))     #> https://example.com/     ```      Args:         max_length: The maximum length of the URL         allowed_schemes: The allowed URL schemes         host_required: Whether the URL must have a host         default_host: The default host to use if the URL does not have a host         default_port: The default port to use if the URL does not have a port         default_path: The default path to use if the URL does not have a path         preserve_empty_path: Whether to preserve an empty path or convert it to '/', default False         strict: Whether to use strict URL parsing         ref: optional unique identifier of the schema, used to reference the schema in other places         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     return _dict_not_none(         type='url',         max_length=max_length,         allowed_schemes=allowed_schemes,         host_required=host_required,         default_host=default_host,         default_port=default_port,         default_path=default_path,         preserve_empty_path=preserve_empty_path,         strict=strict,         ref=ref,         metadata=metadata,         serialization=serialization,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#urlschema-indexhtmlpydanticcorecoreschemaurlschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "multi\\_host\\_url\\_schema [Â¶](index.html#pydantic_core.core_schema.multi_host_url_schema \"Permanent link\")", "anchor": "multihosturlschema-indexhtmlpydanticcorecoreschemamultihosturlschema-permanent-link", "md_text": "```\nmulti_host_url_schema(\n    *,\n    max_length: int | None = None,\n    allowed_schemes: list[str] | None = None,\n    host_required: bool | None = None,\n    default_host: str | None = None,\n    default_port: int | None = None,\n    default_path: str | None = None,\n    preserve_empty_path: bool | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None\n) -> MultiHostUrlSchema\n```\n\nReturns a schema that matches a URL value with possibly multiple hosts, e.g.:\n\n```\nfrom pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.multi_host_url_schema()\nv = SchemaValidator(schema)\nprint(v.validate_python('redis://localhost,0.0.0.0,127.0.0.1'))\n#> redis://localhost,0.0.0.0,127.0.0.1\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `max_length` | `int | None` | The maximum length of the URL | `None` |\n| `allowed_schemes` | `list[str] | None` | The allowed URL schemes | `None` |\n| `host_required` | `bool | None` | Whether the URL must have a host | `None` |\n| `default_host` | `str | None` | The default host to use if the URL does not have a host | `None` |\n| `default_port` | `int | None` | The default port to use if the URL does not have a port | `None` |\n| `default_path` | `str | None` | The default path to use if the URL does not have a path | `None` |\n| `preserve_empty_path` | `bool | None` | Whether to preserve an empty path or convert it to '/', default False | `None` |\n| `strict` | `bool | None` | Whether to use strict URL parsing | `None` |\n| `ref` | `str | None` | optional unique identifier of the schema, used to reference the schema in other places | `None` |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#multihosturlschema-indexhtmlpydanticcorecoreschemamultihosturlschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "multi\\_host\\_url\\_schema [Â¶](index.html#pydantic_core.core_schema.multi_host_url_schema \"Permanent link\")", "anchor": "multihosturlschema-indexhtmlpydanticcorecoreschemamultihosturlschema-permanent-link", "md_text": "|  |  |\n| --- | --- |\n| ``` 3974 3975 3976 3977 3978 3979 3980 3981 3982 3983 3984 3985 3986 3987 3988 3989 3990 3991 3992 3993 3994 3995 3996 3997 3998 3999 4000 4001 4002 4003 4004 4005 4006 4007 4008 4009 4010 4011 4012 4013 4014 4015 4016 4017 4018 4019 4020 4021 4022 4023 4024 4025 4026 ``` | ``` def multi_host_url_schema(     *,     max_length: int | None = None,     allowed_schemes: list[str] | None = None,     host_required: bool | None = None,     default_host: str | None = None,     default_port: int | None = None,     default_path: str | None = None,     preserve_empty_path: bool | None = None,     strict: bool | None = None,     ref: str | None = None,     metadata: dict[str, Any] | None = None,     serialization: SerSchema | None = None, ) -> MultiHostUrlSchema:     \"\"\"     Returns a schema that matches a URL value with possibly multiple hosts, e.g.:      ```py     from pydantic_core import SchemaValidator, core_schema      schema = core_schema.multi_host_url_schema()     v = SchemaValidator(schema)     print(v.validate_python('redis://localhost,0.0.0.0,127.0.0.1'))     #> redis://localhost,0.0.0.0,127.0.0.1     ```      Args:         max_length: The maximum length of the URL         allowed_schemes: The allowed URL schemes         host_required: Whether the URL must have a host         default_host: The default host to use if the URL does not have a host         default_port: The default port to use if the URL does not have a port         default_path: The default path to use if the URL does not have a path         preserve_empty_path: Whether to preserve an empty path or convert it to '/', default False         strict: Whether to use strict URL parsing         ref: optional unique identifier of the schema, used to reference the schema in other places         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     return _dict_not_none(         type='multi-host-url',         max_length=max_length,         allowed_schemes=allowed_schemes,         host_required=host_required,         default_host=default_host,         default_port=default_port,         default_path=default_path,         preserve_empty_path=preserve_empty_path,         strict=strict,         ref=ref,         metadata=metadata,         serialization=serialization,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#multihosturlschema-indexhtmlpydanticcorecoreschemamultihosturlschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "definitions\\_schema [Â¶](index.html#pydantic_core.core_schema.definitions_schema \"Permanent link\")", "anchor": "definitionsschema-indexhtmlpydanticcorecoreschemadefinitionsschema-permanent-link", "md_text": "```\ndefinitions_schema(\n    schema: CoreSchema, definitions: list[CoreSchema]\n) -> DefinitionsSchema\n```\n\nBuild a schema that contains both an inner schema and a list of definitions which can be used\nwithin the inner schema.\n\n```\nfrom pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.definitions_schema(\n    core_schema.list_schema(core_schema.definition_reference_schema('foobar')),\n    [core_schema.int_schema(ref='foobar')],\n)\nv = SchemaValidator(schema)\nassert v.validate_python([1, 2, '3']) == [1, 2, 3]\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `CoreSchema` | The inner schema | *required* |\n| `definitions` | `list[CoreSchema]` | List of definitions which can be referenced within inner schema | *required* |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 4037 4038 4039 4040 4041 4042 4043 4044 4045 4046 4047 4048 4049 4050 4051 4052 4053 4054 4055 4056 4057 ``` | ``` def definitions_schema(schema: CoreSchema, definitions: list[CoreSchema]) -> DefinitionsSchema:     \"\"\"     Build a schema that contains both an inner schema and a list of definitions which can be used     within the inner schema.      ```py     from pydantic_core import SchemaValidator, core_schema      schema = core_schema.definitions_schema(         core_schema.list_schema(core_schema.definition_reference_schema('foobar')),         [core_schema.int_schema(ref='foobar')],     )     v = SchemaValidator(schema)     assert v.validate_python([1, 2, '3']) == [1, 2, 3]     ```      Args:         schema: The inner schema         definitions: List of definitions which can be referenced within inner schema     \"\"\"     return DefinitionsSchema(type='definitions', schema=schema, definitions=definitions) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#definitionsschema-indexhtmlpydanticcorecoreschemadefinitionsschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "definition\\_reference\\_schema [Â¶](index.html#pydantic_core.core_schema.definition_reference_schema \"Permanent link\")", "anchor": "definitionreferenceschema-indexhtmlpydanticcorecoreschemadefinitionreferenceschema-permanent-link", "md_text": "```\ndefinition_reference_schema(\n    schema_ref: str,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n) -> DefinitionReferenceSchema\n```\n\nReturns a schema that points to a schema stored in \"definitions\", this is useful for nested recursive\nmodels and also when you want to define validators separately from the main schema, e.g.:\n\n```\nfrom pydantic_core import SchemaValidator, core_schema\n\nschema_definition = core_schema.definition_reference_schema('list-schema')\nschema = core_schema.definitions_schema(\n    schema=schema_definition,\n    definitions=[\n        core_schema.list_schema(items_schema=schema_definition, ref='list-schema'),\n    ],\n)\nv = SchemaValidator(schema)\nassert v.validate_python([()]) == [[]]\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema_ref` | `str` | The schema ref to use for the definition reference schema | *required* |\n| `metadata` | `dict[str, Any] | None` | Any other information you want to include with the schema, not used by pydantic-core | `None` |\n| `serialization` | `SerSchema | None` | Custom serialization schema | `None` |\n\nSource code in `pydantic_core/core_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 4068 4069 4070 4071 4072 4073 4074 4075 4076 4077 4078 4079 4080 4081 4082 4083 4084 4085 4086 4087 4088 4089 4090 4091 4092 4093 4094 4095 4096 4097 4098 4099 ``` | ``` def definition_reference_schema(     schema_ref: str,     ref: str | None = None,     metadata: dict[str, Any] | None = None,     serialization: SerSchema | None = None, ) -> DefinitionReferenceSchema:     \"\"\"     Returns a schema that points to a schema stored in \"definitions\", this is useful for nested recursive     models and also when you want to define validators separately from the main schema, e.g.:      ```py     from pydantic_core import SchemaValidator, core_schema      schema_definition = core_schema.definition_reference_schema('list-schema')     schema = core_schema.definitions_schema(         schema=schema_definition,         definitions=[             core_schema.list_schema(items_schema=schema_definition, ref='list-schema'),         ],     )     v = SchemaValidator(schema)     assert v.validate_python([()]) == [[]]     ```      Args:         schema_ref: The schema ref to use for the definition reference schema         metadata: Any other information you want to include with the schema, not used by pydantic-core         serialization: Custom serialization schema     \"\"\"     return _dict_not_none(         type='definition-ref', schema_ref=schema_ref, ref=ref, metadata=metadata, serialization=serialization     ) ``` |\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/api/pydantic_core_schema/index.html#definitionreferenceschema-indexhtmlpydanticcorecoreschemadefinitionreferenceschema-permanent-link", "page": "api/pydantic_core_schema/index.html", "source_site": "pydantic"}
{"title": "Booleans[Â¶](index.html#booleans \"Permanent link\")", "anchor": "booleansindexhtmlbooleans-permanent-link", "md_text": "Built-in type: [`bool`](https://docs.python.org/3/library/functions.html#bool)", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#booleansindexhtmlbooleans-permanent-link", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Validation", "anchor": "validation", "md_text": "* A valid [`bool`](https://docs.python.org/3/library/functions.html#bool) instance, i.e. `True` or `False`.\n* The integers `0` or `1`.\n* A string, which when converted to lowercase is one of `'0'`, `'off'`, `'f'`, `'false'`, `'n'`, `'no'`, `'1'`, `'on'` `'t'`, `'true'`, `'y'`, `'yes'`.\n* [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes) objects that are valid per the previous rule when decoded to a string.", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#validation", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Strictness", "anchor": "strictness", "md_text": "In [strict mode](../../concepts/strict_mode/index.html), only boolean values are valid. Pydantic provides the [`StrictBool`](../types/index.html#pydantic.types.StrictBool)\ntype as a convenience to [using the `Strict()` metadata class](../../concepts/strict_mode/index.html#using-the-strict-metadata-class).", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#strictness", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Example", "anchor": "example", "md_text": "```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass BooleanModel(BaseModel):\n    bool_value: bool\n\n\nprint(BooleanModel(bool_value=False))\n#> bool_value=False\nprint(BooleanModel(bool_value='False'))\n#> bool_value=False\nprint(BooleanModel(bool_value=1))\n#> bool_value=True\ntry:\n    BooleanModel(bool_value=[])\nexcept ValidationError as e:\n    print(str(e))\n    \"\"\"\n    1 validation error for BooleanModel\n    bool_value\n      Input should be a valid boolean [type=bool_type, input_value=[], input_type=list]\n    \"\"\"\n```", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#example", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Strings[Â¶](index.html#strings \"Permanent link\")", "anchor": "stringsindexhtmlstrings-permanent-link", "md_text": "Built-in type: [`str`](https://docs.python.org/3/library/stdtypes.html#str)", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#stringsindexhtmlstrings-permanent-link", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Validation", "anchor": "validation", "md_text": "* Strings are accepted as-is.\n* [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes) and [`bytearray`](https://docs.python.org/3/library/stdtypes.html#bytearray) are decoded to UTF-8 strings.\n* [Enums](https://docs.python.org/3/library/enum.html#module-enum) are converted using the [`value`](https://docs.python.org/3/library/enum.html#enum.Enum.value) attribute, by calling [`str()`](https://docs.python.org/3/library/stdtypes.html#str)\n  on it.\n* If [`coerce_numbers_to_str`](../config/index.html#pydantic.config.ConfigDict.coerce_numbers_to_str) is set, any number type\n  ([`int`](https://docs.python.org/3/library/functions.html#int), [`float`](https://docs.python.org/3/library/functions.html#float) and [`Decimal`](https://docs.python.org/3/library/decimal.html#decimal.Decimal)) will be coerced to a string and accepted\n  as-is.", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#validation", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Constraints", "anchor": "constraints", "md_text": "Strings support the following constraints:\n\n| Constraint | Description | JSON Schema |\n| --- | --- | --- |\n| `pattern` | A regex pattern that the string must match | [`pattern`](https://json-schema.org/understanding-json-schema/reference/string#regexp) keyword (see [note](index.html#pattern-constraint-note) below). |\n| `min_length` | The minimum length of the string | [`minLength`](https://json-schema.org/understanding-json-schema/reference/string#length) keyword |\n| `max_length` | The maximum length of the string | [`maxLength`](https://json-schema.org/understanding-json-schema/reference/string#length) keyword |\n| `strip_whitespace` | Whether to remove leading and trailing whitespace | N/A |\n| `to_upper` | Whether to convert the string to uppercase | N/A |\n| `to_lower` | Whether to convert the string to lowercase | N/A |\n\nThese constraints can be provided using the [`StringConstraints`](../types/index.html#pydantic.types.StringConstraints) metadata type, or using the [`Field()`](../fields/index.html#pydantic.fields.Field) function (except for `to_upper` and `to_lower`).\nThe `MinLen`, `MaxLen`, `Len`, `LowerCase`, `UpperCase` metadata types from the [`annotated-types`](https://github.com/annotated-types/annotated-types)\nlibrary can also be used.\n\nBy default, Pydantic will use the [`regex`](https://docs.rs/regex) Rust crate to enforce the `pattern` constraint. The regex engine can be controlled\nusing the [`regex_engine`](../config/index.html#pydantic.config.ConfigDict.regex_engine) configuration value. If a compiled [regular expression object](https://docs.python.org/3/library/re.html#re.Pattern) is used for\n`pattern`, the Python engine will automatically be used.\n\nWhile the JSON Schema specification [recommends](https://json-schema.org/draft/2020-12/json-schema-core#name-regular-expressions) using patterns\nvalid according to dialect described in [ECMA-262](https://262.ecma-international.org/11.0/index.html#sec-patterns), Pydantic will *not* enforce it.", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#constraints", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Strictness", "anchor": "strictness", "md_text": "In [strict mode](../../concepts/strict_mode/index.html), only string values are valid. Pydantic provides the [`StrictStr`](../types/index.html#pydantic.types.StrictStr)\ntype as a convenience to [using the `Strict()` metadata class](../../concepts/strict_mode/index.html#using-the-strict-metadata-class).", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#strictness", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Example", "anchor": "example", "md_text": "```\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, StringConstraints\n\n\nclass StringModel(BaseModel):\n    str_value: str = \"\"\n    constrained_str_value: Annotated[str, StringConstraints(to_lower=True)] = \"\"\n\n\nprint(StringModel(str_value=\"test\").str_value)\n#> test\nprint(StringModel(constrained_str_value='TEST').constrained_str_value)\n#> test\n```", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#example", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Bytes[Â¶](index.html#bytes \"Permanent link\")", "anchor": "bytesindexhtmlbytes-permanent-link", "md_text": "Built-in type: [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes).\n\nSee also: [`ByteSize`](../types/index.html#pydantic.types.ByteSize).", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#bytesindexhtmlbytes-permanent-link", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Validation", "anchor": "validation", "md_text": "* [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes) instances are validated as is.\n* Strings and [`bytearray`](https://docs.python.org/3/library/stdtypes.html#bytearray) instances are converted as bytes, following the [`val_json_bytes`](../config/index.html#pydantic.config.ConfigDict.val_json_bytes) configuration value\n  (despite its name, it applies to both Python and JSON modes).", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#validation", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Constraints", "anchor": "constraints", "md_text": "Strings support the following constraints:\n\n| Constraint | Description | JSON Schema |\n| --- | --- | --- |\n| `min_length` | The minimum length of the bytes | [`minLength`](https://json-schema.org/understanding-json-schema/reference/string#length) keyword |\n| `max_length` | The maximum length of the bytes | [`maxLength`](https://json-schema.org/understanding-json-schema/reference/string#length) keyword |\n\nThe `MinLen` and `MaxLen` metadata types from the [`annotated-types`](https://github.com/annotated-types/annotated-types)\nlibrary can also be used.", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#constraints", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Strictness", "anchor": "strictness", "md_text": "In [strict mode](../../concepts/strict_mode/index.html), only [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes) instances are valid. Pydantic provides the [`StrictBytes`](../types/index.html#pydantic.types.StrictBytes)\ntype as a convenience to [using the `Strict()` metadata class](../../concepts/strict_mode/index.html#using-the-strict-metadata-class).\n\nIn JSON mode, strict mode has no effect.", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#strictness", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Numbers[Â¶](index.html#numbers \"Permanent link\")", "anchor": "numbersindexhtmlnumbers-permanent-link", "md_text": "Pydantic supports the following numeric types from the Python standard library:", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#numbersindexhtmlnumbers-permanent-link", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Integers[Â¶](index.html#integers \"Permanent link\")", "anchor": "integersindexhtmlintegers-permanent-link", "md_text": "Built-in type: [`int`](https://docs.python.org/3/library/functions.html#int).\n\n#### Validation\n\n* Integers are validated as-is.\n* Strings and bytes are attempted to be converted to integers and validated as-is\n  (see the [jiter implementation](https://docs.rs/jiter/latest/jiter/enum.NumberInt.html#impl-TryFrom%3C%26%5Bu8%5D%3E-for-NumberInt) for details).\n* Floats are validated as integers, provided the float input is not infinite or a NaN (not-a-number)\n  and the fractional part is 0.\n* [`Decimal`](https://docs.python.org/3/library/decimal.html#decimal.Decimal) instances, provided they are [finite](https://docs.python.org/3/library/decimal.html#decimal.Decimal.is_finite) and the\n  denominator is 1.\n* [`Fraction`](https://docs.python.org/3/library/fractions.html#fractions.Fraction) instances, provided they are [integers](https://docs.python.org/3/library/fractions.html#fractions.Fraction.is_integer).\n* [Enums](https://docs.python.org/3/library/enum.html#module-enum) are converted using the [`value`](https://docs.python.org/3/library/enum.html#enum.Enum.value) attribute.\n\n#### Constraints\n\nIntegers support the following constraints (numbers must be coercible to integers):\n\n| Constraint | Description | JSON Schema |\n| --- | --- | --- |\n| `le` | The value must be less than or equal to this number | [`maximum`](https://json-schema.org/understanding-json-schema/reference/numeric#range) keyword |\n| `ge` | The value must be greater than or equal to this number | [`minimum`](https://json-schema.org/understanding-json-schema/reference/numeric#range) keyword |\n| `lt` | The value must be strictly less than this number | [`exclusiveMaximum`](https://json-schema.org/understanding-json-schema/reference/numeric#range) keyword |\n| `gt` | The value must be strictly greater than this number | [`exclusiveMinimum`](https://json-schema.org/understanding-json-schema/reference/numeric#range) keyword |\n| `multiple_of` | The value must be a multiple of this number | [`multipleOf`](https://json-schema.org/understanding-json-schema/reference/numeric#multiples) keyword |\n\nThese constraints can be provided using the [`Field()`](../fields/index.html#pydantic.fields.Field) function.\nThe `Le`, `Ge`, `Lt`, `Gt` and `MultipleOf` metadata types from the [`annotated-types`](https://github.com/annotated-types/annotated-types)\nlibrary can also be used.\n\nPydantic also provides the following types to further constrain the allowed integer values:\n\n* [`PositiveInt`](../types/index.html#pydantic.types.PositiveInt): Requires the input to be greater than zero.\n* [`NegativeInt`](../types/index.html#pydantic.types.NegativeInt): Requires the input to be less than zero.\n* [`NonPositiveInt`](../types/index.html#pydantic.types.NonPositiveInt): Requires the input to be less than or equal to zero.\n* [`NonNegativeInt`](../types/index.html#pydantic.types.NonNegativeInt): Requires the input to be greater than or equal to zero.\n\n#### Strictness\n\nIn [strict mode](../../concepts/strict_mode/index.html), only integer values are valid. Pydantic provides the [`StrictInt`](../types/index.html#pydantic.types.StrictInt)\ntype as a convenience to [using the `Strict()` metadata class](../../concepts/strict_mode/index.html#using-the-strict-metadata-class).", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#integersindexhtmlintegers-permanent-link", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Floats[Â¶](index.html#floats \"Permanent link\")", "anchor": "floatsindexhtmlfloats-permanent-link", "md_text": "Built-in type: [`float`](https://docs.python.org/3/library/functions.html#float).\n\n#### Validation\n\n* Floats are validated as-is.\n* String and bytes are attempted to be converted to floats and validated as-is.\n  (see the [Rust implementation](https://doc.rust-lang.org/src/core/num/dec2flt/mod.rs.html) for details).\n* If the input has a [`__float__()`](https://docs.python.org/3/reference/datamodel.html#object.__float__) method, it will be called to convert the input into\n  a float. If `__float__()` is not defined, it falls back to [`__index__()`](https://docs.python.org/3/reference/datamodel.html#object.__index__). This includes\n  (but not limited to) the [`Decimal`](https://docs.python.org/3/library/decimal.html#decimal.Decimal) and [`Fraction`](https://docs.python.org/3/library/fractions.html#fractions.Fraction) types.\n\n#### Constraints\n\nFloats support the following constraints:\n\n| Constraint | Description | JSON Schema |\n| --- | --- | --- |\n| `le` | The value must be less than or equal to this number | [`maximum`](https://json-schema.org/understanding-json-schema/reference/numeric#range) keyword |\n| `ge` | The value must be greater than or equal to this number | [`minimum`](https://json-schema.org/understanding-json-schema/reference/numeric#range) keyword |\n| `lt` | The value must be strictly less than this number | [`exclusiveMaximum`](https://json-schema.org/understanding-json-schema/reference/numeric#range) keyword |\n| `gt` | The value must be strictly greater than this number | [`exclusiveMinimum`](https://json-schema.org/understanding-json-schema/reference/numeric#range) keyword |\n| `multiple_of` | The value must be a multiple of this number | [`multipleOf`](https://json-schema.org/understanding-json-schema/reference/numeric#multiples) keyword |\n| `allow_inf_nan` | Whether to allow NaN (not-a-number) and infinite values | N/A |\n\nThese constraints can be provided using the [`Field()`](../fields/index.html#pydantic.fields.Field) function.\nThe `Le`, `Ge`, `Lt`, `Gt` and `MultipleOf` metadata types from the [`annotated-types`](https://github.com/annotated-types/annotated-types)\nlibrary and the [`AllowInfNan`](../types/index.html#pydantic.types.AllowInfNan) type can also be used.\n\nPydantic also provides the following types as convenience aliases:\n\n* [`PositiveFloat`](../types/index.html#pydantic.types.PositiveFloat): Requires the input to be greater than zero.\n* [`NegativeFloat`](../types/index.html#pydantic.types.NegativeFloat): Requires the input to be less than zero.\n* [`NonPositiveFloat`](../types/index.html#pydantic.types.NonPositiveFloat): Requires the input to be less than or equal to zero.\n* [`NonNegativeFloat`](../types/index.html#pydantic.types.NonNegativeFloat): Requires the input to be greater than or equal to zero.\n* [`FiniteFloat`](../types/index.html#pydantic.types.FiniteFloat): Prevents NaN (not-a-number) and infinite values.\n\n#### Strictness\n\nIn [strict mode](../../concepts/strict_mode/index.html), only float values and inputs having a [`__float__()`](https://docs.python.org/3/reference/datamodel.html#object.__float__)\nor [`__index__()`](https://docs.python.org/3/reference/datamodel.html#object.__index__) method are valid.\nPydantic provides the [`StrictFloat`](../types/index.html#pydantic.types.StrictFloat) type as a convenience to\n[using the `Strict()` metadata class](../../concepts/strict_mode/index.html#using-the-strict-metadata-class).", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#floatsindexhtmlfloats-permanent-link", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Integer enums[Â¶](index.html#integer-enums \"Permanent link\")", "anchor": "integer-enumsindexhtmlinteger-enums-permanent-link", "md_text": "Standard library type: [`enum.IntEnum`](https://docs.python.org/3/library/enum.html#enum.IntEnum).\n\n#### Validation\n\n* If the [`enum.IntEnum`](https://docs.python.org/3/library/enum.html#enum.IntEnum) type is used directly, any [`enum.IntEnum`](https://docs.python.org/3/library/enum.html#enum.IntEnum) instance is validated as-is\n* Id an [`enum.IntEnum`](https://docs.python.org/3/library/enum.html#enum.IntEnum) subclass is used as a type, any enum member or value that correspond to the\n  enum members values is validated as-is.\n\nSee [Enums](index.html#enums) for more details.", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#integer-enumsindexhtmlinteger-enums-permanent-link", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Decimals[Â¶](index.html#decimals \"Permanent link\")", "anchor": "decimalsindexhtmldecimals-permanent-link", "md_text": "Standard library type: [`decimal.Decimal`](https://docs.python.org/3/library/decimal.html#decimal.Decimal).\n\n#### Validation\n\n* [`Decimal`](https://docs.python.org/3/library/decimal.html#decimal.Decimal) instances are validated as is.\n* Any value accepted by the [`Decimal`](https://docs.python.org/3/library/decimal.html#decimal.Decimal) constructor (apart from the\n  three-tuple input) will validate.\n\n#### Constraints\n\nDecimals support the following constraints (numbers must be coercible to decimals):\n\n| Constraint | Description | JSON Schema |\n| --- | --- | --- |\n| `le` | The value must be less than or equal to this number | [`maximum`](https://json-schema.org/understanding-json-schema/reference/numeric#range) keyword |\n| `ge` | The value must be greater than or equal to this number | [`minimum`](https://json-schema.org/understanding-json-schema/reference/numeric#range) keyword |\n| `lt` | The value must be strictly less than this number | [`exclusiveMaximum`](https://json-schema.org/understanding-json-schema/reference/numeric#range) keyword |\n| `gt` | The value must be strictly greater than this number | [`exclusiveMinimum`](https://json-schema.org/understanding-json-schema/reference/numeric#range) keyword |\n| `multiple_of` | The value must be a multiple of this number | [`multipleOf`](https://json-schema.org/understanding-json-schema/reference/numeric#multiples) keyword |\n| `allow_inf_nan` | Whether to allow NaN (not-a-number) and infinite values | N/A |\n| `max_digits` | The maximum number of decimal digits allowed. The zero before the decimal point and trailing zeros are not counted. | [`pattern`](https://json-schema.org/understanding-json-schema/reference/string#regexp) keyword, to describe the string pattern |\n| `decimal_places` | The maximum number of decimal places allowed. Trailing zeros are not counted. | [`pattern`](https://json-schema.org/understanding-json-schema/reference/string#regexp) keyword, to describe the string pattern |\n\nNote that the JSON Schema [`pattern`](https://json-schema.org/understanding-json-schema/reference/string#regexp) keyword will be specified\nin the JSON Schema to describe the string pattern in all cases (and can vary if `max_digits` and/or `decimal_places` is specified).\n\nThese constraints can be provided using the [`Field()`](../fields/index.html#pydantic.fields.Field) function.\nThe `Le`, `Ge`, `Lt`, `Gt` and `MultipleOf` metadata types from the [`annotated-types`](https://github.com/annotated-types/annotated-types)\nlibrary and the [`AllowInfNan`](../types/index.html#pydantic.types.AllowInfNan) type can also be used.\n\n#### Strictness\n\nIn [strict mode](../../concepts/strict_mode/index.html), only [`decimal.Decimal`](https://docs.python.org/3/library/decimal.html#decimal.Decimal) instances are accepted. In JSON mode, strict mode has no effect.\n\n#### Serialization\n\nIn [Python mode](../../concepts/serialization/index.html#python-mode), [`Decimal`](https://docs.python.org/3/library/decimal.html#decimal.Decimal) instances are\nserialized as is.\n\nIn [JSON mode](../../concepts/serialization/index.html#json-mode), they are serialized as strings.\nA [serializer](../../concepts/serialization/index.html#field-plain-serializer) can be used to override this behavior:\n\n```\nfrom decimal import Decimal\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, PlainSerializer\n\n\nclass Model(BaseModel):\n    f: Annotated[Decimal, PlainSerializer(float, when_used='json')]\n\n\nmy_model = Model(f=Decimal('2.1'))\n\nprint(my_model.model_dump())  # (1)!\n#> {'f': Decimal('2.1')}\nprint(my_model.model_dump_json())  # (2)!\n#> {\"f\":2.1}\n```\n\n1. In Python mode, `f`remains a [`Decimal`](https://docs.python.org/3/library/decimal.html#decimal.Decimal) instance.\n2. In JSON mode, `f` is serialized as a float.", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#decimalsindexhtmldecimals-permanent-link", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Complex numbers[Â¶](index.html#complex-numbers \"Permanent link\")", "anchor": "complex-numbersindexhtmlcomplex-numbers-permanent-link", "md_text": "Built-in type: [`complex`](https://docs.python.org/3/library/functions.html#complex).\n\n#### Validation\n\n* [`complex`](https://docs.python.org/3/library/functions.html#complex) instances are validated as-is.\n* Strings are validated using the [`complex()`](https://docs.python.org/3/library/functions.html#complex) constructor.\n* Numbers (integers and floats) are used as the real part.\n* Objects defining [`__complex__()`](https://docs.python.org/3/reference/datamodel.html#object.__complex__), [`__float__()`](https://docs.python.org/3/reference/datamodel.html#object.__float__).\n  or [`__index__()`](https://docs.python.org/3/reference/datamodel.html#object.__index__) are currently *not* accepted.\n\n#### Strictness\n\nIn [strict mode](../../concepts/strict_mode/index.html), only [`complex`](https://docs.python.org/3/library/functions.html#complex) instances are accepted. In JSON mode, only strings that are\naccepted by the [`complex()`](https://docs.python.org/3/library/functions.html#complex) constructor are allowed.\n\n#### Serialization\n\nIn [Python mode](../../concepts/serialization/index.html#python-mode), [`complex`](https://docs.python.org/3/library/functions.html#complex) instances are\nserialized as is.\n\nIn [JSON mode](../../concepts/serialization/index.html#json-mode), they are serialized as strings.", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#complex-numbersindexhtmlcomplex-numbers-permanent-link", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Fractions[Â¶](index.html#fractions \"Permanent link\")", "anchor": "fractionsindexhtmlfractions-permanent-link", "md_text": "Standard library type: [`fractions.Fraction`](https://docs.python.org/3/library/fractions.html#fractions.Fraction).\n\n#### Validation\n\n* [`Fraction`](https://docs.python.org/3/library/fractions.html#fractions.Fraction) instances are validated as is.\n* Floats, strings and [`decimal.Decimal`](https://docs.python.org/3/library/decimal.html#decimal.Decimal) instances are validated using the [`Fraction()`](https://docs.python.org/3/library/fractions.html#fractions.Fraction)\n  constructor.\n\n#### Strictness\n\nIn [strict mode](../../concepts/strict_mode/index.html), only [`Fraction`](https://docs.python.org/3/library/fractions.html#fractions.Fraction) instances are accepted. In JSON mode, strict mode has no effect.\n\n#### Serialization\n\nFractions are serialized as strings, both in [Python](../../concepts/serialization/index.html#python-mode)\nand [JSON](../../concepts/serialization/index.html#json-mode) modes.", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#fractionsindexhtmlfractions-permanent-link", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Date and time types[Â¶](index.html#date-and-time-types \"Permanent link\")", "anchor": "date-and-time-typesindexhtmldate-and-time-types-permanent-link", "md_text": "Pydantic supports the following [date and time](https://docs.python.org/library/datetime.html#available-types)\ntypes from the [`datetime`](https://docs.python.org/3/library/datetime.html#module-datetime) standard library:", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#date-and-time-typesindexhtmldate-and-time-types-permanent-link", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Datetimes[Â¶](index.html#datetimes \"Permanent link\")", "anchor": "datetimesindexhtmldatetimes-permanent-link", "md_text": "Standard library type: [`datetime.datetime`](https://docs.python.org/3/library/datetime.html#datetime.datetime).\n\n#### Validation\n\n* [`datetime`](https://docs.python.org/3/library/datetime.html#datetime.datetime) instances are validated as is.\n* Strings and bytes are validated in two ways:\n  + Strings complying to the [RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339) format (both datetime and date).\n    See the [speedate](https://docs.rs/speedate/) documentation for more details.\n  + Unix timestamps, both as seconds or milliseconds sinch the [epoch](https://en.wikipedia.org/wiki/Unix_time).\n    See the [`val_temporal_unit`](../config/index.html#pydantic.config.ConfigDict.val_temporal_unit) configuration value for more details.\n* Integers and floats (or types that can be coerced as integers or floats) are validated as unix timestamps, following the\n  same semantics as strings.\n* [`datetime.date`](https://docs.python.org/3/library/datetime.html#datetime.date) instances are accepted, and converted to a [`datetime`](https://docs.python.org/3/library/datetime.html#datetime.datetime) instance\n  by setting the [`hour`](https://docs.python.org/3/library/datetime.html#datetime.datetime.hour), [`minute`](https://docs.python.org/3/library/datetime.html#datetime.datetime.minute), [`second`](https://docs.python.org/3/library/datetime.html#datetime.datetime.second) and\n  [`microsecond`](https://docs.python.org/3/library/datetime.html#datetime.datetime.microsecond) attributes to `0`, and the [`tzinfo`](https://docs.python.org/3/library/datetime.html#datetime.datetime.tzinfo) attribute to `None`.\n\nNamed timezone support (as specified in [RFC 9557](https://datatracker.ietf.org/doc/html/rfc9557.html))\ncan be tracked in [this issue](https://github.com/pydantic/pydantic/issues/12252).\n\n#### Serialization\n\nIn [Python mode](../../concepts/serialization/index.html#python-mode), [`datetime`](https://docs.python.org/3/library/datetime.html#datetime.datetime) instances are\nserialized as is.\n\nIn [JSON mode](../../concepts/serialization/index.html#json-mode), they are serialized as strings.\n\n#### Constraints\n\nDatetimes support the following constraints (constraint values must be coercible to a [`datetime`](https://docs.python.org/3/library/datetime.html#datetime.datetime) instance):\n\n| Constraint | Description | JSON Schema |\n| --- | --- | --- |\n| `le` | The value must be less than or equal to this datetime | N/A |\n| `ge` | The value must be greater than or equal to this datetime | N/A |\n| `lt` | The value must be strictly less than this datetime | N/A |\n| `gt` | The value must be strictly greater than this datetime | N/A |\n\nThese constraints can be provided using the [`Field()`](../fields/index.html#pydantic.fields.Field) function.\nThe `Le`, `Ge`, `Lt` and `Gt` metadata types from the [`annotated-types`](https://github.com/annotated-types/annotated-types)\nlibrary can also be used.\n\nPydantic also provides the following types to further constrain the allowed datetime values:\n\n* [`AwareDatetime`](../types/index.html#pydantic.types.AwareDatetime): Requires the input to have a timezone.\n* [`NaiveDatetime`](../types/index.html#pydantic.types.NaiveDatetime): Requires the input to *not* have a timezone.\n* [`PastDatetime`](../types/index.html#pydantic.types.PastDatetime): Requires the input to be in the past when validated.\n* [`FutureDatetime`](../types/index.html#pydantic.types.FutureDatetime): Requires the input to be in the future when validated.\n\n#### Strictness\n\nIn [strict mode](../../concepts/strict_mode/index.html), only [`datetime`](https://docs.python.org/3/library/datetime.html#datetime.datetime) instances are accepted. In JSON mode, only strings complying to the\n[RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339) format (*only* datetime) or as unix timestamps are accepted.\n\n#### Example\n\n```\nfrom datetime import datetime\nfrom typing import Annotated\n\nfrom pydantic import AwareDatetime, BaseModel, Field\n\n\nclass Event(BaseModel):\n    dt: Annotated[AwareDatetime, Field(gt=datetime(2000, 1, 1))]\n\n\nevent = Event(dt='2032-04-23T10:20:30.400+02:30')\n\nprint(event.model_dump())\n\"\"\"\n{'dt': datetime.datetime(2032, 4, 23, 10, 20, 30, 400000, tzinfo=TzInfo(9000))}\n\"\"\"\nprint(event.model_dump_json())\n#> {\"dt\":\"2032-04-23T10:20:30.400000+02:30\"}\n```", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#datetimesindexhtmldatetimes-permanent-link", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Dates[Â¶](index.html#dates \"Permanent link\")", "anchor": "datesindexhtmldates-permanent-link", "md_text": "Standard library type: [`datetime.date`](https://docs.python.org/3/library/datetime.html#datetime.date).\n\n#### Validation\n\n* [`date`](https://docs.python.org/3/library/datetime.html#datetime.date) instances are validated as is.\n* Strings and bytes are validated in two ways:\n  + Strings complying to the [RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339) date format.\n    See the [speedate](https://docs.rs/speedate/) documentation for more details.\n  + Unix timestamps, both as seconds or milliseconds sinch the [epoch](https://en.wikipedia.org/wiki/Unix_time).\n    See the [`val_temporal_unit`](../config/index.html#pydantic.config.ConfigDict.val_temporal_unit) configuration value for more details.\n* If the validation fails, the input can be [validated as a datetime](index.html#datetimes) (including as numbers),\n  provided that the time component is 0 and that it is naive.\n\n#### Serialization\n\nIn [Python mode](../../concepts/serialization/index.html#python-mode), [`date`](https://docs.python.org/3/library/datetime.html#datetime.date) instances are\nserialized as is.\n\nIn [JSON mode](../../concepts/serialization/index.html#json-mode), they are serialized as strings.\n\n#### Constraints\n\nDates support the following constraints (constraint values must be coercible to a [`date`](https://docs.python.org/3/library/datetime.html#datetime.date) instance):\n\n| Constraint | Description | JSON Schema |\n| --- | --- | --- |\n| `le` | The value must be less than or equal to this date | N/A |\n| `ge` | The value must be greater than or equal to this date | N/A |\n| `lt` | The value must be strictly less than this date | N/A |\n| `gt` | The value must be strictly greater than this date | N/A |\n\nThese constraints can be provided using the [`Field()`](../fields/index.html#pydantic.fields.Field) function.\nThe `Le`, `Ge`, `Lt` and `Gt` metadata types from the [`annotated-types`](https://github.com/annotated-types/annotated-types)\nlibrary can also be used.\n\nPydantic also provides the following types to further constrain the allowed date values:\n\n* [`PastDate`](../types/index.html#pydantic.types.PastDate): Requires the input to be in the past when validated.\n* [`FutureDate`](../types/index.html#pydantic.types.FutureDate): Requires the input to be in the future when validated.\n\n#### Strictness\n\nIn [strict mode](../../concepts/strict_mode/index.html), only [`date`](https://docs.python.org/3/library/datetime.html#datetime.date) instances are accepted. In JSON mode, only strings complying to the\n[RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339) format (*only* date) or as unix timestamps are accepted.\n\n#### Example\n\n```\nfrom datetime import date\n\nfrom pydantic import BaseModel\n\n\nclass Birthday(BaseModel):\n    d: date\n\n\nmy_birthday = Birthday(d=1679616000.0)\n\nprint(my_birthday.model_dump())\n#> {'d': datetime.date(2023, 3, 24)}\nprint(my_birthday.model_dump_json())\n#> {\"d\":\"2023-03-24\"}\n```", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#datesindexhtmldates-permanent-link", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Time[Â¶](index.html#time \"Permanent link\")", "anchor": "timeindexhtmltime-permanent-link", "md_text": "Standard library type: [`datetime.time`](https://docs.python.org/3/library/datetime.html#datetime.time).\n\n#### Validation\n\n* [`time`](https://docs.python.org/3/library/datetime.html#datetime.time) instances are validated as is.\n* Strings and bytes are validated according to the [RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339) time format.\n* Integers and floats (or values that can be coerced to such numbers) are validated as seconds. The value should not exceed 86 399.\n\n#### Serialization\n\nIn [Python mode](../../concepts/serialization/index.html#python-mode), [`time`](https://docs.python.org/3/library/datetime.html#datetime.time) instances are\nserialized as is.\n\nIn [JSON mode](../../concepts/serialization/index.html#json-mode), they are serialized as strings.\n\nNamed timezones from the [IANA time zone database](https://www.iana.org/time-zones) (see the [`zoneinfo`](https://docs.python.org/3/library/zoneinfo.html#module-zoneinfo) module) are *not* serialized\nwith time objects. This is consistent with the [`time.isoformat()`](https://docs.python.org/3/library/datetime.html#datetime.time.isoformat) method.\n\n#### Constraints\n\nTime support the following constraints (constraint values must be coercible to a [`time`](https://docs.python.org/3/library/datetime.html#datetime.time) instance):\n\n| Constraint | Description | JSON Schema |\n| --- | --- | --- |\n| `le` | The value must be less than or equal to this time | N/A |\n| `ge` | The value must be greater than or equal to this time | N/A |\n| `lt` | The value must be strictly less than this time | N/A |\n| `gt` | The value must be strictly greater than this time | N/A |\n\nThese constraints can be provided using the [`Field()`](../fields/index.html#pydantic.fields.Field) function.\nThe `Le`, `Ge`, `Lt` and `Gt` metadata types from the [`annotated-types`](https://github.com/annotated-types/annotated-types)\nlibrary can also be used.\n\n#### Strictness\n\nIn [strict mode](../../concepts/strict_mode/index.html), only [`time`](https://docs.python.org/3/library/datetime.html#datetime.time) instances are accepted. In JSON mode, only strings complying to the\n[RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339) format are accepted.\n\n#### Example\n\n```\nfrom datetime import time\n\nfrom pydantic import BaseModel\n\n\nclass Meeting(BaseModel):\n    t: time\n\n\nm = Meeting(t=time(4, 8, 16))\n\nprint(m.model_dump())\n#> {'t': datetime.time(4, 8, 16)}\nprint(m.model_dump_json())\n#> {\"t\":\"04:08:16\"}\n```", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#timeindexhtmltime-permanent-link", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Timedeltas[Â¶](index.html#timedeltas \"Permanent link\")", "anchor": "timedeltasindexhtmltimedeltas-permanent-link", "md_text": "Standard library type: [`datetime.timedelta`](https://docs.python.org/3/library/datetime.html#datetime.timedelta).\n\n#### Validation\n\n* [`timedelta`](https://docs.python.org/3/library/datetime.html#datetime.timedelta) instances are validated as is.\n* Strings and bytes are validated according to the [RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339) time format.\n* Integers and floats (or values that can be coerced to such numbers) are validated as seconds.\n\n#### Constraints\n\nTimedeltas support the following constraints (constraint values must be coercible to a [`timedata`](https://docs.python.org/3/library/datetime.html#datetime.timedelta) instance):\n\n| Constraint | Description | JSON Schema |\n| --- | --- | --- |\n| `le` | The value must be less than or equal to this timedelta | N/A |\n| `ge` | The value must be greater than or equal to this timedelta | N/A |\n| `lt` | The value must be strictly less than this timedelta | N/A |\n| `gt` | The value must be strictly greater than this timedelta | N/A |\n\nThese constraints can be provided using the [`Field()`](../fields/index.html#pydantic.fields.Field) function.\nThe `Le`, `Ge`, `Lt` and `Gt` metadata types from the [`annotated-types`](https://github.com/annotated-types/annotated-types)\nlibrary can also be used.\n\n#### Serialization\n\nIn [Python mode](../../concepts/serialization/index.html#python-mode), [`timedelta`](https://docs.python.org/3/library/datetime.html#datetime.timedelta) instances are\nserialized as is.\n\nIn [JSON mode](../../concepts/serialization/index.html#json-mode), they are serialized as strings.\n\n#### Strictness\n\nIn [strict mode](../../concepts/strict_mode/index.html), only [`timedelta`](https://docs.python.org/3/library/datetime.html#datetime.timedelta) instances are accepted. In JSON mode, only strings complying to the\n[RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339) format are accepted.\n\n#### Example\n\n```\nfrom datetime import timedelta\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    td: timedelta\n\n\nm = Model(td='P3DT12H30M5S')\n\nprint(m.model_dump())\n#> {'td': datetime.timedelta(days=3, seconds=45005)}\nprint(m.model_dump_json())\n#> {\"td\":\"P3DT12H30M5S\"}\n```", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#timedeltasindexhtmltimedeltas-permanent-link", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Enums[Â¶](index.html#enums \"Permanent link\")", "anchor": "enumsindexhtmlenums-permanent-link", "md_text": "Standard library type: [`enum.Enum`](https://docs.python.org/3/library/enum.html#enum.Enum).", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#enumsindexhtmlenums-permanent-link", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Validation", "anchor": "validation", "md_text": "* If the [`enum.Enum`](https://docs.python.org/3/library/enum.html#enum.Enum) type is used directly, any [`enum.Enum`](https://docs.python.org/3/library/enum.html#enum.Enum) instance is validated as-is.\n* Id an [`enum.Enum`](https://docs.python.org/3/library/enum.html#enum.Enum) subclass is used as a type, any enum member or value that correspond to the\n  enum members [values](https://docs.python.org/3/library/enum.html#enum.Enum.value) is validated as-is.", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#validation", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Serialization", "anchor": "serialization", "md_text": "In [Python mode](../../concepts/serialization/index.html#python-mode), enum instances are serialized as is.\nThe [`use_enum_values`](../config/index.html#pydantic.config.ConfigDict.use_enum_values) configuration value can be set to\nuse the enum [value](https://docs.python.org/3/library/enum.html#enum.Enum.value) during validation (so that it is also used during serialization).\n\nIn [JSON mode](../../concepts/serialization/index.html#json-mode), enum instances are serialized using\ntheir [value](https://docs.python.org/3/library/enum.html#enum.Enum.value).", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#serialization", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Example", "anchor": "example", "md_text": "```\nfrom enum import Enum, IntEnum\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass FruitEnum(str, Enum):\n    PEAR = 'pear'\n    BANANA = 'banana'\n\n\nclass ToolEnum(IntEnum):\n    SPANNER = 1\n    WRENCH = 2\n\n\nclass CookingModel(BaseModel):\n    fruit: FruitEnum = FruitEnum.PEAR\n    tool: ToolEnum = ToolEnum.SPANNER\n\n\nprint(CookingModel())\n#> fruit=<FruitEnum.PEAR: 'pear'> tool=<ToolEnum.SPANNER: 1>\nprint(CookingModel(tool=2, fruit='banana'))\n#> fruit=<FruitEnum.BANANA: 'banana'> tool=<ToolEnum.WRENCH: 2>\ntry:\n    CookingModel(fruit='other')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for CookingModel\n    fruit\n      Input should be 'pear' or 'banana' [type=enum, input_value='other', input_type=str]\n    \"\"\"\n```", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#example", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "None types[Â¶](index.html#none-types \"Permanent link\")", "anchor": "none-typesindexhtmlnone-types-permanent-link", "md_text": "Supported types: [`None`](https://docs.python.org/3/library/constants.html#None), [`NoneType`](https://docs.python.org/3/library/types.html#types.NoneType) or `Literal[None]` (they are [equivalent](https://typing.readthedocs.io/en/latest/spec/special-types.html#none)).\n\nAllows only `None` as a value.", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#none-typesindexhtmlnone-types-permanent-link", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Generic collection types[Â¶](index.html#generic-collection-types \"Permanent link\")", "anchor": "generic-collection-typesindexhtmlgeneric-collection-types-permanent-link", "md_text": "Pydantic supports a wide variety of generic collection types, both built-ins (such as [`list`](https://docs.python.org/3/glossary.html#term-list)) and abstract base classes\nfrom the [`collections.abc`](https://docs.python.org/3/library/collections.abc.html#module-collections.abc) module (such as [`Sequence`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence)).\n\nIn most cases, it is recommended to make use of the built-in types over the abstract ones. Due to [data coercion](../../concepts/models/index.html#data-conversion),\nusing [`list`](https://docs.python.org/3/glossary.html#term-list) or [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple) will allow most other iterables as input, with better performance.\n\nWhen applying [strict mode](../../concepts/strict_mode/index.html) on collection types, strictness will *not* apply\nto the inner types. This may change in the future, see [this issue](https://github.com/pydantic/pydantic/issues/12319).", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#generic-collection-typesindexhtmlgeneric-collection-types-permanent-link", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Lists[Â¶](index.html#lists \"Permanent link\")", "anchor": "listsindexhtmllists-permanent-link", "md_text": "Built-in type: [`list`](https://docs.python.org/3/glossary.html#term-list) (deprecated alias: [`typing.List`](https://docs.python.org/3/library/typing.html#typing.List)).\n\n#### Validation\n\n* Allows [`list`](https://docs.python.org/3/glossary.html#term-list), [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple), [`set`](https://docs.python.org/3/reference/expressions.html#set) and [`frozenset`](https://docs.python.org/3/library/stdtypes.html#frozenset) instances, or any iterable that is *not* a\n  [string](https://docs.python.org/3/library/stdtypes.html#str), [bytes](https://docs.python.org/3/library/stdtypes.html#bytes), [bytearray](https://docs.python.org/3/library/stdtypes.html#bytearray), [dict](https://docs.python.org/3/reference/expressions.html#dict) or [mapping](https://docs.python.org/3/glossary.html#term-mapping). Produces a [`list`](https://docs.python.org/3/glossary.html#term-list) instance.\n* If a generic parameter is provided, the appropriate validation is applied to all items of the list.\n\n#### Constraints\n\nLists support the following constraints:\n\n| Constraint | Description | JSON Schema |\n| --- | --- | --- |\n| `min_length` | The list must have at least this many items | [`minItems`](https://json-schema.org/understanding-json-schema/reference/array#length) keyword |\n| `max_length` | The list must have at most this many items | [`maxItems`](https://json-schema.org/understanding-json-schema/reference/array#length) keyword |\n\nThese constraints can be provided using the [`Field()`](../fields/index.html#pydantic.fields.Field) function.\nThe `MinLen` and `MaxLen` metadata types from the [`annotated-types`](https://github.com/annotated-types/annotated-types)\nlibrary can also be used.\n\n#### Strictness\n\nIn [strict mode](../../concepts/strict_mode/index.html), only [`list`](https://docs.python.org/3/glossary.html#term-list) instances are valid. Strict mode does *not* apply to the items of the list.\nThe strict constraint must be applied to the parameter type for this to work.\n\n#### Example\n\nPython 3.9 and abovePython 3.10 and above\n\n```\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    simple_list: Optional[list[object]] = None\n    list_of_ints: Optional[list[int]] = Field(default=None, strict=True)\n\n\nprint(Model(simple_list=('1', '2', '3')).simple_list)\n#> ['1', '2', '3']\nprint(Model(list_of_ints=['1', 2, 3]).list_of_ints)\n#> [1, 2, 3]\n\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    simple_list: list[object] | None = None\n    list_of_ints: list[int] | None = Field(default=None, strict=True)\n\n\nprint(Model(simple_list=('1', '2', '3')).simple_list)\n#> ['1', '2', '3']\nprint(Model(list_of_ints=['1', 2, 3]).list_of_ints)\n#> [1, 2, 3]\n```", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#listsindexhtmllists-permanent-link", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Tuples[Â¶](index.html#tuples \"Permanent link\")", "anchor": "tuplesindexhtmltuples-permanent-link", "md_text": "Built-in type: [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple) (deprecated alias: [`typing.Tuple`](https://docs.python.org/3/library/typing.html#typing.Tuple)).\n\n[Unpacked tuple types](https://typing.python.org/en/latest/spec/generics.html#unpacking-tuple-types)\n(as specified by [PEP 646](https://peps.python.org/pep-0646/)) are *not* yet supported, and can be\ntracked in [this issue](https://github.com/pydantic/pydantic/issues/5952).\n\n#### Validation\n\n* Allows [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple), [`list`](https://docs.python.org/3/glossary.html#term-list), [`set`](https://docs.python.org/3/reference/expressions.html#set) and [`frozenset`](https://docs.python.org/3/library/stdtypes.html#frozenset) instances, or any iterable that is *not* a\n  [string](https://docs.python.org/3/library/stdtypes.html#str), [bytes](https://docs.python.org/3/library/stdtypes.html#bytes), [bytearray](https://docs.python.org/3/library/stdtypes.html#bytearray), [dict](https://docs.python.org/3/reference/expressions.html#dict) or [mapping](https://docs.python.org/3/glossary.html#term-mapping). Produces a [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple) instance.\n* Appropriate validation is applied to items of the tuple, if [element types](https://typing.python.org/en/latest/spec/tuples.html#tuple-type-form)\n  are specified.\n\n#### Constraints\n\nLists support the following constraints:\n\n| Constraint | Description | JSON Schema |\n| --- | --- | --- |\n| `min_length` | The tuple must have at least this many items | [`minItems`](https://json-schema.org/understanding-json-schema/reference/array#length) keyword |\n| `max_length` | The tuple must have at most this many items | [`maxItems`](https://json-schema.org/understanding-json-schema/reference/array#length) keyword |\n\nThese constraints can be provided using the [`Field()`](../fields/index.html#pydantic.fields.Field) function.\nThe `MinLen` and `MaxLen` metadata types from the [`annotated-types`](https://github.com/annotated-types/annotated-types)\nlibrary can also be used.\n\nAdditionally, the [`prefixItems`](https://json-schema.org/understanding-json-schema/reference/array#tupleValidation) JSON Schema keyword may be used\ndepending on the tuple shape.\n\n#### Strictness\n\nIn [strict mode](../../concepts/strict_mode/index.html), only [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple) instances are valid. Strict mode does *not* apply to the items of the tuple.\nThe strict constraint must be applied to the parameter types for this to work.\n\n#### Example\n\nPython 3.9 and abovePython 3.10 and above\n\n```\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    simple_tuple: Optional[tuple] = None\n    tuple_of_different_types: Optional[tuple[int, float, bool]] = None\n\n\nprint(Model(simple_tuple=[1, 2, 3, 4]).simple_tuple)\n#> (1, 2, 3, 4)\nprint(Model(tuple_of_different_types=[3, 2, 1]).tuple_of_different_types)\n#> (3, 2.0, True)\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    simple_tuple: tuple | None = None\n    tuple_of_different_types: tuple[int, float, bool] | None = None\n\n\nprint(Model(simple_tuple=[1, 2, 3, 4]).simple_tuple)\n#> (1, 2, 3, 4)\nprint(Model(tuple_of_different_types=[3, 2, 1]).tuple_of_different_types)\n#> (3, 2.0, True)\n```", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#tuplesindexhtmltuples-permanent-link", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Named tuples[Â¶](index.html#named-tuples \"Permanent link\")", "anchor": "named-tuplesindexhtmlnamed-tuples-permanent-link", "md_text": "Standard library type: [`typing.NamedTuple`](https://docs.python.org/3/library/typing.html#typing.NamedTuple) (and types created by the [`collections.namedtuple()`](https://docs.python.org/3/library/collections.html#collections.namedtuple) factory function\nâ€“ each field will implicitly have the type [`Any`](https://docs.python.org/3/library/typing.html#typing.Any)).\n\n#### Validation\n\n* Allows [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple) and [`list`](https://docs.python.org/3/glossary.html#term-list) instances. Validate each item according to the field definition.\n* Allows [`dict`](https://docs.python.org/3/reference/expressions.html#dict) instances. Keys must match the named tuple field names, and values are validated according to the field definition.\n\n#### Serialization\n\nIn [Python mode](../../concepts/serialization/index.html#python-mode), named tuples are serialized as tuples. In [JSON mode](../../concepts/serialization/index.html#json-mode),\nthey are serialized as arrays.\n\n#### Example\n\n```\nfrom typing import NamedTuple\n\nfrom pydantic import BaseModel\n\n\nclass Point(NamedTuple):\n    x: int\n    y: int\n\n\nclass Model(BaseModel):\n    p: Point\n\n\nmodel = Model(p=('1', 2))\n\nprint(model.model_dump())\n#> {'p': (1, 2)}\n```", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#named-tuplesindexhtmlnamed-tuples-permanent-link", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Sets[Â¶](index.html#sets \"Permanent link\")", "anchor": "setsindexhtmlsets-permanent-link", "md_text": "Types: [`set`](https://docs.python.org/3/reference/expressions.html#set) (or [`collections.abc.MutableSet`](https://docs.python.org/3/library/collections.abc.html#collections.abc.MutableSet)) and [`frozenset`](https://docs.python.org/3/library/stdtypes.html#frozenset) (or [`collections.abc.Set`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Set))\n(deprecated aliases: [`typing.Set`](https://docs.python.org/3/library/typing.html#typing.Set) and [`typing.FrozenSet`](https://docs.python.org/3/library/typing.html#typing.FrozenSet)).\n\n#### Validation\n\n* Allows [`set`](https://docs.python.org/3/reference/expressions.html#set), [`frozenset`](https://docs.python.org/3/library/stdtypes.html#frozenset), [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple) and [`list`](https://docs.python.org/3/glossary.html#term-list) instances, or any iterable that is *not* a\n  [string](https://docs.python.org/3/library/stdtypes.html#str), [bytes](https://docs.python.org/3/library/stdtypes.html#bytes), [bytearray](https://docs.python.org/3/library/stdtypes.html#bytearray), [dict](https://docs.python.org/3/reference/expressions.html#dict) or [mapping](https://docs.python.org/3/glossary.html#term-mapping). Produces a [`set`](https://docs.python.org/3/reference/expressions.html#set) or [`frozenset`](https://docs.python.org/3/library/stdtypes.html#frozenset) instance.\n* If a generic parameter is provided, the appropriate validation is applied to all items of the set/frozenset.\n\n#### Constraints\n\nSets support the following constraints:\n\n| Constraint | Description | JSON Schema |\n| --- | --- | --- |\n| `min_length` | The set must have at least this many items | [`minItems`](https://json-schema.org/understanding-json-schema/reference/array#length) keyword |\n| `max_length` | The set must have at most this many items | [`maxItems`](https://json-schema.org/understanding-json-schema/reference/array#length) keyword |\n\nThese constraints can be provided using the [`Field()`](../fields/index.html#pydantic.fields.Field) function.\nThe `MinLen` and `MaxLen` metadata types from the [`annotated-types`](https://github.com/annotated-types/annotated-types)\nlibrary can also be used.\n\n#### Strictness\n\nIn [strict mode](../../concepts/strict_mode/index.html), only [`set`](https://docs.python.org/3/reference/expressions.html#set)/[`frozenset`](https://docs.python.org/3/library/stdtypes.html#frozenset) instances are valid. Strict mode does *not* apply to the items of the set.\nThe strict constraint must be applied to the parameter type for this to work.\n\n#### Serialization\n\nIn [Python mode](../../concepts/serialization/index.html#python-mode), sets are serialized as is. In [JSON mode](../../concepts/serialization/index.html#json-mode),\nthey are serialized as arrays.\n\n#### Example\n\nPython 3.9 and abovePython 3.10 and above\n\n```\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    simple_set: Optional[set] = None\n    set_of_ints: Optional[frozenset[int]] = None\n\n\nprint(Model(simple_set=['1', '2', '3']).simple_set)\n#> {'1', '2', '3'}\nprint(Model(set_of_ints=['1', '2', '3']).set_of_ints)\n#> frozenset({1, 2, 3})\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    simple_set: set | None = None\n    set_of_ints: frozenset[int] | None = None\n\n\nprint(Model(simple_set=['1', '2', '3']).simple_set)\n#> {'1', '2', '3'}\nprint(Model(set_of_ints=['1', '2', '3']).set_of_ints)\n#> frozenset({1, 2, 3})\n```", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#setsindexhtmlsets-permanent-link", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Deque[Â¶](index.html#deque \"Permanent link\")", "anchor": "dequeindexhtmldeque-permanent-link", "md_text": "Standard library type: [`collections.deque`](https://docs.python.org/3/library/collections.html#collections.deque) (deprecated alias: [`typing.Deque`](https://docs.python.org/3/library/typing.html#typing.Deque)).\n\n#### Validation\n\nValues are first validated as a [list](index.html#lists), and then passed to the [`deque`](https://docs.python.org/3/library/collections.html#collections.deque) constructor.\n\n#### Constraints\n\nDeques support the following constraints:\n\n| Constraint | Description | JSON Schema |\n| --- | --- | --- |\n| `min_length` | The deque must have at least this many items | [`minItems`](https://json-schema.org/understanding-json-schema/reference/array#length) keyword |\n| `max_length` | The deque must have at most this many items | [`maxItems`](https://json-schema.org/understanding-json-schema/reference/array#length) keyword |\n\nThese constraints can be provided using the [`Field()`](../fields/index.html#pydantic.fields.Field) function.\nThe `MinLen` and `MaxLen` metadata types from the [`annotated-types`](https://github.com/annotated-types/annotated-types)\nlibrary can also be used.\n\n#### Strictness\n\nIn [strict mode](../../concepts/strict_mode/index.html), only [`deque`](https://docs.python.org/3/library/collections.html#collections.deque) instances are valid. Strict mode does *not* apply to the items of the deque.\nThe strict constraint must be applied to the parameter type for this to work.\n\n#### Serialization\n\nIn [Python mode](../../concepts/serialization/index.html#python-mode), deques are serialized as is. In [JSON mode](../../concepts/serialization/index.html#json-mode),\nthey are serialized as arrays.\n\n#### Example\n\n```\nfrom collections import deque\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    deque: deque[int]\n\n\nprint(Model(deque=[1, 2, 3]).deque)\n#> deque([1, 2, 3])\n```", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#dequeindexhtmldeque-permanent-link", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Sequences[Â¶](index.html#sequences \"Permanent link\")", "anchor": "sequencesindexhtmlsequences-permanent-link", "md_text": "Standard library type: [`collections.abc.Sequence`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence) (deprecated alias: [`typing.Sequence`](https://docs.python.org/3/library/typing.html#typing.Sequence)).\n\nIn most cases, you will want to use the built-in types (such as [list](index.html#lists) or [tuple](index.html#tuples)) as [type coercion](../../concepts/models/index.html#data-conversion)\nwill apply. The [`Sequence`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence) type can be used when you want to preserve the input type during serialization.\n\n#### Validation\n\nAny [`collections.abc.Sequence`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence) instance (expect strings and bytes) is accepted. It is converted to a list using the [`list()`](https://docs.python.org/3/glossary.html#term-list)\nconstructor, and then converted back to the original input type.\n\nWhile strings are technically valid sequence instances, this is frequently not intended as is a common source of bugs.\n\nAs a result, Pydantic will *not* accept strings and bytes for the [`Sequence`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence) type (see example below).\n\n#### Constraints\n\nSequences support the following constraints:\n\n| Constraint | Description | JSON Schema |\n| --- | --- | --- |\n| `min_length` | The sequence must have at least this many items | [`minItems`](https://json-schema.org/understanding-json-schema/reference/array#length) keyword |\n| `max_length` | The sequence must have at most this many items | [`maxItems`](https://json-schema.org/understanding-json-schema/reference/array#length) keyword |\n\nThese constraints can be provided using the [`Field()`](../fields/index.html#pydantic.fields.Field) function.\nThe `MinLen` and `MaxLen` metadata types from the [`annotated-types`](https://github.com/annotated-types/annotated-types)\nlibrary can also be used.\n\n#### Serialization\n\nIn [Python mode](../../concepts/serialization/index.html#python-mode), sequences are serialized as is. In [JSON mode](../../concepts/serialization/index.html#json-mode),\nthey are serialized as arrays.\n\n#### Example\n\n```\nfrom collections.abc import Sequence\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    sequence_of_strs: Sequence[str]\n\n\nprint(Model(sequence_of_strs=['a', 'bc']).sequence_of_strs)\n#> ['a', 'bc']\nprint(Model(sequence_of_strs=('a', 'bc')).sequence_of_strs)\n#> ('a', 'bc')\n\ntry:\n    Model(sequence_of_strs='abc')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    sequence_of_strs\n      'str' instances are not allowed as a Sequence value [type=sequence_str, input_value='abc', input_type=str]\n    \"\"\"\n```", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#sequencesindexhtmlsequences-permanent-link", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Dictionaries[Â¶](index.html#dictionaries \"Permanent link\")", "anchor": "dictionariesindexhtmldictionaries-permanent-link", "md_text": "Built-in type: [`dict`](https://docs.python.org/3/reference/expressions.html#dict).\n\n#### Validation\n\n* [`dict`](https://docs.python.org/3/reference/expressions.html#dict) instances are accepted as is.\n* [mappings](https://docs.python.org/3/glossary.html#term-mapping) instances are accepted and coerced to a [`dict`](https://docs.python.org/3/reference/expressions.html#dict).\n* If generic parameters for keys and values are provided, the appropriate validation is applied.\n\n#### Constraints\n\nDictionaries support the following constraints:\n\n| Constraint | Description | JSON Schema |\n| --- | --- | --- |\n| `min_length` | The dictionary must have at least this many items | [`minItems`](https://json-schema.org/understanding-json-schema/reference/array#length) keyword |\n| `max_length` | The dictionary must have at most this many items | [`maxItems`](https://json-schema.org/understanding-json-schema/reference/array#length) keyword |\n\nThese constraints can be provided using the [`Field()`](../fields/index.html#pydantic.fields.Field) function.\nThe `MinLen` and `MaxLen` metadata types from the [`annotated-types`](https://github.com/annotated-types/annotated-types)\nlibrary can also be used.\n\n#### Strictness\n\nIn [strict mode](../../concepts/strict_mode/index.html), only [`dict`](https://docs.python.org/3/reference/expressions.html#dict) instances are valid. Strict mode does *not* apply to the keys and values of the dictionaries.\nThe strict constraint must be applied to the parameter types for this to work.\n\n#### Example\n\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: dict[str, int]\n\n\nm = Model(x={'foo': 1})\nprint(m.model_dump())\n#> {'x': {'foo': 1}}\n\ntry:\n    Model(x='test')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    x\n      Input should be a valid dictionary [type=dict_type, input_value='test', input_type=str]\n    \"\"\"\n```", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#dictionariesindexhtmldictionaries-permanent-link", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Typed dictionaries[Â¶](index.html#typed-dictionaries \"Permanent link\")", "anchor": "typed-dictionariesindexhtmltyped-dictionaries-permanent-link", "md_text": "Standard library type: [`typing.TypedDict`](https://docs.python.org/3/library/typing.html#typing.TypedDict) (see also: the [typing specification](https://typing.python.org/en/latest/spec/typeddict.html)).\n\nBecause of runtime limitations, Pydantic will require using the [`TypedDict`](https://typing-extensions.readthedocs.io/en/latest/index.html#typing_extensions.TypedDict) type from\n[`typing_extensions`](https://typing-extensions.readthedocs.io/en/latest/index.html#module-typing_extensions) when using Python 3.12 and lower.\n\n[`TypedDict`](https://docs.python.org/3/library/typing.html#typing.TypedDict) declares a dictionary type that expects all of its instances to have a certain set of keys\nwhere each key is associated with a value of a consistent type.\n\nThis type [supports configuration](../../concepts/config/index.html#configuration-on-other-supported-types).\n\n#### Strictness\n\nIn [strict mode](../../concepts/strict_mode/index.html), only [`dict`](https://docs.python.org/3/reference/expressions.html#dict) instances are valid (unlike mappings in lax mode).\nStrict mode does *not* apply to the values of the typed dictionary. The strict constraint must be applied to the value types for this to work.\n\n#### Example\n\nPython 3.9 and abovePython 3.13 and above\n\n```\nfrom typing_extensions import TypedDict\n\nfrom pydantic import TypeAdapter, ValidationError\n\n\nclass User(TypedDict):\n    name: str\n    id: int\n\n\nta = TypeAdapter(User)\n\nprint(ta.validate_python({'name': 'foo', 'id': 1}))\n#> {'name': 'foo', 'id': 1}\n\ntry:\n    ta.validate_python({'name': 'foo'})\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n    id\n      Field required [type=missing, input_value={'name': 'foo'}, input_type=dict]\n    \"\"\"\n\nfrom typing import TypedDict\n\nfrom pydantic import TypeAdapter, ValidationError\n\n\nclass User(TypedDict):\n    name: str\n    id: int\n\n\nta = TypeAdapter(User)\n\nprint(ta.validate_python({'name': 'foo', 'id': 1}))\n#> {'name': 'foo', 'id': 1}\n\ntry:\n    ta.validate_python({'name': 'foo'})\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n    id\n      Field required [type=missing, input_value={'name': 'foo'}, input_type=dict]\n    \"\"\"\n```", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#typed-dictionariesindexhtmltyped-dictionaries-permanent-link", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Iterables[Â¶](index.html#iterables \"Permanent link\")", "anchor": "iterablesindexhtmliterables-permanent-link", "md_text": "Standard library type: [`collections.abc.Iterable`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable) (deprecated alias: [`typing.Iterable`](https://docs.python.org/3/library/typing.html#typing.Iterable)).\n\n#### Validation\n\nIterables are lazily validated, and wrapped in an internal datastructure that can be iterated over\n(and will validated the items type while doing so). This means that even if you provide a concrete\ncontainer such as a list, the validated type will *not* be of type [`list`](https://docs.python.org/3/glossary.html#term-list). However, Pydantic\nwill ensure that the input value is iterable by getting an [iterator](https://docs.python.org/3/glossary.html#term-iterator) from it (by calling\n[`iter()`](https://docs.python.org/3/library/functions.html#iter) on the value).\n\nIt is recommended to use concrete collection types (such as [lists](index.html#lists)) instead, unless\nyou are using an infinite iterator (in which case eagerly validating the input would result\nin an infinite loop).\n\n#### Example\n\n```\nfrom collections.abc import Iterable\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    f: Iterable[str]\n\n\nm = Model(f=[1, 2])  # Validates fine\n\ntry:\n    next(m.f)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for ValidatorIterator\n    0\n      Input should be a valid string [type=string_type, input_value=1, input_type=int]\n    \"\"\"\n```", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#iterablesindexhtmliterables-permanent-link", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Callable[Â¶](index.html#callable \"Permanent link\")", "anchor": "callableindexhtmlcallable-permanent-link", "md_text": "Standard library type: [`collections.abc.Callable`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable) (deprecated alias: [`typing.Callable`](https://docs.python.org/3/library/typing.html#typing.Callable)).", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#callableindexhtmlcallable-permanent-link", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Validation", "anchor": "validation", "md_text": "Pydantic only validates that the input is a [callable](https://docs.python.org/3/glossary.html#term-callable) (using the [`callable()`](https://docs.python.org/3/library/functions.html#callable) function).\nIt does *not* validate the number of parameters or their type, nor the type of the return value.\n\nPython 3.9 and abovePython 3.10 and above\n\n```\nfrom typing import Callable\n\nfrom pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    callback: Callable[[int], int]\n\n\nm = Foo(callback=lambda x: x)\nprint(m)\n#> callback=<function <lambda> at 0x0123456789ab>\n\nfrom collections.abc import Callable\n\nfrom pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    callback: Callable[[int], int]\n\n\nm = Foo(callback=lambda x: x)\nprint(m)\n#> callback=<function <lambda> at 0x0123456789ab>\n```", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#validation", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Serialization", "anchor": "serialization", "md_text": "Callables are serialized as is. Callables can't be serialized in [JSON mode](../../concepts/serialization/index.html#json-mode)\n(a [`PydanticSerializationError`](../pydantic_core/index.html#pydantic_core.PydanticSerializationError) is raised).", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#serialization", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "IP Addresses[Â¶](index.html#ip-addresses \"Permanent link\")", "anchor": "ip-addressesindexhtmlip-addresses-permanent-link", "md_text": "Standard library types:\n\n* [`ipaddress.IPv4Address`](https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv4Address)\n* [`ipaddress.IPv4Interface`](https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv4Interface)\n* [`ipaddress.IPv4Network`](https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv4Network)\n* [`ipaddress.IPv6Address`](https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv6Address)\n* [`ipaddress.IPv6Interface`](https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv6Interface)\n* [`ipaddress.IPv6Network`](https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv6Network)\n\nSee also: the [`IPvAnyAddress`](../networks/index.html#pydantic.networks.IPvAnyAddress), [`IPvAnyInterface`](../networks/index.html#pydantic.networks.IPvAnyInterface)\nand [`IPvAnyNetwork`](../networks/index.html#pydantic.networks.IPvAnyNetwork) Pydantic types.", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#ip-addressesindexhtmlip-addresses-permanent-link", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Validation", "anchor": "validation", "md_text": "* Instances are validated as is.\n* Other input values are passed to the constructor of the relevant address type.", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#validation", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Strictness", "anchor": "strictness", "md_text": "In [strict mode](../../concepts/strict_mode/index.html), only the address types are accepted.\nIn JSON mode, strict mode has no effect.", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#strictness", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Serialization", "anchor": "serialization", "md_text": "In [Python mode](../../concepts/serialization/index.html#python-mode), IP addresses are serialized as is. In [JSON mode](../../concepts/serialization/index.html#json-mode),\nthey are serialized as strings.", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#serialization", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "UUID[Â¶](index.html#uuid \"Permanent link\")", "anchor": "uuidindexhtmluuid-permanent-link", "md_text": "Standard library type: [`uuid.UUID`](https://docs.python.org/3/library/uuid.html#uuid.UUID).", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#uuidindexhtmluuid-permanent-link", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Validation", "anchor": "validation", "md_text": "* [`UUID`](https://docs.python.org/3/library/uuid.html#uuid.UUID) instances are validated as is.\n* Strings and bytes are validated as UUIDs, and casted to a [`UUID`](https://docs.python.org/3/library/uuid.html#uuid.UUID) instance.", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#validation", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Constraints", "anchor": "constraints", "md_text": "The [`UUID`](https://docs.python.org/3/library/uuid.html#uuid.UUID) type supports a `version` constraint. The [`UuidVersion`](../types/index.html#pydantic.types.UuidVersion) metadata type can be used.\n\nPydantic also provides the following types as convenience aliases: [`UUID1`](../types/index.html#pydantic.types.UUID1), [`UUID3`](../types/index.html#pydantic.types.UUID3),\n[`UUID4`](../types/index.html#pydantic.types.UUID4), [`UUID5`](../types/index.html#pydantic.types.UUID5), [`UUID6`](../types/index.html#pydantic.types.UUID6), [`UUID7`](../types/index.html#pydantic.types.UUID7),\n[`UUID8`](../types/index.html#pydantic.types.UUID8).", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#constraints", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Strictness", "anchor": "strictness", "md_text": "In [strict mode](../../concepts/strict_mode/index.html), only [`UUID`](https://docs.python.org/3/library/uuid.html#uuid.UUID) instances are accepted.\nIn JSON mode, strict mode has no effect.", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#strictness", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Serialization", "anchor": "serialization", "md_text": "In [Python mode](../../concepts/serialization/index.html#python-mode), UUIDs are serialized as is. In [JSON mode](../../concepts/serialization/index.html#json-mode),\nthey are serialized as strings.", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#serialization", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Example", "anchor": "example", "md_text": "```\nfrom typing import Annotated\nfrom uuid import UUID\n\nfrom pydantic import BaseModel\nfrom pydantic.types import UUID7, UuidVersion\n\n\nclass Model(BaseModel):\n    u1: UUID7\n    u2: Annotated[UUID, UuidVersion(4)]\n\n\nprint(\n    Model(\n        u1='01999b2c-8353-749b-8dac-859307fae22b',\n        u2=UUID('125725f3-e1b4-44e3-90c3-1a20eab12da5'),\n    )\n)\n\"\"\"\nu1=UUID('01999b2c-8353-749b-8dac-859307fae22b') u2=UUID('125725f3-e1b4-44e3-90c3-1a20eab12da5')\n\"\"\"\n```", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#example", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Type[Â¶](index.html#type \"Permanent link\")", "anchor": "typeindexhtmltype-permanent-link", "md_text": "Built-in type: [`type`](https://docs.python.org/3/glossary.html#term-type) (deprecated alias: [`typing.Type`](https://docs.python.org/3/library/typing.html#typing.Type)).", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#typeindexhtmltype-permanent-link", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Validation", "anchor": "validation", "md_text": "Allows any type that is a subclass of the type argument. For instance, with `type[str]`, allows the [`str`](https://docs.python.org/3/library/stdtypes.html#str)\nclass or any [`str`](https://docs.python.org/3/library/stdtypes.html#str) subclass as an input. If no type argument is provided (i.e. `type` is used as an annotation),\nallow any class.", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#validation", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Serialization", "anchor": "serialization", "md_text": "Types are serialized as is. Types can't be serialized in [JSON mode](../../concepts/serialization/index.html#json-mode)\n(a [`PydanticSerializationError`](../pydantic_core/index.html#pydantic_core.PydanticSerializationError) is raised).\n\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Foo:\n    pass\n\n\nclass Bar(Foo):\n    pass\n\n\nclass Other:\n    pass\n\n\nclass SimpleModel(BaseModel):\n    just_subclasses: type[Foo]\n\n\nSimpleModel(just_subclasses=Foo)\nSimpleModel(just_subclasses=Bar)\ntry:\n    SimpleModel(just_subclasses=Other)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for SimpleModel\n    just_subclasses\n      Input should be a subclass of Foo [type=is_subclass_of, input_value=<class '__main__.Other'>, input_type=type]\n    \"\"\"\n```", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#serialization", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Literals[Â¶](index.html#literals \"Permanent link\")", "anchor": "literalsindexhtmlliterals-permanent-link", "md_text": "Typing construct: [`typing.Literal`](https://docs.python.org/3/library/typing.html#typing.Literal) (see also: the [typing specification](https://typing.python.org/en/latest/spec/literal.html#literal)).\n\nLiterals can be used to only allow specific literal values.\n\nNote that Pydantic applies [strict mode](../../concepts/strict_mode/index.html) behavior when validating literal values (see [this issue](https://github.com/pydantic/pydantic/issues/9991)).", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#literalsindexhtmlliterals-permanent-link", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Example", "anchor": "example", "md_text": "```\nfrom typing import Literal\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Pie(BaseModel):\n    flavor: Literal['apple', 'pumpkin']\n    quantity: Literal[1, 2] = 1\n\n\nPie(flavor='apple')\nPie(flavor='pumpkin')\ntry:\n    Pie(flavor='cherry')\nexcept ValidationError as e:\n    print(str(e))\n    \"\"\"\n    1 validation error for Pie\n    flavor\n      Input should be 'apple' or 'pumpkin' [type=literal_error, input_value='cherry', input_type=str]\n    \"\"\"\n\ntry:\n    Pie(flavor='apple', quantity='1')\nexcept ValidationError as e:\n    print(str(e))\n    \"\"\"\n    1 validation error for Pie\n    quantity\n      Input should be 1 or 2 [type=literal_error, input_value='1', input_type=str]\n    \"\"\"\n```", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#example", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Any[Â¶](index.html#any \"Permanent link\")", "anchor": "anyindexhtmlany-permanent-link", "md_text": "Types: [`typing.Any`](https://docs.python.org/3/library/typing.html#typing.Any) or [`object`](https://docs.python.org/3/glossary.html#term-object).\n\nAllows any value, including `None`.", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#anyindexhtmlany-permanent-link", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Hashables[Â¶](index.html#hashables \"Permanent link\")", "anchor": "hashablesindexhtmlhashables-permanent-link", "md_text": "Standard library type: [`collections.abc.Hashable`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Hashable) (deprecated alias: [`typing.Hashable`](https://docs.python.org/3/library/typing.html#typing.Hashable)).", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#hashablesindexhtmlhashables-permanent-link", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Validation", "anchor": "validation", "md_text": "Any value that is hashable (using `isinstance(value, Hashable)`).", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#validation", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Regex patterns[Â¶](index.html#regex-patterns \"Permanent link\")", "anchor": "regex-patternsindexhtmlregex-patterns-permanent-link", "md_text": "Standard library type: [`re.Pattern`](https://docs.python.org/3/library/re.html#re.Pattern) (deprecated alias: [`typing.Pattern`](https://docs.python.org/3/library/typing.html#typing.Pattern)).", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#regex-patternsindexhtmlregex-patterns-permanent-link", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Validation", "anchor": "validation", "md_text": "* For [`Pattern`](https://docs.python.org/3/library/re.html#re.Pattern) instances, check that the [`pattern`](https://docs.python.org/3/library/re.html#re.Pattern.pattern) attribute\n  is of the right type ([`str`](https://docs.python.org/3/library/stdtypes.html#str) or [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes) depending on the [`Pattern`](https://docs.python.org/3/library/re.html#re.Pattern) type\n  parameter).\n* If the type parameter is [`str`](https://docs.python.org/3/library/stdtypes.html#str) or [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes), input values of type [`str`](https://docs.python.org/3/library/stdtypes.html#str) (or [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes) respectively)\n  are attempted to be compiled using [`re.compile()`](https://docs.python.org/3/library/re.html#re.compile).", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#validation", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Serialization", "anchor": "serialization", "md_text": "In [Python mode](../../concepts/serialization/index.html#python-mode), [`Pattern`](https://docs.python.org/3/library/re.html#re.Pattern) instances are\nserialized as is.\n\nIn [JSON mode](../../concepts/serialization/index.html#json-mode), they are serialized as strings.", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#serialization", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Paths[Â¶](index.html#paths \"Permanent link\")", "anchor": "pathsindexhtmlpaths-permanent-link", "md_text": "Standard library types:\n\n* [`pathlib.Path`](https://docs.python.org/3/library/pathlib.html#pathlib.Path).\n* [`pathlib.PurePath`](https://docs.python.org/3/library/pathlib.html#pathlib.PurePath).\n* [`pathlib.PosixPath`](https://docs.python.org/3/library/pathlib.html#pathlib.PosixPath).\n* [`pathlib.PurePosixPath`](https://docs.python.org/3/library/pathlib.html#pathlib.PurePosixPath).\n* [`pathlib.PureWindowsPath`](https://docs.python.org/3/library/pathlib.html#pathlib.PureWindowsPath).\n* [`os.PathLike`](https://docs.python.org/3/library/os.html#os.PathLike) (must be parameterized with [`str`](https://docs.python.org/3/library/stdtypes.html#str), [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes) or [`Any`](https://docs.python.org/3/library/typing.html#typing.Any)).", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#pathsindexhtmlpaths-permanent-link", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Validation", "anchor": "validation", "md_text": "* Path instances are validated as is.\n* Strings are accepted and passed to the type constructor. If [`os.PathLike`](https://docs.python.org/3/library/os.html#os.PathLike) was used,\n  bytes are accepted if it was parameterized with the [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes) type.", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#validation", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Strictness", "anchor": "strictness", "md_text": "In [strict mode](../../concepts/strict_mode/index.html), only Path instances are accepted.\nIn JSON mode, strict mode has no effect.", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#strictness", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "Serialization", "anchor": "serialization", "md_text": "In [Python mode](../../concepts/serialization/index.html#python-mode), Path instances are\nserialized as is.\n\nIn [JSON mode](../../concepts/serialization/index.html#json-mode), they are serialized as strings.\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/api/standard_library_types/index.html#serialization", "page": "api/standard_library_types/index.html", "source_site": "pydantic"}
{"title": "CountryAlpha2 [Â¶](index.html#pydantic_extra_types.country.CountryAlpha2 \"Permanent link\")", "anchor": "countryalpha2-indexhtmlpydanticextratypescountrycountryalpha2-permanent-link", "md_text": "Bases: `str`\n\nCountryAlpha2 parses country codes in the [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)\nformat.\n\n```\nfrom pydantic import BaseModel\n\nfrom pydantic_extra_types.country import CountryAlpha2\n\n\nclass Product(BaseModel):\n    made_in: CountryAlpha2\n\n\nproduct = Product(made_in='ES')\nprint(product)\n# > made_in='ES'\n```", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_country/index.html#countryalpha2-indexhtmlpydanticextratypescountrycountryalpha2-permanent-link", "page": "api/pydantic_extra_types_country/index.html", "source_site": "pydantic"}
{"title": "alpha3 `property` [Â¶](index.html#pydantic_extra_types.country.CountryAlpha2.alpha3 \"Permanent link\")", "anchor": "alpha3-property-indexhtmlpydanticextratypescountrycountryalpha2alpha3-permanent-link", "md_text": "```\nalpha3: str\n```\n\nThe country code in the [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) format.", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_country/index.html#alpha3-property-indexhtmlpydanticextratypescountrycountryalpha2alpha3-permanent-link", "page": "api/pydantic_extra_types_country/index.html", "source_site": "pydantic"}
{"title": "numeric\\_code `property` [Â¶](index.html#pydantic_extra_types.country.CountryAlpha2.numeric_code \"Permanent link\")", "anchor": "numericcode-property-indexhtmlpydanticextratypescountrycountryalpha2numericcode-permanent-link", "md_text": "```\nnumeric_code: str\n```\n\nThe country code in the [ISO 3166-1 numeric](https://en.wikipedia.org/wiki/ISO_3166-1_numeric) format.", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_country/index.html#numericcode-property-indexhtmlpydanticextratypescountrycountryalpha2numericcode-permanent-link", "page": "api/pydantic_extra_types_country/index.html", "source_site": "pydantic"}
{"title": "short\\_name `property` [Â¶](index.html#pydantic_extra_types.country.CountryAlpha2.short_name \"Permanent link\")", "anchor": "shortname-property-indexhtmlpydanticextratypescountrycountryalpha2shortname-permanent-link", "md_text": "```\nshort_name: str\n```\n\nThe country short name.", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_country/index.html#shortname-property-indexhtmlpydanticextratypescountrycountryalpha2shortname-permanent-link", "page": "api/pydantic_extra_types_country/index.html", "source_site": "pydantic"}
{"title": "CountryAlpha3 [Â¶](index.html#pydantic_extra_types.country.CountryAlpha3 \"Permanent link\")", "anchor": "countryalpha3-indexhtmlpydanticextratypescountrycountryalpha3-permanent-link", "md_text": "Bases: `str`\n\nCountryAlpha3 parses country codes in the [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3)\nformat.\n\n```\nfrom pydantic import BaseModel\n\nfrom pydantic_extra_types.country import CountryAlpha3\n\n\nclass Product(BaseModel):\n    made_in: CountryAlpha3\n\n\nproduct = Product(made_in='USA')\nprint(product)\n# > made_in='USA'\n```", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_country/index.html#countryalpha3-indexhtmlpydanticextratypescountrycountryalpha3-permanent-link", "page": "api/pydantic_extra_types_country/index.html", "source_site": "pydantic"}
{"title": "alpha2 `property` [Â¶](index.html#pydantic_extra_types.country.CountryAlpha3.alpha2 \"Permanent link\")", "anchor": "alpha2-property-indexhtmlpydanticextratypescountrycountryalpha3alpha2-permanent-link", "md_text": "```\nalpha2: str\n```\n\nThe country code in the [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_country/index.html#alpha2-property-indexhtmlpydanticextratypescountrycountryalpha3alpha2-permanent-link", "page": "api/pydantic_extra_types_country/index.html", "source_site": "pydantic"}
{"title": "numeric\\_code `property` [Â¶](index.html#pydantic_extra_types.country.CountryAlpha3.numeric_code \"Permanent link\")", "anchor": "numericcode-property-indexhtmlpydanticextratypescountrycountryalpha3numericcode-permanent-link", "md_text": "```\nnumeric_code: str\n```\n\nThe country code in the [ISO 3166-1 numeric](https://en.wikipedia.org/wiki/ISO_3166-1_numeric) format.", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_country/index.html#numericcode-property-indexhtmlpydanticextratypescountrycountryalpha3numericcode-permanent-link", "page": "api/pydantic_extra_types_country/index.html", "source_site": "pydantic"}
{"title": "short\\_name `property` [Â¶](index.html#pydantic_extra_types.country.CountryAlpha3.short_name \"Permanent link\")", "anchor": "shortname-property-indexhtmlpydanticextratypescountrycountryalpha3shortname-permanent-link", "md_text": "```\nshort_name: str\n```\n\nThe country short name.", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_country/index.html#shortname-property-indexhtmlpydanticextratypescountrycountryalpha3shortname-permanent-link", "page": "api/pydantic_extra_types_country/index.html", "source_site": "pydantic"}
{"title": "CountryNumericCode [Â¶](index.html#pydantic_extra_types.country.CountryNumericCode \"Permanent link\")", "anchor": "countrynumericcode-indexhtmlpydanticextratypescountrycountrynumericcode-permanent-link", "md_text": "Bases: `str`\n\nCountryNumericCode parses country codes in the\n[ISO 3166-1 numeric](https://en.wikipedia.org/wiki/ISO_3166-1_numeric) format.\n\n```\nfrom pydantic import BaseModel\n\nfrom pydantic_extra_types.country import CountryNumericCode\n\n\nclass Product(BaseModel):\n    made_in: CountryNumericCode\n\n\nproduct = Product(made_in='840')\nprint(product)\n# > made_in='840'\n```", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_country/index.html#countrynumericcode-indexhtmlpydanticextratypescountrycountrynumericcode-permanent-link", "page": "api/pydantic_extra_types_country/index.html", "source_site": "pydantic"}
{"title": "alpha2 `property` [Â¶](index.html#pydantic_extra_types.country.CountryNumericCode.alpha2 \"Permanent link\")", "anchor": "alpha2-property-indexhtmlpydanticextratypescountrycountrynumericcodealpha2-permanent-link", "md_text": "```\nalpha2: str\n```\n\nThe country code in the [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_country/index.html#alpha2-property-indexhtmlpydanticextratypescountrycountrynumericcodealpha2-permanent-link", "page": "api/pydantic_extra_types_country/index.html", "source_site": "pydantic"}
{"title": "alpha3 `property` [Â¶](index.html#pydantic_extra_types.country.CountryNumericCode.alpha3 \"Permanent link\")", "anchor": "alpha3-property-indexhtmlpydanticextratypescountrycountrynumericcodealpha3-permanent-link", "md_text": "```\nalpha3: str\n```\n\nThe country code in the [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) format.", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_country/index.html#alpha3-property-indexhtmlpydanticextratypescountrycountrynumericcodealpha3-permanent-link", "page": "api/pydantic_extra_types_country/index.html", "source_site": "pydantic"}
{"title": "short\\_name `property` [Â¶](index.html#pydantic_extra_types.country.CountryNumericCode.short_name \"Permanent link\")", "anchor": "shortname-property-indexhtmlpydanticextratypescountrycountrynumericcodeshortname-permanent-link", "md_text": "```\nshort_name: str\n```\n\nThe country short name.", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_country/index.html#shortname-property-indexhtmlpydanticextratypescountrycountrynumericcodeshortname-permanent-link", "page": "api/pydantic_extra_types_country/index.html", "source_site": "pydantic"}
{"title": "CountryShortName [Â¶](index.html#pydantic_extra_types.country.CountryShortName \"Permanent link\")", "anchor": "countryshortname-indexhtmlpydanticextratypescountrycountryshortname-permanent-link", "md_text": "Bases: `str`\n\nCountryShortName parses country codes in the short name format.\n\n```\nfrom pydantic import BaseModel\n\nfrom pydantic_extra_types.country import CountryShortName\n\n\nclass Product(BaseModel):\n    made_in: CountryShortName\n\n\nproduct = Product(made_in='United States')\nprint(product)\n# > made_in='United States'\n```", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_country/index.html#countryshortname-indexhtmlpydanticextratypescountrycountryshortname-permanent-link", "page": "api/pydantic_extra_types_country/index.html", "source_site": "pydantic"}
{"title": "alpha2 `property` [Â¶](index.html#pydantic_extra_types.country.CountryShortName.alpha2 \"Permanent link\")", "anchor": "alpha2-property-indexhtmlpydanticextratypescountrycountryshortnamealpha2-permanent-link", "md_text": "```\nalpha2: str\n```\n\nThe country code in the [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_country/index.html#alpha2-property-indexhtmlpydanticextratypescountrycountryshortnamealpha2-permanent-link", "page": "api/pydantic_extra_types_country/index.html", "source_site": "pydantic"}
{"title": "alpha3 `property` [Â¶](index.html#pydantic_extra_types.country.CountryShortName.alpha3 \"Permanent link\")", "anchor": "alpha3-property-indexhtmlpydanticextratypescountrycountryshortnamealpha3-permanent-link", "md_text": "```\nalpha3: str\n```\n\nThe country code in the [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) format.", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_country/index.html#alpha3-property-indexhtmlpydanticextratypescountrycountryshortnamealpha3-permanent-link", "page": "api/pydantic_extra_types_country/index.html", "source_site": "pydantic"}
{"title": "numeric\\_code `property` [Â¶](index.html#pydantic_extra_types.country.CountryShortName.numeric_code \"Permanent link\")", "anchor": "numericcode-property-indexhtmlpydanticextratypescountrycountryshortnamenumericcode-permanent-link", "md_text": "```\nnumeric_code: str\n```\n\nThe country code in the [ISO 3166-1 numeric](https://en.wikipedia.org/wiki/ISO_3166-1_numeric) format.\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_country/index.html#numericcode-property-indexhtmlpydanticextratypescountrycountryshortnamenumericcode-permanent-link", "page": "api/pydantic_extra_types_country/index.html", "source_site": "pydantic"}
{"title": "\\_\\_version\\_\\_ `module-attribute` [Â¶](index.html#pydantic_core.__version__ \"Permanent link\")", "anchor": "version-module-attribute-indexhtmlpydanticcoreversion-permanent-link", "md_text": "```\n__version__: str\n```", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#version-module-attribute-indexhtmlpydanticcoreversion-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "SchemaValidator [Â¶](index.html#pydantic_core.SchemaValidator \"Permanent link\")", "anchor": "schemavalidator-indexhtmlpydanticcoreschemavalidator-permanent-link", "md_text": "```\nSchemaValidator(\n    schema: CoreSchema, config: CoreConfig | None = None\n)\n```\n\n`SchemaValidator` is the Python wrapper for `pydantic-core`'s Rust validation logic, internally it owns one\n`CombinedValidator` which may in turn own more `CombinedValidator`s which make up the full schema validator.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `CoreSchema` | The `CoreSchema` to use for validation. | *required* |\n| `config` | `CoreConfig | None` | Optionally a [`CoreConfig`](../pydantic_core_schema/index.html#pydantic_core.core_schema.CoreConfig) to configure validation. | `None` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#schemavalidator-indexhtmlpydanticcoreschemavalidator-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "title `property` [Â¶](index.html#pydantic_core.SchemaValidator.title \"Permanent link\")", "anchor": "title-property-indexhtmlpydanticcoreschemavalidatortitle-permanent-link", "md_text": "```\ntitle: str\n```\n\nThe title of the schema, as used in the heading of [`ValidationError.__str__()`](index.html#pydantic_core.ValidationError).", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#title-property-indexhtmlpydanticcoreschemavalidatortitle-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "validate\\_python [Â¶](index.html#pydantic_core.SchemaValidator.validate_python \"Permanent link\")", "anchor": "validatepython-indexhtmlpydanticcoreschemavalidatorvalidatepython-permanent-link", "md_text": "```\nvalidate_python(\n    input: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraBehavior | None = None,\n    from_attributes: bool | None = None,\n    context: Any | None = None,\n    self_instance: Any | None = None,\n    allow_partial: (\n        bool | Literal[\"off\", \"on\", \"trailing-strings\"]\n    ) = False,\n    by_alias: bool | None = None,\n    by_name: bool | None = None\n) -> Any\n```\n\nValidate a Python object against the schema and return the validated object.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `input` | `Any` | The Python object to validate. | *required* |\n| `strict` | `bool | None` | Whether to validate the object in strict mode. If `None`, the value of [`CoreConfig.strict`](../pydantic_core_schema/index.html#pydantic_core.core_schema.CoreConfig) is used. | `None` |\n| `extra` | `ExtraBehavior | None` | Whether to ignore, allow, or forbid extra data during model validation. If `None`, the value of [`CoreConfig.extra_fields_behavior`](../pydantic_core_schema/index.html#pydantic_core.core_schema.CoreConfig) is used. | `None` |\n| `from_attributes` | `bool | None` | Whether to validate objects as inputs to models by extracting attributes. If `None`, the value of [`CoreConfig.from_attributes`](../pydantic_core_schema/index.html#pydantic_core.core_schema.CoreConfig) is used. | `None` |\n| `context` | `Any | None` | The context to use for validation, this is passed to functional validators as [`info.context`](../pydantic_core_schema/index.html#pydantic_core.core_schema.ValidationInfo.context). | `None` |\n| `self_instance` | `Any | None` | An instance of a model set attributes on from validation, this is used when running validation from the `__init__` method of a model. | `None` |\n| `allow_partial` | `bool | Literal['off', 'on', 'trailing-strings']` | Whether to allow partial validation; if `True` errors in the last element of sequences and mappings are ignored. `'trailing-strings'` means any final unfinished JSON string is included in the result. | `False` |\n| `by_alias` | `bool | None` | Whether to use the field's alias when validating against the provided input data. | `None` |\n| `by_name` | `bool | None` | Whether to use the field's name when validating against the provided input data. | `None` |\n\nRaises:\n\n| Type | Description |\n| --- | --- |\n| `ValidationError` | If validation fails. |\n| `Exception` | Other error types maybe raised if internal errors occur. |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `Any` | The validated object. |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#validatepython-indexhtmlpydanticcoreschemavalidatorvalidatepython-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "isinstance\\_python [Â¶](index.html#pydantic_core.SchemaValidator.isinstance_python \"Permanent link\")", "anchor": "isinstancepython-indexhtmlpydanticcoreschemavalidatorisinstancepython-permanent-link", "md_text": "```\nisinstance_python(\n    input: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraBehavior | None = None,\n    from_attributes: bool | None = None,\n    context: Any | None = None,\n    self_instance: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None\n) -> bool\n```\n\nSimilar to [`validate_python()`](index.html#pydantic_core.SchemaValidator.validate_python) but returns a boolean.\n\nArguments match `validate_python()`. This method will not raise `ValidationError`s but will raise internal\nerrors.\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `bool` | `True` if validation succeeds, `False` if validation fails. |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#isinstancepython-indexhtmlpydanticcoreschemavalidatorisinstancepython-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "validate\\_json [Â¶](index.html#pydantic_core.SchemaValidator.validate_json \"Permanent link\")", "anchor": "validatejson-indexhtmlpydanticcoreschemavalidatorvalidatejson-permanent-link", "md_text": "```\nvalidate_json(\n    input: str | bytes | bytearray,\n    *,\n    strict: bool | None = None,\n    extra: ExtraBehavior | None = None,\n    context: Any | None = None,\n    self_instance: Any | None = None,\n    allow_partial: (\n        bool | Literal[\"off\", \"on\", \"trailing-strings\"]\n    ) = False,\n    by_alias: bool | None = None,\n    by_name: bool | None = None\n) -> Any\n```\n\nValidate JSON data directly against the schema and return the validated Python object.\n\nThis method should be significantly faster than `validate_python(json.loads(json_data))` as it avoids the\nneed to create intermediate Python objects\n\nIt also handles constructing the correct Python type even in strict mode, where\n`validate_python(json.loads(json_data))` would fail validation.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `input` | `str | bytes | bytearray` | The JSON data to validate. | *required* |\n| `strict` | `bool | None` | Whether to validate the object in strict mode. If `None`, the value of [`CoreConfig.strict`](../pydantic_core_schema/index.html#pydantic_core.core_schema.CoreConfig) is used. | `None` |\n| `extra` | `ExtraBehavior | None` | Whether to ignore, allow, or forbid extra data during model validation. If `None`, the value of [`CoreConfig.extra_fields_behavior`](../pydantic_core_schema/index.html#pydantic_core.core_schema.CoreConfig) is used. | `None` |\n| `context` | `Any | None` | The context to use for validation, this is passed to functional validators as [`info.context`](../pydantic_core_schema/index.html#pydantic_core.core_schema.ValidationInfo.context). | `None` |\n| `self_instance` | `Any | None` | An instance of a model set attributes on from validation. | `None` |\n| `allow_partial` | `bool | Literal['off', 'on', 'trailing-strings']` | Whether to allow partial validation; if `True` incomplete JSON will be parsed successfully and errors in the last element of sequences and mappings are ignored. `'trailing-strings'` means any final unfinished JSON string is included in the result. | `False` |\n| `by_alias` | `bool | None` | Whether to use the field's alias when validating against the provided input data. | `None` |\n| `by_name` | `bool | None` | Whether to use the field's name when validating against the provided input data. | `None` |\n\nRaises:\n\n| Type | Description |\n| --- | --- |\n| `ValidationError` | If validation fails or if the JSON data is invalid. |\n| `Exception` | Other error types maybe raised if internal errors occur. |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `Any` | The validated Python object. |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#validatejson-indexhtmlpydanticcoreschemavalidatorvalidatejson-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "validate\\_strings [Â¶](index.html#pydantic_core.SchemaValidator.validate_strings \"Permanent link\")", "anchor": "validatestrings-indexhtmlpydanticcoreschemavalidatorvalidatestrings-permanent-link", "md_text": "```\nvalidate_strings(\n    input: _StringInput,\n    *,\n    strict: bool | None = None,\n    extra: ExtraBehavior | None = None,\n    context: Any | None = None,\n    allow_partial: (\n        bool | Literal[\"off\", \"on\", \"trailing-strings\"]\n    ) = False,\n    by_alias: bool | None = None,\n    by_name: bool | None = None\n) -> Any\n```\n\nValidate a string against the schema and return the validated Python object.\n\nThis is similar to `validate_json` but applies to scenarios where the input will be a string but not\nJSON data, e.g. URL fragments, query parameters, etc.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `input` | `_StringInput` | The input as a string, or bytes/bytearray if `strict=False`. | *required* |\n| `strict` | `bool | None` | Whether to validate the object in strict mode. If `None`, the value of [`CoreConfig.strict`](../pydantic_core_schema/index.html#pydantic_core.core_schema.CoreConfig) is used. | `None` |\n| `extra` | `ExtraBehavior | None` | Whether to ignore, allow, or forbid extra data during model validation. If `None`, the value of [`CoreConfig.extra_fields_behavior`](../pydantic_core_schema/index.html#pydantic_core.core_schema.CoreConfig) is used. | `None` |\n| `context` | `Any | None` | The context to use for validation, this is passed to functional validators as [`info.context`](../pydantic_core_schema/index.html#pydantic_core.core_schema.ValidationInfo.context). | `None` |\n| `allow_partial` | `bool | Literal['off', 'on', 'trailing-strings']` | Whether to allow partial validation; if `True` errors in the last element of sequences and mappings are ignored. `'trailing-strings'` means any final unfinished JSON string is included in the result. | `False` |\n| `by_alias` | `bool | None` | Whether to use the field's alias when validating against the provided input data. | `None` |\n| `by_name` | `bool | None` | Whether to use the field's name when validating against the provided input data. | `None` |\n\nRaises:\n\n| Type | Description |\n| --- | --- |\n| `ValidationError` | If validation fails or if the JSON data is invalid. |\n| `Exception` | Other error types maybe raised if internal errors occur. |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `Any` | The validated Python object. |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#validatestrings-indexhtmlpydanticcoreschemavalidatorvalidatestrings-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "validate\\_assignment [Â¶](index.html#pydantic_core.SchemaValidator.validate_assignment \"Permanent link\")", "anchor": "validateassignment-indexhtmlpydanticcoreschemavalidatorvalidateassignment-permanent-link", "md_text": "```\nvalidate_assignment(\n    obj: Any,\n    field_name: str,\n    field_value: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraBehavior | None = None,\n    from_attributes: bool | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None\n) -> (\n    dict[str, Any]\n    | tuple[dict[str, Any], dict[str, Any] | None, set[str]]\n)\n```\n\nValidate an assignment to a field on a model.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `obj` | `Any` | The model instance being assigned to. | *required* |\n| `field_name` | `str` | The name of the field to validate assignment for. | *required* |\n| `field_value` | `Any` | The value to assign to the field. | *required* |\n| `strict` | `bool | None` | Whether to validate the object in strict mode. If `None`, the value of [`CoreConfig.strict`](../pydantic_core_schema/index.html#pydantic_core.core_schema.CoreConfig) is used. | `None` |\n| `extra` | `ExtraBehavior | None` | Whether to ignore, allow, or forbid extra data during model validation. If `None`, the value of [`CoreConfig.extra_fields_behavior`](../pydantic_core_schema/index.html#pydantic_core.core_schema.CoreConfig) is used. | `None` |\n| `from_attributes` | `bool | None` | Whether to validate objects as inputs to models by extracting attributes. If `None`, the value of [`CoreConfig.from_attributes`](../pydantic_core_schema/index.html#pydantic_core.core_schema.CoreConfig) is used. | `None` |\n| `context` | `Any | None` | The context to use for validation, this is passed to functional validators as [`info.context`](../pydantic_core_schema/index.html#pydantic_core.core_schema.ValidationInfo.context). | `None` |\n| `by_alias` | `bool | None` | Whether to use the field's alias when validating against the provided input data. | `None` |\n| `by_name` | `bool | None` | Whether to use the field's name when validating against the provided input data. | `None` |\n\nRaises:\n\n| Type | Description |\n| --- | --- |\n| `ValidationError` | If validation fails. |\n| `Exception` | Other error types maybe raised if internal errors occur. |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `dict[str, Any] | tuple[dict[str, Any], dict[str, Any] | None, set[str]]` | Either the model dict or a tuple of `(model_data, model_extra, fields_set)` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#validateassignment-indexhtmlpydanticcoreschemavalidatorvalidateassignment-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "get\\_default\\_value [Â¶](index.html#pydantic_core.SchemaValidator.get_default_value \"Permanent link\")", "anchor": "getdefaultvalue-indexhtmlpydanticcoreschemavalidatorgetdefaultvalue-permanent-link", "md_text": "```\nget_default_value(\n    *, strict: bool | None = None, context: Any = None\n) -> Some | None\n```\n\nGet the default value for the schema, including running default value validation.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `strict` | `bool | None` | Whether to validate the default value in strict mode. If `None`, the value of [`CoreConfig.strict`](../pydantic_core_schema/index.html#pydantic_core.core_schema.CoreConfig) is used. | `None` |\n| `context` | `Any` | The context to use for validation, this is passed to functional validators as [`info.context`](../pydantic_core_schema/index.html#pydantic_core.core_schema.ValidationInfo.context). | `None` |\n\nRaises:\n\n| Type | Description |\n| --- | --- |\n| `ValidationError` | If validation fails. |\n| `Exception` | Other error types maybe raised if internal errors occur. |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `Some | None` | `None` if the schema has no default value, otherwise a [`Some`](index.html#pydantic_core.Some) containing the default. |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#getdefaultvalue-indexhtmlpydanticcoreschemavalidatorgetdefaultvalue-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "SchemaSerializer [Â¶](index.html#pydantic_core.SchemaSerializer \"Permanent link\")", "anchor": "schemaserializer-indexhtmlpydanticcoreschemaserializer-permanent-link", "md_text": "```\nSchemaSerializer(\n    schema: CoreSchema, config: CoreConfig | None = None\n)\n```\n\n`SchemaSerializer` is the Python wrapper for `pydantic-core`'s Rust serialization logic, internally it owns one\n`CombinedSerializer` which may in turn own more `CombinedSerializer`s which make up the full schema serializer.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `CoreSchema` | The `CoreSchema` to use for serialization. | *required* |\n| `config` | `CoreConfig | None` | Optionally a [`CoreConfig`](../pydantic_core_schema/index.html#pydantic_core.core_schema.CoreConfig) to to configure serialization. | `None` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#schemaserializer-indexhtmlpydanticcoreschemaserializer-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "to\\_python [Â¶](index.html#pydantic_core.SchemaSerializer.to_python \"Permanent link\")", "anchor": "topython-indexhtmlpydanticcoreschemaserializertopython-permanent-link", "md_text": "```\nto_python(\n    value: Any,\n    *,\n    mode: str | None = None,\n    include: _IncEx | None = None,\n    exclude: _IncEx | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: (\n        bool | Literal[\"none\", \"warn\", \"error\"]\n    ) = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n    context: Any | None = None\n) -> Any\n```\n\nSerialize/marshal a Python object to a Python object including transforming and filtering data.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `value` | `Any` | The Python object to serialize. | *required* |\n| `mode` | `str | None` | The serialization mode to use, either `'python'` or `'json'`, defaults to `'python'`. In JSON mode, all values are converted to JSON compatible types, e.g. `None`, `int`, `float`, `str`, `list`, `dict`. | `None` |\n| `include` | `_IncEx | None` | A set of fields to include, if `None` all fields are included. | `None` |\n| `exclude` | `_IncEx | None` | A set of fields to exclude, if `None` no fields are excluded. | `None` |\n| `by_alias` | `bool | None` | Whether to use the alias names of fields. | `None` |\n| `exclude_unset` | `bool` | Whether to exclude fields that are not set, e.g. are not included in `__pydantic_fields_set__`. | `False` |\n| `exclude_defaults` | `bool` | Whether to exclude fields that are equal to their default value. | `False` |\n| `exclude_none` | `bool` | Whether to exclude fields that have a value of `None`. | `False` |\n| `exclude_computed_fields` | `bool` | Whether to exclude computed fields. | `False` |\n| `round_trip` | `bool` | Whether to enable serialization and validation round-trip support. | `False` |\n| `warnings` | `bool | Literal['none', 'warn', 'error']` | How to handle invalid fields. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a [`PydanticSerializationError`](index.html#pydantic_core.PydanticSerializationError). | `True` |\n| `fallback` | `Callable[[Any], Any] | None` | A function to call when an unknown value is encountered, if `None` a [`PydanticSerializationError`](index.html#pydantic_core.PydanticSerializationError) error is raised. | `None` |\n| `serialize_as_any` | `bool` | Whether to serialize fields with duck-typing serialization behavior. | `False` |\n| `context` | `Any | None` | The context to use for serialization, this is passed to functional serializers as [`info.context`](../pydantic_core_schema/index.html#pydantic_core.core_schema.SerializationInfo.context). | `None` |\n\nRaises:\n\n| Type | Description |\n| --- | --- |\n| `PydanticSerializationError` | If serialization fails and no `fallback` function is provided. |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `Any` | The serialized Python object. |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#topython-indexhtmlpydanticcoreschemaserializertopython-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "to\\_json [Â¶](index.html#pydantic_core.SchemaSerializer.to_json \"Permanent link\")", "anchor": "tojson-indexhtmlpydanticcoreschemaserializertojson-permanent-link", "md_text": "```\nto_json(\n    value: Any,\n    *,\n    indent: int | None = None,\n    ensure_ascii: bool = False,\n    include: _IncEx | None = None,\n    exclude: _IncEx | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: (\n        bool | Literal[\"none\", \"warn\", \"error\"]\n    ) = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n    context: Any | None = None\n) -> bytes\n```\n\nSerialize a Python object to JSON including transforming and filtering data.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `value` | `Any` | The Python object to serialize. | *required* |\n| `indent` | `int | None` | If `None`, the JSON will be compact, otherwise it will be pretty-printed with the indent provided. | `None` |\n| `ensure_ascii` | `bool` | If `True`, the output is guaranteed to have all incoming non-ASCII characters escaped. If `False` (the default), these characters will be output as-is. | `False` |\n| `include` | `_IncEx | None` | A set of fields to include, if `None` all fields are included. | `None` |\n| `exclude` | `_IncEx | None` | A set of fields to exclude, if `None` no fields are excluded. | `None` |\n| `by_alias` | `bool | None` | Whether to use the alias names of fields. | `None` |\n| `exclude_unset` | `bool` | Whether to exclude fields that are not set, e.g. are not included in `__pydantic_fields_set__`. | `False` |\n| `exclude_defaults` | `bool` | Whether to exclude fields that are equal to their default value. | `False` |\n| `exclude_none` | `bool` | Whether to exclude fields that have a value of `None`. | `False` |\n| `exclude_computed_fields` | `bool` | Whether to exclude computed fields. | `False` |\n| `round_trip` | `bool` | Whether to enable serialization and validation round-trip support. | `False` |\n| `warnings` | `bool | Literal['none', 'warn', 'error']` | How to handle invalid fields. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a [`PydanticSerializationError`](index.html#pydantic_core.PydanticSerializationError). | `True` |\n| `fallback` | `Callable[[Any], Any] | None` | A function to call when an unknown value is encountered, if `None` a [`PydanticSerializationError`](index.html#pydantic_core.PydanticSerializationError) error is raised. | `None` |\n| `serialize_as_any` | `bool` | Whether to serialize fields with duck-typing serialization behavior. | `False` |\n| `context` | `Any | None` | The context to use for serialization, this is passed to functional serializers as [`info.context`](../pydantic_core_schema/index.html#pydantic_core.core_schema.SerializationInfo.context). | `None` |\n\nRaises:\n\n| Type | Description |\n| --- | --- |\n| `PydanticSerializationError` | If serialization fails and no `fallback` function is provided. |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `bytes` | JSON bytes. |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#tojson-indexhtmlpydanticcoreschemaserializertojson-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "ValidationError [Â¶](index.html#pydantic_core.ValidationError \"Permanent link\")", "anchor": "validationerror-indexhtmlpydanticcorevalidationerror-permanent-link", "md_text": "Bases: `ValueError`\n\n`ValidationError` is the exception raised by `pydantic-core` when validation fails, it contains a list of errors\nwhich detail why validation failed.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#validationerror-indexhtmlpydanticcorevalidationerror-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "title `property` [Â¶](index.html#pydantic_core.ValidationError.title \"Permanent link\")", "anchor": "title-property-indexhtmlpydanticcorevalidationerrortitle-permanent-link", "md_text": "```\ntitle: str\n```\n\nThe title of the error, as used in the heading of `str(validation_error)`.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#title-property-indexhtmlpydanticcorevalidationerrortitle-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "from\\_exception\\_data `classmethod` [Â¶](index.html#pydantic_core.ValidationError.from_exception_data \"Permanent link\")", "anchor": "fromexceptiondata-classmethod-indexhtmlpydanticcorevalidationerrorfromexceptiondata-permanent-link", "md_text": "```\nfrom_exception_data(\n    title: str,\n    line_errors: list[InitErrorDetails],\n    input_type: Literal[\"python\", \"json\"] = \"python\",\n    hide_input: bool = False,\n) -> Self\n```\n\nPython constructor for a Validation Error.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `title` | `str` | The title of the error, as used in the heading of `str(validation_error)` | *required* |\n| `line_errors` | `list[InitErrorDetails]` | A list of [`InitErrorDetails`](index.html#pydantic_core.InitErrorDetails) which contain information about errors that occurred during validation. | *required* |\n| `input_type` | `Literal['python', 'json']` | Whether the error is for a Python object or JSON. | `'python'` |\n| `hide_input` | `bool` | Whether to hide the input value in the error message. | `False` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#fromexceptiondata-classmethod-indexhtmlpydanticcorevalidationerrorfromexceptiondata-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "error\\_count [Â¶](index.html#pydantic_core.ValidationError.error_count \"Permanent link\")", "anchor": "errorcount-indexhtmlpydanticcorevalidationerrorerrorcount-permanent-link", "md_text": "```\nerror_count() -> int\n```\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `int` | The number of errors in the validation error. |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#errorcount-indexhtmlpydanticcorevalidationerrorerrorcount-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "errors [Â¶](index.html#pydantic_core.ValidationError.errors \"Permanent link\")", "anchor": "errors-indexhtmlpydanticcorevalidationerrorerrors-permanent-link", "md_text": "```\nerrors(\n    *,\n    include_url: bool = True,\n    include_context: bool = True,\n    include_input: bool = True\n) -> list[ErrorDetails]\n```\n\nDetails about each error in the validation error.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `include_url` | `bool` | Whether to include a URL to documentation on the error each error. | `True` |\n| `include_context` | `bool` | Whether to include the context of each error. | `True` |\n| `include_input` | `bool` | Whether to include the input value of each error. | `True` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `list[ErrorDetails]` | A list of [`ErrorDetails`](index.html#pydantic_core.ErrorDetails) for each error in the validation error. |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#errors-indexhtmlpydanticcorevalidationerrorerrors-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "json [Â¶](index.html#pydantic_core.ValidationError.json \"Permanent link\")", "anchor": "json-indexhtmlpydanticcorevalidationerrorjson-permanent-link", "md_text": "```\njson(\n    *,\n    indent: int | None = None,\n    include_url: bool = True,\n    include_context: bool = True,\n    include_input: bool = True\n) -> str\n```\n\nSame as [`errors()`](index.html#pydantic_core.ValidationError.errors) but returns a JSON string.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `indent` | `int | None` | The number of spaces to indent the JSON by, or `None` for no indentation - compact JSON. | `None` |\n| `include_url` | `bool` | Whether to include a URL to documentation on the error each error. | `True` |\n| `include_context` | `bool` | Whether to include the context of each error. | `True` |\n| `include_input` | `bool` | Whether to include the input value of each error. | `True` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `str` | a JSON string. |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#json-indexhtmlpydanticcorevalidationerrorjson-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "ErrorDetails [Â¶](index.html#pydantic_core.ErrorDetails \"Permanent link\")", "anchor": "errordetails-indexhtmlpydanticcoreerrordetails-permanent-link", "md_text": "Bases: `TypedDict`", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#errordetails-indexhtmlpydanticcoreerrordetails-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "type `instance-attribute` [Â¶](index.html#pydantic_core.ErrorDetails.type \"Permanent link\")", "anchor": "type-instance-attribute-indexhtmlpydanticcoreerrordetailstype-permanent-link", "md_text": "```\ntype: str\n```\n\nThe type of error that occurred, this is an identifier designed for\nprogrammatic use that will change rarely or never.\n\n`type` is unique for each error message, and can hence be used as an identifier to build custom error messages.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#type-instance-attribute-indexhtmlpydanticcoreerrordetailstype-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "loc `instance-attribute` [Â¶](index.html#pydantic_core.ErrorDetails.loc \"Permanent link\")", "anchor": "loc-instance-attribute-indexhtmlpydanticcoreerrordetailsloc-permanent-link", "md_text": "```\nloc: tuple[int | str, ...]\n```\n\nTuple of strings and ints identifying where in the schema the error occurred.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#loc-instance-attribute-indexhtmlpydanticcoreerrordetailsloc-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "msg `instance-attribute` [Â¶](index.html#pydantic_core.ErrorDetails.msg \"Permanent link\")", "anchor": "msg-instance-attribute-indexhtmlpydanticcoreerrordetailsmsg-permanent-link", "md_text": "```\nmsg: str\n```\n\nA human readable error message.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#msg-instance-attribute-indexhtmlpydanticcoreerrordetailsmsg-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "input `instance-attribute` [Â¶](index.html#pydantic_core.ErrorDetails.input \"Permanent link\")", "anchor": "input-instance-attribute-indexhtmlpydanticcoreerrordetailsinput-permanent-link", "md_text": "```\ninput: Any\n```\n\nThe input data at this `loc` that caused the error.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#input-instance-attribute-indexhtmlpydanticcoreerrordetailsinput-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "ctx `instance-attribute` [Â¶](index.html#pydantic_core.ErrorDetails.ctx \"Permanent link\")", "anchor": "ctx-instance-attribute-indexhtmlpydanticcoreerrordetailsctx-permanent-link", "md_text": "```\nctx: NotRequired[dict[str, Any]]\n```\n\nValues which are required to render the error message, and could hence be useful in rendering custom error messages.\nAlso useful for passing custom error data forward.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#ctx-instance-attribute-indexhtmlpydanticcoreerrordetailsctx-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "url `instance-attribute` [Â¶](index.html#pydantic_core.ErrorDetails.url \"Permanent link\")", "anchor": "url-instance-attribute-indexhtmlpydanticcoreerrordetailsurl-permanent-link", "md_text": "```\nurl: NotRequired[str]\n```\n\nThe documentation URL giving information about the error. No URL is available if\na [`PydanticCustomError`](index.html#pydantic_core.PydanticCustomError) is used.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#url-instance-attribute-indexhtmlpydanticcoreerrordetailsurl-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "InitErrorDetails [Â¶](index.html#pydantic_core.InitErrorDetails \"Permanent link\")", "anchor": "initerrordetails-indexhtmlpydanticcoreiniterrordetails-permanent-link", "md_text": "Bases: `TypedDict`", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#initerrordetails-indexhtmlpydanticcoreiniterrordetails-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "type `instance-attribute` [Â¶](index.html#pydantic_core.InitErrorDetails.type \"Permanent link\")", "anchor": "type-instance-attribute-indexhtmlpydanticcoreiniterrordetailstype-permanent-link", "md_text": "```\ntype: str | PydanticCustomError\n```\n\nThe type of error that occurred, this should be a \"slug\" identifier that changes rarely or never.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#type-instance-attribute-indexhtmlpydanticcoreiniterrordetailstype-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "loc `instance-attribute` [Â¶](index.html#pydantic_core.InitErrorDetails.loc \"Permanent link\")", "anchor": "loc-instance-attribute-indexhtmlpydanticcoreiniterrordetailsloc-permanent-link", "md_text": "```\nloc: NotRequired[tuple[int | str, ...]]\n```\n\nTuple of strings and ints identifying where in the schema the error occurred.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#loc-instance-attribute-indexhtmlpydanticcoreiniterrordetailsloc-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "input `instance-attribute` [Â¶](index.html#pydantic_core.InitErrorDetails.input \"Permanent link\")", "anchor": "input-instance-attribute-indexhtmlpydanticcoreiniterrordetailsinput-permanent-link", "md_text": "```\ninput: Any\n```\n\nThe input data at this `loc` that caused the error.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#input-instance-attribute-indexhtmlpydanticcoreiniterrordetailsinput-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "ctx `instance-attribute` [Â¶](index.html#pydantic_core.InitErrorDetails.ctx \"Permanent link\")", "anchor": "ctx-instance-attribute-indexhtmlpydanticcoreiniterrordetailsctx-permanent-link", "md_text": "```\nctx: NotRequired[dict[str, Any]]\n```\n\nValues which are required to render the error message, and could hence be useful in rendering custom error messages.\nAlso useful for passing custom error data forward.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#ctx-instance-attribute-indexhtmlpydanticcoreiniterrordetailsctx-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "SchemaError [Â¶](index.html#pydantic_core.SchemaError \"Permanent link\")", "anchor": "schemaerror-indexhtmlpydanticcoreschemaerror-permanent-link", "md_text": "Bases: `Exception`\n\nInformation about errors that occur while building a [`SchemaValidator`](index.html#pydantic_core.SchemaValidator)\nor [`SchemaSerializer`](index.html#pydantic_core.SchemaSerializer).", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#schemaerror-indexhtmlpydanticcoreschemaerror-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "error\\_count [Â¶](index.html#pydantic_core.SchemaError.error_count \"Permanent link\")", "anchor": "errorcount-indexhtmlpydanticcoreschemaerrorerrorcount-permanent-link", "md_text": "```\nerror_count() -> int\n```\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `int` | The number of errors in the schema. |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#errorcount-indexhtmlpydanticcoreschemaerrorerrorcount-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "errors [Â¶](index.html#pydantic_core.SchemaError.errors \"Permanent link\")", "anchor": "errors-indexhtmlpydanticcoreschemaerrorerrors-permanent-link", "md_text": "```\nerrors() -> list[ErrorDetails]\n```\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `list[ErrorDetails]` | A list of [`ErrorDetails`](index.html#pydantic_core.ErrorDetails) for each error in the schema. |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#errors-indexhtmlpydanticcoreschemaerrorerrors-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "PydanticCustomError [Â¶](index.html#pydantic_core.PydanticCustomError \"Permanent link\")", "anchor": "pydanticcustomerror-indexhtmlpydanticcorepydanticcustomerror-permanent-link", "md_text": "```\nPydanticCustomError(\n    error_type: LiteralString,\n    message_template: LiteralString,\n    context: dict[str, Any] | None = None,\n)\n```\n\nBases: `ValueError`\n\nA custom exception providing flexible error handling for Pydantic validators.\n\nYou can raise this error in custom validators when you'd like flexibility in regards to the error type, message, and context.\n\nExample\n\n```\nfrom pydantic_core import PydanticCustomError\n\ndef custom_validator(v) -> None:\n    if v <= 10:\n        raise PydanticCustomError('custom_value_error', 'Value must be greater than {value}', {'value': 10, 'extra_context': 'extra_data'})\n    return v\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `error_type` | `LiteralString` | The error type. | *required* |\n| `message_template` | `LiteralString` | The message template. | *required* |\n| `context` | `dict[str, Any] | None` | The data to inject into the message template. | `None` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#pydanticcustomerror-indexhtmlpydanticcorepydanticcustomerror-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "context `property` [Â¶](index.html#pydantic_core.PydanticCustomError.context \"Permanent link\")", "anchor": "context-property-indexhtmlpydanticcorepydanticcustomerrorcontext-permanent-link", "md_text": "```\ncontext: dict[str, Any] | None\n```\n\nValues which are required to render the error message, and could hence be useful in passing error data forward.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#context-property-indexhtmlpydanticcorepydanticcustomerrorcontext-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "type `property` [Â¶](index.html#pydantic_core.PydanticCustomError.type \"Permanent link\")", "anchor": "type-property-indexhtmlpydanticcorepydanticcustomerrortype-permanent-link", "md_text": "```\ntype: str\n```\n\nThe error type associated with the error. For consistency with Pydantic, this is typically a snake\\_case string.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#type-property-indexhtmlpydanticcorepydanticcustomerrortype-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "message\\_template `property` [Â¶](index.html#pydantic_core.PydanticCustomError.message_template \"Permanent link\")", "anchor": "messagetemplate-property-indexhtmlpydanticcorepydanticcustomerrormessagetemplate-permanent-link", "md_text": "```\nmessage_template: str\n```\n\nThe message template associated with the error. This is a string that can be formatted with context variables in `{curly_braces}`.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#messagetemplate-property-indexhtmlpydanticcorepydanticcustomerrormessagetemplate-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "message [Â¶](index.html#pydantic_core.PydanticCustomError.message \"Permanent link\")", "anchor": "message-indexhtmlpydanticcorepydanticcustomerrormessage-permanent-link", "md_text": "```\nmessage() -> str\n```\n\nThe formatted message associated with the error. This presents as the message template with context variables appropriately injected.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#message-indexhtmlpydanticcorepydanticcustomerrormessage-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "PydanticKnownError [Â¶](index.html#pydantic_core.PydanticKnownError \"Permanent link\")", "anchor": "pydanticknownerror-indexhtmlpydanticcorepydanticknownerror-permanent-link", "md_text": "```\nPydanticKnownError(\n    error_type: ErrorType,\n    context: dict[str, Any] | None = None,\n)\n```\n\nBases: `ValueError`\n\nA helper class for raising exceptions that mimic Pydantic's built-in exceptions, with more flexibility in regards to context.\n\nUnlike [`PydanticCustomError`](index.html#pydantic_core.PydanticCustomError), the `error_type` argument must be a known `ErrorType`.\n\nExample\n\n```\nfrom pydantic_core import PydanticKnownError\n\ndef custom_validator(v) -> None:\n    if v <= 10:\n        raise PydanticKnownError('greater_than', {'gt': 10})\n    return v\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `error_type` | `ErrorType` | The error type. | *required* |\n| `context` | `dict[str, Any] | None` | The data to inject into the message template. | `None` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#pydanticknownerror-indexhtmlpydanticcorepydanticknownerror-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "context `property` [Â¶](index.html#pydantic_core.PydanticKnownError.context \"Permanent link\")", "anchor": "context-property-indexhtmlpydanticcorepydanticknownerrorcontext-permanent-link", "md_text": "```\ncontext: dict[str, Any] | None\n```\n\nValues which are required to render the error message, and could hence be useful in passing error data forward.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#context-property-indexhtmlpydanticcorepydanticknownerrorcontext-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "type `property` [Â¶](index.html#pydantic_core.PydanticKnownError.type \"Permanent link\")", "anchor": "type-property-indexhtmlpydanticcorepydanticknownerrortype-permanent-link", "md_text": "```\ntype: ErrorType\n```\n\nThe type of the error.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#type-property-indexhtmlpydanticcorepydanticknownerrortype-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "message\\_template `property` [Â¶](index.html#pydantic_core.PydanticKnownError.message_template \"Permanent link\")", "anchor": "messagetemplate-property-indexhtmlpydanticcorepydanticknownerrormessagetemplate-permanent-link", "md_text": "```\nmessage_template: str\n```\n\nThe message template associated with the provided error type. This is a string that can be formatted with context variables in `{curly_braces}`.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#messagetemplate-property-indexhtmlpydanticcorepydanticknownerrormessagetemplate-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "message [Â¶](index.html#pydantic_core.PydanticKnownError.message \"Permanent link\")", "anchor": "message-indexhtmlpydanticcorepydanticknownerrormessage-permanent-link", "md_text": "```\nmessage() -> str\n```\n\nThe formatted message associated with the error. This presents as the message template with context variables appropriately injected.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#message-indexhtmlpydanticcorepydanticknownerrormessage-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "PydanticOmit [Â¶](index.html#pydantic_core.PydanticOmit \"Permanent link\")", "anchor": "pydanticomit-indexhtmlpydanticcorepydanticomit-permanent-link", "md_text": "Bases: `Exception`\n\nAn exception to signal that a field should be omitted from a generated result.\n\nThis could span from omitting a field from a JSON Schema to omitting a field from a serialized result.\nUpcoming: more robust support for using PydanticOmit in custom serializers is still in development.\nRight now, this is primarily used in the JSON Schema generation process.\n\nExample\n\n```\nfrom typing import Callable\n\nfrom pydantic_core import PydanticOmit\n\nfrom pydantic import BaseModel\nfrom pydantic.json_schema import GenerateJsonSchema, JsonSchemaValue\n\n\nclass MyGenerateJsonSchema(GenerateJsonSchema):\n    def handle_invalid_for_json_schema(self, schema, error_info) -> JsonSchemaValue:\n        raise PydanticOmit\n\n\nclass Predicate(BaseModel):\n    name: str = 'no-op'\n    func: Callable = lambda x: x\n\n\ninstance_example = Predicate()\n\nvalidation_schema = instance_example.model_json_schema(schema_generator=MyGenerateJsonSchema, mode='validation')\nprint(validation_schema)\n'''\n{'properties': {'name': {'default': 'no-op', 'title': 'Name', 'type': 'string'}}, 'title': 'Predicate', 'type': 'object'}\n'''\n```\n\nFor a more in depth example / explanation, see the [customizing JSON schema](../../concepts/json_schema/index.html#customizing-the-json-schema-generation-process) docs.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#pydanticomit-indexhtmlpydanticcorepydanticomit-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "PydanticUseDefault [Â¶](index.html#pydantic_core.PydanticUseDefault \"Permanent link\")", "anchor": "pydanticusedefault-indexhtmlpydanticcorepydanticusedefault-permanent-link", "md_text": "Bases: `Exception`\n\nAn exception to signal that standard validation either failed or should be skipped, and the default value should be used instead.\n\nThis warning can be raised in custom valiation functions to redirect the flow of validation.\n\nExample\n\n```\nfrom pydantic_core import PydanticUseDefault\nfrom datetime import datetime\nfrom pydantic import BaseModel, field_validator\n\n\nclass Event(BaseModel):\n    name: str = 'meeting'\n    time: datetime\n\n    @field_validator('name', mode='plain')\n    def name_must_be_present(cls, v) -> str:\n        if not v or not isinstance(v, str):\n            raise PydanticUseDefault()\n        return v\n\n\nevent1 = Event(name='party', time=datetime(2024, 1, 1, 12, 0, 0))\nprint(repr(event1))\n# > Event(name='party', time=datetime.datetime(2024, 1, 1, 12, 0))\nevent2 = Event(time=datetime(2024, 1, 1, 12, 0, 0))\nprint(repr(event2))\n# > Event(name='meeting', time=datetime.datetime(2024, 1, 1, 12, 0))\n```\n\nFor an additional example, see the [validating partial json data](../../concepts/json/index.html#partial-json-parsing) section of the Pydantic documentation.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#pydanticusedefault-indexhtmlpydanticcorepydanticusedefault-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "PydanticSerializationError [Â¶](index.html#pydantic_core.PydanticSerializationError \"Permanent link\")", "anchor": "pydanticserializationerror-indexhtmlpydanticcorepydanticserializationerror-permanent-link", "md_text": "```\nPydanticSerializationError(message: str)\n```\n\nBases: `ValueError`\n\nAn error raised when an issue occurs during serialization.\n\nIn custom serializers, this error can be used to indicate that serialization has failed.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `message` | `str` | The message associated with the error. | *required* |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#pydanticserializationerror-indexhtmlpydanticcorepydanticserializationerror-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "PydanticSerializationUnexpectedValue [Â¶](index.html#pydantic_core.PydanticSerializationUnexpectedValue \"Permanent link\")", "anchor": "pydanticserializationunexpectedvalue-indexhtmlpydanticcorepydanticserializationunexpectedvalue-permanent-link", "md_text": "```\nPydanticSerializationUnexpectedValue(message: str)\n```\n\nBases: `ValueError`\n\nAn error raised when an unexpected value is encountered during serialization.\n\nThis error is often caught and coerced into a warning, as `pydantic-core` generally makes a best attempt\nat serializing values, in contrast with validation where errors are eagerly raised.\n\nExample\n\n```\nfrom pydantic import BaseModel, field_serializer\nfrom pydantic_core import PydanticSerializationUnexpectedValue\n\nclass BasicPoint(BaseModel):\n    x: int\n    y: int\n\n    @field_serializer('*')\n    def serialize(self, v):\n        if not isinstance(v, int):\n            raise PydanticSerializationUnexpectedValue(f'Expected type `int`, got {type(v)} with value {v}')\n        return v\n\npoint = BasicPoint(x=1, y=2)\n# some sort of mutation\npoint.x = 'a'\n\nprint(point.model_dump())\n'''\nUserWarning: Pydantic serializer warnings:\nPydanticSerializationUnexpectedValue(Expected type `int`, got <class 'str'> with value a)\nreturn self.__pydantic_serializer__.to_python(\n{'x': 'a', 'y': 2}\n'''\n```\n\nThis is often used internally in `pydantic-core` when unexpected types are encountered during serialization,\nbut it can also be used by users in custom serializers, as seen above.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `message` | `str` | The message associated with the unexpected value. | *required* |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#pydanticserializationunexpectedvalue-indexhtmlpydanticcorepydanticserializationunexpectedvalue-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "Url [Â¶](index.html#pydantic_core.Url \"Permanent link\")", "anchor": "url-indexhtmlpydanticcoreurl-permanent-link", "md_text": "```\nUrl(url: str)\n```\n\nBases: `SupportsAllComparisons`\n\nA URL type, internal logic uses the [url rust crate](https://docs.rs/url/latest/url/) originally developed\nby Mozilla.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#url-indexhtmlpydanticcoreurl-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "MultiHostUrl [Â¶](index.html#pydantic_core.MultiHostUrl \"Permanent link\")", "anchor": "multihosturl-indexhtmlpydanticcoremultihosturl-permanent-link", "md_text": "```\nMultiHostUrl(url: str)\n```\n\nBases: `SupportsAllComparisons`\n\nA URL type with support for multiple hosts, as used by some databases for DSNs, e.g. `https://foo.com,bar.com/path`.\n\nInternal URL logic uses the [url rust crate](https://docs.rs/url/latest/url/) originally developed\nby Mozilla.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#multihosturl-indexhtmlpydanticcoremultihosturl-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "MultiHostHost [Â¶](index.html#pydantic_core.MultiHostHost \"Permanent link\")", "anchor": "multihosthost-indexhtmlpydanticcoremultihosthost-permanent-link", "md_text": "Bases: `TypedDict`\n\nA host part of a multi-host URL.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#multihosthost-indexhtmlpydanticcoremultihosthost-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "username `instance-attribute` [Â¶](index.html#pydantic_core.MultiHostHost.username \"Permanent link\")", "anchor": "username-instance-attribute-indexhtmlpydanticcoremultihosthostusername-permanent-link", "md_text": "```\nusername: str | None\n```\n\nThe username part of this host, or `None`.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#username-instance-attribute-indexhtmlpydanticcoremultihosthostusername-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "password `instance-attribute` [Â¶](index.html#pydantic_core.MultiHostHost.password \"Permanent link\")", "anchor": "password-instance-attribute-indexhtmlpydanticcoremultihosthostpassword-permanent-link", "md_text": "```\npassword: str | None\n```\n\nThe password part of this host, or `None`.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#password-instance-attribute-indexhtmlpydanticcoremultihosthostpassword-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "host `instance-attribute` [Â¶](index.html#pydantic_core.MultiHostHost.host \"Permanent link\")", "anchor": "host-instance-attribute-indexhtmlpydanticcoremultihosthosthost-permanent-link", "md_text": "```\nhost: str | None\n```\n\nThe host part of this host, or `None`.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#host-instance-attribute-indexhtmlpydanticcoremultihosthosthost-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "port `instance-attribute` [Â¶](index.html#pydantic_core.MultiHostHost.port \"Permanent link\")", "anchor": "port-instance-attribute-indexhtmlpydanticcoremultihosthostport-permanent-link", "md_text": "```\nport: int | None\n```\n\nThe port part of this host, or `None`.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#port-instance-attribute-indexhtmlpydanticcoremultihosthostport-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "ArgsKwargs [Â¶](index.html#pydantic_core.ArgsKwargs \"Permanent link\")", "anchor": "argskwargs-indexhtmlpydanticcoreargskwargs-permanent-link", "md_text": "```\nArgsKwargs(\n    args: tuple[Any, ...],\n    kwargs: dict[str, Any] | None = None,\n)\n```\n\nA construct used to store arguments and keyword arguments for a function call.\n\nThis data structure is generally used to store information for core schemas associated with functions (like in an arguments schema).\nThis data structure is also currently used for some validation against dataclasses.\n\nExample\n\n```\nfrom pydantic.dataclasses import dataclass\nfrom pydantic import model_validator\n\n\n@dataclass\nclass Model:\n    a: int\n    b: int\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def no_op_validator(cls, values):\n        print(values)\n        return values\n\nModel(1, b=2)\n#> ArgsKwargs((1,), {\"b\": 2})\n\nModel(1, 2)\n#> ArgsKwargs((1, 2), {})\n\nModel(a=1, b=2)\n#> ArgsKwargs((), {\"a\": 1, \"b\": 2})\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `args` | `tuple[Any, ...]` | The arguments (inherently ordered) for a function call. | *required* |\n| `kwargs` | `dict[str, Any] | None` | The keyword arguments for a function call | `None` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#argskwargs-indexhtmlpydanticcoreargskwargs-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "args `property` [Â¶](index.html#pydantic_core.ArgsKwargs.args \"Permanent link\")", "anchor": "args-property-indexhtmlpydanticcoreargskwargsargs-permanent-link", "md_text": "```\nargs: tuple[Any, ...]\n```\n\nThe arguments (inherently ordered) for a function call.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#args-property-indexhtmlpydanticcoreargskwargsargs-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "kwargs `property` [Â¶](index.html#pydantic_core.ArgsKwargs.kwargs \"Permanent link\")", "anchor": "kwargs-property-indexhtmlpydanticcoreargskwargskwargs-permanent-link", "md_text": "```\nkwargs: dict[str, Any] | None\n```\n\nThe keyword arguments for a function call.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#kwargs-property-indexhtmlpydanticcoreargskwargskwargs-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "Some [Â¶](index.html#pydantic_core.Some \"Permanent link\")", "anchor": "some-indexhtmlpydanticcoresome-permanent-link", "md_text": "Bases: `Generic[_T]`\n\nSimilar to Rust's [`Option::Some`](https://doc.rust-lang.org/std/option/enum.Option.html) type, this\nidentifies a value as being present, and provides a way to access it.\n\nGenerally used in a union with `None` to different between \"some value which could be None\" and no value.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#some-indexhtmlpydanticcoresome-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "value `property` [Â¶](index.html#pydantic_core.Some.value \"Permanent link\")", "anchor": "value-property-indexhtmlpydanticcoresomevalue-permanent-link", "md_text": "```\nvalue: _T\n```\n\nReturns the value wrapped by `Some`.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#value-property-indexhtmlpydanticcoresomevalue-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "TzInfo [Â¶](index.html#pydantic_core.TzInfo \"Permanent link\")", "anchor": "tzinfo-indexhtmlpydanticcoretzinfo-permanent-link", "md_text": "```\nTzInfo(seconds: float = 0.0)\n```\n\nBases: `tzinfo`\n\nAn `pydantic-core` implementation of the abstract [`datetime.tzinfo`](https://docs.python.org/3/library/datetime.html#datetime.tzinfo) class.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `seconds` | `float` | The offset from UTC in seconds. Defaults to 0.0 (UTC). | `0.0` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#tzinfo-indexhtmlpydanticcoretzinfo-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "tzname [Â¶](index.html#pydantic_core.TzInfo.tzname \"Permanent link\")", "anchor": "tzname-indexhtmlpydanticcoretzinfotzname-permanent-link", "md_text": "```\ntzname(dt: datetime | None) -> str | None\n```\n\nReturn the time zone name corresponding to the [`datetime`](https://docs.python.org/3/library/datetime.html#datetime.datetime) object *dt*, as a string.\n\nFor more info, see [`tzinfo.tzname`](https://docs.python.org/3/library/datetime.html#datetime.tzinfo.tzname).", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#tzname-indexhtmlpydanticcoretzinfotzname-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "utcoffset [Â¶](index.html#pydantic_core.TzInfo.utcoffset \"Permanent link\")", "anchor": "utcoffset-indexhtmlpydanticcoretzinfoutcoffset-permanent-link", "md_text": "```\nutcoffset(dt: datetime | None) -> timedelta | None\n```\n\nReturn offset of local time from UTC, as a [`timedelta`](https://docs.python.org/3/library/datetime.html#datetime.timedelta) object that is positive east of UTC. If local time is west of UTC, this should be negative.\n\nMore info can be found at [`tzinfo.utcoffset`](https://docs.python.org/3/library/datetime.html#datetime.tzinfo.utcoffset).", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#utcoffset-indexhtmlpydanticcoretzinfoutcoffset-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "dst [Â¶](index.html#pydantic_core.TzInfo.dst \"Permanent link\")", "anchor": "dst-indexhtmlpydanticcoretzinfodst-permanent-link", "md_text": "```\ndst(dt: datetime | None) -> timedelta | None\n```\n\nReturn the daylight saving time (DST) adjustment, as a [`timedelta`](https://docs.python.org/3/library/datetime.html#datetime.timedelta) object or `None` if DST information isnâ€™t known.\n\nMore info can be found at[`tzinfo.dst`](https://docs.python.org/3/library/datetime.html#datetime.tzinfo.dst).", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#dst-indexhtmlpydanticcoretzinfodst-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "fromutc [Â¶](index.html#pydantic_core.TzInfo.fromutc \"Permanent link\")", "anchor": "fromutc-indexhtmlpydanticcoretzinfofromutc-permanent-link", "md_text": "```\nfromutc(dt: datetime) -> datetime\n```\n\nAdjust the date and time data associated datetime object *dt*, returning an equivalent datetime in selfâ€™s local time.\n\nMore info can be found at [`tzinfo.fromutc`](https://docs.python.org/3/library/datetime.html#datetime.tzinfo.fromutc).", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#fromutc-indexhtmlpydanticcoretzinfofromutc-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "ErrorTypeInfo [Â¶](index.html#pydantic_core.ErrorTypeInfo \"Permanent link\")", "anchor": "errortypeinfo-indexhtmlpydanticcoreerrortypeinfo-permanent-link", "md_text": "Bases: `TypedDict`\n\nGives information about errors.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#errortypeinfo-indexhtmlpydanticcoreerrortypeinfo-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "type `instance-attribute` [Â¶](index.html#pydantic_core.ErrorTypeInfo.type \"Permanent link\")", "anchor": "type-instance-attribute-indexhtmlpydanticcoreerrortypeinfotype-permanent-link", "md_text": "```\ntype: ErrorType\n```\n\nThe type of error that occurred, this should be a \"slug\" identifier that changes rarely or never.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#type-instance-attribute-indexhtmlpydanticcoreerrortypeinfotype-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "message\\_template\\_python `instance-attribute` [Â¶](index.html#pydantic_core.ErrorTypeInfo.message_template_python \"Permanent link\")", "anchor": "messagetemplatepython-instance-attribute-indexhtmlpydanticcoreerrortypeinfomessagetemplatepython-permanent-link", "md_text": "```\nmessage_template_python: str\n```\n\nString template to render a human readable error message from using context, when the input is Python.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#messagetemplatepython-instance-attribute-indexhtmlpydanticcoreerrortypeinfomessagetemplatepython-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "example\\_message\\_python `instance-attribute` [Â¶](index.html#pydantic_core.ErrorTypeInfo.example_message_python \"Permanent link\")", "anchor": "examplemessagepython-instance-attribute-indexhtmlpydanticcoreerrortypeinfoexamplemessagepython-permanent-link", "md_text": "```\nexample_message_python: str\n```\n\nExample of a human readable error message, when the input is Python.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#examplemessagepython-instance-attribute-indexhtmlpydanticcoreerrortypeinfoexamplemessagepython-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "message\\_template\\_json `instance-attribute` [Â¶](index.html#pydantic_core.ErrorTypeInfo.message_template_json \"Permanent link\")", "anchor": "messagetemplatejson-instance-attribute-indexhtmlpydanticcoreerrortypeinfomessagetemplatejson-permanent-link", "md_text": "```\nmessage_template_json: NotRequired[str]\n```\n\nString template to render a human readable error message from using context, when the input is JSON data.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#messagetemplatejson-instance-attribute-indexhtmlpydanticcoreerrortypeinfomessagetemplatejson-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "example\\_message\\_json `instance-attribute` [Â¶](index.html#pydantic_core.ErrorTypeInfo.example_message_json \"Permanent link\")", "anchor": "examplemessagejson-instance-attribute-indexhtmlpydanticcoreerrortypeinfoexamplemessagejson-permanent-link", "md_text": "```\nexample_message_json: NotRequired[str]\n```\n\nExample of a human readable error message, when the input is JSON data.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#examplemessagejson-instance-attribute-indexhtmlpydanticcoreerrortypeinfoexamplemessagejson-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "example\\_context `instance-attribute` [Â¶](index.html#pydantic_core.ErrorTypeInfo.example_context \"Permanent link\")", "anchor": "examplecontext-instance-attribute-indexhtmlpydanticcoreerrortypeinfoexamplecontext-permanent-link", "md_text": "```\nexample_context: dict[str, Any] | None\n```\n\nExample of context values.", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#examplecontext-instance-attribute-indexhtmlpydanticcoreerrortypeinfoexamplecontext-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "to\\_json [Â¶](index.html#pydantic_core.to_json \"Permanent link\")", "anchor": "tojson-indexhtmlpydanticcoretojson-permanent-link", "md_text": "```\nto_json(\n    value: Any,\n    *,\n    indent: int | None = None,\n    ensure_ascii: bool = False,\n    include: _IncEx | None = None,\n    exclude: _IncEx | None = None,\n    by_alias: bool = True,\n    exclude_none: bool = False,\n    round_trip: bool = False,\n    timedelta_mode: Literal[\"iso8601\", \"float\"] = \"iso8601\",\n    temporal_mode: Literal[\n        \"iso8601\", \"seconds\", \"milliseconds\"\n    ] = \"iso8601\",\n    bytes_mode: Literal[\"utf8\", \"base64\", \"hex\"] = \"utf8\",\n    inf_nan_mode: Literal[\n        \"null\", \"constants\", \"strings\"\n    ] = \"constants\",\n    serialize_unknown: bool = False,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n    context: Any | None = None\n) -> bytes\n```\n\nSerialize a Python object to JSON including transforming and filtering data.\n\nThis is effectively a standalone version of [`SchemaSerializer.to_json`](index.html#pydantic_core.SchemaSerializer.to_json).\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `value` | `Any` | The Python object to serialize. | *required* |\n| `indent` | `int | None` | If `None`, the JSON will be compact, otherwise it will be pretty-printed with the indent provided. | `None` |\n| `ensure_ascii` | `bool` | If `True`, the output is guaranteed to have all incoming non-ASCII characters escaped. If `False` (the default), these characters will be output as-is. | `False` |\n| `include` | `_IncEx | None` | A set of fields to include, if `None` all fields are included. | `None` |\n| `exclude` | `_IncEx | None` | A set of fields to exclude, if `None` no fields are excluded. | `None` |\n| `by_alias` | `bool` | Whether to use the alias names of fields. | `True` |\n| `exclude_none` | `bool` | Whether to exclude fields that have a value of `None`. | `False` |\n| `round_trip` | `bool` | Whether to enable serialization and validation round-trip support. | `False` |\n| `timedelta_mode` | `Literal['iso8601', 'float']` | How to serialize `timedelta` objects, either `'iso8601'` or `'float'`. | `'iso8601'` |\n| `temporal_mode` | `Literal['iso8601', 'seconds', 'milliseconds']` | How to serialize datetime-like objects (`datetime`, `date`, `time`), either `'iso8601'`, `'seconds'`, or `'milliseconds'`. `iso8601` returns an ISO 8601 string; `seconds` returns the Unix timestamp in seconds as a float; `milliseconds` returns the Unix timestamp in milliseconds as a float. | `'iso8601'` |\n| `bytes_mode` | `Literal['utf8', 'base64', 'hex']` | How to serialize `bytes` objects, either `'utf8'`, `'base64'`, or `'hex'`. | `'utf8'` |\n| `inf_nan_mode` | `Literal['null', 'constants', 'strings']` | How to serialize `Infinity`, `-Infinity` and `NaN` values, either `'null'`, `'constants'`, or `'strings'`. | `'constants'` |\n| `serialize_unknown` | `bool` | Attempt to serialize unknown types, `str(value)` will be used, if that fails `\"<Unserializable {value_type} object>\"` will be used. | `False` |\n| `fallback` | `Callable[[Any], Any] | None` | A function to call when an unknown value is encountered, if `None` a [`PydanticSerializationError`](index.html#pydantic_core.PydanticSerializationError) error is raised. | `None` |\n| `serialize_as_any` | `bool` | Whether to serialize fields with duck-typing serialization behavior. | `False` |\n| `context` | `Any | None` | The context to use for serialization, this is passed to functional serializers as [`info.context`](../pydantic_core_schema/index.html#pydantic_core.core_schema.SerializationInfo.context). | `None` |\n\nRaises:\n\n| Type | Description |\n| --- | --- |\n| `PydanticSerializationError` | If serialization fails and no `fallback` function is provided. |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `bytes` | JSON bytes. |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#tojson-indexhtmlpydanticcoretojson-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "from\\_json [Â¶](index.html#pydantic_core.from_json \"Permanent link\")", "anchor": "fromjson-indexhtmlpydanticcorefromjson-permanent-link", "md_text": "```\nfrom_json(\n    data: str | bytes | bytearray,\n    *,\n    allow_inf_nan: bool = True,\n    cache_strings: (\n        bool | Literal[\"all\", \"keys\", \"none\"]\n    ) = True,\n    allow_partial: (\n        bool | Literal[\"off\", \"on\", \"trailing-strings\"]\n    ) = False\n) -> Any\n```\n\nDeserialize JSON data to a Python object.\n\nThis is effectively a faster version of `json.loads()`, with some extra functionality.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `data` | `str | bytes | bytearray` | The JSON data to deserialize. | *required* |\n| `allow_inf_nan` | `bool` | Whether to allow `Infinity`, `-Infinity` and `NaN` values as `json.loads()` does by default. | `True` |\n| `cache_strings` | `bool | Literal['all', 'keys', 'none']` | Whether to cache strings to avoid constructing new Python objects, this should have a significant impact on performance while increasing memory usage slightly, `all/True` means cache all strings, `keys` means cache only dict keys, `none/False` means no caching. | `True` |\n| `allow_partial` | `bool | Literal['off', 'on', 'trailing-strings']` | Whether to allow partial deserialization, if `True` JSON data is returned if the end of the input is reached before the full object is deserialized, e.g. `[\"aa\", \"bb\", \"c` would return `['aa', 'bb']`. `'trailing-strings'` means any final unfinished JSON string is included in the result. | `False` |\n\nRaises:\n\n| Type | Description |\n| --- | --- |\n| `ValueError` | If deserialization fails. |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `Any` | The deserialized Python object. |", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#fromjson-indexhtmlpydanticcorefromjson-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "to\\_jsonable\\_python [Â¶](index.html#pydantic_core.to_jsonable_python \"Permanent link\")", "anchor": "tojsonablepython-indexhtmlpydanticcoretojsonablepython-permanent-link", "md_text": "```\nto_jsonable_python(\n    value: Any,\n    *,\n    include: _IncEx | None = None,\n    exclude: _IncEx | None = None,\n    by_alias: bool = True,\n    exclude_none: bool = False,\n    round_trip: bool = False,\n    timedelta_mode: Literal[\"iso8601\", \"float\"] = \"iso8601\",\n    temporal_mode: Literal[\n        \"iso8601\", \"seconds\", \"milliseconds\"\n    ] = \"iso8601\",\n    bytes_mode: Literal[\"utf8\", \"base64\", \"hex\"] = \"utf8\",\n    inf_nan_mode: Literal[\n        \"null\", \"constants\", \"strings\"\n    ] = \"constants\",\n    serialize_unknown: bool = False,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n    context: Any | None = None\n) -> Any\n```\n\nSerialize/marshal a Python object to a JSON-serializable Python object including transforming and filtering data.\n\nThis is effectively a standalone version of\n[`SchemaSerializer.to_python(mode='json')`](index.html#pydantic_core.SchemaSerializer.to_python).\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `value` | `Any` | The Python object to serialize. | *required* |\n| `include` | `_IncEx | None` | A set of fields to include, if `None` all fields are included. | `None` |\n| `exclude` | `_IncEx | None` | A set of fields to exclude, if `None` no fields are excluded. | `None` |\n| `by_alias` | `bool` | Whether to use the alias names of fields. | `True` |\n| `exclude_none` | `bool` | Whether to exclude fields that have a value of `None`. | `False` |\n| `round_trip` | `bool` | Whether to enable serialization and validation round-trip support. | `False` |\n| `timedelta_mode` | `Literal['iso8601', 'float']` | How to serialize `timedelta` objects, either `'iso8601'` or `'float'`. | `'iso8601'` |\n| `temporal_mode` | `Literal['iso8601', 'seconds', 'milliseconds']` | How to serialize datetime-like objects (`datetime`, `date`, `time`), either `'iso8601'`, `'seconds'`, or `'milliseconds'`. `iso8601` returns an ISO 8601 string; `seconds` returns the Unix timestamp in seconds as a float; `milliseconds` returns the Unix timestamp in milliseconds as a float. | `'iso8601'` |\n| `bytes_mode` | `Literal['utf8', 'base64', 'hex']` | How to serialize `bytes` objects, either `'utf8'`, `'base64'`, or `'hex'`. | `'utf8'` |\n| `inf_nan_mode` | `Literal['null', 'constants', 'strings']` | How to serialize `Infinity`, `-Infinity` and `NaN` values, either `'null'`, `'constants'`, or `'strings'`. | `'constants'` |\n| `serialize_unknown` | `bool` | Attempt to serialize unknown types, `str(value)` will be used, if that fails `\"<Unserializable {value_type} object>\"` will be used. | `False` |\n| `fallback` | `Callable[[Any], Any] | None` | A function to call when an unknown value is encountered, if `None` a [`PydanticSerializationError`](index.html#pydantic_core.PydanticSerializationError) error is raised. | `None` |\n| `serialize_as_any` | `bool` | Whether to serialize fields with duck-typing serialization behavior. | `False` |\n| `context` | `Any | None` | The context to use for serialization, this is passed to functional serializers as [`info.context`](../pydantic_core_schema/index.html#pydantic_core.core_schema.SerializationInfo.context). | `None` |\n\nRaises:\n\n| Type | Description |\n| --- | --- |\n| `PydanticSerializationError` | If serialization fails and no `fallback` function is provided. |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `Any` | The serialized Python object. |\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/api/pydantic_core/index.html#tojsonablepython-indexhtmlpydanticcoretojsonablepython-permanent-link", "page": "api/pydantic_core/index.html", "source_site": "pydantic"}
{"title": "pydantic.types [Â¶](index.html#pydantic.types \"Permanent link\")", "anchor": "pydantictypes-indexhtmlpydantictypes-permanent-link", "md_text": "The types module contains custom types used by pydantic.", "url": "https://docs.pydantic.dev/latest/api/types/index.html#pydantictypes-indexhtmlpydantictypes-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "StrictBool `module-attribute` [Â¶](index.html#pydantic.types.StrictBool \"Permanent link\")", "anchor": "strictbool-module-attribute-indexhtmlpydantictypesstrictbool-permanent-link", "md_text": "```\nStrictBool = Annotated[bool, Strict()]\n```\n\nA boolean that must be either `True` or `False`.", "url": "https://docs.pydantic.dev/latest/api/types/index.html#strictbool-module-attribute-indexhtmlpydantictypesstrictbool-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "PositiveInt `module-attribute` [Â¶](index.html#pydantic.types.PositiveInt \"Permanent link\")", "anchor": "positiveint-module-attribute-indexhtmlpydantictypespositiveint-permanent-link", "md_text": "```\nPositiveInt = Annotated[int, Gt(0)]\n```\n\nAn integer that must be greater than zero.\n\n```\nfrom pydantic import BaseModel, PositiveInt, ValidationError\n\nclass Model(BaseModel):\n    positive_int: PositiveInt\n\nm = Model(positive_int=1)\nprint(repr(m))\n#> Model(positive_int=1)\n\ntry:\n    Model(positive_int=-1)\nexcept ValidationError as e:\n    print(e.errors())\n    '''\n    [\n        {\n            'type': 'greater_than',\n            'loc': ('positive_int',),\n            'msg': 'Input should be greater than 0',\n            'input': -1,\n            'ctx': {'gt': 0},\n            'url': 'https://errors.pydantic.dev/2/v/greater_than',\n        }\n    ]\n    '''\n```", "url": "https://docs.pydantic.dev/latest/api/types/index.html#positiveint-module-attribute-indexhtmlpydantictypespositiveint-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "NegativeInt `module-attribute` [Â¶](index.html#pydantic.types.NegativeInt \"Permanent link\")", "anchor": "negativeint-module-attribute-indexhtmlpydantictypesnegativeint-permanent-link", "md_text": "```\nNegativeInt = Annotated[int, Lt(0)]\n```\n\nAn integer that must be less than zero.\n\n```\nfrom pydantic import BaseModel, NegativeInt, ValidationError\n\nclass Model(BaseModel):\n    negative_int: NegativeInt\n\nm = Model(negative_int=-1)\nprint(repr(m))\n#> Model(negative_int=-1)\n\ntry:\n    Model(negative_int=1)\nexcept ValidationError as e:\n    print(e.errors())\n    '''\n    [\n        {\n            'type': 'less_than',\n            'loc': ('negative_int',),\n            'msg': 'Input should be less than 0',\n            'input': 1,\n            'ctx': {'lt': 0},\n            'url': 'https://errors.pydantic.dev/2/v/less_than',\n        }\n    ]\n    '''\n```", "url": "https://docs.pydantic.dev/latest/api/types/index.html#negativeint-module-attribute-indexhtmlpydantictypesnegativeint-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "NonPositiveInt `module-attribute` [Â¶](index.html#pydantic.types.NonPositiveInt \"Permanent link\")", "anchor": "nonpositiveint-module-attribute-indexhtmlpydantictypesnonpositiveint-permanent-link", "md_text": "```\nNonPositiveInt = Annotated[int, Le(0)]\n```\n\nAn integer that must be less than or equal to zero.\n\n```\nfrom pydantic import BaseModel, NonPositiveInt, ValidationError\n\nclass Model(BaseModel):\n    non_positive_int: NonPositiveInt\n\nm = Model(non_positive_int=0)\nprint(repr(m))\n#> Model(non_positive_int=0)\n\ntry:\n    Model(non_positive_int=1)\nexcept ValidationError as e:\n    print(e.errors())\n    '''\n    [\n        {\n            'type': 'less_than_equal',\n            'loc': ('non_positive_int',),\n            'msg': 'Input should be less than or equal to 0',\n            'input': 1,\n            'ctx': {'le': 0},\n            'url': 'https://errors.pydantic.dev/2/v/less_than_equal',\n        }\n    ]\n    '''\n```", "url": "https://docs.pydantic.dev/latest/api/types/index.html#nonpositiveint-module-attribute-indexhtmlpydantictypesnonpositiveint-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "NonNegativeInt `module-attribute` [Â¶](index.html#pydantic.types.NonNegativeInt \"Permanent link\")", "anchor": "nonnegativeint-module-attribute-indexhtmlpydantictypesnonnegativeint-permanent-link", "md_text": "```\nNonNegativeInt = Annotated[int, Ge(0)]\n```\n\nAn integer that must be greater than or equal to zero.\n\n```\nfrom pydantic import BaseModel, NonNegativeInt, ValidationError\n\nclass Model(BaseModel):\n    non_negative_int: NonNegativeInt\n\nm = Model(non_negative_int=0)\nprint(repr(m))\n#> Model(non_negative_int=0)\n\ntry:\n    Model(non_negative_int=-1)\nexcept ValidationError as e:\n    print(e.errors())\n    '''\n    [\n        {\n            'type': 'greater_than_equal',\n            'loc': ('non_negative_int',),\n            'msg': 'Input should be greater than or equal to 0',\n            'input': -1,\n            'ctx': {'ge': 0},\n            'url': 'https://errors.pydantic.dev/2/v/greater_than_equal',\n        }\n    ]\n    '''\n```", "url": "https://docs.pydantic.dev/latest/api/types/index.html#nonnegativeint-module-attribute-indexhtmlpydantictypesnonnegativeint-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "StrictInt `module-attribute` [Â¶](index.html#pydantic.types.StrictInt \"Permanent link\")", "anchor": "strictint-module-attribute-indexhtmlpydantictypesstrictint-permanent-link", "md_text": "```\nStrictInt = Annotated[int, Strict()]\n```\n\nAn integer that must be validated in strict mode.\n\n```\nfrom pydantic import BaseModel, StrictInt, ValidationError\n\nclass StrictIntModel(BaseModel):\n    strict_int: StrictInt\n\ntry:\n    StrictIntModel(strict_int=3.14159)\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for StrictIntModel\n    strict_int\n      Input should be a valid integer [type=int_type, input_value=3.14159, input_type=float]\n    '''\n```", "url": "https://docs.pydantic.dev/latest/api/types/index.html#strictint-module-attribute-indexhtmlpydantictypesstrictint-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "PositiveFloat `module-attribute` [Â¶](index.html#pydantic.types.PositiveFloat \"Permanent link\")", "anchor": "positivefloat-module-attribute-indexhtmlpydantictypespositivefloat-permanent-link", "md_text": "```\nPositiveFloat = Annotated[float, Gt(0)]\n```\n\nA float that must be greater than zero.\n\n```\nfrom pydantic import BaseModel, PositiveFloat, ValidationError\n\nclass Model(BaseModel):\n    positive_float: PositiveFloat\n\nm = Model(positive_float=1.0)\nprint(repr(m))\n#> Model(positive_float=1.0)\n\ntry:\n    Model(positive_float=-1.0)\nexcept ValidationError as e:\n    print(e.errors())\n    '''\n    [\n        {\n            'type': 'greater_than',\n            'loc': ('positive_float',),\n            'msg': 'Input should be greater than 0',\n            'input': -1.0,\n            'ctx': {'gt': 0.0},\n            'url': 'https://errors.pydantic.dev/2/v/greater_than',\n        }\n    ]\n    '''\n```", "url": "https://docs.pydantic.dev/latest/api/types/index.html#positivefloat-module-attribute-indexhtmlpydantictypespositivefloat-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "NegativeFloat `module-attribute` [Â¶](index.html#pydantic.types.NegativeFloat \"Permanent link\")", "anchor": "negativefloat-module-attribute-indexhtmlpydantictypesnegativefloat-permanent-link", "md_text": "```\nNegativeFloat = Annotated[float, Lt(0)]\n```\n\nA float that must be less than zero.\n\n```\nfrom pydantic import BaseModel, NegativeFloat, ValidationError\n\nclass Model(BaseModel):\n    negative_float: NegativeFloat\n\nm = Model(negative_float=-1.0)\nprint(repr(m))\n#> Model(negative_float=-1.0)\n\ntry:\n    Model(negative_float=1.0)\nexcept ValidationError as e:\n    print(e.errors())\n    '''\n    [\n        {\n            'type': 'less_than',\n            'loc': ('negative_float',),\n            'msg': 'Input should be less than 0',\n            'input': 1.0,\n            'ctx': {'lt': 0.0},\n            'url': 'https://errors.pydantic.dev/2/v/less_than',\n        }\n    ]\n    '''\n```", "url": "https://docs.pydantic.dev/latest/api/types/index.html#negativefloat-module-attribute-indexhtmlpydantictypesnegativefloat-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "NonPositiveFloat `module-attribute` [Â¶](index.html#pydantic.types.NonPositiveFloat \"Permanent link\")", "anchor": "nonpositivefloat-module-attribute-indexhtmlpydantictypesnonpositivefloat-permanent-link", "md_text": "```\nNonPositiveFloat = Annotated[float, Le(0)]\n```\n\nA float that must be less than or equal to zero.\n\n```\nfrom pydantic import BaseModel, NonPositiveFloat, ValidationError\n\nclass Model(BaseModel):\n    non_positive_float: NonPositiveFloat\n\nm = Model(non_positive_float=0.0)\nprint(repr(m))\n#> Model(non_positive_float=0.0)\n\ntry:\n    Model(non_positive_float=1.0)\nexcept ValidationError as e:\n    print(e.errors())\n    '''\n    [\n        {\n            'type': 'less_than_equal',\n            'loc': ('non_positive_float',),\n            'msg': 'Input should be less than or equal to 0',\n            'input': 1.0,\n            'ctx': {'le': 0.0},\n            'url': 'https://errors.pydantic.dev/2/v/less_than_equal',\n        }\n    ]\n    '''\n```", "url": "https://docs.pydantic.dev/latest/api/types/index.html#nonpositivefloat-module-attribute-indexhtmlpydantictypesnonpositivefloat-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "NonNegativeFloat `module-attribute` [Â¶](index.html#pydantic.types.NonNegativeFloat \"Permanent link\")", "anchor": "nonnegativefloat-module-attribute-indexhtmlpydantictypesnonnegativefloat-permanent-link", "md_text": "```\nNonNegativeFloat = Annotated[float, Ge(0)]\n```\n\nA float that must be greater than or equal to zero.\n\n```\nfrom pydantic import BaseModel, NonNegativeFloat, ValidationError\n\nclass Model(BaseModel):\n    non_negative_float: NonNegativeFloat\n\nm = Model(non_negative_float=0.0)\nprint(repr(m))\n#> Model(non_negative_float=0.0)\n\ntry:\n    Model(non_negative_float=-1.0)\nexcept ValidationError as e:\n    print(e.errors())\n    '''\n    [\n        {\n            'type': 'greater_than_equal',\n            'loc': ('non_negative_float',),\n            'msg': 'Input should be greater than or equal to 0',\n            'input': -1.0,\n            'ctx': {'ge': 0.0},\n            'url': 'https://errors.pydantic.dev/2/v/greater_than_equal',\n        }\n    ]\n    '''\n```", "url": "https://docs.pydantic.dev/latest/api/types/index.html#nonnegativefloat-module-attribute-indexhtmlpydantictypesnonnegativefloat-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "StrictFloat `module-attribute` [Â¶](index.html#pydantic.types.StrictFloat \"Permanent link\")", "anchor": "strictfloat-module-attribute-indexhtmlpydantictypesstrictfloat-permanent-link", "md_text": "```\nStrictFloat = Annotated[float, Strict(True)]\n```\n\nA float that must be validated in strict mode.\n\n```\nfrom pydantic import BaseModel, StrictFloat, ValidationError\n\nclass StrictFloatModel(BaseModel):\n    strict_float: StrictFloat\n\ntry:\n    StrictFloatModel(strict_float='1.0')\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for StrictFloatModel\n    strict_float\n      Input should be a valid number [type=float_type, input_value='1.0', input_type=str]\n    '''\n```", "url": "https://docs.pydantic.dev/latest/api/types/index.html#strictfloat-module-attribute-indexhtmlpydantictypesstrictfloat-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "FiniteFloat `module-attribute` [Â¶](index.html#pydantic.types.FiniteFloat \"Permanent link\")", "anchor": "finitefloat-module-attribute-indexhtmlpydantictypesfinitefloat-permanent-link", "md_text": "```\nFiniteFloat = Annotated[float, AllowInfNan(False)]\n```\n\nA float that must be finite (not `-inf`, `inf`, or `nan`).\n\n```\nfrom pydantic import BaseModel, FiniteFloat\n\nclass Model(BaseModel):\n    finite: FiniteFloat\n\nm = Model(finite=1.0)\nprint(m)\n#> finite=1.0\n```", "url": "https://docs.pydantic.dev/latest/api/types/index.html#finitefloat-module-attribute-indexhtmlpydantictypesfinitefloat-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "StrictBytes `module-attribute` [Â¶](index.html#pydantic.types.StrictBytes \"Permanent link\")", "anchor": "strictbytes-module-attribute-indexhtmlpydantictypesstrictbytes-permanent-link", "md_text": "```\nStrictBytes = Annotated[bytes, Strict()]\n```\n\nA bytes that must be validated in strict mode.", "url": "https://docs.pydantic.dev/latest/api/types/index.html#strictbytes-module-attribute-indexhtmlpydantictypesstrictbytes-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "StrictStr `module-attribute` [Â¶](index.html#pydantic.types.StrictStr \"Permanent link\")", "anchor": "strictstr-module-attribute-indexhtmlpydantictypesstrictstr-permanent-link", "md_text": "```\nStrictStr = Annotated[str, Strict()]\n```\n\nA string that must be validated in strict mode.", "url": "https://docs.pydantic.dev/latest/api/types/index.html#strictstr-module-attribute-indexhtmlpydantictypesstrictstr-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "UUID1 `module-attribute` [Â¶](index.html#pydantic.types.UUID1 \"Permanent link\")", "anchor": "uuid1-module-attribute-indexhtmlpydantictypesuuid1-permanent-link", "md_text": "```\nUUID1 = Annotated[UUID, UuidVersion(1)]\n```\n\nA [UUID](https://docs.python.org/3/library/uuid.html) that must be version 1.\n\n```\nimport uuid\n\nfrom pydantic import UUID1, BaseModel\n\nclass Model(BaseModel):\n    uuid1: UUID1\n\nModel(uuid1=uuid.uuid1())\n```", "url": "https://docs.pydantic.dev/latest/api/types/index.html#uuid1-module-attribute-indexhtmlpydantictypesuuid1-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "UUID3 `module-attribute` [Â¶](index.html#pydantic.types.UUID3 \"Permanent link\")", "anchor": "uuid3-module-attribute-indexhtmlpydantictypesuuid3-permanent-link", "md_text": "```\nUUID3 = Annotated[UUID, UuidVersion(3)]\n```\n\nA [UUID](https://docs.python.org/3/library/uuid.html) that must be version 3.\n\n```\nimport uuid\n\nfrom pydantic import UUID3, BaseModel\n\nclass Model(BaseModel):\n    uuid3: UUID3\n\nModel(uuid3=uuid.uuid3(uuid.NAMESPACE_DNS, 'pydantic.org'))\n```", "url": "https://docs.pydantic.dev/latest/api/types/index.html#uuid3-module-attribute-indexhtmlpydantictypesuuid3-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "UUID4 `module-attribute` [Â¶](index.html#pydantic.types.UUID4 \"Permanent link\")", "anchor": "uuid4-module-attribute-indexhtmlpydantictypesuuid4-permanent-link", "md_text": "```\nUUID4 = Annotated[UUID, UuidVersion(4)]\n```\n\nA [UUID](https://docs.python.org/3/library/uuid.html) that must be version 4.\n\n```\nimport uuid\n\nfrom pydantic import UUID4, BaseModel\n\nclass Model(BaseModel):\n    uuid4: UUID4\n\nModel(uuid4=uuid.uuid4())\n```", "url": "https://docs.pydantic.dev/latest/api/types/index.html#uuid4-module-attribute-indexhtmlpydantictypesuuid4-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "UUID5 `module-attribute` [Â¶](index.html#pydantic.types.UUID5 \"Permanent link\")", "anchor": "uuid5-module-attribute-indexhtmlpydantictypesuuid5-permanent-link", "md_text": "```\nUUID5 = Annotated[UUID, UuidVersion(5)]\n```\n\nA [UUID](https://docs.python.org/3/library/uuid.html) that must be version 5.\n\n```\nimport uuid\n\nfrom pydantic import UUID5, BaseModel\n\nclass Model(BaseModel):\n    uuid5: UUID5\n\nModel(uuid5=uuid.uuid5(uuid.NAMESPACE_DNS, 'pydantic.org'))\n```", "url": "https://docs.pydantic.dev/latest/api/types/index.html#uuid5-module-attribute-indexhtmlpydantictypesuuid5-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "UUID6 `module-attribute` [Â¶](index.html#pydantic.types.UUID6 \"Permanent link\")", "anchor": "uuid6-module-attribute-indexhtmlpydantictypesuuid6-permanent-link", "md_text": "```\nUUID6 = Annotated[UUID, UuidVersion(6)]\n```\n\nA [UUID](https://docs.python.org/3/library/uuid.html) that must be version 6.\n\n```\nimport uuid\n\nfrom pydantic import UUID6, BaseModel\n\nclass Model(BaseModel):\n    uuid6: UUID6\n\nModel(uuid6=uuid.UUID('1efea953-c2d6-6790-aa0a-69db8c87df97'))\n```", "url": "https://docs.pydantic.dev/latest/api/types/index.html#uuid6-module-attribute-indexhtmlpydantictypesuuid6-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "UUID7 `module-attribute` [Â¶](index.html#pydantic.types.UUID7 \"Permanent link\")", "anchor": "uuid7-module-attribute-indexhtmlpydantictypesuuid7-permanent-link", "md_text": "```\nUUID7 = Annotated[UUID, UuidVersion(7)]\n```\n\nA [UUID](https://docs.python.org/3/library/uuid.html) that must be version 7.\n\n```\nimport uuid\n\nfrom pydantic import UUID7, BaseModel\n\nclass Model(BaseModel):\n    uuid7: UUID7\n\nModel(uuid7=uuid.UUID('0194fdcb-1c47-7a09-b52c-561154de0b4a'))\n```", "url": "https://docs.pydantic.dev/latest/api/types/index.html#uuid7-module-attribute-indexhtmlpydantictypesuuid7-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "UUID8 `module-attribute` [Â¶](index.html#pydantic.types.UUID8 \"Permanent link\")", "anchor": "uuid8-module-attribute-indexhtmlpydantictypesuuid8-permanent-link", "md_text": "```\nUUID8 = Annotated[UUID, UuidVersion(8)]\n```\n\nA [UUID](https://docs.python.org/3/library/uuid.html) that must be version 8.\n\n```\nimport uuid\n\nfrom pydantic import UUID8, BaseModel\n\nclass Model(BaseModel):\n    uuid8: UUID8\n\nModel(uuid8=uuid.UUID('81a0b92e-6078-8551-9c81-8ccb666bdab8'))\n```", "url": "https://docs.pydantic.dev/latest/api/types/index.html#uuid8-module-attribute-indexhtmlpydantictypesuuid8-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "FilePath `module-attribute` [Â¶](index.html#pydantic.types.FilePath \"Permanent link\")", "anchor": "filepath-module-attribute-indexhtmlpydantictypesfilepath-permanent-link", "md_text": "```\nFilePath = Annotated[Path, PathType('file')]\n```\n\nA path that must point to a file.\n\n```\nfrom pathlib import Path\n\nfrom pydantic import BaseModel, FilePath, ValidationError\n\nclass Model(BaseModel):\n    f: FilePath\n\npath = Path('text.txt')\npath.touch()\nm = Model(f='text.txt')\nprint(m.model_dump())\n#> {'f': PosixPath('text.txt')}\npath.unlink()\n\npath = Path('directory')\npath.mkdir(exist_ok=True)\ntry:\n    Model(f='directory')  # directory\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for Model\n    f\n      Path does not point to a file [type=path_not_file, input_value='directory', input_type=str]\n    '''\npath.rmdir()\n\ntry:\n    Model(f='not-exists-file')\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for Model\n    f\n      Path does not point to a file [type=path_not_file, input_value='not-exists-file', input_type=str]\n    '''\n```", "url": "https://docs.pydantic.dev/latest/api/types/index.html#filepath-module-attribute-indexhtmlpydantictypesfilepath-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "DirectoryPath `module-attribute` [Â¶](index.html#pydantic.types.DirectoryPath \"Permanent link\")", "anchor": "directorypath-module-attribute-indexhtmlpydantictypesdirectorypath-permanent-link", "md_text": "```\nDirectoryPath = Annotated[Path, PathType('dir')]\n```\n\nA path that must point to a directory.\n\n```\nfrom pathlib import Path\n\nfrom pydantic import BaseModel, DirectoryPath, ValidationError\n\nclass Model(BaseModel):\n    f: DirectoryPath\n\npath = Path('directory/')\npath.mkdir()\nm = Model(f='directory/')\nprint(m.model_dump())\n#> {'f': PosixPath('directory')}\npath.rmdir()\n\npath = Path('file.txt')\npath.touch()\ntry:\n    Model(f='file.txt')  # file\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for Model\n    f\n      Path does not point to a directory [type=path_not_directory, input_value='file.txt', input_type=str]\n    '''\npath.unlink()\n\ntry:\n    Model(f='not-exists-directory')\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for Model\n    f\n      Path does not point to a directory [type=path_not_directory, input_value='not-exists-directory', input_type=str]\n    '''\n```", "url": "https://docs.pydantic.dev/latest/api/types/index.html#directorypath-module-attribute-indexhtmlpydantictypesdirectorypath-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "NewPath `module-attribute` [Â¶](index.html#pydantic.types.NewPath \"Permanent link\")", "anchor": "newpath-module-attribute-indexhtmlpydantictypesnewpath-permanent-link", "md_text": "```\nNewPath = Annotated[Path, PathType('new')]\n```\n\nA path for a new file or directory that must not already exist. The parent directory must already exist.", "url": "https://docs.pydantic.dev/latest/api/types/index.html#newpath-module-attribute-indexhtmlpydantictypesnewpath-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "SocketPath `module-attribute` [Â¶](index.html#pydantic.types.SocketPath \"Permanent link\")", "anchor": "socketpath-module-attribute-indexhtmlpydantictypessocketpath-permanent-link", "md_text": "```\nSocketPath = Annotated[Path, PathType('socket')]\n```\n\nA path to an existing socket file", "url": "https://docs.pydantic.dev/latest/api/types/index.html#socketpath-module-attribute-indexhtmlpydantictypessocketpath-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "Base64Bytes `module-attribute` [Â¶](index.html#pydantic.types.Base64Bytes \"Permanent link\")", "anchor": "base64bytes-module-attribute-indexhtmlpydantictypesbase64bytes-permanent-link", "md_text": "```\nBase64Bytes = Annotated[\n    bytes, EncodedBytes(encoder=Base64Encoder)\n]\n```\n\nA bytes type that is encoded and decoded using the standard (non-URL-safe) base64 encoder.\n\nNote\n\nUnder the hood, `Base64Bytes` uses the standard library `base64.b64encode` and `base64.b64decode` functions.\n\nAs a result, attempting to decode url-safe base64 data using the `Base64Bytes` type may fail or produce an incorrect\ndecoding.\n\n\nWarning\n\nIn versions of Pydantic prior to v2.10, `Base64Bytes` used [`base64.encodebytes`](https://docs.python.org/3/library/base64.html#base64.encodebytes)\nand [`base64.decodebytes`](https://docs.python.org/3/library/base64.html#base64.decodebytes) functions. According to the [base64 documentation](https://docs.python.org/3/library/base64.html),\nthese methods are considered legacy implementation, and thus, Pydantic v2.10+ now uses the modern\n[`base64.b64encode`](https://docs.python.org/3/library/base64.html#base64.b64encode) and [`base64.b64decode`](https://docs.python.org/3/library/base64.html#base64.b64decode) functions.\n\nIf you'd still like to use these legacy encoders / decoders, you can achieve this by creating a custom annotated type,\nlike follows:\n\n```\nimport base64\nfrom typing import Annotated, Literal\n\nfrom pydantic_core import PydanticCustomError\n\nfrom pydantic import EncodedBytes, EncoderProtocol\n\nclass LegacyBase64Encoder(EncoderProtocol):\n    @classmethod\n    def decode(cls, data: bytes) -> bytes:\n        try:\n            return base64.decodebytes(data)\n        except ValueError as e:\n            raise PydanticCustomError(\n                'base64_decode',\n                \"Base64 decoding error: '{error}'\",\n                {'error': str(e)},\n            )\n\n    @classmethod\n    def encode(cls, value: bytes) -> bytes:\n        return base64.encodebytes(value)\n\n    @classmethod\n    def get_json_format(cls) -> Literal['base64']:\n        return 'base64'\n\nLegacyBase64Bytes = Annotated[bytes, EncodedBytes(encoder=LegacyBase64Encoder)]\n\nfrom pydantic import Base64Bytes, BaseModel, ValidationError\n\nclass Model(BaseModel):\n    base64_bytes: Base64Bytes\n\n# Initialize the model with base64 data\nm = Model(base64_bytes=b'VGhpcyBpcyB0aGUgd2F5')\n\n# Access decoded value\nprint(m.base64_bytes)\n#> b'This is the way'\n\n# Serialize into the base64 form\nprint(m.model_dump())\n#> {'base64_bytes': b'VGhpcyBpcyB0aGUgd2F5'}\n\n# Validate base64 data\ntry:\n    print(Model(base64_bytes=b'undecodable').base64_bytes)\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for Model\n    base64_bytes\n      Base64 decoding error: 'Incorrect padding' [type=base64_decode, input_value=b'undecodable', input_type=bytes]\n    '''\n```", "url": "https://docs.pydantic.dev/latest/api/types/index.html#base64bytes-module-attribute-indexhtmlpydantictypesbase64bytes-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "Base64Str `module-attribute` [Â¶](index.html#pydantic.types.Base64Str \"Permanent link\")", "anchor": "base64str-module-attribute-indexhtmlpydantictypesbase64str-permanent-link", "md_text": "```\nBase64Str = Annotated[\n    str, EncodedStr(encoder=Base64Encoder)\n]\n```\n\nA str type that is encoded and decoded using the standard (non-URL-safe) base64 encoder.\n\nNote\n\nUnder the hood, `Base64Str` uses the standard library `base64.b64encode` and `base64.b64decode` functions.\n\nAs a result, attempting to decode url-safe base64 data using the `Base64Str` type may fail or produce an incorrect\ndecoding.\n\n\nWarning\n\nIn versions of Pydantic prior to v2.10, `Base64Str` used [`base64.encodebytes`](https://docs.python.org/3/library/base64.html#base64.encodebytes)\nand [`base64.decodebytes`](https://docs.python.org/3/library/base64.html#base64.decodebytes) functions. According to the [base64 documentation](https://docs.python.org/3/library/base64.html),\nthese methods are considered legacy implementation, and thus, Pydantic v2.10+ now uses the modern\n[`base64.b64encode`](https://docs.python.org/3/library/base64.html#base64.b64encode) and [`base64.b64decode`](https://docs.python.org/3/library/base64.html#base64.b64decode) functions.\n\nSee the [`Base64Bytes`](index.html#pydantic.types.Base64Bytes) type for more information on how to\nreplicate the old behavior with the legacy encoders / decoders.\n\n```\nfrom pydantic import Base64Str, BaseModel, ValidationError\n\nclass Model(BaseModel):\n    base64_str: Base64Str\n\n# Initialize the model with base64 data\nm = Model(base64_str='VGhlc2UgYXJlbid0IHRoZSBkcm9pZHMgeW91J3JlIGxvb2tpbmcgZm9y')\n\n# Access decoded value\nprint(m.base64_str)\n#> These aren't the droids you're looking for\n\n# Serialize into the base64 form\nprint(m.model_dump())\n#> {'base64_str': 'VGhlc2UgYXJlbid0IHRoZSBkcm9pZHMgeW91J3JlIGxvb2tpbmcgZm9y'}\n\n# Validate base64 data\ntry:\n    print(Model(base64_str='undecodable').base64_str)\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for Model\n    base64_str\n      Base64 decoding error: 'Incorrect padding' [type=base64_decode, input_value='undecodable', input_type=str]\n    '''\n```", "url": "https://docs.pydantic.dev/latest/api/types/index.html#base64str-module-attribute-indexhtmlpydantictypesbase64str-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "Base64UrlBytes `module-attribute` [Â¶](index.html#pydantic.types.Base64UrlBytes \"Permanent link\")", "anchor": "base64urlbytes-module-attribute-indexhtmlpydantictypesbase64urlbytes-permanent-link", "md_text": "```\nBase64UrlBytes = Annotated[\n    bytes, EncodedBytes(encoder=Base64UrlEncoder)\n]\n```\n\nA bytes type that is encoded and decoded using the URL-safe base64 encoder.\n\nNote\n\nUnder the hood, `Base64UrlBytes` use standard library `base64.urlsafe_b64encode` and `base64.urlsafe_b64decode`\nfunctions.\n\nAs a result, the `Base64UrlBytes` type can be used to faithfully decode \"vanilla\" base64 data\n(using `'+'` and `'/'`).\n\n```\nfrom pydantic import Base64UrlBytes, BaseModel\n\nclass Model(BaseModel):\n    base64url_bytes: Base64UrlBytes\n\n# Initialize the model with base64 data\nm = Model(base64url_bytes=b'SHc_dHc-TXc==')\nprint(m)\n#> base64url_bytes=b'Hw?tw>Mw'\n```", "url": "https://docs.pydantic.dev/latest/api/types/index.html#base64urlbytes-module-attribute-indexhtmlpydantictypesbase64urlbytes-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "Base64UrlStr `module-attribute` [Â¶](index.html#pydantic.types.Base64UrlStr \"Permanent link\")", "anchor": "base64urlstr-module-attribute-indexhtmlpydantictypesbase64urlstr-permanent-link", "md_text": "```\nBase64UrlStr = Annotated[\n    str, EncodedStr(encoder=Base64UrlEncoder)\n]\n```\n\nA str type that is encoded and decoded using the URL-safe base64 encoder.\n\nNote\n\nUnder the hood, `Base64UrlStr` use standard library `base64.urlsafe_b64encode` and `base64.urlsafe_b64decode`\nfunctions.\n\nAs a result, the `Base64UrlStr` type can be used to faithfully decode \"vanilla\" base64 data (using `'+'` and `'/'`).\n\n```\nfrom pydantic import Base64UrlStr, BaseModel\n\nclass Model(BaseModel):\n    base64url_str: Base64UrlStr\n\n# Initialize the model with base64 data\nm = Model(base64url_str='SHc_dHc-TXc==')\nprint(m)\n#> base64url_str='Hw?tw>Mw'\n```", "url": "https://docs.pydantic.dev/latest/api/types/index.html#base64urlstr-module-attribute-indexhtmlpydantictypesbase64urlstr-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "JsonValue `module-attribute` [Â¶](index.html#pydantic.types.JsonValue \"Permanent link\")", "anchor": "jsonvalue-module-attribute-indexhtmlpydantictypesjsonvalue-permanent-link", "md_text": "```\nJsonValue: TypeAlias = Union[\n    list[\"JsonValue\"],\n    dict[str, \"JsonValue\"],\n    str,\n    bool,\n    int,\n    float,\n    None,\n]\n```\n\nA `JsonValue` is used to represent a value that can be serialized to JSON.\n\nIt may be one of:\n\n* `list['JsonValue']`\n* `dict[str, 'JsonValue']`\n* `str`\n* `bool`\n* `int`\n* `float`\n* `None`\n\nThe following example demonstrates how to use `JsonValue` to validate JSON data,\nand what kind of errors to expect when input data is not json serializable.\n\n```\nimport json\n\nfrom pydantic import BaseModel, JsonValue, ValidationError\n\nclass Model(BaseModel):\n    j: JsonValue\n\nvalid_json_data = {'j': {'a': {'b': {'c': 1, 'd': [2, None]}}}}\ninvalid_json_data = {'j': {'a': {'b': ...}}}\n\nprint(repr(Model.model_validate(valid_json_data)))\n#> Model(j={'a': {'b': {'c': 1, 'd': [2, None]}}})\nprint(repr(Model.model_validate_json(json.dumps(valid_json_data))))\n#> Model(j={'a': {'b': {'c': 1, 'd': [2, None]}}})\n\ntry:\n    Model.model_validate(invalid_json_data)\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for Model\n    j.dict.a.dict.b\n      input was not a valid JSON value [type=invalid-json-value, input_value=Ellipsis, input_type=ellipsis]\n    '''\n```", "url": "https://docs.pydantic.dev/latest/api/types/index.html#jsonvalue-module-attribute-indexhtmlpydantictypesjsonvalue-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "OnErrorOmit `module-attribute` [Â¶](index.html#pydantic.types.OnErrorOmit \"Permanent link\")", "anchor": "onerroromit-module-attribute-indexhtmlpydantictypesonerroromit-permanent-link", "md_text": "```\nOnErrorOmit = Annotated[T, _OnErrorOmit]\n```\n\nWhen used as an item in a list, the key type in a dict, optional values of a TypedDict, etc.\nthis annotation omits the item from the iteration if there is any error validating it.\nThat is, instead of a [`ValidationError`](../pydantic_core/index.html#pydantic_core.ValidationError) being propagated up and the entire iterable being discarded\nany invalid items are discarded and the valid ones are returned.", "url": "https://docs.pydantic.dev/latest/api/types/index.html#onerroromit-module-attribute-indexhtmlpydantictypesonerroromit-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "Strict `dataclass` [Â¶](index.html#pydantic.types.Strict \"Permanent link\")", "anchor": "strict-dataclass-indexhtmlpydantictypesstrict-permanent-link", "md_text": "Bases: `PydanticMetadata`, `BaseMetadata`\n\n[Strict Mode with `Annotated` `Strict`](../../concepts/strict_mode/index.html#strict-mode-with-annotated-strict)\n\nA field metadata class to indicate that a field should be validated in strict mode.\nUse this class as an annotation via [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated), as seen below.\n\nAttributes:\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `strict` | `bool` | Whether to validate the field in strict mode. |\n\nExample\n\n```\nfrom typing import Annotated\n\nfrom pydantic.types import Strict\n\nStrictBool = Annotated[bool, Strict()]\n```\n\n\nSource code in `pydantic/types.py`\n\n|  |  |\n| --- | --- |\n| ``` 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 ``` | ``` @_dataclasses.dataclass class Strict(_fields.PydanticMetadata, BaseMetadata):     \"\"\"!!! abstract \"Usage Documentation\"         [Strict Mode with `Annotated` `Strict`](../concepts/strict_mode.md#strict-mode-with-annotated-strict)      A field metadata class to indicate that a field should be validated in strict mode.     Use this class as an annotation via [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated), as seen below.      Attributes:         strict: Whether to validate the field in strict mode.      Example:         ```python         from typing import Annotated          from pydantic.types import Strict          StrictBool = Annotated[bool, Strict()]         ```     \"\"\"      strict: bool = True      def __hash__(self) -> int:         return hash(self.strict) ``` |", "url": "https://docs.pydantic.dev/latest/api/types/index.html#strict-dataclass-indexhtmlpydantictypesstrict-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "AllowInfNan `dataclass` [Â¶](index.html#pydantic.types.AllowInfNan \"Permanent link\")", "anchor": "allowinfnan-dataclass-indexhtmlpydantictypesallowinfnan-permanent-link", "md_text": "Bases: `PydanticMetadata`\n\nA field metadata class to indicate that a field should allow `-inf`, `inf`, and `nan`.\n\nUse this class as an annotation via [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated), as seen below.\n\nAttributes:\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `allow_inf_nan` | `bool` | Whether to allow `-inf`, `inf`, and `nan`. Defaults to `True`. |\n\nExample\n\n```\nfrom typing import Annotated\n\nfrom pydantic.types import AllowInfNan\n\nLaxFloat = Annotated[float, AllowInfNan()]\n```\n\n\nSource code in `pydantic/types.py`\n\n|  |  |\n| --- | --- |\n| ``` 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 ``` | ``` @_dataclasses.dataclass class AllowInfNan(_fields.PydanticMetadata):     \"\"\"A field metadata class to indicate that a field should allow `-inf`, `inf`, and `nan`.      Use this class as an annotation via [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated), as seen below.      Attributes:         allow_inf_nan: Whether to allow `-inf`, `inf`, and `nan`. Defaults to `True`.      Example:         ```python         from typing import Annotated          from pydantic.types import AllowInfNan          LaxFloat = Annotated[float, AllowInfNan()]         ```     \"\"\"      allow_inf_nan: bool = True      def __hash__(self) -> int:         return hash(self.allow_inf_nan) ``` |", "url": "https://docs.pydantic.dev/latest/api/types/index.html#allowinfnan-dataclass-indexhtmlpydantictypesallowinfnan-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "StringConstraints `dataclass` [Â¶](index.html#pydantic.types.StringConstraints \"Permanent link\")", "anchor": "stringconstraints-dataclass-indexhtmlpydantictypesstringconstraints-permanent-link", "md_text": "Bases: `GroupedMetadata`\n\n[String types](../standard_library_types/index.html#strings)\n\nA field metadata class to apply constraints to `str` types.\nUse this class as an annotation via [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated), as seen below.\n\nAttributes:\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `strip_whitespace` | `bool | None` | Whether to remove leading and trailing whitespace. |\n| `to_upper` | `bool | None` | Whether to convert the string to uppercase. |\n| `to_lower` | `bool | None` | Whether to convert the string to lowercase. |\n| `strict` | `bool | None` | Whether to validate the string in strict mode. |\n| `min_length` | `int | None` | The minimum length of the string. |\n| `max_length` | `int | None` | The maximum length of the string. |\n| `pattern` | `str | Pattern[str] | None` | A regex pattern that the string must match. |\n\nExample\n\n```\nfrom typing import Annotated\n\nfrom pydantic.types import StringConstraints\n\nConstrainedStr = Annotated[str, StringConstraints(min_length=1, max_length=10)]\n```\n\n\nSource code in `pydantic/types.py`\n\n|  |  |\n| --- | --- |\n| ``` 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 ``` | ``` @_dataclasses.dataclass(frozen=True) class StringConstraints(annotated_types.GroupedMetadata):     \"\"\"!!! abstract \"Usage Documentation\"         [String types](./standard_library_types.md#strings)      A field metadata class to apply constraints to `str` types.     Use this class as an annotation via [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated), as seen below.      Attributes:         strip_whitespace: Whether to remove leading and trailing whitespace.         to_upper: Whether to convert the string to uppercase.         to_lower: Whether to convert the string to lowercase.         strict: Whether to validate the string in strict mode.         min_length: The minimum length of the string.         max_length: The maximum length of the string.         pattern: A regex pattern that the string must match.      Example:         ```python         from typing import Annotated          from pydantic.types import StringConstraints          ConstrainedStr = Annotated[str, StringConstraints(min_length=1, max_length=10)]         ```     \"\"\"      strip_whitespace: bool | None = None     to_upper: bool | None = None     to_lower: bool | None = None     strict: bool | None = None     min_length: int | None = None     max_length: int | None = None     pattern: str | Pattern[str] | None = None      def __iter__(self) -> Iterator[BaseMetadata]:         if self.min_length is not None:             yield MinLen(self.min_length)         if self.max_length is not None:             yield MaxLen(self.max_length)         if self.strict is not None:             yield Strict(self.strict)         if (             self.strip_whitespace is not None             or self.pattern is not None             or self.to_lower is not None             or self.to_upper is not None         ):             yield _fields.pydantic_general_metadata(                 strip_whitespace=self.strip_whitespace,                 to_upper=self.to_upper,                 to_lower=self.to_lower,                 pattern=self.pattern,             ) ``` |", "url": "https://docs.pydantic.dev/latest/api/types/index.html#stringconstraints-dataclass-indexhtmlpydantictypesstringconstraints-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "ImportString [Â¶](index.html#pydantic.types.ImportString \"Permanent link\")", "anchor": "importstring-indexhtmlpydantictypesimportstring-permanent-link", "md_text": "A type that can be used to import a Python object from a string.\n\n`ImportString` expects a string and loads the Python object importable at that dotted path.\nAttributes of modules may be separated from the module by `:` or `.`, e.g. if `'math:cos'` is provided,\nthe resulting field value would be the function `cos`. If a `.` is used and both an attribute and submodule\nare present at the same path, the module will be preferred.\n\nOn model instantiation, pointers will be evaluated and imported. There is\nsome nuance to this behavior, demonstrated in the examples below.\n\n```\nimport math\n\nfrom pydantic import BaseModel, Field, ImportString, ValidationError\n\nclass ImportThings(BaseModel):\n    obj: ImportString\n\n# A string value will cause an automatic import\nmy_cos = ImportThings(obj='math.cos')\n\n# You can use the imported function as you would expect\ncos_of_0 = my_cos.obj(0)\nassert cos_of_0 == 1\n\n# A string whose value cannot be imported will raise an error\ntry:\n    ImportThings(obj='foo.bar')\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for ImportThings\n    obj\n      Invalid python path: No module named 'foo.bar' [type=import_error, input_value='foo.bar', input_type=str]\n    '''\n\n# Actual python objects can be assigned as well\nmy_cos = ImportThings(obj=math.cos)\nmy_cos_2 = ImportThings(obj='math.cos')\nmy_cos_3 = ImportThings(obj='math:cos')\nassert my_cos == my_cos_2 == my_cos_3\n\n# You can set default field value either as Python object:\nclass ImportThingsDefaultPyObj(BaseModel):\n    obj: ImportString = math.cos\n\n# or as a string value (but only if used with `validate_default=True`)\nclass ImportThingsDefaultString(BaseModel):\n    obj: ImportString = Field(default='math.cos', validate_default=True)\n\nmy_cos_default1 = ImportThingsDefaultPyObj()\nmy_cos_default2 = ImportThingsDefaultString()\nassert my_cos_default1.obj == my_cos_default2.obj == math.cos\n\n# note: this will not work!\nclass ImportThingsMissingValidateDefault(BaseModel):\n    obj: ImportString = 'math.cos'\n\nmy_cos_default3 = ImportThingsMissingValidateDefault()\nassert my_cos_default3.obj == 'math.cos'  # just string, not evaluated\n```\n\nSerializing an `ImportString` type to json is also possible.\n\n```\nfrom pydantic import BaseModel, ImportString\n\nclass ImportThings(BaseModel):\n    obj: ImportString\n\n# Create an instance\nm = ImportThings(obj='math.cos')\nprint(m)\n#> obj=<built-in function cos>\nprint(m.model_dump_json())\n#> {\"obj\":\"math.cos\"}\n```\n\nSource code in `pydantic/types.py`", "url": "https://docs.pydantic.dev/latest/api/types/index.html#importstring-indexhtmlpydantictypesimportstring-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "ImportString [Â¶](index.html#pydantic.types.ImportString \"Permanent link\")", "anchor": "importstring-indexhtmlpydantictypesimportstring-permanent-link", "md_text": "|  |  |\n| --- | --- |\n| ```  913  914  915  916  917  918  919  920  921  922  923  924  925  926  927  928  929  930  931  932  933  934  935  936  937  938  939  940  941  942  943  944  945  946  947  948  949  950  951  952  953  954  955  956  957  958  959  960  961  962  963  964  965  966  967  968  969  970  971  972  973  974  975  976  977  978  979  980  981  982  983  984  985  986  987  988  989  990  991  992  993  994  995  996  997  998  999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 ``` | ``` class ImportString:     \"\"\"A type that can be used to import a Python object from a string.      `ImportString` expects a string and loads the Python object importable at that dotted path.     Attributes of modules may be separated from the module by `:` or `.`, e.g. if `'math:cos'` is provided,     the resulting field value would be the function `cos`. If a `.` is used and both an attribute and submodule     are present at the same path, the module will be preferred.      On model instantiation, pointers will be evaluated and imported. There is     some nuance to this behavior, demonstrated in the examples below.      ```python     import math      from pydantic import BaseModel, Field, ImportString, ValidationError      class ImportThings(BaseModel):         obj: ImportString      # A string value will cause an automatic import     my_cos = ImportThings(obj='math.cos')      # You can use the imported function as you would expect     cos_of_0 = my_cos.obj(0)     assert cos_of_0 == 1      # A string whose value cannot be imported will raise an error     try:         ImportThings(obj='foo.bar')     except ValidationError as e:         print(e)         '''         1 validation error for ImportThings         obj           Invalid python path: No module named 'foo.bar' [type=import_error, input_value='foo.bar', input_type=str]         '''      # Actual python objects can be assigned as well     my_cos = ImportThings(obj=math.cos)     my_cos_2 = ImportThings(obj='math.cos')     my_cos_3 = ImportThings(obj='math:cos')     assert my_cos == my_cos_2 == my_cos_3      # You can set default field value either as Python object:     class ImportThingsDefaultPyObj(BaseModel):         obj: ImportString = math.cos      # or as a string value (but only if used with `validate_default=True`)     class ImportThingsDefaultString(BaseModel):         obj: ImportString = Field(default='math.cos', validate_default=True)      my_cos_default1 = ImportThingsDefaultPyObj()     my_cos_default2 = ImportThingsDefaultString()     assert my_cos_default1.obj == my_cos_default2.obj == math.cos      # note: this will not work!     class ImportThingsMissingValidateDefault(BaseModel):         obj: ImportString = 'math.cos'      my_cos_default3 = ImportThingsMissingValidateDefault()     assert my_cos_default3.obj == 'math.cos'  # just string, not evaluated     ```      Serializing an `ImportString` type to json is also possible.      ```python     from pydantic import BaseModel, ImportString      class ImportThings(BaseModel):         obj: ImportString      # Create an instance     m = ImportThings(obj='math.cos')     print(m)     #> obj=<built-in function cos>     print(m.model_dump_json())     #> {\"obj\":\"math.cos\"}     ```     \"\"\"      @classmethod     def __class_getitem__(cls, item: AnyType) -> AnyType:         return Annotated[item, cls()]      @classmethod     def __get_pydantic_core_schema__(         cls, source: type[Any], handler: GetCoreSchemaHandler     ) -> core_schema.CoreSchema:         serializer = core_schema.plain_serializer_function_ser_schema(cls._serialize, when_used='json')         if cls is source:             # Treat bare usage of ImportString (`schema is None`) as the same as ImportString[Any]             return core_schema.no_info_plain_validator_function(                 function=_validators.import_string, serialization=serializer             )         else:             return core_schema.no_info_before_validator_function(                 function=_validators.import_string, schema=handler(source), serialization=serializer             )      @classmethod     def __get_pydantic_json_schema__(cls, cs: CoreSchema, handler: GetJsonSchemaHandler) -> JsonSchemaValue:         return handler(core_schema.str_schema())      @staticmethod     def _serialize(v: Any) -> str:         if isinstance(v, ModuleType):             return v.__name__         elif hasattr(v, '__module__') and hasattr(v, '__name__'):             return f'{v.__module__}.{v.__name__}'         # Handle special cases for sys.XXX streams         # if we see more of these, we should consider a more general solution         elif hasattr(v, 'name'):             if v.name == '<stdout>':                 return 'sys.stdout'             elif v.name == '<stdin>':                 return 'sys.stdin'             elif v.name == '<stderr>':                 return 'sys.stderr'         return v      def __repr__(self) -> str:         return 'ImportString' ``` |", "url": "https://docs.pydantic.dev/latest/api/types/index.html#importstring-indexhtmlpydantictypesimportstring-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "UuidVersion `dataclass` [Â¶](index.html#pydantic.types.UuidVersion \"Permanent link\")", "anchor": "uuidversion-dataclass-indexhtmlpydantictypesuuidversion-permanent-link", "md_text": "A field metadata class to indicate a [UUID](https://docs.python.org/3/library/uuid.html) version.\n\nUse this class as an annotation via [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated), as seen below.\n\nAttributes:\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `uuid_version` | `Literal[1, 3, 4, 5, 6, 7, 8]` | The version of the UUID. Must be one of 1, 3, 4, 5, 6, 7 or 8. |\n\nExample\n\n```\nfrom typing import Annotated\nfrom uuid import UUID\n\nfrom pydantic.types import UuidVersion\n\nUUID1 = Annotated[UUID, UuidVersion(1)]\n```\n\n\nSource code in `pydantic/types.py`\n\n|  |  |\n| --- | --- |\n| ``` 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 ``` | ``` @_dataclasses.dataclass(**_internal_dataclass.slots_true) class UuidVersion:     \"\"\"A field metadata class to indicate a [UUID](https://docs.python.org/3/library/uuid.html) version.      Use this class as an annotation via [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated), as seen below.      Attributes:         uuid_version: The version of the UUID. Must be one of 1, 3, 4, 5, 6, 7 or 8.      Example:         ```python         from typing import Annotated         from uuid import UUID          from pydantic.types import UuidVersion          UUID1 = Annotated[UUID, UuidVersion(1)]         ```     \"\"\"      uuid_version: Literal[1, 3, 4, 5, 6, 7, 8]      def __get_pydantic_json_schema__(         self, core_schema: core_schema.CoreSchema, handler: GetJsonSchemaHandler     ) -> JsonSchemaValue:         field_schema = handler(core_schema)         field_schema.pop('anyOf', None)  # remove the bytes/str union         field_schema.update(type='string', format=f'uuid{self.uuid_version}')         return field_schema      def __get_pydantic_core_schema__(self, source: Any, handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:         schema = handler(source)         _check_annotated_type(schema['type'], 'uuid', self.__class__.__name__)         schema['version'] = self.uuid_version  # type: ignore         return schema      def __hash__(self) -> int:         return hash(type(self.uuid_version)) ``` |", "url": "https://docs.pydantic.dev/latest/api/types/index.html#uuidversion-dataclass-indexhtmlpydantictypesuuidversion-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "Json [Â¶](index.html#pydantic.types.Json \"Permanent link\")", "anchor": "json-indexhtmlpydantictypesjson-permanent-link", "md_text": "A special type wrapper which loads JSON before parsing.\n\nYou can use the `Json` data type to make Pydantic first load a raw JSON string before\nvalidating the loaded data into the parametrized type:\n\n```\nfrom typing import Any\n\nfrom pydantic import BaseModel, Json, ValidationError\n\nclass AnyJsonModel(BaseModel):\n    json_obj: Json[Any]\n\nclass ConstrainedJsonModel(BaseModel):\n    json_obj: Json[list[int]]\n\nprint(AnyJsonModel(json_obj='{\"b\": 1}'))\n#> json_obj={'b': 1}\nprint(ConstrainedJsonModel(json_obj='[1, 2, 3]'))\n#> json_obj=[1, 2, 3]\n\ntry:\n    ConstrainedJsonModel(json_obj=12)\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for ConstrainedJsonModel\n    json_obj\n      JSON input should be string, bytes or bytearray [type=json_type, input_value=12, input_type=int]\n    '''\n\ntry:\n    ConstrainedJsonModel(json_obj='[a, b]')\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for ConstrainedJsonModel\n    json_obj\n      Invalid JSON: expected value at line 1 column 2 [type=json_invalid, input_value='[a, b]', input_type=str]\n    '''\n\ntry:\n    ConstrainedJsonModel(json_obj='[\"a\", \"b\"]')\nexcept ValidationError as e:\n    print(e)\n    '''\n    2 validation errors for ConstrainedJsonModel\n    json_obj.0\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='a', input_type=str]\n    json_obj.1\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='b', input_type=str]\n    '''\n```\n\nWhen you dump the model using `model_dump` or `model_dump_json`, the dumped value will be the result of validation,\nnot the original JSON string. However, you can use the argument `round_trip=True` to get the original JSON string back:\n\n```\nfrom pydantic import BaseModel, Json\n\nclass ConstrainedJsonModel(BaseModel):\n    json_obj: Json[list[int]]\n\nprint(ConstrainedJsonModel(json_obj='[1, 2, 3]').model_dump_json())\n#> {\"json_obj\":[1,2,3]}\nprint(\n    ConstrainedJsonModel(json_obj='[1, 2, 3]').model_dump_json(round_trip=True)\n)\n#> {\"json_obj\":\"[1,2,3]\"}\n```\n\nSource code in `pydantic/types.py`", "url": "https://docs.pydantic.dev/latest/api/types/index.html#json-indexhtmlpydantictypesjson-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "Json [Â¶](index.html#pydantic.types.Json \"Permanent link\")", "anchor": "json-indexhtmlpydantictypesjson-permanent-link", "md_text": "|  |  |\n| --- | --- |\n| ``` 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 ``` | ``` class Json:     \"\"\"A special type wrapper which loads JSON before parsing.      You can use the `Json` data type to make Pydantic first load a raw JSON string before     validating the loaded data into the parametrized type:      ```python     from typing import Any      from pydantic import BaseModel, Json, ValidationError      class AnyJsonModel(BaseModel):         json_obj: Json[Any]      class ConstrainedJsonModel(BaseModel):         json_obj: Json[list[int]]      print(AnyJsonModel(json_obj='{\"b\": 1}'))     #> json_obj={'b': 1}     print(ConstrainedJsonModel(json_obj='[1, 2, 3]'))     #> json_obj=[1, 2, 3]      try:         ConstrainedJsonModel(json_obj=12)     except ValidationError as e:         print(e)         '''         1 validation error for ConstrainedJsonModel         json_obj           JSON input should be string, bytes or bytearray [type=json_type, input_value=12, input_type=int]         '''      try:         ConstrainedJsonModel(json_obj='[a, b]')     except ValidationError as e:         print(e)         '''         1 validation error for ConstrainedJsonModel         json_obj           Invalid JSON: expected value at line 1 column 2 [type=json_invalid, input_value='[a, b]', input_type=str]         '''      try:         ConstrainedJsonModel(json_obj='[\"a\", \"b\"]')     except ValidationError as e:         print(e)         '''         2 validation errors for ConstrainedJsonModel         json_obj.0           Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='a', input_type=str]         json_obj.1           Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='b', input_type=str]         '''     ```      When you dump the model using `model_dump` or `model_dump_json`, the dumped value will be the result of validation,     not the original JSON string. However, you can use the argument `round_trip=True` to get the original JSON string back:      ```python     from pydantic import BaseModel, Json      class ConstrainedJsonModel(BaseModel):         json_obj: Json[list[int]]      print(ConstrainedJsonModel(json_obj='[1, 2, 3]').model_dump_json())     #> {\"json_obj\":[1,2,3]}     print(         ConstrainedJsonModel(json_obj='[1, 2, 3]').model_dump_json(round_trip=True)     )     #> {\"json_obj\":\"[1,2,3]\"}     ```     \"\"\"      @classmethod     def __class_getitem__(cls, item: AnyType) -> AnyType:         return Annotated[item, cls()]      @classmethod     def __get_pydantic_core_schema__(cls, source: Any, handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:         if cls is source:             return core_schema.json_schema(None)         else:             return core_schema.json_schema(handler(source))      def __repr__(self) -> str:         return 'Json'      def __hash__(self) -> int:         return hash(type(self))      def __eq__(self, other: Any) -> bool:         return type(other) is type(self) ``` |", "url": "https://docs.pydantic.dev/latest/api/types/index.html#json-indexhtmlpydantictypesjson-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "Secret [Â¶](index.html#pydantic.types.Secret \"Permanent link\")", "anchor": "secret-indexhtmlpydantictypessecret-permanent-link", "md_text": "Bases: `_SecretBase[SecretType]`\n\nA generic base class used for defining a field with sensitive information that you do not want to be visible in logging or tracebacks.\n\nYou may either directly parametrize `Secret` with a type, or subclass from `Secret` with a parametrized type. The benefit of subclassing\nis that you can define a custom `_display` method, which will be used for `repr()` and `str()` methods. The examples below demonstrate both\nways of using `Secret` to create a new secret type.\n\n1. Directly parametrizing `Secret` with a type:\n\n```\nfrom pydantic import BaseModel, Secret\n\nSecretBool = Secret[bool]\n\nclass Model(BaseModel):\n    secret_bool: SecretBool\n\nm = Model(secret_bool=True)\nprint(m.model_dump())\n#> {'secret_bool': Secret('**********')}\n\nprint(m.model_dump_json())\n#> {\"secret_bool\":\"**********\"}\n\nprint(m.secret_bool.get_secret_value())\n#> True\n```\n\n1. Subclassing from parametrized `Secret`:\n\n```\nfrom datetime import date\n\nfrom pydantic import BaseModel, Secret\n\nclass SecretDate(Secret[date]):\n    def _display(self) -> str:\n        return '****/**/**'\n\nclass Model(BaseModel):\n    secret_date: SecretDate\n\nm = Model(secret_date=date(2022, 1, 1))\nprint(m.model_dump())\n#> {'secret_date': SecretDate('****/**/**')}\n\nprint(m.model_dump_json())\n#> {\"secret_date\":\"****/**/**\"}\n\nprint(m.secret_date.get_secret_value())\n#> 2022-01-01\n```\n\nThe value returned by the `_display` method will be used for `repr()` and `str()`.\n\nYou can enforce constraints on the underlying type through annotations:\nFor example:\n\n```\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Field, Secret, ValidationError\n\nSecretPosInt = Secret[Annotated[int, Field(gt=0, strict=True)]]\n\nclass Model(BaseModel):\n    sensitive_int: SecretPosInt\n\nm = Model(sensitive_int=42)\nprint(m.model_dump())\n#> {'sensitive_int': Secret('**********')}\n\ntry:\n    m = Model(sensitive_int=-42)  # (1)!\nexcept ValidationError as exc_info:\n    print(exc_info.errors(include_url=False, include_input=False))\n    '''\n    [\n        {\n            'type': 'greater_than',\n            'loc': ('sensitive_int',),\n            'msg': 'Input should be greater than 0',\n            'ctx': {'gt': 0},\n        }\n    ]\n    '''\n\ntry:\n    m = Model(sensitive_int='42')  # (2)!\nexcept ValidationError as exc_info:\n    print(exc_info.errors(include_url=False, include_input=False))\n    '''\n    [\n        {\n            'type': 'int_type',\n            'loc': ('sensitive_int',),\n            'msg': 'Input should be a valid integer',\n        }\n    ]\n    '''\n```\n\n1. The input value is not greater than 0, so it raises a validation error.\n2. The input value is not an integer, so it raises a validation error because the `SecretPosInt` type has strict mode enabled.\n\nSource code in `pydantic/types.py`", "url": "https://docs.pydantic.dev/latest/api/types/index.html#secret-indexhtmlpydantictypessecret-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "Secret [Â¶](index.html#pydantic.types.Secret \"Permanent link\")", "anchor": "secret-indexhtmlpydantictypessecret-permanent-link", "md_text": "|  |  |\n| --- | --- |\n| ``` 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 1689 1690 1691 1692 1693 1694 1695 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711 1712 1713 1714 1715 1716 1717 1718 1719 1720 1721 1722 1723 1724 1725 1726 1727 1728 ``` | ``` class Secret(_SecretBase[SecretType]):     \"\"\"A generic base class used for defining a field with sensitive information that you do not want to be visible in logging or tracebacks.      You may either directly parametrize `Secret` with a type, or subclass from `Secret` with a parametrized type. The benefit of subclassing     is that you can define a custom `_display` method, which will be used for `repr()` and `str()` methods. The examples below demonstrate both     ways of using `Secret` to create a new secret type.      1. Directly parametrizing `Secret` with a type:      ```python     from pydantic import BaseModel, Secret      SecretBool = Secret[bool]      class Model(BaseModel):         secret_bool: SecretBool      m = Model(secret_bool=True)     print(m.model_dump())     #> {'secret_bool': Secret('**********')}      print(m.model_dump_json())     #> {\"secret_bool\":\"**********\"}      print(m.secret_bool.get_secret_value())     #> True     ```      2. Subclassing from parametrized `Secret`:      ```python     from datetime import date      from pydantic import BaseModel, Secret      class SecretDate(Secret[date]):         def _display(self) -> str:             return '****/**/**'      class Model(BaseModel):         secret_date: SecretDate      m = Model(secret_date=date(2022, 1, 1))     print(m.model_dump())     #> {'secret_date': SecretDate('****/**/**')}      print(m.model_dump_json())     #> {\"secret_date\":\"****/**/**\"}      print(m.secret_date.get_secret_value())     #> 2022-01-01     ```      The value returned by the `_display` method will be used for `repr()` and `str()`.      You can enforce constraints on the underlying type through annotations:     For example:      ```python     from typing import Annotated      from pydantic import BaseModel, Field, Secret, ValidationError      SecretPosInt = Secret[Annotated[int, Field(gt=0, strict=True)]]      class Model(BaseModel):         sensitive_int: SecretPosInt      m = Model(sensitive_int=42)     print(m.model_dump())     #> {'sensitive_int': Secret('**********')}      try:         m = Model(sensitive_int=-42)  # (1)!     except ValidationError as exc_info:         print(exc_info.errors(include_url=False, include_input=False))         '''         [             {                 'type': 'greater_than',                 'loc': ('sensitive_int',),                 'msg': 'Input should be greater than 0',                 'ctx': {'gt': 0},             }         ]         '''      try:         m = Model(sensitive_int='42')  # (2)!     except ValidationError as exc_info:         print(exc_info.errors(include_url=False, include_input=False))         '''         [             {                 'type': 'int_type',                 'loc': ('sensitive_int',),                 'msg': 'Input should be a valid integer',             }         ]         '''     ```      1. The input value is not greater than 0, so it raises a validation error.     2. The input value is not an integer, so it raises a validation error because the `SecretPosInt` type has strict mode enabled.     \"\"\"      def _display(self) -> str | bytes:         return '**********' if self.get_secret_value() else ''      @classmethod     def __get_pydantic_core_schema__(cls, source: type[Any], handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:         inner_type = None         # if origin_type is Secret, then cls is a GenericAlias, and we can extract the inner type directly         origin_type = get_origin(source)         if origin_type is not None:             inner_type = get_args(source)[0]         # otherwise, we need to get the inner type from the base class         else:             bases = getattr(cls, '__orig_bases__', getattr(cls, '__bases__', []))             for base in bases:                 if get_origin(base) is Secret:                     inner_type = get_args(base)[0]             if bases == [] or inner_type is None:                 raise TypeError(                     f\"Can't get secret type from {cls.__name__}. \"                     'Please use Secret[<type>], or subclass from Secret[<type>] instead.'                 )          inner_schema = handler.generate_schema(inner_type)  # type: ignore          def validate_secret_value(value, handler) -> Secret[SecretType]:             if isinstance(value, Secret):                 value = value.get_secret_value()             validated_inner = handler(value)             return cls(validated_inner)          return core_schema.json_or_python_schema(             python_schema=core_schema.no_info_wrap_validator_function(                 validate_secret_value,                 inner_schema,             ),             json_schema=core_schema.no_info_after_validator_function(lambda x: cls(x), inner_schema),             serialization=core_schema.plain_serializer_function_ser_schema(                 _serialize_secret,                 info_arg=True,                 when_used='always',             ),         )      __pydantic_serializer__ = SchemaSerializer(         core_schema.any_schema(             serialization=core_schema.plain_serializer_function_ser_schema(                 _serialize_secret,                 info_arg=True,                 when_used='always',             )         )     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/types/index.html#secret-indexhtmlpydantictypessecret-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "SecretStr [Â¶](index.html#pydantic.types.SecretStr \"Permanent link\")", "anchor": "secretstr-indexhtmlpydantictypessecretstr-permanent-link", "md_text": "Bases: `_SecretField[str]`\n\nA string used for storing sensitive information that you do not want to be visible in logging or tracebacks.\n\nWhen the secret value is nonempty, it is displayed as `'**********'` instead of the underlying value in\ncalls to `repr()` and `str()`. If the value *is* empty, it is displayed as `''`.\n\n```\nfrom pydantic import BaseModel, SecretStr\n\nclass User(BaseModel):\n    username: str\n    password: SecretStr\n\nuser = User(username='scolvin', password='password1')\n\nprint(user)\n#> username='scolvin' password=SecretStr('**********')\nprint(user.password.get_secret_value())\n#> password1\nprint((SecretStr('password'), SecretStr('')))\n#> (SecretStr('**********'), SecretStr(''))\n```\n\nAs seen above, by default, [`SecretStr`](index.html#pydantic.types.SecretStr) (and [`SecretBytes`](index.html#pydantic.types.SecretBytes))\nwill be serialized as `**********` when serializing to json.\n\nYou can use the [`field_serializer`](../functional_serializers/index.html#pydantic.functional_serializers.field_serializer) to dump the\nsecret as plain-text when serializing to json.\n\n```\nfrom pydantic import BaseModel, SecretBytes, SecretStr, field_serializer\n\nclass Model(BaseModel):\n    password: SecretStr\n    password_bytes: SecretBytes\n\n    @field_serializer('password', 'password_bytes', when_used='json')\n    def dump_secret(self, v):\n        return v.get_secret_value()\n\nmodel = Model(password='IAmSensitive', password_bytes=b'IAmSensitiveBytes')\nprint(model)\n#> password=SecretStr('**********') password_bytes=SecretBytes(b'**********')\nprint(model.password)\n#> **********\nprint(model.model_dump())\n'''\n{\n    'password': SecretStr('**********'),\n    'password_bytes': SecretBytes(b'**********'),\n}\n'''\nprint(model.model_dump_json())\n#> {\"password\":\"IAmSensitive\",\"password_bytes\":\"IAmSensitiveBytes\"}\n```\n\nSource code in `pydantic/types.py`\n\n|  |  |\n| --- | --- |\n| ``` 1801 1802 1803 1804 1805 1806 1807 1808 1809 1810 1811 1812 1813 1814 1815 1816 1817 1818 1819 1820 1821 1822 1823 1824 1825 1826 1827 1828 1829 1830 1831 1832 1833 1834 1835 1836 1837 1838 1839 1840 1841 1842 1843 1844 1845 1846 1847 1848 1849 1850 1851 1852 1853 1854 1855 1856 1857 1858 1859 1860 1861 1862 1863 1864 1865 ``` | ``` class SecretStr(_SecretField[str]):     \"\"\"A string used for storing sensitive information that you do not want to be visible in logging or tracebacks.      When the secret value is nonempty, it is displayed as `'**********'` instead of the underlying value in     calls to `repr()` and `str()`. If the value _is_ empty, it is displayed as `''`.      ```python     from pydantic import BaseModel, SecretStr      class User(BaseModel):         username: str         password: SecretStr      user = User(username='scolvin', password='password1')      print(user)     #> username='scolvin' password=SecretStr('**********')     print(user.password.get_secret_value())     #> password1     print((SecretStr('password'), SecretStr('')))     #> (SecretStr('**********'), SecretStr(''))     ```      As seen above, by default, [`SecretStr`][pydantic.types.SecretStr] (and [`SecretBytes`][pydantic.types.SecretBytes])     will be serialized as `**********` when serializing to json.      You can use the [`field_serializer`][pydantic.functional_serializers.field_serializer] to dump the     secret as plain-text when serializing to json.      ```python     from pydantic import BaseModel, SecretBytes, SecretStr, field_serializer      class Model(BaseModel):         password: SecretStr         password_bytes: SecretBytes          @field_serializer('password', 'password_bytes', when_used='json')         def dump_secret(self, v):             return v.get_secret_value()      model = Model(password='IAmSensitive', password_bytes=b'IAmSensitiveBytes')     print(model)     #> password=SecretStr('**********') password_bytes=SecretBytes(b'**********')     print(model.password)     #> **********     print(model.model_dump())     '''     {         'password': SecretStr('**********'),         'password_bytes': SecretBytes(b'**********'),     }     '''     print(model.model_dump_json())     #> {\"password\":\"IAmSensitive\",\"password_bytes\":\"IAmSensitiveBytes\"}     ```     \"\"\"      _inner_schema: ClassVar[CoreSchema] = core_schema.str_schema()     _error_kind: ClassVar[str] = 'string_type'      def __len__(self) -> int:         return len(self._secret_value)      def _display(self) -> str:         return _secret_display(self._secret_value) ``` |", "url": "https://docs.pydantic.dev/latest/api/types/index.html#secretstr-indexhtmlpydantictypessecretstr-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "SecretBytes [Â¶](index.html#pydantic.types.SecretBytes \"Permanent link\")", "anchor": "secretbytes-indexhtmlpydantictypessecretbytes-permanent-link", "md_text": "Bases: `_SecretField[bytes]`\n\nA bytes used for storing sensitive information that you do not want to be visible in logging or tracebacks.\n\nIt displays `b'**********'` instead of the string value on `repr()` and `str()` calls.\nWhen the secret value is nonempty, it is displayed as `b'**********'` instead of the underlying value in\ncalls to `repr()` and `str()`. If the value *is* empty, it is displayed as `b''`.\n\n```\nfrom pydantic import BaseModel, SecretBytes\n\nclass User(BaseModel):\n    username: str\n    password: SecretBytes\n\nuser = User(username='scolvin', password=b'password1')\n#> username='scolvin' password=SecretBytes(b'**********')\nprint(user.password.get_secret_value())\n#> b'password1'\nprint((SecretBytes(b'password'), SecretBytes(b'')))\n#> (SecretBytes(b'**********'), SecretBytes(b''))\n```\n\nSource code in `pydantic/types.py`\n\n|  |  |\n| --- | --- |\n| ``` 1868 1869 1870 1871 1872 1873 1874 1875 1876 1877 1878 1879 1880 1881 1882 1883 1884 1885 1886 1887 1888 1889 1890 1891 1892 1893 1894 1895 1896 1897 1898 ``` | ``` class SecretBytes(_SecretField[bytes]):     \"\"\"A bytes used for storing sensitive information that you do not want to be visible in logging or tracebacks.      It displays `b'**********'` instead of the string value on `repr()` and `str()` calls.     When the secret value is nonempty, it is displayed as `b'**********'` instead of the underlying value in     calls to `repr()` and `str()`. If the value _is_ empty, it is displayed as `b''`.      ```python     from pydantic import BaseModel, SecretBytes      class User(BaseModel):         username: str         password: SecretBytes      user = User(username='scolvin', password=b'password1')     #> username='scolvin' password=SecretBytes(b'**********')     print(user.password.get_secret_value())     #> b'password1'     print((SecretBytes(b'password'), SecretBytes(b'')))     #> (SecretBytes(b'**********'), SecretBytes(b''))     ```     \"\"\"      _inner_schema: ClassVar[CoreSchema] = core_schema.bytes_schema()     _error_kind: ClassVar[str] = 'bytes_type'      def __len__(self) -> int:         return len(self._secret_value)      def _display(self) -> bytes:         return _secret_display(self._secret_value).encode() ``` |", "url": "https://docs.pydantic.dev/latest/api/types/index.html#secretbytes-indexhtmlpydantictypessecretbytes-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "PaymentCardNumber [Â¶](index.html#pydantic.types.PaymentCardNumber \"Permanent link\")", "anchor": "paymentcardnumber-indexhtmlpydantictypespaymentcardnumber-permanent-link", "md_text": "Bases: `str`\n\nBased on: https://en.wikipedia.org/wiki/Payment\\_card\\_number.\n\nSource code in `pydantic/types.py`", "url": "https://docs.pydantic.dev/latest/api/types/index.html#paymentcardnumber-indexhtmlpydantictypespaymentcardnumber-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "PaymentCardNumber [Â¶](index.html#pydantic.types.PaymentCardNumber \"Permanent link\")", "anchor": "paymentcardnumber-indexhtmlpydantictypespaymentcardnumber-permanent-link", "md_text": "|  |  |\n| --- | --- |\n| ``` 1914 1915 1916 1917 1918 1919 1920 1921 1922 1923 1924 1925 1926 1927 1928 1929 1930 1931 1932 1933 1934 1935 1936 1937 1938 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 ``` | ``` @deprecated(     'The `PaymentCardNumber` class is deprecated, use `pydantic_extra_types` instead. '     'See https://docs.pydantic.dev/latest/api/pydantic_extra_types_payment/#pydantic_extra_types.payment.PaymentCardNumber.',     category=PydanticDeprecatedSince20, ) class PaymentCardNumber(str):     \"\"\"Based on: https://en.wikipedia.org/wiki/Payment_card_number.\"\"\"      strip_whitespace: ClassVar[bool] = True     min_length: ClassVar[int] = 12     max_length: ClassVar[int] = 19     bin: str     last4: str     brand: PaymentCardBrand      def __init__(self, card_number: str):         self.validate_digits(card_number)          card_number = self.validate_luhn_check_digit(card_number)          self.bin = card_number[:6]         self.last4 = card_number[-4:]         self.brand = self.validate_brand(card_number)      @classmethod     def __get_pydantic_core_schema__(cls, source: type[Any], handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:         return core_schema.with_info_after_validator_function(             cls.validate,             core_schema.str_schema(                 min_length=cls.min_length, max_length=cls.max_length, strip_whitespace=cls.strip_whitespace             ),         )      @classmethod     def validate(cls, input_value: str, /, _: core_schema.ValidationInfo) -> PaymentCardNumber:         \"\"\"Validate the card number and return a `PaymentCardNumber` instance.\"\"\"         return cls(input_value)      @property     def masked(self) -> str:         \"\"\"Mask all but the last 4 digits of the card number.          Returns:             A masked card number string.         \"\"\"         num_masked = len(self) - 10  # len(bin) + len(last4) == 10         return f'{self.bin}{\"*\" * num_masked}{self.last4}'      @classmethod     def validate_digits(cls, card_number: str) -> None:         \"\"\"Validate that the card number is all digits.\"\"\"         if not card_number.isdigit():             raise PydanticCustomError('payment_card_number_digits', 'Card number is not all digits')      @classmethod     def validate_luhn_check_digit(cls, card_number: str) -> str:         \"\"\"Based on: https://en.wikipedia.org/wiki/Luhn_algorithm.\"\"\"         sum_ = int(card_number[-1])         length = len(card_number)         parity = length % 2         for i in range(length - 1):             digit = int(card_number[i])             if i % 2 == parity:                 digit *= 2             if digit > 9:                 digit -= 9             sum_ += digit         valid = sum_ % 10 == 0         if not valid:             raise PydanticCustomError('payment_card_number_luhn', 'Card number is not luhn valid')         return card_number      @staticmethod     def validate_brand(card_number: str) -> PaymentCardBrand:         \"\"\"Validate length based on BIN for major brands:         https://en.wikipedia.org/wiki/Payment_card_number#Issuer_identification_number_(IIN).         \"\"\"         if card_number[0] == '4':             brand = PaymentCardBrand.visa         elif 51 <= int(card_number[:2]) <= 55:             brand = PaymentCardBrand.mastercard         elif card_number[:2] in {'34', '37'}:             brand = PaymentCardBrand.amex         else:             brand = PaymentCardBrand.other          required_length: None | int | str = None         if brand in PaymentCardBrand.mastercard:             required_length = 16             valid = len(card_number) == required_length         elif brand == PaymentCardBrand.visa:             required_length = '13, 16 or 19'             valid = len(card_number) in {13, 16, 19}         elif brand == PaymentCardBrand.amex:             required_length = 15             valid = len(card_number) == required_length         else:             valid = True          if not valid:             raise PydanticCustomError(                 'payment_card_number_brand',                 'Length for a {brand} card must be {required_length}',                 {'brand': brand, 'required_length': required_length},             )         return brand ``` |", "url": "https://docs.pydantic.dev/latest/api/types/index.html#paymentcardnumber-indexhtmlpydantictypespaymentcardnumber-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "PaymentCardNumber [Â¶](index.html#pydantic.types.PaymentCardNumber \"Permanent link\")", "anchor": "paymentcardnumber-indexhtmlpydantictypespaymentcardnumber-permanent-link", "md_text": "#### masked `property` [Â¶](index.html#pydantic.types.PaymentCardNumber.masked \"Permanent link\")\n\n```\nmasked: str\n```\n\nMask all but the last 4 digits of the card number.\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `str` | A masked card number string. |\n\n#### validate `classmethod` [Â¶](index.html#pydantic.types.PaymentCardNumber.validate \"Permanent link\")\n\n```\nvalidate(\n    input_value: str, /, _: ValidationInfo\n) -> PaymentCardNumber\n```\n\nValidate the card number and return a `PaymentCardNumber` instance.\n\nSource code in `pydantic/types.py`\n\n|  |  |\n| --- | --- |\n| ``` 1947 1948 1949 1950 ``` | ``` @classmethod def validate(cls, input_value: str, /, _: core_schema.ValidationInfo) -> PaymentCardNumber:     \"\"\"Validate the card number and return a `PaymentCardNumber` instance.\"\"\"     return cls(input_value) ``` |\n\n#### validate\\_digits `classmethod` [Â¶](index.html#pydantic.types.PaymentCardNumber.validate_digits \"Permanent link\")\n\n```\nvalidate_digits(card_number: str) -> None\n```\n\nValidate that the card number is all digits.\n\nSource code in `pydantic/types.py`\n\n|  |  |\n| --- | --- |\n| ``` 1962 1963 1964 1965 1966 ``` | ``` @classmethod def validate_digits(cls, card_number: str) -> None:     \"\"\"Validate that the card number is all digits.\"\"\"     if not card_number.isdigit():         raise PydanticCustomError('payment_card_number_digits', 'Card number is not all digits') ``` |\n\n#### validate\\_luhn\\_check\\_digit `classmethod` [Â¶](index.html#pydantic.types.PaymentCardNumber.validate_luhn_check_digit \"Permanent link\")\n\n```\nvalidate_luhn_check_digit(card_number: str) -> str\n```\n\nBased on: https://en.wikipedia.org/wiki/Luhn\\_algorithm.\n\nSource code in `pydantic/types.py`\n\n|  |  |\n| --- | --- |\n| ``` 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 ``` | ``` @classmethod def validate_luhn_check_digit(cls, card_number: str) -> str:     \"\"\"Based on: https://en.wikipedia.org/wiki/Luhn_algorithm.\"\"\"     sum_ = int(card_number[-1])     length = len(card_number)     parity = length % 2     for i in range(length - 1):         digit = int(card_number[i])         if i % 2 == parity:             digit *= 2         if digit > 9:             digit -= 9         sum_ += digit     valid = sum_ % 10 == 0     if not valid:         raise PydanticCustomError('payment_card_number_luhn', 'Card number is not luhn valid')     return card_number ``` |\n\n#### validate\\_brand `staticmethod` [Â¶](index.html#pydantic.types.PaymentCardNumber.validate_brand \"Permanent link\")\n\n```\nvalidate_brand(card_number: str) -> PaymentCardBrand\n```\n\nValidate length based on BIN for major brands:\nhttps://en.wikipedia.org/wiki/Payment\\_card\\_number#Issuer\\_identification\\_number\\_(IIN).\n\nSource code in `pydantic/types.py`\n\n|  |  |\n| --- | --- |\n| ``` 1986 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 ``` | ``` @staticmethod def validate_brand(card_number: str) -> PaymentCardBrand:     \"\"\"Validate length based on BIN for major brands:     https://en.wikipedia.org/wiki/Payment_card_number#Issuer_identification_number_(IIN).     \"\"\"     if card_number[0] == '4':         brand = PaymentCardBrand.visa     elif 51 <= int(card_number[:2]) <= 55:         brand = PaymentCardBrand.mastercard     elif card_number[:2] in {'34', '37'}:         brand = PaymentCardBrand.amex     else:         brand = PaymentCardBrand.other      required_length: None | int | str = None     if brand in PaymentCardBrand.mastercard:         required_length = 16         valid = len(card_number) == required_length     elif brand == PaymentCardBrand.visa:         required_length = '13, 16 or 19'         valid = len(card_number) in {13, 16, 19}     elif brand == PaymentCardBrand.amex:         required_length = 15         valid = len(card_number) == required_length     else:         valid = True      if not valid:         raise PydanticCustomError(             'payment_card_number_brand',             'Length for a {brand} card must be {required_length}',             {'brand': brand, 'required_length': required_length},         )     return brand ``` |", "url": "https://docs.pydantic.dev/latest/api/types/index.html#paymentcardnumber-indexhtmlpydantictypespaymentcardnumber-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "ByteSize [Â¶](index.html#pydantic.types.ByteSize \"Permanent link\")", "anchor": "bytesize-indexhtmlpydantictypesbytesize-permanent-link", "md_text": "Bases: `int`\n\nConverts a string representing a number of bytes with units (such as `'1KB'` or `'11.5MiB'`) into an integer.\n\nYou can use the `ByteSize` data type to (case-insensitively) convert a string representation of a number of bytes into\nan integer, and also to print out human-readable strings representing a number of bytes.\n\nIn conformance with [IEC 80000-13 Standard](https://en.wikipedia.org/wiki/ISO/IEC_80000) we interpret `'1KB'` to mean 1000 bytes,\nand `'1KiB'` to mean 1024 bytes. In general, including a middle `'i'` will cause the unit to be interpreted as a power of 2,\nrather than a power of 10 (so, for example, `'1 MB'` is treated as `1_000_000` bytes, whereas `'1 MiB'` is treated as `1_048_576` bytes).\n\nNote that `1b` will be parsed as \"1 byte\" and not \"1 bit\".\n\n```\nfrom pydantic import BaseModel, ByteSize\n\nclass MyModel(BaseModel):\n    size: ByteSize\n\nprint(MyModel(size=52000).size)\n#> 52000\nprint(MyModel(size='3000 KiB').size)\n#> 3072000\n\nm = MyModel(size='50 PB')\nprint(m.size.human_readable())\n#> 44.4PiB\nprint(m.size.human_readable(decimal=True))\n#> 50.0PB\nprint(m.size.human_readable(separator=' '))\n#> 44.4 PiB\n\nprint(m.size.to('TiB'))\n#> 45474.73508864641\n```\n\nSource code in `pydantic/types.py`", "url": "https://docs.pydantic.dev/latest/api/types/index.html#bytesize-indexhtmlpydantictypesbytesize-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "ByteSize [Â¶](index.html#pydantic.types.ByteSize \"Permanent link\")", "anchor": "bytesize-indexhtmlpydantictypesbytesize-permanent-link", "md_text": "|  |  |\n| --- | --- |\n| ``` 2025 2026 2027 2028 2029 2030 2031 2032 2033 2034 2035 2036 2037 2038 2039 2040 2041 2042 2043 2044 2045 2046 2047 2048 2049 2050 2051 2052 2053 2054 2055 2056 2057 2058 2059 2060 2061 2062 2063 2064 2065 2066 2067 2068 2069 2070 2071 2072 2073 2074 2075 2076 2077 2078 2079 2080 2081 2082 2083 2084 2085 2086 2087 2088 2089 2090 2091 2092 2093 2094 2095 2096 2097 2098 2099 2100 2101 2102 2103 2104 2105 2106 2107 2108 2109 2110 2111 2112 2113 2114 2115 2116 2117 2118 2119 2120 2121 2122 2123 2124 2125 2126 2127 2128 2129 2130 2131 2132 2133 2134 2135 2136 2137 2138 2139 2140 2141 2142 2143 2144 2145 2146 2147 2148 2149 2150 2151 2152 2153 2154 2155 2156 2157 2158 2159 2160 2161 2162 2163 2164 2165 2166 2167 2168 2169 2170 2171 2172 2173 2174 2175 2176 2177 2178 2179 2180 2181 2182 ``` | ``` class ByteSize(int):     \"\"\"Converts a string representing a number of bytes with units (such as `'1KB'` or `'11.5MiB'`) into an integer.      You can use the `ByteSize` data type to (case-insensitively) convert a string representation of a number of bytes into     an integer, and also to print out human-readable strings representing a number of bytes.      In conformance with [IEC 80000-13 Standard](https://en.wikipedia.org/wiki/ISO/IEC_80000) we interpret `'1KB'` to mean 1000 bytes,     and `'1KiB'` to mean 1024 bytes. In general, including a middle `'i'` will cause the unit to be interpreted as a power of 2,     rather than a power of 10 (so, for example, `'1 MB'` is treated as `1_000_000` bytes, whereas `'1 MiB'` is treated as `1_048_576` bytes).      !!! info         Note that `1b` will be parsed as \"1 byte\" and not \"1 bit\".      ```python     from pydantic import BaseModel, ByteSize      class MyModel(BaseModel):         size: ByteSize      print(MyModel(size=52000).size)     #> 52000     print(MyModel(size='3000 KiB').size)     #> 3072000      m = MyModel(size='50 PB')     print(m.size.human_readable())     #> 44.4PiB     print(m.size.human_readable(decimal=True))     #> 50.0PB     print(m.size.human_readable(separator=' '))     #> 44.4 PiB      print(m.size.to('TiB'))     #> 45474.73508864641     ```     \"\"\"      byte_sizes = {         'b': 1,         'kb': 10**3,         'mb': 10**6,         'gb': 10**9,         'tb': 10**12,         'pb': 10**15,         'eb': 10**18,         'kib': 2**10,         'mib': 2**20,         'gib': 2**30,         'tib': 2**40,         'pib': 2**50,         'eib': 2**60,         'bit': 1 / 8,         'kbit': 10**3 / 8,         'mbit': 10**6 / 8,         'gbit': 10**9 / 8,         'tbit': 10**12 / 8,         'pbit': 10**15 / 8,         'ebit': 10**18 / 8,         'kibit': 2**10 / 8,         'mibit': 2**20 / 8,         'gibit': 2**30 / 8,         'tibit': 2**40 / 8,         'pibit': 2**50 / 8,         'eibit': 2**60 / 8,     }     byte_sizes.update({k.lower()[0]: v for k, v in byte_sizes.items() if 'i' not in k})      byte_string_pattern = r'^\\s*(\\d*\\.?\\d+)\\s*(\\w+)?'     byte_string_re = re.compile(byte_string_pattern, re.IGNORECASE)      @classmethod     def __get_pydantic_core_schema__(cls, source: type[Any], handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:         return core_schema.with_info_after_validator_function(             function=cls._validate,             schema=core_schema.union_schema(                 [                     core_schema.str_schema(pattern=cls.byte_string_pattern),                     core_schema.int_schema(ge=0),                 ],                 custom_error_type='byte_size',                 custom_error_message='could not parse value and unit from byte string',             ),             serialization=core_schema.plain_serializer_function_ser_schema(                 int, return_schema=core_schema.int_schema(ge=0)             ),         )      @classmethod     def _validate(cls, input_value: Any, /, _: core_schema.ValidationInfo) -> ByteSize:         try:             return cls(int(input_value))         except ValueError:             pass          str_match = cls.byte_string_re.match(str(input_value))         if str_match is None:             raise PydanticCustomError('byte_size', 'could not parse value and unit from byte string')          scalar, unit = str_match.groups()         if unit is None:             unit = 'b'          try:             unit_mult = cls.byte_sizes[unit.lower()]         except KeyError:             raise PydanticCustomError('byte_size_unit', 'could not interpret byte unit: {unit}', {'unit': unit})          return cls(int(float(scalar) * unit_mult))      def human_readable(self, decimal: bool = False, separator: str = '') -> str:         \"\"\"Converts a byte size to a human readable string.          Args:             decimal: If True, use decimal units (e.g. 1000 bytes per KB). If False, use binary units                 (e.g. 1024 bytes per KiB).             separator: A string used to split the value and unit. Defaults to an empty string ('').          Returns:             A human readable string representation of the byte size.         \"\"\"         if decimal:             divisor = 1000             units = 'B', 'KB', 'MB', 'GB', 'TB', 'PB'             final_unit = 'EB'         else:             divisor = 1024             units = 'B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB'             final_unit = 'EiB'          num = float(self)         for unit in units:             if abs(num) < divisor:                 if unit == 'B':                     return f'{num:0.0f}{separator}{unit}'                 else:                     return f'{num:0.1f}{separator}{unit}'             num /= divisor          return f'{num:0.1f}{separator}{final_unit}'      def to(self, unit: str) -> float:         \"\"\"Converts a byte size to another unit, including both byte and bit units.          Args:             unit: The unit to convert to. Must be one of the following: B, KB, MB, GB, TB, PB, EB,                 KiB, MiB, GiB, TiB, PiB, EiB (byte units) and                 bit, kbit, mbit, gbit, tbit, pbit, ebit,                 kibit, mibit, gibit, tibit, pibit, eibit (bit units).          Returns:             The byte size in the new unit.         \"\"\"         try:             unit_div = self.byte_sizes[unit.lower()]         except KeyError:             raise PydanticCustomError('byte_size_unit', 'Could not interpret byte unit: {unit}', {'unit': unit})          return self / unit_div ``` |", "url": "https://docs.pydantic.dev/latest/api/types/index.html#bytesize-indexhtmlpydantictypesbytesize-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "ByteSize [Â¶](index.html#pydantic.types.ByteSize \"Permanent link\")", "anchor": "bytesize-indexhtmlpydantictypesbytesize-permanent-link", "md_text": "#### human\\_readable [Â¶](index.html#pydantic.types.ByteSize.human_readable \"Permanent link\")\n\n```\nhuman_readable(\n    decimal: bool = False, separator: str = \"\"\n) -> str\n```\n\nConverts a byte size to a human readable string.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `decimal` | `bool` | If True, use decimal units (e.g. 1000 bytes per KB). If False, use binary units (e.g. 1024 bytes per KiB). | `False` |\n| `separator` | `str` | A string used to split the value and unit. Defaults to an empty string (''). | `''` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `str` | A human readable string representation of the byte size. |\n\nSource code in `pydantic/types.py`\n\n|  |  |\n| --- | --- |\n| ``` 2134 2135 2136 2137 2138 2139 2140 2141 2142 2143 2144 2145 2146 2147 2148 2149 2150 2151 2152 2153 2154 2155 2156 2157 2158 2159 2160 2161 2162 2163 ``` | ``` def human_readable(self, decimal: bool = False, separator: str = '') -> str:     \"\"\"Converts a byte size to a human readable string.      Args:         decimal: If True, use decimal units (e.g. 1000 bytes per KB). If False, use binary units             (e.g. 1024 bytes per KiB).         separator: A string used to split the value and unit. Defaults to an empty string ('').      Returns:         A human readable string representation of the byte size.     \"\"\"     if decimal:         divisor = 1000         units = 'B', 'KB', 'MB', 'GB', 'TB', 'PB'         final_unit = 'EB'     else:         divisor = 1024         units = 'B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB'         final_unit = 'EiB'      num = float(self)     for unit in units:         if abs(num) < divisor:             if unit == 'B':                 return f'{num:0.0f}{separator}{unit}'             else:                 return f'{num:0.1f}{separator}{unit}'         num /= divisor      return f'{num:0.1f}{separator}{final_unit}' ``` |\n\n#### to [Â¶](index.html#pydantic.types.ByteSize.to \"Permanent link\")\n\n```\nto(unit: str) -> float\n```\n\nConverts a byte size to another unit, including both byte and bit units.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `unit` | `str` | The unit to convert to. Must be one of the following: B, KB, MB, GB, TB, PB, EB, KiB, MiB, GiB, TiB, PiB, EiB (byte units) and bit, kbit, mbit, gbit, tbit, pbit, ebit, kibit, mibit, gibit, tibit, pibit, eibit (bit units). | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `float` | The byte size in the new unit. |\n\nSource code in `pydantic/types.py`\n\n|  |  |\n| --- | --- |\n| ``` 2165 2166 2167 2168 2169 2170 2171 2172 2173 2174 2175 2176 2177 2178 2179 2180 2181 2182 ``` | ``` def to(self, unit: str) -> float:     \"\"\"Converts a byte size to another unit, including both byte and bit units.      Args:         unit: The unit to convert to. Must be one of the following: B, KB, MB, GB, TB, PB, EB,             KiB, MiB, GiB, TiB, PiB, EiB (byte units) and             bit, kbit, mbit, gbit, tbit, pbit, ebit,             kibit, mibit, gibit, tibit, pibit, eibit (bit units).      Returns:         The byte size in the new unit.     \"\"\"     try:         unit_div = self.byte_sizes[unit.lower()]     except KeyError:         raise PydanticCustomError('byte_size_unit', 'Could not interpret byte unit: {unit}', {'unit': unit})      return self / unit_div ``` |", "url": "https://docs.pydantic.dev/latest/api/types/index.html#bytesize-indexhtmlpydantictypesbytesize-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "PastDate [Â¶](index.html#pydantic.types.PastDate \"Permanent link\")", "anchor": "pastdate-indexhtmlpydantictypespastdate-permanent-link", "md_text": "A date in the past.\n\nSource code in `pydantic/types.py`\n\n|  |  |\n| --- | --- |\n| ``` 2198 2199 2200 2201 2202 2203 2204 2205 2206 2207 2208 2209 2210 2211 2212 2213 2214 2215 ``` | ``` class PastDate:     \"\"\"A date in the past.\"\"\"      @classmethod     def __get_pydantic_core_schema__(         cls, source: type[Any], handler: GetCoreSchemaHandler     ) -> core_schema.CoreSchema:         if cls is source:             # used directly as a type             return core_schema.date_schema(now_op='past')         else:             schema = handler(source)             _check_annotated_type(schema['type'], 'date', cls.__name__)             schema['now_op'] = 'past'             return schema      def __repr__(self) -> str:         return 'PastDate' ``` |", "url": "https://docs.pydantic.dev/latest/api/types/index.html#pastdate-indexhtmlpydantictypespastdate-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "FutureDate [Â¶](index.html#pydantic.types.FutureDate \"Permanent link\")", "anchor": "futuredate-indexhtmlpydantictypesfuturedate-permanent-link", "md_text": "A date in the future.\n\nSource code in `pydantic/types.py`\n\n|  |  |\n| --- | --- |\n| ``` 2217 2218 2219 2220 2221 2222 2223 2224 2225 2226 2227 2228 2229 2230 2231 2232 2233 2234 ``` | ``` class FutureDate:     \"\"\"A date in the future.\"\"\"      @classmethod     def __get_pydantic_core_schema__(         cls, source: type[Any], handler: GetCoreSchemaHandler     ) -> core_schema.CoreSchema:         if cls is source:             # used directly as a type             return core_schema.date_schema(now_op='future')         else:             schema = handler(source)             _check_annotated_type(schema['type'], 'date', cls.__name__)             schema['now_op'] = 'future'             return schema      def __repr__(self) -> str:         return 'FutureDate' ``` |", "url": "https://docs.pydantic.dev/latest/api/types/index.html#futuredate-indexhtmlpydantictypesfuturedate-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "AwareDatetime [Â¶](index.html#pydantic.types.AwareDatetime \"Permanent link\")", "anchor": "awaredatetime-indexhtmlpydantictypesawaredatetime-permanent-link", "md_text": "A datetime that requires timezone info.\n\nSource code in `pydantic/types.py`\n\n|  |  |\n| --- | --- |\n| ``` 2274 2275 2276 2277 2278 2279 2280 2281 2282 2283 2284 2285 2286 2287 2288 2289 2290 2291 ``` | ``` class AwareDatetime:     \"\"\"A datetime that requires timezone info.\"\"\"      @classmethod     def __get_pydantic_core_schema__(         cls, source: type[Any], handler: GetCoreSchemaHandler     ) -> core_schema.CoreSchema:         if cls is source:             # used directly as a type             return core_schema.datetime_schema(tz_constraint='aware')         else:             schema = handler(source)             _check_annotated_type(schema['type'], 'datetime', cls.__name__)             schema['tz_constraint'] = 'aware'             return schema      def __repr__(self) -> str:         return 'AwareDatetime' ``` |", "url": "https://docs.pydantic.dev/latest/api/types/index.html#awaredatetime-indexhtmlpydantictypesawaredatetime-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "NaiveDatetime [Â¶](index.html#pydantic.types.NaiveDatetime \"Permanent link\")", "anchor": "naivedatetime-indexhtmlpydantictypesnaivedatetime-permanent-link", "md_text": "A datetime that doesn't require timezone info.\n\nSource code in `pydantic/types.py`\n\n|  |  |\n| --- | --- |\n| ``` 2293 2294 2295 2296 2297 2298 2299 2300 2301 2302 2303 2304 2305 2306 2307 2308 2309 2310 ``` | ``` class NaiveDatetime:     \"\"\"A datetime that doesn't require timezone info.\"\"\"      @classmethod     def __get_pydantic_core_schema__(         cls, source: type[Any], handler: GetCoreSchemaHandler     ) -> core_schema.CoreSchema:         if cls is source:             # used directly as a type             return core_schema.datetime_schema(tz_constraint='naive')         else:             schema = handler(source)             _check_annotated_type(schema['type'], 'datetime', cls.__name__)             schema['tz_constraint'] = 'naive'             return schema      def __repr__(self) -> str:         return 'NaiveDatetime' ``` |", "url": "https://docs.pydantic.dev/latest/api/types/index.html#naivedatetime-indexhtmlpydantictypesnaivedatetime-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "PastDatetime [Â¶](index.html#pydantic.types.PastDatetime \"Permanent link\")", "anchor": "pastdatetime-indexhtmlpydantictypespastdatetime-permanent-link", "md_text": "A datetime that must be in the past.\n\nSource code in `pydantic/types.py`\n\n|  |  |\n| --- | --- |\n| ``` 2312 2313 2314 2315 2316 2317 2318 2319 2320 2321 2322 2323 2324 2325 2326 2327 2328 2329 ``` | ``` class PastDatetime:     \"\"\"A datetime that must be in the past.\"\"\"      @classmethod     def __get_pydantic_core_schema__(         cls, source: type[Any], handler: GetCoreSchemaHandler     ) -> core_schema.CoreSchema:         if cls is source:             # used directly as a type             return core_schema.datetime_schema(now_op='past')         else:             schema = handler(source)             _check_annotated_type(schema['type'], 'datetime', cls.__name__)             schema['now_op'] = 'past'             return schema      def __repr__(self) -> str:         return 'PastDatetime' ``` |", "url": "https://docs.pydantic.dev/latest/api/types/index.html#pastdatetime-indexhtmlpydantictypespastdatetime-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "FutureDatetime [Â¶](index.html#pydantic.types.FutureDatetime \"Permanent link\")", "anchor": "futuredatetime-indexhtmlpydantictypesfuturedatetime-permanent-link", "md_text": "A datetime that must be in the future.\n\nSource code in `pydantic/types.py`\n\n|  |  |\n| --- | --- |\n| ``` 2331 2332 2333 2334 2335 2336 2337 2338 2339 2340 2341 2342 2343 2344 2345 2346 2347 2348 ``` | ``` class FutureDatetime:     \"\"\"A datetime that must be in the future.\"\"\"      @classmethod     def __get_pydantic_core_schema__(         cls, source: type[Any], handler: GetCoreSchemaHandler     ) -> core_schema.CoreSchema:         if cls is source:             # used directly as a type             return core_schema.datetime_schema(now_op='future')         else:             schema = handler(source)             _check_annotated_type(schema['type'], 'datetime', cls.__name__)             schema['now_op'] = 'future'             return schema      def __repr__(self) -> str:         return 'FutureDatetime' ``` |", "url": "https://docs.pydantic.dev/latest/api/types/index.html#futuredatetime-indexhtmlpydantictypesfuturedatetime-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "EncoderProtocol [Â¶](index.html#pydantic.types.EncoderProtocol \"Permanent link\")", "anchor": "encoderprotocol-indexhtmlpydantictypesencoderprotocol-permanent-link", "md_text": "Bases: `Protocol`\n\nProtocol for encoding and decoding data to and from bytes.\n\nSource code in `pydantic/types.py`\n\n|  |  |\n| --- | --- |\n| ``` 2354 2355 2356 2357 2358 2359 2360 2361 2362 2363 2364 2365 2366 2367 2368 2369 2370 2371 2372 2373 2374 2375 2376 2377 2378 2379 2380 2381 2382 2383 2384 2385 2386 2387 2388 ``` | ``` class EncoderProtocol(Protocol):     \"\"\"Protocol for encoding and decoding data to and from bytes.\"\"\"      @classmethod     def decode(cls, data: bytes) -> bytes:         \"\"\"Decode the data using the encoder.          Args:             data: The data to decode.          Returns:             The decoded data.         \"\"\"         ...      @classmethod     def encode(cls, value: bytes) -> bytes:         \"\"\"Encode the data using the encoder.          Args:             value: The data to encode.          Returns:             The encoded data.         \"\"\"         ...      @classmethod     def get_json_format(cls) -> str:         \"\"\"Get the JSON format for the encoded data.          Returns:             The JSON format for the encoded data.         \"\"\"         ... ``` |\n\n#### decode `classmethod` [Â¶](index.html#pydantic.types.EncoderProtocol.decode \"Permanent link\")\n\n```\ndecode(data: bytes) -> bytes\n```\n\nDecode the data using the encoder.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `data` | `bytes` | The data to decode. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `bytes` | The decoded data. |\n\nSource code in `pydantic/types.py`\n\n|  |  |\n| --- | --- |\n| ``` 2357 2358 2359 2360 2361 2362 2363 2364 2365 2366 2367 ``` | ``` @classmethod def decode(cls, data: bytes) -> bytes:     \"\"\"Decode the data using the encoder.      Args:         data: The data to decode.      Returns:         The decoded data.     \"\"\"     ... ``` |\n\n#### encode `classmethod` [Â¶](index.html#pydantic.types.EncoderProtocol.encode \"Permanent link\")\n\n```\nencode(value: bytes) -> bytes\n```\n\nEncode the data using the encoder.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `value` | `bytes` | The data to encode. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `bytes` | The encoded data. |\n\nSource code in `pydantic/types.py`\n\n|  |  |\n| --- | --- |\n| ``` 2369 2370 2371 2372 2373 2374 2375 2376 2377 2378 2379 ``` | ``` @classmethod def encode(cls, value: bytes) -> bytes:     \"\"\"Encode the data using the encoder.      Args:         value: The data to encode.      Returns:         The encoded data.     \"\"\"     ... ``` |\n\n#### get\\_json\\_format `classmethod` [Â¶](index.html#pydantic.types.EncoderProtocol.get_json_format \"Permanent link\")\n\n```\nget_json_format() -> str\n```\n\nGet the JSON format for the encoded data.\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `str` | The JSON format for the encoded data. |\n\nSource code in `pydantic/types.py`\n\n|  |  |\n| --- | --- |\n| ``` 2381 2382 2383 2384 2385 2386 2387 2388 ``` | ``` @classmethod def get_json_format(cls) -> str:     \"\"\"Get the JSON format for the encoded data.      Returns:         The JSON format for the encoded data.     \"\"\"     ... ``` |", "url": "https://docs.pydantic.dev/latest/api/types/index.html#encoderprotocol-indexhtmlpydantictypesencoderprotocol-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "Base64Encoder [Â¶](index.html#pydantic.types.Base64Encoder \"Permanent link\")", "anchor": "base64encoder-indexhtmlpydantictypesbase64encoder-permanent-link", "md_text": "Bases: `EncoderProtocol`\n\nStandard (non-URL-safe) Base64 encoder.\n\nSource code in `pydantic/types.py`\n\n|  |  |\n| --- | --- |\n| ``` 2391 2392 2393 2394 2395 2396 2397 2398 2399 2400 2401 2402 2403 2404 2405 2406 2407 2408 2409 2410 2411 2412 2413 2414 2415 2416 2417 2418 2419 2420 2421 2422 2423 2424 2425 2426 2427 2428 ``` | ``` class Base64Encoder(EncoderProtocol):     \"\"\"Standard (non-URL-safe) Base64 encoder.\"\"\"      @classmethod     def decode(cls, data: bytes) -> bytes:         \"\"\"Decode the data from base64 encoded bytes to original bytes data.          Args:             data: The data to decode.          Returns:             The decoded data.         \"\"\"         try:             return base64.b64decode(data)         except ValueError as e:             raise PydanticCustomError('base64_decode', \"Base64 decoding error: '{error}'\", {'error': str(e)})      @classmethod     def encode(cls, value: bytes) -> bytes:         \"\"\"Encode the data from bytes to a base64 encoded bytes.          Args:             value: The data to encode.          Returns:             The encoded data.         \"\"\"         return base64.b64encode(value)      @classmethod     def get_json_format(cls) -> Literal['base64']:         \"\"\"Get the JSON format for the encoded data.          Returns:             The JSON format for the encoded data.         \"\"\"         return 'base64' ``` |\n\n#### decode `classmethod` [Â¶](index.html#pydantic.types.Base64Encoder.decode \"Permanent link\")\n\n```\ndecode(data: bytes) -> bytes\n```\n\nDecode the data from base64 encoded bytes to original bytes data.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `data` | `bytes` | The data to decode. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `bytes` | The decoded data. |\n\nSource code in `pydantic/types.py`\n\n|  |  |\n| --- | --- |\n| ``` 2394 2395 2396 2397 2398 2399 2400 2401 2402 2403 2404 2405 2406 2407 ``` | ``` @classmethod def decode(cls, data: bytes) -> bytes:     \"\"\"Decode the data from base64 encoded bytes to original bytes data.      Args:         data: The data to decode.      Returns:         The decoded data.     \"\"\"     try:         return base64.b64decode(data)     except ValueError as e:         raise PydanticCustomError('base64_decode', \"Base64 decoding error: '{error}'\", {'error': str(e)}) ``` |\n\n#### encode `classmethod` [Â¶](index.html#pydantic.types.Base64Encoder.encode \"Permanent link\")\n\n```\nencode(value: bytes) -> bytes\n```\n\nEncode the data from bytes to a base64 encoded bytes.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `value` | `bytes` | The data to encode. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `bytes` | The encoded data. |\n\nSource code in `pydantic/types.py`\n\n|  |  |\n| --- | --- |\n| ``` 2409 2410 2411 2412 2413 2414 2415 2416 2417 2418 2419 ``` | ``` @classmethod def encode(cls, value: bytes) -> bytes:     \"\"\"Encode the data from bytes to a base64 encoded bytes.      Args:         value: The data to encode.      Returns:         The encoded data.     \"\"\"     return base64.b64encode(value) ``` |\n\n#### get\\_json\\_format `classmethod` [Â¶](index.html#pydantic.types.Base64Encoder.get_json_format \"Permanent link\")\n\n```\nget_json_format() -> Literal['base64']\n```\n\nGet the JSON format for the encoded data.\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `Literal['base64']` | The JSON format for the encoded data. |\n\nSource code in `pydantic/types.py`\n\n|  |  |\n| --- | --- |\n| ``` 2421 2422 2423 2424 2425 2426 2427 2428 ``` | ``` @classmethod def get_json_format(cls) -> Literal['base64']:     \"\"\"Get the JSON format for the encoded data.      Returns:         The JSON format for the encoded data.     \"\"\"     return 'base64' ``` |", "url": "https://docs.pydantic.dev/latest/api/types/index.html#base64encoder-indexhtmlpydantictypesbase64encoder-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "Base64UrlEncoder [Â¶](index.html#pydantic.types.Base64UrlEncoder \"Permanent link\")", "anchor": "base64urlencoder-indexhtmlpydantictypesbase64urlencoder-permanent-link", "md_text": "Bases: `EncoderProtocol`\n\nURL-safe Base64 encoder.\n\nSource code in `pydantic/types.py`\n\n|  |  |\n| --- | --- |\n| ``` 2431 2432 2433 2434 2435 2436 2437 2438 2439 2440 2441 2442 2443 2444 2445 2446 2447 2448 2449 2450 2451 2452 2453 2454 2455 2456 2457 2458 2459 2460 2461 2462 2463 2464 2465 2466 2467 2468 ``` | ``` class Base64UrlEncoder(EncoderProtocol):     \"\"\"URL-safe Base64 encoder.\"\"\"      @classmethod     def decode(cls, data: bytes) -> bytes:         \"\"\"Decode the data from base64 encoded bytes to original bytes data.          Args:             data: The data to decode.          Returns:             The decoded data.         \"\"\"         try:             return base64.urlsafe_b64decode(data)         except ValueError as e:             raise PydanticCustomError('base64_decode', \"Base64 decoding error: '{error}'\", {'error': str(e)})      @classmethod     def encode(cls, value: bytes) -> bytes:         \"\"\"Encode the data from bytes to a base64 encoded bytes.          Args:             value: The data to encode.          Returns:             The encoded data.         \"\"\"         return base64.urlsafe_b64encode(value)      @classmethod     def get_json_format(cls) -> Literal['base64url']:         \"\"\"Get the JSON format for the encoded data.          Returns:             The JSON format for the encoded data.         \"\"\"         return 'base64url' ``` |\n\n#### decode `classmethod` [Â¶](index.html#pydantic.types.Base64UrlEncoder.decode \"Permanent link\")\n\n```\ndecode(data: bytes) -> bytes\n```\n\nDecode the data from base64 encoded bytes to original bytes data.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `data` | `bytes` | The data to decode. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `bytes` | The decoded data. |\n\nSource code in `pydantic/types.py`\n\n|  |  |\n| --- | --- |\n| ``` 2434 2435 2436 2437 2438 2439 2440 2441 2442 2443 2444 2445 2446 2447 ``` | ``` @classmethod def decode(cls, data: bytes) -> bytes:     \"\"\"Decode the data from base64 encoded bytes to original bytes data.      Args:         data: The data to decode.      Returns:         The decoded data.     \"\"\"     try:         return base64.urlsafe_b64decode(data)     except ValueError as e:         raise PydanticCustomError('base64_decode', \"Base64 decoding error: '{error}'\", {'error': str(e)}) ``` |\n\n#### encode `classmethod` [Â¶](index.html#pydantic.types.Base64UrlEncoder.encode \"Permanent link\")\n\n```\nencode(value: bytes) -> bytes\n```\n\nEncode the data from bytes to a base64 encoded bytes.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `value` | `bytes` | The data to encode. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `bytes` | The encoded data. |\n\nSource code in `pydantic/types.py`\n\n|  |  |\n| --- | --- |\n| ``` 2449 2450 2451 2452 2453 2454 2455 2456 2457 2458 2459 ``` | ``` @classmethod def encode(cls, value: bytes) -> bytes:     \"\"\"Encode the data from bytes to a base64 encoded bytes.      Args:         value: The data to encode.      Returns:         The encoded data.     \"\"\"     return base64.urlsafe_b64encode(value) ``` |\n\n#### get\\_json\\_format `classmethod` [Â¶](index.html#pydantic.types.Base64UrlEncoder.get_json_format \"Permanent link\")\n\n```\nget_json_format() -> Literal['base64url']\n```\n\nGet the JSON format for the encoded data.\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `Literal['base64url']` | The JSON format for the encoded data. |\n\nSource code in `pydantic/types.py`\n\n|  |  |\n| --- | --- |\n| ``` 2461 2462 2463 2464 2465 2466 2467 2468 ``` | ``` @classmethod def get_json_format(cls) -> Literal['base64url']:     \"\"\"Get the JSON format for the encoded data.      Returns:         The JSON format for the encoded data.     \"\"\"     return 'base64url' ``` |", "url": "https://docs.pydantic.dev/latest/api/types/index.html#base64urlencoder-indexhtmlpydantictypesbase64urlencoder-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "EncodedBytes `dataclass` [Â¶](index.html#pydantic.types.EncodedBytes \"Permanent link\")", "anchor": "encodedbytes-dataclass-indexhtmlpydantictypesencodedbytes-permanent-link", "md_text": "A bytes type that is encoded and decoded using the specified encoder.\n\n`EncodedBytes` needs an encoder that implements `EncoderProtocol` to operate.\n\n```\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, EncodedBytes, EncoderProtocol, ValidationError\n\nclass MyEncoder(EncoderProtocol):\n    @classmethod\n    def decode(cls, data: bytes) -> bytes:\n        if data == b'**undecodable**':\n            raise ValueError('Cannot decode data')\n        return data[13:]\n\n    @classmethod\n    def encode(cls, value: bytes) -> bytes:\n        return b'**encoded**: ' + value\n\n    @classmethod\n    def get_json_format(cls) -> str:\n        return 'my-encoder'\n\nMyEncodedBytes = Annotated[bytes, EncodedBytes(encoder=MyEncoder)]\n\nclass Model(BaseModel):\n    my_encoded_bytes: MyEncodedBytes\n\n# Initialize the model with encoded data\nm = Model(my_encoded_bytes=b'**encoded**: some bytes')\n\n# Access decoded value\nprint(m.my_encoded_bytes)\n#> b'some bytes'\n\n# Serialize into the encoded form\nprint(m.model_dump())\n#> {'my_encoded_bytes': b'**encoded**: some bytes'}\n\n# Validate encoded data\ntry:\n    Model(my_encoded_bytes=b'**undecodable**')\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for Model\n    my_encoded_bytes\n      Value error, Cannot decode data [type=value_error, input_value=b'**undecodable**', input_type=bytes]\n    '''\n```\n\nSource code in `pydantic/types.py`", "url": "https://docs.pydantic.dev/latest/api/types/index.html#encodedbytes-dataclass-indexhtmlpydantictypesencodedbytes-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "EncodedBytes `dataclass` [Â¶](index.html#pydantic.types.EncodedBytes \"Permanent link\")", "anchor": "encodedbytes-dataclass-indexhtmlpydantictypesencodedbytes-permanent-link", "md_text": "|  |  |\n| --- | --- |\n| ``` 2471 2472 2473 2474 2475 2476 2477 2478 2479 2480 2481 2482 2483 2484 2485 2486 2487 2488 2489 2490 2491 2492 2493 2494 2495 2496 2497 2498 2499 2500 2501 2502 2503 2504 2505 2506 2507 2508 2509 2510 2511 2512 2513 2514 2515 2516 2517 2518 2519 2520 2521 2522 2523 2524 2525 2526 2527 2528 2529 2530 2531 2532 2533 2534 2535 2536 2537 2538 2539 2540 2541 2542 2543 2544 2545 2546 2547 2548 2549 2550 2551 2552 2553 2554 2555 2556 2557 2558 2559 2560 2561 2562 2563 2564 2565 2566 2567 ``` | ``` @_dataclasses.dataclass(**_internal_dataclass.slots_true) class EncodedBytes:     \"\"\"A bytes type that is encoded and decoded using the specified encoder.      `EncodedBytes` needs an encoder that implements `EncoderProtocol` to operate.      ```python     from typing import Annotated      from pydantic import BaseModel, EncodedBytes, EncoderProtocol, ValidationError      class MyEncoder(EncoderProtocol):         @classmethod         def decode(cls, data: bytes) -> bytes:             if data == b'**undecodable**':                 raise ValueError('Cannot decode data')             return data[13:]          @classmethod         def encode(cls, value: bytes) -> bytes:             return b'**encoded**: ' + value          @classmethod         def get_json_format(cls) -> str:             return 'my-encoder'      MyEncodedBytes = Annotated[bytes, EncodedBytes(encoder=MyEncoder)]      class Model(BaseModel):         my_encoded_bytes: MyEncodedBytes      # Initialize the model with encoded data     m = Model(my_encoded_bytes=b'**encoded**: some bytes')      # Access decoded value     print(m.my_encoded_bytes)     #> b'some bytes'      # Serialize into the encoded form     print(m.model_dump())     #> {'my_encoded_bytes': b'**encoded**: some bytes'}      # Validate encoded data     try:         Model(my_encoded_bytes=b'**undecodable**')     except ValidationError as e:         print(e)         '''         1 validation error for Model         my_encoded_bytes           Value error, Cannot decode data [type=value_error, input_value=b'**undecodable**', input_type=bytes]         '''     ```     \"\"\"      encoder: type[EncoderProtocol]      def __get_pydantic_json_schema__(         self, core_schema: core_schema.CoreSchema, handler: GetJsonSchemaHandler     ) -> JsonSchemaValue:         field_schema = handler(core_schema)         field_schema.update(type='string', format=self.encoder.get_json_format())         return field_schema      def __get_pydantic_core_schema__(self, source: type[Any], handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:         schema = handler(source)         _check_annotated_type(schema['type'], 'bytes', self.__class__.__name__)         return core_schema.with_info_after_validator_function(             function=self.decode,             schema=schema,             serialization=core_schema.plain_serializer_function_ser_schema(function=self.encode),         )      def decode(self, data: bytes, _: core_schema.ValidationInfo) -> bytes:         \"\"\"Decode the data using the specified encoder.          Args:             data: The data to decode.          Returns:             The decoded data.         \"\"\"         return self.encoder.decode(data)      def encode(self, value: bytes) -> bytes:         \"\"\"Encode the data using the specified encoder.          Args:             value: The data to encode.          Returns:             The encoded data.         \"\"\"         return self.encoder.encode(value)      def __hash__(self) -> int:         return hash(self.encoder) ``` |\n\n#### decode [Â¶](index.html#pydantic.types.EncodedBytes.decode \"Permanent link\")\n\n```\ndecode(data: bytes, _: ValidationInfo) -> bytes\n```\n\nDecode the data using the specified encoder.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `data` | `bytes` | The data to decode. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `bytes` | The decoded data. |\n\nSource code in `pydantic/types.py`\n\n|  |  |\n| --- | --- |\n| ``` 2544 2545 2546 2547 2548 2549 2550 2551 2552 2553 ``` | ``` def decode(self, data: bytes, _: core_schema.ValidationInfo) -> bytes:     \"\"\"Decode the data using the specified encoder.      Args:         data: The data to decode.      Returns:         The decoded data.     \"\"\"     return self.encoder.decode(data) ``` |\n\n#### encode [Â¶](index.html#pydantic.types.EncodedBytes.encode \"Permanent link\")\n\n```\nencode(value: bytes) -> bytes\n```\n\nEncode the data using the specified encoder.\n\nParameters:", "url": "https://docs.pydantic.dev/latest/api/types/index.html#encodedbytes-dataclass-indexhtmlpydantictypesencodedbytes-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "EncodedBytes `dataclass` [Â¶](index.html#pydantic.types.EncodedBytes \"Permanent link\")", "anchor": "encodedbytes-dataclass-indexhtmlpydantictypesencodedbytes-permanent-link", "md_text": "| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `value` | `bytes` | The data to encode. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `bytes` | The encoded data. |\n\nSource code in `pydantic/types.py`\n\n|  |  |\n| --- | --- |\n| ``` 2555 2556 2557 2558 2559 2560 2561 2562 2563 2564 ``` | ``` def encode(self, value: bytes) -> bytes:     \"\"\"Encode the data using the specified encoder.      Args:         value: The data to encode.      Returns:         The encoded data.     \"\"\"     return self.encoder.encode(value) ``` |", "url": "https://docs.pydantic.dev/latest/api/types/index.html#encodedbytes-dataclass-indexhtmlpydantictypesencodedbytes-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "EncodedStr `dataclass` [Â¶](index.html#pydantic.types.EncodedStr \"Permanent link\")", "anchor": "encodedstr-dataclass-indexhtmlpydantictypesencodedstr-permanent-link", "md_text": "A str type that is encoded and decoded using the specified encoder.\n\n`EncodedStr` needs an encoder that implements `EncoderProtocol` to operate.\n\n```\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, EncodedStr, EncoderProtocol, ValidationError\n\nclass MyEncoder(EncoderProtocol):\n    @classmethod\n    def decode(cls, data: bytes) -> bytes:\n        if data == b'**undecodable**':\n            raise ValueError('Cannot decode data')\n        return data[13:]\n\n    @classmethod\n    def encode(cls, value: bytes) -> bytes:\n        return b'**encoded**: ' + value\n\n    @classmethod\n    def get_json_format(cls) -> str:\n        return 'my-encoder'\n\nMyEncodedStr = Annotated[str, EncodedStr(encoder=MyEncoder)]\n\nclass Model(BaseModel):\n    my_encoded_str: MyEncodedStr\n\n# Initialize the model with encoded data\nm = Model(my_encoded_str='**encoded**: some str')\n\n# Access decoded value\nprint(m.my_encoded_str)\n#> some str\n\n# Serialize into the encoded form\nprint(m.model_dump())\n#> {'my_encoded_str': '**encoded**: some str'}\n\n# Validate encoded data\ntry:\n    Model(my_encoded_str='**undecodable**')\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for Model\n    my_encoded_str\n      Value error, Cannot decode data [type=value_error, input_value='**undecodable**', input_type=str]\n    '''\n```\n\nSource code in `pydantic/types.py`", "url": "https://docs.pydantic.dev/latest/api/types/index.html#encodedstr-dataclass-indexhtmlpydantictypesencodedstr-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "EncodedStr `dataclass` [Â¶](index.html#pydantic.types.EncodedStr \"Permanent link\")", "anchor": "encodedstr-dataclass-indexhtmlpydantictypesencodedstr-permanent-link", "md_text": "|  |  |\n| --- | --- |\n| ``` 2570 2571 2572 2573 2574 2575 2576 2577 2578 2579 2580 2581 2582 2583 2584 2585 2586 2587 2588 2589 2590 2591 2592 2593 2594 2595 2596 2597 2598 2599 2600 2601 2602 2603 2604 2605 2606 2607 2608 2609 2610 2611 2612 2613 2614 2615 2616 2617 2618 2619 2620 2621 2622 2623 2624 2625 2626 2627 2628 2629 2630 2631 2632 2633 2634 2635 2636 2637 2638 2639 2640 2641 2642 2643 2644 2645 2646 2647 2648 2649 2650 2651 2652 2653 2654 2655 2656 2657 2658 2659 2660 2661 2662 2663 2664 2665 2666 ``` | ``` @_dataclasses.dataclass(**_internal_dataclass.slots_true) class EncodedStr:     \"\"\"A str type that is encoded and decoded using the specified encoder.      `EncodedStr` needs an encoder that implements `EncoderProtocol` to operate.      ```python     from typing import Annotated      from pydantic import BaseModel, EncodedStr, EncoderProtocol, ValidationError      class MyEncoder(EncoderProtocol):         @classmethod         def decode(cls, data: bytes) -> bytes:             if data == b'**undecodable**':                 raise ValueError('Cannot decode data')             return data[13:]          @classmethod         def encode(cls, value: bytes) -> bytes:             return b'**encoded**: ' + value          @classmethod         def get_json_format(cls) -> str:             return 'my-encoder'      MyEncodedStr = Annotated[str, EncodedStr(encoder=MyEncoder)]      class Model(BaseModel):         my_encoded_str: MyEncodedStr      # Initialize the model with encoded data     m = Model(my_encoded_str='**encoded**: some str')      # Access decoded value     print(m.my_encoded_str)     #> some str      # Serialize into the encoded form     print(m.model_dump())     #> {'my_encoded_str': '**encoded**: some str'}      # Validate encoded data     try:         Model(my_encoded_str='**undecodable**')     except ValidationError as e:         print(e)         '''         1 validation error for Model         my_encoded_str           Value error, Cannot decode data [type=value_error, input_value='**undecodable**', input_type=str]         '''     ```     \"\"\"      encoder: type[EncoderProtocol]      def __get_pydantic_json_schema__(         self, core_schema: core_schema.CoreSchema, handler: GetJsonSchemaHandler     ) -> JsonSchemaValue:         field_schema = handler(core_schema)         field_schema.update(type='string', format=self.encoder.get_json_format())         return field_schema      def __get_pydantic_core_schema__(self, source: type[Any], handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:         schema = handler(source)         _check_annotated_type(schema['type'], 'str', self.__class__.__name__)         return core_schema.with_info_after_validator_function(             function=self.decode_str,             schema=schema,             serialization=core_schema.plain_serializer_function_ser_schema(function=self.encode_str),         )      def decode_str(self, data: str, _: core_schema.ValidationInfo) -> str:         \"\"\"Decode the data using the specified encoder.          Args:             data: The data to decode.          Returns:             The decoded data.         \"\"\"         return self.encoder.decode(data.encode()).decode()      def encode_str(self, value: str) -> str:         \"\"\"Encode the data using the specified encoder.          Args:             value: The data to encode.          Returns:             The encoded data.         \"\"\"         return self.encoder.encode(value.encode()).decode()  # noqa: UP008      def __hash__(self) -> int:         return hash(self.encoder) ``` |\n\n#### decode\\_str [Â¶](index.html#pydantic.types.EncodedStr.decode_str \"Permanent link\")\n\n```\ndecode_str(data: str, _: ValidationInfo) -> str\n```\n\nDecode the data using the specified encoder.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `data` | `str` | The data to decode. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `str` | The decoded data. |\n\nSource code in `pydantic/types.py`\n\n|  |  |\n| --- | --- |\n| ``` 2643 2644 2645 2646 2647 2648 2649 2650 2651 2652 ``` | ``` def decode_str(self, data: str, _: core_schema.ValidationInfo) -> str:     \"\"\"Decode the data using the specified encoder.      Args:         data: The data to decode.      Returns:         The decoded data.     \"\"\"     return self.encoder.decode(data.encode()).decode() ``` |\n\n#### encode\\_str [Â¶](index.html#pydantic.types.EncodedStr.encode_str \"Permanent link\")", "url": "https://docs.pydantic.dev/latest/api/types/index.html#encodedstr-dataclass-indexhtmlpydantictypesencodedstr-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "EncodedStr `dataclass` [Â¶](index.html#pydantic.types.EncodedStr \"Permanent link\")", "anchor": "encodedstr-dataclass-indexhtmlpydantictypesencodedstr-permanent-link", "md_text": "```\nencode_str(value: str) -> str\n```\n\nEncode the data using the specified encoder.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `value` | `str` | The data to encode. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `str` | The encoded data. |\n\nSource code in `pydantic/types.py`\n\n|  |  |\n| --- | --- |\n| ``` 2654 2655 2656 2657 2658 2659 2660 2661 2662 2663 ``` | ``` def encode_str(self, value: str) -> str:     \"\"\"Encode the data using the specified encoder.      Args:         value: The data to encode.      Returns:         The encoded data.     \"\"\"     return self.encoder.encode(value.encode()).decode()  # noqa: UP008 ``` |", "url": "https://docs.pydantic.dev/latest/api/types/index.html#encodedstr-dataclass-indexhtmlpydantictypesencodedstr-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "GetPydanticSchema `dataclass` [Â¶](index.html#pydantic.types.GetPydanticSchema \"Permanent link\")", "anchor": "getpydanticschema-dataclass-indexhtmlpydantictypesgetpydanticschema-permanent-link", "md_text": "[Using `GetPydanticSchema` to Reduce Boilerplate](../../concepts/types/index.html#using-getpydanticschema-to-reduce-boilerplate)\n\nA convenience class for creating an annotation that provides pydantic custom type hooks.\n\nThis class is intended to eliminate the need to create a custom \"marker\" which defines the\n`__get_pydantic_core_schema__` and `__get_pydantic_json_schema__` custom hook methods.\n\nFor example, to have a field treated by type checkers as `int`, but by pydantic as `Any`, you can do:\n\n```\nfrom typing import Annotated, Any\n\nfrom pydantic import BaseModel, GetPydanticSchema\n\nHandleAsAny = GetPydanticSchema(lambda _s, h: h(Any))\n\nclass Model(BaseModel):\n    x: Annotated[int, HandleAsAny]  # pydantic sees `x: Any`\n\nprint(repr(Model(x='abc').x))\n#> 'abc'\n```\n\nSource code in `pydantic/types.py`\n\n|  |  |\n| --- | --- |\n| ``` 2842 2843 2844 2845 2846 2847 2848 2849 2850 2851 2852 2853 2854 2855 2856 2857 2858 2859 2860 2861 2862 2863 2864 2865 2866 2867 2868 2869 2870 2871 2872 2873 2874 2875 2876 2877 2878 2879 2880 2881 2882 2883 2884 2885 2886 ``` | ``` @_dataclasses.dataclass(**_internal_dataclass.slots_true) class GetPydanticSchema:     \"\"\"!!! abstract \"Usage Documentation\"         [Using `GetPydanticSchema` to Reduce Boilerplate](../concepts/types.md#using-getpydanticschema-to-reduce-boilerplate)      A convenience class for creating an annotation that provides pydantic custom type hooks.      This class is intended to eliminate the need to create a custom \"marker\" which defines the      `__get_pydantic_core_schema__` and `__get_pydantic_json_schema__` custom hook methods.      For example, to have a field treated by type checkers as `int`, but by pydantic as `Any`, you can do:     ```python     from typing import Annotated, Any      from pydantic import BaseModel, GetPydanticSchema      HandleAsAny = GetPydanticSchema(lambda _s, h: h(Any))      class Model(BaseModel):         x: Annotated[int, HandleAsAny]  # pydantic sees `x: Any`      print(repr(Model(x='abc').x))     #> 'abc'     ```     \"\"\"      get_pydantic_core_schema: Callable[[Any, GetCoreSchemaHandler], CoreSchema] | None = None     get_pydantic_json_schema: Callable[[Any, GetJsonSchemaHandler], JsonSchemaValue] | None = None      # Note: we may want to consider adding a convenience staticmethod `def for_type(type_: Any) -> GetPydanticSchema:`     #   which returns `GetPydanticSchema(lambda _s, h: h(type_))`      if not TYPE_CHECKING:         # We put `__getattr__` in a non-TYPE_CHECKING block because otherwise, mypy allows arbitrary attribute access          def __getattr__(self, item: str) -> Any:             \"\"\"Use this rather than defining `__get_pydantic_core_schema__` etc. to reduce the number of nested calls.\"\"\"             if item == '__get_pydantic_core_schema__' and self.get_pydantic_core_schema:                 return self.get_pydantic_core_schema             elif item == '__get_pydantic_json_schema__' and self.get_pydantic_json_schema:                 return self.get_pydantic_json_schema             else:                 return object.__getattribute__(self, item)      __hash__ = object.__hash__ ``` |", "url": "https://docs.pydantic.dev/latest/api/types/index.html#getpydanticschema-dataclass-indexhtmlpydantictypesgetpydanticschema-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "Tag `dataclass` [Â¶](index.html#pydantic.types.Tag \"Permanent link\")", "anchor": "tag-dataclass-indexhtmlpydantictypestag-permanent-link", "md_text": "Provides a way to specify the expected tag to use for a case of a (callable) discriminated union.\n\nAlso provides a way to label a union case in error messages.\n\nWhen using a callable `Discriminator`, attach a `Tag` to each case in the `Union` to specify the tag that\nshould be used to identify that case. For example, in the below example, the `Tag` is used to specify that\nif `get_discriminator_value` returns `'apple'`, the input should be validated as an `ApplePie`, and if it\nreturns `'pumpkin'`, the input should be validated as a `PumpkinPie`.\n\nThe primary role of the `Tag` here is to map the return value from the callable `Discriminator` function to\nthe appropriate member of the `Union` in question.\n\n```\nfrom typing import Annotated, Any, Literal, Union\n\nfrom pydantic import BaseModel, Discriminator, Tag\n\nclass Pie(BaseModel):\n    time_to_cook: int\n    num_ingredients: int\n\nclass ApplePie(Pie):\n    fruit: Literal['apple'] = 'apple'\n\nclass PumpkinPie(Pie):\n    filling: Literal['pumpkin'] = 'pumpkin'\n\ndef get_discriminator_value(v: Any) -> str:\n    if isinstance(v, dict):\n        return v.get('fruit', v.get('filling'))\n    return getattr(v, 'fruit', getattr(v, 'filling', None))\n\nclass ThanksgivingDinner(BaseModel):\n    dessert: Annotated[\n        Union[\n            Annotated[ApplePie, Tag('apple')],\n            Annotated[PumpkinPie, Tag('pumpkin')],\n        ],\n        Discriminator(get_discriminator_value),\n    ]\n\napple_variation = ThanksgivingDinner.model_validate(\n    {'dessert': {'fruit': 'apple', 'time_to_cook': 60, 'num_ingredients': 8}}\n)\nprint(repr(apple_variation))\n'''\nThanksgivingDinner(dessert=ApplePie(time_to_cook=60, num_ingredients=8, fruit='apple'))\n'''\n\npumpkin_variation = ThanksgivingDinner.model_validate(\n    {\n        'dessert': {\n            'filling': 'pumpkin',\n            'time_to_cook': 40,\n            'num_ingredients': 6,\n        }\n    }\n)\nprint(repr(pumpkin_variation))\n'''\nThanksgivingDinner(dessert=PumpkinPie(time_to_cook=40, num_ingredients=6, filling='pumpkin'))\n'''\n```\n\nYou must specify a `Tag` for every case in a `Tag` that is associated with a\ncallable `Discriminator`. Failing to do so will result in a `PydanticUserError` with code\n[`callable-discriminator-no-tag`](../../errors/usage_errors/index.html#callable-discriminator-no-tag).\n\nSee the [Discriminated Unions](../../concepts/unions/index.html#discriminated-unions) concepts docs for more details on how to use `Tag`s.\n\nSource code in `pydantic/types.py`", "url": "https://docs.pydantic.dev/latest/api/types/index.html#tag-dataclass-indexhtmlpydantictypestag-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "Tag `dataclass` [Â¶](index.html#pydantic.types.Tag \"Permanent link\")", "anchor": "tag-dataclass-indexhtmlpydantictypestag-permanent-link", "md_text": "|  |  |\n| --- | --- |\n| ``` 2889 2890 2891 2892 2893 2894 2895 2896 2897 2898 2899 2900 2901 2902 2903 2904 2905 2906 2907 2908 2909 2910 2911 2912 2913 2914 2915 2916 2917 2918 2919 2920 2921 2922 2923 2924 2925 2926 2927 2928 2929 2930 2931 2932 2933 2934 2935 2936 2937 2938 2939 2940 2941 2942 2943 2944 2945 2946 2947 2948 2949 2950 2951 2952 2953 2954 2955 2956 2957 2958 2959 2960 2961 2962 2963 2964 2965 2966 2967 2968 2969 2970 2971 ``` | ``` @_dataclasses.dataclass(**_internal_dataclass.slots_true, frozen=True) class Tag:     \"\"\"Provides a way to specify the expected tag to use for a case of a (callable) discriminated union.      Also provides a way to label a union case in error messages.      When using a callable `Discriminator`, attach a `Tag` to each case in the `Union` to specify the tag that     should be used to identify that case. For example, in the below example, the `Tag` is used to specify that     if `get_discriminator_value` returns `'apple'`, the input should be validated as an `ApplePie`, and if it     returns `'pumpkin'`, the input should be validated as a `PumpkinPie`.      The primary role of the `Tag` here is to map the return value from the callable `Discriminator` function to     the appropriate member of the `Union` in question.      ```python     from typing import Annotated, Any, Literal, Union      from pydantic import BaseModel, Discriminator, Tag      class Pie(BaseModel):         time_to_cook: int         num_ingredients: int      class ApplePie(Pie):         fruit: Literal['apple'] = 'apple'      class PumpkinPie(Pie):         filling: Literal['pumpkin'] = 'pumpkin'      def get_discriminator_value(v: Any) -> str:         if isinstance(v, dict):             return v.get('fruit', v.get('filling'))         return getattr(v, 'fruit', getattr(v, 'filling', None))      class ThanksgivingDinner(BaseModel):         dessert: Annotated[             Union[                 Annotated[ApplePie, Tag('apple')],                 Annotated[PumpkinPie, Tag('pumpkin')],             ],             Discriminator(get_discriminator_value),         ]      apple_variation = ThanksgivingDinner.model_validate(         {'dessert': {'fruit': 'apple', 'time_to_cook': 60, 'num_ingredients': 8}}     )     print(repr(apple_variation))     '''     ThanksgivingDinner(dessert=ApplePie(time_to_cook=60, num_ingredients=8, fruit='apple'))     '''      pumpkin_variation = ThanksgivingDinner.model_validate(         {             'dessert': {                 'filling': 'pumpkin',                 'time_to_cook': 40,                 'num_ingredients': 6,             }         }     )     print(repr(pumpkin_variation))     '''     ThanksgivingDinner(dessert=PumpkinPie(time_to_cook=40, num_ingredients=6, filling='pumpkin'))     '''     ```      !!! note         You must specify a `Tag` for every case in a `Tag` that is associated with a         callable `Discriminator`. Failing to do so will result in a `PydanticUserError` with code         [`callable-discriminator-no-tag`](../errors/usage_errors.md#callable-discriminator-no-tag).      See the [Discriminated Unions] concepts docs for more details on how to use `Tag`s.      [Discriminated Unions]: ../concepts/unions.md#discriminated-unions     \"\"\"      tag: str      def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaHandler) -> CoreSchema:         schema = handler(source_type)         metadata = cast('CoreMetadata', schema.setdefault('metadata', {}))         metadata['pydantic_internal_union_tag_key'] = self.tag         return schema ``` |", "url": "https://docs.pydantic.dev/latest/api/types/index.html#tag-dataclass-indexhtmlpydantictypestag-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "Discriminator `dataclass` [Â¶](index.html#pydantic.types.Discriminator \"Permanent link\")", "anchor": "discriminator-dataclass-indexhtmlpydantictypesdiscriminator-permanent-link", "md_text": "[Discriminated Unions with `Callable` `Discriminator`](../../concepts/unions/index.html#discriminated-unions-with-callable-discriminator)\n\nProvides a way to use a custom callable as the way to extract the value of a union discriminator.\n\nThis allows you to get validation behavior like you'd get from `Field(discriminator=<field_name>)`,\nbut without needing to have a single shared field across all the union choices. This also makes it\npossible to handle unions of models and primitive types with discriminated-union-style validation errors.\nFinally, this allows you to use a custom callable as the way to identify which member of a union a value\nbelongs to, while still seeing all the performance benefits of a discriminated union.\n\nConsider this example, which is much more performant with the use of `Discriminator` and thus a `TaggedUnion`\nthan it would be as a normal `Union`.\n\n```\nfrom typing import Annotated, Any, Literal, Union\n\nfrom pydantic import BaseModel, Discriminator, Tag\n\nclass Pie(BaseModel):\n    time_to_cook: int\n    num_ingredients: int\n\nclass ApplePie(Pie):\n    fruit: Literal['apple'] = 'apple'\n\nclass PumpkinPie(Pie):\n    filling: Literal['pumpkin'] = 'pumpkin'\n\ndef get_discriminator_value(v: Any) -> str:\n    if isinstance(v, dict):\n        return v.get('fruit', v.get('filling'))\n    return getattr(v, 'fruit', getattr(v, 'filling', None))\n\nclass ThanksgivingDinner(BaseModel):\n    dessert: Annotated[\n        Union[\n            Annotated[ApplePie, Tag('apple')],\n            Annotated[PumpkinPie, Tag('pumpkin')],\n        ],\n        Discriminator(get_discriminator_value),\n    ]\n\napple_variation = ThanksgivingDinner.model_validate(\n    {'dessert': {'fruit': 'apple', 'time_to_cook': 60, 'num_ingredients': 8}}\n)\nprint(repr(apple_variation))\n'''\nThanksgivingDinner(dessert=ApplePie(time_to_cook=60, num_ingredients=8, fruit='apple'))\n'''\n\npumpkin_variation = ThanksgivingDinner.model_validate(\n    {\n        'dessert': {\n            'filling': 'pumpkin',\n            'time_to_cook': 40,\n            'num_ingredients': 6,\n        }\n    }\n)\nprint(repr(pumpkin_variation))\n'''\nThanksgivingDinner(dessert=PumpkinPie(time_to_cook=40, num_ingredients=6, filling='pumpkin'))\n'''\n```\n\nSee the [Discriminated Unions](../../concepts/unions/index.html#discriminated-unions) concepts docs for more details on how to use `Discriminator`s.\n\nSource code in `pydantic/types.py`", "url": "https://docs.pydantic.dev/latest/api/types/index.html#discriminator-dataclass-indexhtmlpydantictypesdiscriminator-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "Discriminator `dataclass` [Â¶](index.html#pydantic.types.Discriminator \"Permanent link\")", "anchor": "discriminator-dataclass-indexhtmlpydantictypesdiscriminator-permanent-link", "md_text": "|  |  |\n| --- | --- |\n| ``` 2974 2975 2976 2977 2978 2979 2980 2981 2982 2983 2984 2985 2986 2987 2988 2989 2990 2991 2992 2993 2994 2995 2996 2997 2998 2999 3000 3001 3002 3003 3004 3005 3006 3007 3008 3009 3010 3011 3012 3013 3014 3015 3016 3017 3018 3019 3020 3021 3022 3023 3024 3025 3026 3027 3028 3029 3030 3031 3032 3033 3034 3035 3036 3037 3038 3039 3040 3041 3042 3043 3044 3045 3046 3047 3048 3049 3050 3051 3052 3053 3054 3055 3056 3057 3058 3059 3060 3061 3062 3063 3064 3065 3066 3067 3068 3069 3070 3071 3072 3073 3074 3075 3076 3077 3078 3079 3080 3081 3082 3083 3084 3085 3086 3087 3088 3089 3090 3091 3092 3093 3094 3095 3096 3097 3098 3099 3100 3101 3102 3103 3104 3105 3106 3107 3108 3109 3110 3111 3112 3113 3114 3115 3116 3117 3118 3119 3120 3121 3122 3123 3124 3125 3126 3127 3128 3129 3130 3131 3132 3133 3134 3135 3136 ``` | ``` @_dataclasses.dataclass(**_internal_dataclass.slots_true, frozen=True) class Discriminator:     \"\"\"!!! abstract \"Usage Documentation\"         [Discriminated Unions with `Callable` `Discriminator`](../concepts/unions.md#discriminated-unions-with-callable-discriminator)      Provides a way to use a custom callable as the way to extract the value of a union discriminator.      This allows you to get validation behavior like you'd get from `Field(discriminator=<field_name>)`,     but without needing to have a single shared field across all the union choices. This also makes it     possible to handle unions of models and primitive types with discriminated-union-style validation errors.     Finally, this allows you to use a custom callable as the way to identify which member of a union a value     belongs to, while still seeing all the performance benefits of a discriminated union.      Consider this example, which is much more performant with the use of `Discriminator` and thus a `TaggedUnion`     than it would be as a normal `Union`.      ```python     from typing import Annotated, Any, Literal, Union      from pydantic import BaseModel, Discriminator, Tag      class Pie(BaseModel):         time_to_cook: int         num_ingredients: int      class ApplePie(Pie):         fruit: Literal['apple'] = 'apple'      class PumpkinPie(Pie):         filling: Literal['pumpkin'] = 'pumpkin'      def get_discriminator_value(v: Any) -> str:         if isinstance(v, dict):             return v.get('fruit', v.get('filling'))         return getattr(v, 'fruit', getattr(v, 'filling', None))      class ThanksgivingDinner(BaseModel):         dessert: Annotated[             Union[                 Annotated[ApplePie, Tag('apple')],                 Annotated[PumpkinPie, Tag('pumpkin')],             ],             Discriminator(get_discriminator_value),         ]      apple_variation = ThanksgivingDinner.model_validate(         {'dessert': {'fruit': 'apple', 'time_to_cook': 60, 'num_ingredients': 8}}     )     print(repr(apple_variation))     '''     ThanksgivingDinner(dessert=ApplePie(time_to_cook=60, num_ingredients=8, fruit='apple'))     '''      pumpkin_variation = ThanksgivingDinner.model_validate(         {             'dessert': {                 'filling': 'pumpkin',                 'time_to_cook': 40,                 'num_ingredients': 6,             }         }     )     print(repr(pumpkin_variation))     '''     ThanksgivingDinner(dessert=PumpkinPie(time_to_cook=40, num_ingredients=6, filling='pumpkin'))     '''     ```      See the [Discriminated Unions] concepts docs for more details on how to use `Discriminator`s.      [Discriminated Unions]: ../concepts/unions.md#discriminated-unions     \"\"\"      discriminator: str | Callable[[Any], Hashable]     \"\"\"The callable or field name for discriminating the type in a tagged union.      A `Callable` discriminator must extract the value of the discriminator from the input.     A `str` discriminator must be the name of a field to discriminate against.     \"\"\"     custom_error_type: str | None = None     \"\"\"Type to use in [custom errors](../errors/errors.md) replacing the standard discriminated union     validation errors.     \"\"\"     custom_error_message: str | None = None     \"\"\"Message to use in custom errors.\"\"\"     custom_error_context: dict[str, int | str | float] | None = None     \"\"\"Context to use in custom errors.\"\"\"      def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaHandler) -> CoreSchema:         if not is_union_origin(get_origin(source_type)):             raise TypeError(f'{type(self).__name__} must be used with a Union type, not {source_type}')          if isinstance(self.discriminator, str):             from pydantic import Field              return handler(Annotated[source_type, Field(discriminator=self.discriminator)])         else:             original_schema = handler(source_type)             return self._convert_schema(original_schema, handler)      def _convert_schema(         self, original_schema: core_schema.CoreSchema, handler: GetCoreSchemaHandler | None = None     ) -> core_schema.TaggedUnionSchema:         if original_schema['type'] != 'union':             # This likely indicates that the schema was a single-item union that was simplified.             # In this case, we do the same thing we do in             # `pydantic._internal._discriminated_union._ApplyInferredDiscriminator._apply_to_root`, namely,             # package the generated schema back into a single-item union.             original_schema = core_schema.union_schema([original_schema])          tagged_union_choices = {}         for choice in original_schema['choices']:             tag = None             if isinstance(choice, tuple):                 choice, tag = choice             metadata = cast('CoreMetadata | None', choice.get('metadata'))             if metadata is not None:                 tag = metadata.get('pydantic_internal_union_tag_key') or tag             if tag is None:                 # `handler` is None when this method is called from `apply_discriminator()` (deferred discriminators)                 if handler is not None and choice['type'] == 'definition-ref':                     # If choice was built from a PEP 695 type alias, try to resolve the def:                     try:                         choice = handler.resolve_ref_schema(choice)                     except LookupError:                         pass                     else:                         metadata = cast('CoreMetadata | None', choice.get('metadata'))                         if metadata is not None:                             tag = metadata.get('pydantic_internal_union_tag_key')                  if tag is None:                     raise PydanticUserError(                         f'`Tag` not provided for choice {choice} used with `Discriminator`',                         code='callable-discriminator-no-tag',                     )             tagged_union_choices[tag] = choice          # Have to do these verbose checks to ensure falsy values ('' and {}) don't get ignored         custom_error_type = self.custom_error_type         if custom_error_type is None:             custom_error_type = original_schema.get('custom_error_type')          custom_error_message = self.custom_error_message         if custom_error_message is None:             custom_error_message = original_schema.get('custom_error_message')          custom_error_context = self.custom_error_context         if custom_error_context is None:             custom_error_context = original_schema.get('custom_error_context')          custom_error_type = original_schema.get('custom_error_type') if custom_error_type is None else custom_error_type         return core_schema.tagged_union_schema(             tagged_union_choices,             self.discriminator,             custom_error_type=custom_error_type,             custom_error_message=custom_error_message,             custom_error_context=custom_error_context,             strict=original_schema.get('strict'),             ref=original_schema.get('ref'),             metadata=original_schema.get('metadata'),             serialization=original_schema.get('serialization'),         ) ``` |", "url": "https://docs.pydantic.dev/latest/api/types/index.html#discriminator-dataclass-indexhtmlpydantictypesdiscriminator-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "Discriminator `dataclass` [Â¶](index.html#pydantic.types.Discriminator \"Permanent link\")", "anchor": "discriminator-dataclass-indexhtmlpydantictypesdiscriminator-permanent-link", "md_text": "#### discriminator `instance-attribute` [Â¶](index.html#pydantic.types.Discriminator.discriminator \"Permanent link\")\n\n```\ndiscriminator: str | Callable[[Any], Hashable]\n```\n\nThe callable or field name for discriminating the type in a tagged union.\n\nA `Callable` discriminator must extract the value of the discriminator from the input.\nA `str` discriminator must be the name of a field to discriminate against.\n\n#### custom\\_error\\_type `class-attribute` `instance-attribute` [Â¶](index.html#pydantic.types.Discriminator.custom_error_type \"Permanent link\")\n\n```\ncustom_error_type: str | None = None\n```\n\nType to use in [custom errors](../../errors/errors/index.html) replacing the standard discriminated union\nvalidation errors.\n\n#### custom\\_error\\_message `class-attribute` `instance-attribute` [Â¶](index.html#pydantic.types.Discriminator.custom_error_message \"Permanent link\")\n\n```\ncustom_error_message: str | None = None\n```\n\nMessage to use in custom errors.\n\n#### custom\\_error\\_context `class-attribute` `instance-attribute` [Â¶](index.html#pydantic.types.Discriminator.custom_error_context \"Permanent link\")\n\n```\ncustom_error_context: (\n    dict[str, int | str | float] | None\n) = None\n```\n\nContext to use in custom errors.", "url": "https://docs.pydantic.dev/latest/api/types/index.html#discriminator-dataclass-indexhtmlpydantictypesdiscriminator-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "FailFast `dataclass` [Â¶](index.html#pydantic.types.FailFast \"Permanent link\")", "anchor": "failfast-dataclass-indexhtmlpydantictypesfailfast-permanent-link", "md_text": "Bases: `PydanticMetadata`, `BaseMetadata`\n\nA `FailFast` annotation can be used to specify that validation should stop at the first error.\n\nThis can be useful when you want to validate a large amount of data and you only need to know if it's valid or not.\n\nYou might want to enable this setting if you want to validate your data faster (basically, if you use this,\nvalidation will be more performant with the caveat that you get less information).\n\n```\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, FailFast, ValidationError\n\nclass Model(BaseModel):\n    x: Annotated[list[int], FailFast()]\n\n# This will raise a single error for the first invalid value and stop validation\ntry:\n    obj = Model(x=[1, 2, 'a', 4, 5, 'b', 7, 8, 9, 'c'])\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for Model\n    x.2\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='a', input_type=str]\n    '''\n```\n\nSource code in `pydantic/types.py`\n\n|  |  |\n| --- | --- |\n| ``` 3265 3266 3267 3268 3269 3270 3271 3272 3273 3274 3275 3276 3277 3278 3279 3280 3281 3282 3283 3284 3285 3286 3287 3288 3289 3290 3291 3292 3293 3294 3295 ``` | ``` @_dataclasses.dataclass class FailFast(_fields.PydanticMetadata, BaseMetadata):     \"\"\"A `FailFast` annotation can be used to specify that validation should stop at the first error.      This can be useful when you want to validate a large amount of data and you only need to know if it's valid or not.      You might want to enable this setting if you want to validate your data faster (basically, if you use this,     validation will be more performant with the caveat that you get less information).      ```python     from typing import Annotated      from pydantic import BaseModel, FailFast, ValidationError      class Model(BaseModel):         x: Annotated[list[int], FailFast()]      # This will raise a single error for the first invalid value and stop validation     try:         obj = Model(x=[1, 2, 'a', 4, 5, 'b', 7, 8, 9, 'c'])     except ValidationError as e:         print(e)         '''         1 validation error for Model         x.2           Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='a', input_type=str]         '''     ```     \"\"\"      fail_fast: bool = True ``` |", "url": "https://docs.pydantic.dev/latest/api/types/index.html#failfast-dataclass-indexhtmlpydantictypesfailfast-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "conint [Â¶](index.html#pydantic.types.conint \"Permanent link\")", "anchor": "conint-indexhtmlpydantictypesconint-permanent-link", "md_text": "```\nconint(\n    *,\n    strict: bool | None = None,\n    gt: int | None = None,\n    ge: int | None = None,\n    lt: int | None = None,\n    le: int | None = None,\n    multiple_of: int | None = None\n) -> type[int]\n```\n\nThis function is **discouraged** in favor of using\n[`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated) with\n[`Field`](../fields/index.html#pydantic.fields.Field) instead.\n\nThis function will be **deprecated** in Pydantic 3.0.\n\nThe reason is that `conint` returns a type, which doesn't play well with static analysis tools.\n\n![âŒ](https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.1.0/assets/svg/274c.svg \":x:\") Don't do this![âœ…](https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.1.0/assets/svg/2705.svg \":white_check_mark:\") Do this\n\n```\nfrom pydantic import BaseModel, conint\n\nclass Foo(BaseModel):\n    bar: conint(strict=True, gt=0)\n\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Field\n\nclass Foo(BaseModel):\n    bar: Annotated[int, Field(strict=True, gt=0)]\n```\n\nA wrapper around `int` that allows for additional constraints.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `strict` | `bool | None` | Whether to validate the integer in strict mode. Defaults to `None`. | `None` |\n| `gt` | `int | None` | The value must be greater than this. | `None` |\n| `ge` | `int | None` | The value must be greater than or equal to this. | `None` |\n| `lt` | `int | None` | The value must be less than this. | `None` |\n| `le` | `int | None` | The value must be less than or equal to this. | `None` |\n| `multiple_of` | `int | None` | The value must be a multiple of this. | `None` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `type[int]` | The wrapped integer type. |\n\n```\nfrom pydantic import BaseModel, ValidationError, conint\n\nclass ConstrainedExample(BaseModel):\n    constrained_int: conint(gt=1)\n\nm = ConstrainedExample(constrained_int=2)\nprint(repr(m))\n#> ConstrainedExample(constrained_int=2)\n\ntry:\n    ConstrainedExample(constrained_int=0)\nexcept ValidationError as e:\n    print(e.errors())\n    '''\n    [\n        {\n            'type': 'greater_than',\n            'loc': ('constrained_int',),\n            'msg': 'Input should be greater than 1',\n            'input': 0,\n            'ctx': {'gt': 1},\n            'url': 'https://errors.pydantic.dev/2/v/greater_than',\n        }\n    ]\n    '''\n```\n\nSource code in `pydantic/types.py`", "url": "https://docs.pydantic.dev/latest/api/types/index.html#conint-indexhtmlpydantictypesconint-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "conint [Â¶](index.html#pydantic.types.conint \"Permanent link\")", "anchor": "conint-indexhtmlpydantictypesconint-permanent-link", "md_text": "|  |  |\n| --- | --- |\n| ``` 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 ``` | ``` def conint(     *,     strict: bool | None = None,     gt: int | None = None,     ge: int | None = None,     lt: int | None = None,     le: int | None = None,     multiple_of: int | None = None, ) -> type[int]:     \"\"\"     !!! warning \"Discouraged\"         This function is **discouraged** in favor of using         [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated) with         [`Field`][pydantic.fields.Field] instead.          This function will be **deprecated** in Pydantic 3.0.          The reason is that `conint` returns a type, which doesn't play well with static analysis tools.          === \":x: Don't do this\"             ```python             from pydantic import BaseModel, conint              class Foo(BaseModel):                 bar: conint(strict=True, gt=0)             ```          === \":white_check_mark: Do this\"             ```python             from typing import Annotated              from pydantic import BaseModel, Field              class Foo(BaseModel):                 bar: Annotated[int, Field(strict=True, gt=0)]             ```      A wrapper around `int` that allows for additional constraints.      Args:         strict: Whether to validate the integer in strict mode. Defaults to `None`.         gt: The value must be greater than this.         ge: The value must be greater than or equal to this.         lt: The value must be less than this.         le: The value must be less than or equal to this.         multiple_of: The value must be a multiple of this.      Returns:         The wrapped integer type.      ```python     from pydantic import BaseModel, ValidationError, conint      class ConstrainedExample(BaseModel):         constrained_int: conint(gt=1)      m = ConstrainedExample(constrained_int=2)     print(repr(m))     #> ConstrainedExample(constrained_int=2)      try:         ConstrainedExample(constrained_int=0)     except ValidationError as e:         print(e.errors())         '''         [             {                 'type': 'greater_than',                 'loc': ('constrained_int',),                 'msg': 'Input should be greater than 1',                 'input': 0,                 'ctx': {'gt': 1},                 'url': 'https://errors.pydantic.dev/2/v/greater_than',             }         ]         '''     ```      \"\"\"  # noqa: D212     return Annotated[  # pyright: ignore[reportReturnType]         int,         Strict(strict) if strict is not None else None,         annotated_types.Interval(gt=gt, ge=ge, lt=lt, le=le),         annotated_types.MultipleOf(multiple_of) if multiple_of is not None else None,     ] ``` |", "url": "https://docs.pydantic.dev/latest/api/types/index.html#conint-indexhtmlpydantictypesconint-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "confloat [Â¶](index.html#pydantic.types.confloat \"Permanent link\")", "anchor": "confloat-indexhtmlpydantictypesconfloat-permanent-link", "md_text": "```\nconfloat(\n    *,\n    strict: bool | None = None,\n    gt: float | None = None,\n    ge: float | None = None,\n    lt: float | None = None,\n    le: float | None = None,\n    multiple_of: float | None = None,\n    allow_inf_nan: bool | None = None\n) -> type[float]\n```\n\nThis function is **discouraged** in favor of using\n[`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated) with\n[`Field`](../fields/index.html#pydantic.fields.Field) instead.\n\nThis function will be **deprecated** in Pydantic 3.0.\n\nThe reason is that `confloat` returns a type, which doesn't play well with static analysis tools.\n\n![âŒ](https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.1.0/assets/svg/274c.svg \":x:\") Don't do this![âœ…](https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.1.0/assets/svg/2705.svg \":white_check_mark:\") Do this\n\n```\nfrom pydantic import BaseModel, confloat\n\nclass Foo(BaseModel):\n    bar: confloat(strict=True, gt=0)\n\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Field\n\nclass Foo(BaseModel):\n    bar: Annotated[float, Field(strict=True, gt=0)]\n```\n\nA wrapper around `float` that allows for additional constraints.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `strict` | `bool | None` | Whether to validate the float in strict mode. | `None` |\n| `gt` | `float | None` | The value must be greater than this. | `None` |\n| `ge` | `float | None` | The value must be greater than or equal to this. | `None` |\n| `lt` | `float | None` | The value must be less than this. | `None` |\n| `le` | `float | None` | The value must be less than or equal to this. | `None` |\n| `multiple_of` | `float | None` | The value must be a multiple of this. | `None` |\n| `allow_inf_nan` | `bool | None` | Whether to allow `-inf`, `inf`, and `nan`. | `None` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `type[float]` | The wrapped float type. |\n\n```\nfrom pydantic import BaseModel, ValidationError, confloat\n\nclass ConstrainedExample(BaseModel):\n    constrained_float: confloat(gt=1.0)\n\nm = ConstrainedExample(constrained_float=1.1)\nprint(repr(m))\n#> ConstrainedExample(constrained_float=1.1)\n\ntry:\n    ConstrainedExample(constrained_float=0.9)\nexcept ValidationError as e:\n    print(e.errors())\n    '''\n    [\n        {\n            'type': 'greater_than',\n            'loc': ('constrained_float',),\n            'msg': 'Input should be greater than 1',\n            'input': 0.9,\n            'ctx': {'gt': 1.0},\n            'url': 'https://errors.pydantic.dev/2/v/greater_than',\n        }\n    ]\n    '''\n```\n\nSource code in `pydantic/types.py`", "url": "https://docs.pydantic.dev/latest/api/types/index.html#confloat-indexhtmlpydantictypesconfloat-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "confloat [Â¶](index.html#pydantic.types.confloat \"Permanent link\")", "anchor": "confloat-indexhtmlpydantictypesconfloat-permanent-link", "md_text": "|  |  |\n| --- | --- |\n| ``` 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 ``` | ``` def confloat(     *,     strict: bool | None = None,     gt: float | None = None,     ge: float | None = None,     lt: float | None = None,     le: float | None = None,     multiple_of: float | None = None,     allow_inf_nan: bool | None = None, ) -> type[float]:     \"\"\"     !!! warning \"Discouraged\"         This function is **discouraged** in favor of using         [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated) with         [`Field`][pydantic.fields.Field] instead.          This function will be **deprecated** in Pydantic 3.0.          The reason is that `confloat` returns a type, which doesn't play well with static analysis tools.          === \":x: Don't do this\"             ```python             from pydantic import BaseModel, confloat              class Foo(BaseModel):                 bar: confloat(strict=True, gt=0)             ```          === \":white_check_mark: Do this\"             ```python             from typing import Annotated              from pydantic import BaseModel, Field              class Foo(BaseModel):                 bar: Annotated[float, Field(strict=True, gt=0)]             ```      A wrapper around `float` that allows for additional constraints.      Args:         strict: Whether to validate the float in strict mode.         gt: The value must be greater than this.         ge: The value must be greater than or equal to this.         lt: The value must be less than this.         le: The value must be less than or equal to this.         multiple_of: The value must be a multiple of this.         allow_inf_nan: Whether to allow `-inf`, `inf`, and `nan`.      Returns:         The wrapped float type.      ```python     from pydantic import BaseModel, ValidationError, confloat      class ConstrainedExample(BaseModel):         constrained_float: confloat(gt=1.0)      m = ConstrainedExample(constrained_float=1.1)     print(repr(m))     #> ConstrainedExample(constrained_float=1.1)      try:         ConstrainedExample(constrained_float=0.9)     except ValidationError as e:         print(e.errors())         '''         [             {                 'type': 'greater_than',                 'loc': ('constrained_float',),                 'msg': 'Input should be greater than 1',                 'input': 0.9,                 'ctx': {'gt': 1.0},                 'url': 'https://errors.pydantic.dev/2/v/greater_than',             }         ]         '''     ```     \"\"\"  # noqa: D212     return Annotated[  # pyright: ignore[reportReturnType]         float,         Strict(strict) if strict is not None else None,         annotated_types.Interval(gt=gt, ge=ge, lt=lt, le=le),         annotated_types.MultipleOf(multiple_of) if multiple_of is not None else None,         AllowInfNan(allow_inf_nan) if allow_inf_nan is not None else None,     ] ``` |", "url": "https://docs.pydantic.dev/latest/api/types/index.html#confloat-indexhtmlpydantictypesconfloat-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "conbytes [Â¶](index.html#pydantic.types.conbytes \"Permanent link\")", "anchor": "conbytes-indexhtmlpydantictypesconbytes-permanent-link", "md_text": "```\nconbytes(\n    *,\n    min_length: int | None = None,\n    max_length: int | None = None,\n    strict: bool | None = None\n) -> type[bytes]\n```\n\nA wrapper around `bytes` that allows for additional constraints.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `min_length` | `int | None` | The minimum length of the bytes. | `None` |\n| `max_length` | `int | None` | The maximum length of the bytes. | `None` |\n| `strict` | `bool | None` | Whether to validate the bytes in strict mode. | `None` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `type[bytes]` | The wrapped bytes type. |\n\nSource code in `pydantic/types.py`\n\n|  |  |\n| --- | --- |\n| ``` 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 ``` | ``` def conbytes(     *,     min_length: int | None = None,     max_length: int | None = None,     strict: bool | None = None, ) -> type[bytes]:     \"\"\"A wrapper around `bytes` that allows for additional constraints.      Args:         min_length: The minimum length of the bytes.         max_length: The maximum length of the bytes.         strict: Whether to validate the bytes in strict mode.      Returns:         The wrapped bytes type.     \"\"\"     return Annotated[  # pyright: ignore[reportReturnType]         bytes,         Strict(strict) if strict is not None else None,         annotated_types.Len(min_length or 0, max_length),     ] ``` |", "url": "https://docs.pydantic.dev/latest/api/types/index.html#conbytes-indexhtmlpydantictypesconbytes-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "constr [Â¶](index.html#pydantic.types.constr \"Permanent link\")", "anchor": "constr-indexhtmlpydantictypesconstr-permanent-link", "md_text": "```\nconstr(\n    *,\n    strip_whitespace: bool | None = None,\n    to_upper: bool | None = None,\n    to_lower: bool | None = None,\n    strict: bool | None = None,\n    min_length: int | None = None,\n    max_length: int | None = None,\n    pattern: str | Pattern[str] | None = None\n) -> type[str]\n```\n\nThis function is **discouraged** in favor of using\n[`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated) with\n[`StringConstraints`](index.html#pydantic.types.StringConstraints) instead.\n\nThis function will be **deprecated** in Pydantic 3.0.\n\nThe reason is that `constr` returns a type, which doesn't play well with static analysis tools.\n\n![âŒ](https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.1.0/assets/svg/274c.svg \":x:\") Don't do this![âœ…](https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.1.0/assets/svg/2705.svg \":white_check_mark:\") Do this\n\n```\nfrom pydantic import BaseModel, constr\n\nclass Foo(BaseModel):\n    bar: constr(strip_whitespace=True, to_upper=True, pattern=r'^[A-Z]+$')\n\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, StringConstraints\n\nclass Foo(BaseModel):\n    bar: Annotated[\n        str,\n        StringConstraints(\n            strip_whitespace=True, to_upper=True, pattern=r'^[A-Z]+$'\n        ),\n    ]\n```\n\nA wrapper around `str` that allows for additional constraints.\n\n```\nfrom pydantic import BaseModel, constr\n\nclass Foo(BaseModel):\n    bar: constr(strip_whitespace=True, to_upper=True)\n\nfoo = Foo(bar='  hello  ')\nprint(foo)\n#> bar='HELLO'\n```\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `strip_whitespace` | `bool | None` | Whether to remove leading and trailing whitespace. | `None` |\n| `to_upper` | `bool | None` | Whether to turn all characters to uppercase. | `None` |\n| `to_lower` | `bool | None` | Whether to turn all characters to lowercase. | `None` |\n| `strict` | `bool | None` | Whether to validate the string in strict mode. | `None` |\n| `min_length` | `int | None` | The minimum length of the string. | `None` |\n| `max_length` | `int | None` | The maximum length of the string. | `None` |\n| `pattern` | `str | Pattern[str] | None` | A regex pattern to validate the string against. | `None` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `type[str]` | The wrapped string type. |\n\nSource code in `pydantic/types.py`", "url": "https://docs.pydantic.dev/latest/api/types/index.html#constr-indexhtmlpydantictypesconstr-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "constr [Â¶](index.html#pydantic.types.constr \"Permanent link\")", "anchor": "constr-indexhtmlpydantictypesconstr-permanent-link", "md_text": "|  |  |\n| --- | --- |\n| ``` 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 ``` | ``` def constr(     *,     strip_whitespace: bool | None = None,     to_upper: bool | None = None,     to_lower: bool | None = None,     strict: bool | None = None,     min_length: int | None = None,     max_length: int | None = None,     pattern: str | Pattern[str] | None = None, ) -> type[str]:     \"\"\"     !!! warning \"Discouraged\"         This function is **discouraged** in favor of using         [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated) with         [`StringConstraints`][pydantic.types.StringConstraints] instead.          This function will be **deprecated** in Pydantic 3.0.          The reason is that `constr` returns a type, which doesn't play well with static analysis tools.          === \":x: Don't do this\"             ```python             from pydantic import BaseModel, constr              class Foo(BaseModel):                 bar: constr(strip_whitespace=True, to_upper=True, pattern=r'^[A-Z]+$')             ```          === \":white_check_mark: Do this\"             ```python             from typing import Annotated              from pydantic import BaseModel, StringConstraints              class Foo(BaseModel):                 bar: Annotated[                     str,                     StringConstraints(                         strip_whitespace=True, to_upper=True, pattern=r'^[A-Z]+$'                     ),                 ]             ```      A wrapper around `str` that allows for additional constraints.      ```python     from pydantic import BaseModel, constr      class Foo(BaseModel):         bar: constr(strip_whitespace=True, to_upper=True)      foo = Foo(bar='  hello  ')     print(foo)     #> bar='HELLO'     ```      Args:         strip_whitespace: Whether to remove leading and trailing whitespace.         to_upper: Whether to turn all characters to uppercase.         to_lower: Whether to turn all characters to lowercase.         strict: Whether to validate the string in strict mode.         min_length: The minimum length of the string.         max_length: The maximum length of the string.         pattern: A regex pattern to validate the string against.      Returns:         The wrapped string type.     \"\"\"  # noqa: D212     return Annotated[  # pyright: ignore[reportReturnType]         str,         StringConstraints(             strip_whitespace=strip_whitespace,             to_upper=to_upper,             to_lower=to_lower,             strict=strict,             min_length=min_length,             max_length=max_length,             pattern=pattern,         ),     ] ``` |", "url": "https://docs.pydantic.dev/latest/api/types/index.html#constr-indexhtmlpydantictypesconstr-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "conset [Â¶](index.html#pydantic.types.conset \"Permanent link\")", "anchor": "conset-indexhtmlpydantictypesconset-permanent-link", "md_text": "```\nconset(\n    item_type: type[HashableItemType],\n    *,\n    min_length: int | None = None,\n    max_length: int | None = None\n) -> type[set[HashableItemType]]\n```\n\nA wrapper around `typing.Set` that allows for additional constraints.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `item_type` | `type[HashableItemType]` | The type of the items in the set. | *required* |\n| `min_length` | `int | None` | The minimum length of the set. | `None` |\n| `max_length` | `int | None` | The maximum length of the set. | `None` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `type[set[HashableItemType]]` | The wrapped set type. |\n\nSource code in `pydantic/types.py`\n\n|  |  |\n| --- | --- |\n| ``` 839 840 841 842 843 844 845 846 847 848 849 850 851 852 ``` | ``` def conset(     item_type: type[HashableItemType], *, min_length: int | None = None, max_length: int | None = None ) -> type[set[HashableItemType]]:     \"\"\"A wrapper around `typing.Set` that allows for additional constraints.      Args:         item_type: The type of the items in the set.         min_length: The minimum length of the set.         max_length: The maximum length of the set.      Returns:         The wrapped set type.     \"\"\"     return Annotated[set[item_type], annotated_types.Len(min_length or 0, max_length)]  # pyright: ignore[reportReturnType] ``` |", "url": "https://docs.pydantic.dev/latest/api/types/index.html#conset-indexhtmlpydantictypesconset-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "confrozenset [Â¶](index.html#pydantic.types.confrozenset \"Permanent link\")", "anchor": "confrozenset-indexhtmlpydantictypesconfrozenset-permanent-link", "md_text": "```\nconfrozenset(\n    item_type: type[HashableItemType],\n    *,\n    min_length: int | None = None,\n    max_length: int | None = None\n) -> type[frozenset[HashableItemType]]\n```\n\nA wrapper around `typing.FrozenSet` that allows for additional constraints.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `item_type` | `type[HashableItemType]` | The type of the items in the frozenset. | *required* |\n| `min_length` | `int | None` | The minimum length of the frozenset. | `None` |\n| `max_length` | `int | None` | The maximum length of the frozenset. | `None` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `type[frozenset[HashableItemType]]` | The wrapped frozenset type. |\n\nSource code in `pydantic/types.py`\n\n|  |  |\n| --- | --- |\n| ``` 855 856 857 858 859 860 861 862 863 864 865 866 867 868 ``` | ``` def confrozenset(     item_type: type[HashableItemType], *, min_length: int | None = None, max_length: int | None = None ) -> type[frozenset[HashableItemType]]:     \"\"\"A wrapper around `typing.FrozenSet` that allows for additional constraints.      Args:         item_type: The type of the items in the frozenset.         min_length: The minimum length of the frozenset.         max_length: The maximum length of the frozenset.      Returns:         The wrapped frozenset type.     \"\"\"     return Annotated[frozenset[item_type], annotated_types.Len(min_length or 0, max_length)]  # pyright: ignore[reportReturnType] ``` |", "url": "https://docs.pydantic.dev/latest/api/types/index.html#confrozenset-indexhtmlpydantictypesconfrozenset-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "conlist [Â¶](index.html#pydantic.types.conlist \"Permanent link\")", "anchor": "conlist-indexhtmlpydantictypesconlist-permanent-link", "md_text": "```\nconlist(\n    item_type: type[AnyItemType],\n    *,\n    min_length: int | None = None,\n    max_length: int | None = None,\n    unique_items: bool | None = None\n) -> type[list[AnyItemType]]\n```\n\nA wrapper around [`list`](https://docs.python.org/3/glossary.html#term-list) that adds validation.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `item_type` | `type[AnyItemType]` | The type of the items in the list. | *required* |\n| `min_length` | `int | None` | The minimum length of the list. Defaults to None. | `None` |\n| `max_length` | `int | None` | The maximum length of the list. Defaults to None. | `None` |\n| `unique_items` | `bool | None` | Whether the items in the list must be unique. Defaults to None.  The `unique_items` parameter is deprecated, use `Set` instead. See [this issue](https://github.com/pydantic/pydantic-core/issues/296) for more details. | `None` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `type[list[AnyItemType]]` | The wrapped list type. |\n\nSource code in `pydantic/types.py`\n\n|  |  |\n| --- | --- |\n| ``` 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 ``` | ``` def conlist(     item_type: type[AnyItemType],     *,     min_length: int | None = None,     max_length: int | None = None,     unique_items: bool | None = None, ) -> type[list[AnyItemType]]:     \"\"\"A wrapper around [`list`][] that adds validation.      Args:         item_type: The type of the items in the list.         min_length: The minimum length of the list. Defaults to None.         max_length: The maximum length of the list. Defaults to None.         unique_items: Whether the items in the list must be unique. Defaults to None.             !!! warning Deprecated                 The `unique_items` parameter is deprecated, use `Set` instead.                 See [this issue](https://github.com/pydantic/pydantic-core/issues/296) for more details.      Returns:         The wrapped list type.     \"\"\"     if unique_items is not None:         raise PydanticUserError(             (                 '`unique_items` is removed, use `Set` instead'                 '(this feature is discussed in https://github.com/pydantic/pydantic-core/issues/296)'             ),             code='removed-kwargs',         )     return Annotated[list[item_type], annotated_types.Len(min_length or 0, max_length)]  # pyright: ignore[reportReturnType] ``` |", "url": "https://docs.pydantic.dev/latest/api/types/index.html#conlist-indexhtmlpydantictypesconlist-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "condecimal [Â¶](index.html#pydantic.types.condecimal \"Permanent link\")", "anchor": "condecimal-indexhtmlpydantictypescondecimal-permanent-link", "md_text": "```\ncondecimal(\n    *,\n    strict: bool | None = None,\n    gt: int | Decimal | None = None,\n    ge: int | Decimal | None = None,\n    lt: int | Decimal | None = None,\n    le: int | Decimal | None = None,\n    multiple_of: int | Decimal | None = None,\n    max_digits: int | None = None,\n    decimal_places: int | None = None,\n    allow_inf_nan: bool | None = None\n) -> type[Decimal]\n```\n\nThis function is **discouraged** in favor of using\n[`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated) with\n[`Field`](../fields/index.html#pydantic.fields.Field) instead.\n\nThis function will be **deprecated** in Pydantic 3.0.\n\nThe reason is that `condecimal` returns a type, which doesn't play well with static analysis tools.\n\n![âŒ](https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.1.0/assets/svg/274c.svg \":x:\") Don't do this![âœ…](https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.1.0/assets/svg/2705.svg \":white_check_mark:\") Do this\n\n```\nfrom pydantic import BaseModel, condecimal\n\nclass Foo(BaseModel):\n    bar: condecimal(strict=True, allow_inf_nan=True)\n\nfrom decimal import Decimal\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Field\n\nclass Foo(BaseModel):\n    bar: Annotated[Decimal, Field(strict=True, allow_inf_nan=True)]\n```\n\nA wrapper around Decimal that adds validation.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `strict` | `bool | None` | Whether to validate the value in strict mode. Defaults to `None`. | `None` |\n| `gt` | `int | Decimal | None` | The value must be greater than this. Defaults to `None`. | `None` |\n| `ge` | `int | Decimal | None` | The value must be greater than or equal to this. Defaults to `None`. | `None` |\n| `lt` | `int | Decimal | None` | The value must be less than this. Defaults to `None`. | `None` |\n| `le` | `int | Decimal | None` | The value must be less than or equal to this. Defaults to `None`. | `None` |\n| `multiple_of` | `int | Decimal | None` | The value must be a multiple of this. Defaults to `None`. | `None` |\n| `max_digits` | `int | None` | The maximum number of digits. Defaults to `None`. | `None` |\n| `decimal_places` | `int | None` | The number of decimal places. Defaults to `None`. | `None` |\n| `allow_inf_nan` | `bool | None` | Whether to allow infinity and NaN. Defaults to `None`. | `None` |\n\n```\nfrom decimal import Decimal\n\nfrom pydantic import BaseModel, ValidationError, condecimal\n\nclass ConstrainedExample(BaseModel):\n    constrained_decimal: condecimal(gt=Decimal('1.0'))\n\nm = ConstrainedExample(constrained_decimal=Decimal('1.1'))\nprint(repr(m))\n#> ConstrainedExample(constrained_decimal=Decimal('1.1'))\n\ntry:\n    ConstrainedExample(constrained_decimal=Decimal('0.9'))\nexcept ValidationError as e:\n    print(e.errors())\n    '''\n    [\n        {\n            'type': 'greater_than',\n            'loc': ('constrained_decimal',),\n            'msg': 'Input should be greater than 1.0',\n            'input': Decimal('0.9'),\n            'ctx': {'gt': Decimal('1.0')},\n            'url': 'https://errors.pydantic.dev/2/v/greater_than',\n        }\n    ]\n    '''\n```\n\nSource code in `pydantic/types.py`", "url": "https://docs.pydantic.dev/latest/api/types/index.html#condecimal-indexhtmlpydantictypescondecimal-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "condecimal [Â¶](index.html#pydantic.types.condecimal \"Permanent link\")", "anchor": "condecimal-indexhtmlpydantictypescondecimal-permanent-link", "md_text": "|  |  |\n| --- | --- |\n| ``` 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 ``` | ``` def condecimal(     *,     strict: bool | None = None,     gt: int | Decimal | None = None,     ge: int | Decimal | None = None,     lt: int | Decimal | None = None,     le: int | Decimal | None = None,     multiple_of: int | Decimal | None = None,     max_digits: int | None = None,     decimal_places: int | None = None,     allow_inf_nan: bool | None = None, ) -> type[Decimal]:     \"\"\"     !!! warning \"Discouraged\"         This function is **discouraged** in favor of using         [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated) with         [`Field`][pydantic.fields.Field] instead.          This function will be **deprecated** in Pydantic 3.0.          The reason is that `condecimal` returns a type, which doesn't play well with static analysis tools.          === \":x: Don't do this\"             ```python             from pydantic import BaseModel, condecimal              class Foo(BaseModel):                 bar: condecimal(strict=True, allow_inf_nan=True)             ```          === \":white_check_mark: Do this\"             ```python             from decimal import Decimal             from typing import Annotated              from pydantic import BaseModel, Field              class Foo(BaseModel):                 bar: Annotated[Decimal, Field(strict=True, allow_inf_nan=True)]             ```      A wrapper around Decimal that adds validation.      Args:         strict: Whether to validate the value in strict mode. Defaults to `None`.         gt: The value must be greater than this. Defaults to `None`.         ge: The value must be greater than or equal to this. Defaults to `None`.         lt: The value must be less than this. Defaults to `None`.         le: The value must be less than or equal to this. Defaults to `None`.         multiple_of: The value must be a multiple of this. Defaults to `None`.         max_digits: The maximum number of digits. Defaults to `None`.         decimal_places: The number of decimal places. Defaults to `None`.         allow_inf_nan: Whether to allow infinity and NaN. Defaults to `None`.      ```python     from decimal import Decimal      from pydantic import BaseModel, ValidationError, condecimal      class ConstrainedExample(BaseModel):         constrained_decimal: condecimal(gt=Decimal('1.0'))      m = ConstrainedExample(constrained_decimal=Decimal('1.1'))     print(repr(m))     #> ConstrainedExample(constrained_decimal=Decimal('1.1'))      try:         ConstrainedExample(constrained_decimal=Decimal('0.9'))     except ValidationError as e:         print(e.errors())         '''         [             {                 'type': 'greater_than',                 'loc': ('constrained_decimal',),                 'msg': 'Input should be greater than 1.0',                 'input': Decimal('0.9'),                 'ctx': {'gt': Decimal('1.0')},                 'url': 'https://errors.pydantic.dev/2/v/greater_than',             }         ]         '''     ```     \"\"\"  # noqa: D212     return Annotated[  # pyright: ignore[reportReturnType]         Decimal,         Strict(strict) if strict is not None else None,         annotated_types.Interval(gt=gt, ge=ge, lt=lt, le=le),         annotated_types.MultipleOf(multiple_of) if multiple_of is not None else None,         _fields.pydantic_general_metadata(max_digits=max_digits, decimal_places=decimal_places),         AllowInfNan(allow_inf_nan) if allow_inf_nan is not None else None,     ] ``` |", "url": "https://docs.pydantic.dev/latest/api/types/index.html#condecimal-indexhtmlpydantictypescondecimal-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "condate [Â¶](index.html#pydantic.types.condate \"Permanent link\")", "anchor": "condate-indexhtmlpydantictypescondate-permanent-link", "md_text": "```\ncondate(\n    *,\n    strict: bool | None = None,\n    gt: date | None = None,\n    ge: date | None = None,\n    lt: date | None = None,\n    le: date | None = None\n) -> type[date]\n```\n\nA wrapper for date that adds constraints.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `strict` | `bool | None` | Whether to validate the date value in strict mode. Defaults to `None`. | `None` |\n| `gt` | `date | None` | The value must be greater than this. Defaults to `None`. | `None` |\n| `ge` | `date | None` | The value must be greater than or equal to this. Defaults to `None`. | `None` |\n| `lt` | `date | None` | The value must be less than this. Defaults to `None`. | `None` |\n| `le` | `date | None` | The value must be less than or equal to this. Defaults to `None`. | `None` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `type[date]` | A date type with the specified constraints. |\n\nSource code in `pydantic/types.py`\n\n|  |  |\n| --- | --- |\n| ``` 2237 2238 2239 2240 2241 2242 2243 2244 2245 2246 2247 2248 2249 2250 2251 2252 2253 2254 2255 2256 2257 2258 2259 2260 2261 ``` | ``` def condate(     *,     strict: bool | None = None,     gt: date | None = None,     ge: date | None = None,     lt: date | None = None,     le: date | None = None, ) -> type[date]:     \"\"\"A wrapper for date that adds constraints.      Args:         strict: Whether to validate the date value in strict mode. Defaults to `None`.         gt: The value must be greater than this. Defaults to `None`.         ge: The value must be greater than or equal to this. Defaults to `None`.         lt: The value must be less than this. Defaults to `None`.         le: The value must be less than or equal to this. Defaults to `None`.      Returns:         A date type with the specified constraints.     \"\"\"     return Annotated[  # pyright: ignore[reportReturnType]         date,         Strict(strict) if strict is not None else None,         annotated_types.Interval(gt=gt, ge=ge, lt=lt, le=le),     ] ``` |\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/api/types/index.html#condate-indexhtmlpydantictypescondate-permanent-link", "page": "api/types/index.html", "source_site": "pydantic"}
{"title": "ISO4217 [Â¶](index.html#pydantic_extra_types.currency_code.ISO4217 \"Permanent link\")", "anchor": "iso4217-indexhtmlpydanticextratypescurrencycodeiso4217-permanent-link", "md_text": "Bases: `str`\n\nISO4217 parses Currency in the [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) format.\n\n```\nfrom pydantic import BaseModel\n\nfrom pydantic_extra_types.currency_code import ISO4217\n\n\nclass Currency(BaseModel):\n    alpha_3: ISO4217\n\n\ncurrency = Currency(alpha_3='AED')\nprint(currency)\n# > alpha_3='AED'\n```", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_currency_code/index.html#iso4217-indexhtmlpydanticextratypescurrencycodeiso4217-permanent-link", "page": "api/pydantic_extra_types_currency_code/index.html", "source_site": "pydantic"}
{"title": "Currency [Â¶](index.html#pydantic_extra_types.currency_code.Currency \"Permanent link\")", "anchor": "currency-indexhtmlpydanticextratypescurrencycodecurrency-permanent-link", "md_text": "Bases: `str`\n\nCurrency parses currency subset of the [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) format.\nIt excludes bonds testing codes and precious metals.\n\n```\nfrom pydantic import BaseModel\n\nfrom pydantic_extra_types.currency_code import Currency\n\n\nclass currency(BaseModel):\n    alpha_3: Currency\n\n\ncur = currency(alpha_3='AED')\nprint(cur)\n# > alpha_3='AED'\n```\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_currency_code/index.html#currency-indexhtmlpydanticextratypescurrencycodecurrency-permanent-link", "page": "api/pydantic_extra_types_currency_code/index.html", "source_site": "pydantic"}
{"title": "GetJsonSchemaHandler [Â¶](index.html#pydantic.annotated_handlers.GetJsonSchemaHandler \"Permanent link\")", "anchor": "getjsonschemahandler-indexhtmlpydanticannotatedhandlersgetjsonschemahandler-permanent-link", "md_text": "Handler to call into the next JSON schema generation function.\n\nAttributes:\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `mode` | `JsonSchemaMode` | Json schema mode, can be `validation` or `serialization`. |", "url": "https://docs.pydantic.dev/latest/api/annotated_handlers/index.html#getjsonschemahandler-indexhtmlpydanticannotatedhandlersgetjsonschemahandler-permanent-link", "page": "api/annotated_handlers/index.html", "source_site": "pydantic"}
{"title": "resolve\\_ref\\_schema [Â¶](index.html#pydantic.annotated_handlers.GetJsonSchemaHandler.resolve_ref_schema \"Permanent link\")", "anchor": "resolverefschema-indexhtmlpydanticannotatedhandlersgetjsonschemahandlerresolverefschema-permanent-link", "md_text": "```\nresolve_ref_schema(\n    maybe_ref_json_schema: JsonSchemaValue,\n) -> JsonSchemaValue\n```\n\nGet the real schema for a `{\"$ref\": ...}` schema.\nIf the schema given is not a `$ref` schema, it will be returned as is.\nThis means you don't have to check before calling this function.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `maybe_ref_json_schema` | `JsonSchemaValue` | A JsonSchemaValue which may be a `$ref` schema. | *required* |\n\nRaises:\n\n| Type | Description |\n| --- | --- |\n| `LookupError` | If the ref is not found. |\n\nReturns:\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `JsonSchemaValue` | `JsonSchemaValue` | A JsonSchemaValue that has no `$ref`. |\n\nSource code in `pydantic/annotated_handlers.py`\n\n|  |  |\n| --- | --- |\n| ``` 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 ``` | ``` def resolve_ref_schema(self, maybe_ref_json_schema: JsonSchemaValue, /) -> JsonSchemaValue:     \"\"\"Get the real schema for a `{\"$ref\": ...}` schema.     If the schema given is not a `$ref` schema, it will be returned as is.     This means you don't have to check before calling this function.      Args:         maybe_ref_json_schema: A JsonSchemaValue which may be a `$ref` schema.      Raises:         LookupError: If the ref is not found.      Returns:         JsonSchemaValue: A JsonSchemaValue that has no `$ref`.     \"\"\"     raise NotImplementedError ``` |", "url": "https://docs.pydantic.dev/latest/api/annotated_handlers/index.html#resolverefschema-indexhtmlpydanticannotatedhandlersgetjsonschemahandlerresolverefschema-permanent-link", "page": "api/annotated_handlers/index.html", "source_site": "pydantic"}
{"title": "GetCoreSchemaHandler [Â¶](index.html#pydantic.annotated_handlers.GetCoreSchemaHandler \"Permanent link\")", "anchor": "getcoreschemahandler-indexhtmlpydanticannotatedhandlersgetcoreschemahandler-permanent-link", "md_text": "Handler to call into the next CoreSchema schema generation function.", "url": "https://docs.pydantic.dev/latest/api/annotated_handlers/index.html#getcoreschemahandler-indexhtmlpydanticannotatedhandlersgetcoreschemahandler-permanent-link", "page": "api/annotated_handlers/index.html", "source_site": "pydantic"}
{"title": "field\\_name `property` [Â¶](index.html#pydantic.annotated_handlers.GetCoreSchemaHandler.field_name \"Permanent link\")", "anchor": "fieldname-property-indexhtmlpydanticannotatedhandlersgetcoreschemahandlerfieldname-permanent-link", "md_text": "```\nfield_name: str | None\n```\n\nGet the name of the closest field to this validator.", "url": "https://docs.pydantic.dev/latest/api/annotated_handlers/index.html#fieldname-property-indexhtmlpydanticannotatedhandlersgetcoreschemahandlerfieldname-permanent-link", "page": "api/annotated_handlers/index.html", "source_site": "pydantic"}
{"title": "generate\\_schema [Â¶](index.html#pydantic.annotated_handlers.GetCoreSchemaHandler.generate_schema \"Permanent link\")", "anchor": "generateschema-indexhtmlpydanticannotatedhandlersgetcoreschemahandlergenerateschema-permanent-link", "md_text": "```\ngenerate_schema(source_type: Any) -> CoreSchema\n```\n\nGenerate a schema unrelated to the current context.\nUse this function if e.g. you are handling schema generation for a sequence\nand want to generate a schema for its items.\nOtherwise, you may end up doing something like applying a `min_length` constraint\nthat was intended for the sequence itself to its items!\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `source_type` | `Any` | The input type. | *required* |\n\nReturns:\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `CoreSchema` | `CoreSchema` | The `pydantic-core` CoreSchema generated. |\n\nSource code in `pydantic/annotated_handlers.py`\n\n|  |  |\n| --- | --- |\n| ``` 84 85 86 87 88 89 90 91 92 93 94 95 96 97 ``` | ``` def generate_schema(self, source_type: Any, /) -> core_schema.CoreSchema:     \"\"\"Generate a schema unrelated to the current context.     Use this function if e.g. you are handling schema generation for a sequence     and want to generate a schema for its items.     Otherwise, you may end up doing something like applying a `min_length` constraint     that was intended for the sequence itself to its items!      Args:         source_type: The input type.      Returns:         CoreSchema: The `pydantic-core` CoreSchema generated.     \"\"\"     raise NotImplementedError ``` |", "url": "https://docs.pydantic.dev/latest/api/annotated_handlers/index.html#generateschema-indexhtmlpydanticannotatedhandlersgetcoreschemahandlergenerateschema-permanent-link", "page": "api/annotated_handlers/index.html", "source_site": "pydantic"}
{"title": "resolve\\_ref\\_schema [Â¶](index.html#pydantic.annotated_handlers.GetCoreSchemaHandler.resolve_ref_schema \"Permanent link\")", "anchor": "resolverefschema-indexhtmlpydanticannotatedhandlersgetcoreschemahandlerresolverefschema-permanent-link", "md_text": "```\nresolve_ref_schema(\n    maybe_ref_schema: CoreSchema,\n) -> CoreSchema\n```\n\nGet the real schema for a `definition-ref` schema.\nIf the schema given is not a `definition-ref` schema, it will be returned as is.\nThis means you don't have to check before calling this function.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `maybe_ref_schema` | `CoreSchema` | A `CoreSchema`, `ref`-based or not. | *required* |\n\nRaises:\n\n| Type | Description |\n| --- | --- |\n| `LookupError` | If the `ref` is not found. |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `CoreSchema` | A concrete `CoreSchema`. |\n\nSource code in `pydantic/annotated_handlers.py`\n\n|  |  |\n| --- | --- |\n| ```  99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 ``` | ``` def resolve_ref_schema(self, maybe_ref_schema: core_schema.CoreSchema, /) -> core_schema.CoreSchema:     \"\"\"Get the real schema for a `definition-ref` schema.     If the schema given is not a `definition-ref` schema, it will be returned as is.     This means you don't have to check before calling this function.      Args:         maybe_ref_schema: A `CoreSchema`, `ref`-based or not.      Raises:         LookupError: If the `ref` is not found.      Returns:         A concrete `CoreSchema`.     \"\"\"     raise NotImplementedError ``` |\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/api/annotated_handlers/index.html#resolverefschema-indexhtmlpydanticannotatedhandlersgetcoreschemahandlerresolverefschema-permanent-link", "page": "api/annotated_handlers/index.html", "source_site": "pydantic"}
{"title": "validate\\_call [Â¶](index.html#pydantic.validate_call_decorator.validate_call \"Permanent link\")", "anchor": "validatecall-indexhtmlpydanticvalidatecalldecoratorvalidatecall-permanent-link", "md_text": "```\nvalidate_call(\n    *,\n    config: ConfigDict | None = None,\n    validate_return: bool = False\n) -> Callable[[AnyCallableT], AnyCallableT]\n\nvalidate_call(func: AnyCallableT) -> AnyCallableT\n\nvalidate_call(\n    func: AnyCallableT | None = None,\n    /,\n    *,\n    config: ConfigDict | None = None,\n    validate_return: bool = False,\n) -> AnyCallableT | Callable[[AnyCallableT], AnyCallableT]\n```\n\n[Validation Decorator](../../concepts/validation_decorator/index.html)\n\nReturns a decorated wrapper around the function that validates the arguments and, optionally, the return value.\n\nUsage may be either as a plain decorator `@validate_call` or with arguments `@validate_call(...)`.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `func` | `AnyCallableT | None` | The function to be decorated. | `None` |\n| `config` | `ConfigDict | None` | The configuration dictionary. | `None` |\n| `validate_return` | `bool` | Whether to validate the return value. | `False` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `AnyCallableT | Callable[[AnyCallableT], AnyCallableT]` | The decorated function. |\n\nSource code in `pydantic/validate_call_decorator.py`\n\n|  |  |\n| --- | --- |\n| ```  82  83  84  85  86  87  88  89  90  91  92  93  94  95  96  97  98  99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 ``` | ``` def validate_call(     func: AnyCallableT | None = None,     /,     *,     config: ConfigDict | None = None,     validate_return: bool = False, ) -> AnyCallableT | Callable[[AnyCallableT], AnyCallableT]:     \"\"\"!!! abstract \"Usage Documentation\"         [Validation Decorator](../concepts/validation_decorator.md)      Returns a decorated wrapper around the function that validates the arguments and, optionally, the return value.      Usage may be either as a plain decorator `@validate_call` or with arguments `@validate_call(...)`.      Args:         func: The function to be decorated.         config: The configuration dictionary.         validate_return: Whether to validate the return value.      Returns:         The decorated function.     \"\"\"     parent_namespace = _typing_extra.parent_frame_namespace()      def validate(function: AnyCallableT) -> AnyCallableT:         _check_function_type(function)         validate_call_wrapper = _validate_call.ValidateCallWrapper(             cast(_generate_schema.ValidateCallSupportedTypes, function), config, validate_return, parent_namespace         )         return _validate_call.update_wrapper_attributes(function, validate_call_wrapper.__call__)  # type: ignore      if func is not None:         return validate(func)     else:         return validate ``` |\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/api/validate_call/index.html#validatecall-indexhtmlpydanticvalidatecalldecoratorvalidatecall-permanent-link", "page": "api/validate_call/index.html", "source_site": "pydantic"}
{"title": "FieldPlainSerializer `module-attribute` [Â¶](index.html#pydantic.functional_serializers.FieldPlainSerializer \"Permanent link\")", "anchor": "fieldplainserializer-module-attribute-indexhtmlpydanticfunctionalserializersfieldplainserializer-permanent-link", "md_text": "```\nFieldPlainSerializer: TypeAlias = (\n    \"core_schema.SerializerFunction | _Partial\"\n)\n```\n\nA field serializer method or function in `plain` mode.", "url": "https://docs.pydantic.dev/latest/api/functional_serializers/index.html#fieldplainserializer-module-attribute-indexhtmlpydanticfunctionalserializersfieldplainserializer-permanent-link", "page": "api/functional_serializers/index.html", "source_site": "pydantic"}
{"title": "FieldWrapSerializer `module-attribute` [Â¶](index.html#pydantic.functional_serializers.FieldWrapSerializer \"Permanent link\")", "anchor": "fieldwrapserializer-module-attribute-indexhtmlpydanticfunctionalserializersfieldwrapserializer-permanent-link", "md_text": "```\nFieldWrapSerializer: TypeAlias = (\n    \"core_schema.WrapSerializerFunction | _Partial\"\n)\n```\n\nA field serializer method or function in `wrap` mode.", "url": "https://docs.pydantic.dev/latest/api/functional_serializers/index.html#fieldwrapserializer-module-attribute-indexhtmlpydanticfunctionalserializersfieldwrapserializer-permanent-link", "page": "api/functional_serializers/index.html", "source_site": "pydantic"}
{"title": "FieldSerializer `module-attribute` [Â¶](index.html#pydantic.functional_serializers.FieldSerializer \"Permanent link\")", "anchor": "fieldserializer-module-attribute-indexhtmlpydanticfunctionalserializersfieldserializer-permanent-link", "md_text": "```\nFieldSerializer: TypeAlias = (\n    \"FieldPlainSerializer | FieldWrapSerializer\"\n)\n```\n\nA field serializer method or function.", "url": "https://docs.pydantic.dev/latest/api/functional_serializers/index.html#fieldserializer-module-attribute-indexhtmlpydanticfunctionalserializersfieldserializer-permanent-link", "page": "api/functional_serializers/index.html", "source_site": "pydantic"}
{"title": "ModelPlainSerializerWithInfo `module-attribute` [Â¶](index.html#pydantic.functional_serializers.ModelPlainSerializerWithInfo \"Permanent link\")", "anchor": "modelplainserializerwithinfo-module-attribute-indexhtmlpydanticfunctionalserializersmodelplainserializerwithinfo-permanent-link", "md_text": "```\nModelPlainSerializerWithInfo: TypeAlias = Callable[\n    [Any, SerializationInfo[Any]], Any\n]\n```\n\nA model serializer method with the `info` argument, in `plain` mode.", "url": "https://docs.pydantic.dev/latest/api/functional_serializers/index.html#modelplainserializerwithinfo-module-attribute-indexhtmlpydanticfunctionalserializersmodelplainserializerwithinfo-permanent-link", "page": "api/functional_serializers/index.html", "source_site": "pydantic"}
{"title": "ModelPlainSerializerWithoutInfo `module-attribute` [Â¶](index.html#pydantic.functional_serializers.ModelPlainSerializerWithoutInfo \"Permanent link\")", "anchor": "modelplainserializerwithoutinfo-module-attribute-indexhtmlpydanticfunctionalserializersmodelplainserializerwithoutinfo-permanent-link", "md_text": "```\nModelPlainSerializerWithoutInfo: TypeAlias = Callable[\n    [Any], Any\n]\n```\n\nA model serializer method without the `info` argument, in `plain` mode.", "url": "https://docs.pydantic.dev/latest/api/functional_serializers/index.html#modelplainserializerwithoutinfo-module-attribute-indexhtmlpydanticfunctionalserializersmodelplainserializerwithoutinfo-permanent-link", "page": "api/functional_serializers/index.html", "source_site": "pydantic"}
{"title": "ModelPlainSerializer `module-attribute` [Â¶](index.html#pydantic.functional_serializers.ModelPlainSerializer \"Permanent link\")", "anchor": "modelplainserializer-module-attribute-indexhtmlpydanticfunctionalserializersmodelplainserializer-permanent-link", "md_text": "```\nModelPlainSerializer: TypeAlias = (\n    \"ModelPlainSerializerWithInfo | ModelPlainSerializerWithoutInfo\"\n)\n```\n\nA model serializer method in `plain` mode.", "url": "https://docs.pydantic.dev/latest/api/functional_serializers/index.html#modelplainserializer-module-attribute-indexhtmlpydanticfunctionalserializersmodelplainserializer-permanent-link", "page": "api/functional_serializers/index.html", "source_site": "pydantic"}
{"title": "ModelWrapSerializerWithInfo `module-attribute` [Â¶](index.html#pydantic.functional_serializers.ModelWrapSerializerWithInfo \"Permanent link\")", "anchor": "modelwrapserializerwithinfo-module-attribute-indexhtmlpydanticfunctionalserializersmodelwrapserializerwithinfo-permanent-link", "md_text": "```\nModelWrapSerializerWithInfo: TypeAlias = Callable[\n    [\n        Any,\n        SerializerFunctionWrapHandler,\n        SerializationInfo[Any],\n    ],\n    Any,\n]\n```\n\nA model serializer method with the `info` argument, in `wrap` mode.", "url": "https://docs.pydantic.dev/latest/api/functional_serializers/index.html#modelwrapserializerwithinfo-module-attribute-indexhtmlpydanticfunctionalserializersmodelwrapserializerwithinfo-permanent-link", "page": "api/functional_serializers/index.html", "source_site": "pydantic"}
{"title": "ModelWrapSerializerWithoutInfo `module-attribute` [Â¶](index.html#pydantic.functional_serializers.ModelWrapSerializerWithoutInfo \"Permanent link\")", "anchor": "modelwrapserializerwithoutinfo-module-attribute-indexhtmlpydanticfunctionalserializersmodelwrapserializerwithoutinfo-permanent-link", "md_text": "```\nModelWrapSerializerWithoutInfo: TypeAlias = Callable[\n    [Any, SerializerFunctionWrapHandler], Any\n]\n```\n\nA model serializer method without the `info` argument, in `wrap` mode.", "url": "https://docs.pydantic.dev/latest/api/functional_serializers/index.html#modelwrapserializerwithoutinfo-module-attribute-indexhtmlpydanticfunctionalserializersmodelwrapserializerwithoutinfo-permanent-link", "page": "api/functional_serializers/index.html", "source_site": "pydantic"}
{"title": "ModelWrapSerializer `module-attribute` [Â¶](index.html#pydantic.functional_serializers.ModelWrapSerializer \"Permanent link\")", "anchor": "modelwrapserializer-module-attribute-indexhtmlpydanticfunctionalserializersmodelwrapserializer-permanent-link", "md_text": "```\nModelWrapSerializer: TypeAlias = (\n    \"ModelWrapSerializerWithInfo | ModelWrapSerializerWithoutInfo\"\n)\n```\n\nA model serializer method in `wrap` mode.", "url": "https://docs.pydantic.dev/latest/api/functional_serializers/index.html#modelwrapserializer-module-attribute-indexhtmlpydanticfunctionalserializersmodelwrapserializer-permanent-link", "page": "api/functional_serializers/index.html", "source_site": "pydantic"}
{"title": "PlainSerializer `dataclass` [Â¶](index.html#pydantic.functional_serializers.PlainSerializer \"Permanent link\")", "anchor": "plainserializer-dataclass-indexhtmlpydanticfunctionalserializersplainserializer-permanent-link", "md_text": "```\nPlainSerializer(\n    func: SerializerFunction,\n    return_type: Any = PydanticUndefined,\n    when_used: WhenUsed = \"always\",\n)\n```\n\nPlain serializers use a function to modify the output of serialization.\n\nThis is particularly helpful when you want to customize the serialization for annotated types.\nConsider an input of `list`, which will be serialized into a space-delimited string.\n\n```\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, PlainSerializer\n\nCustomStr = Annotated[\n    list, PlainSerializer(lambda x: ' '.join(x), return_type=str)\n]\n\nclass StudentModel(BaseModel):\n    courses: CustomStr\n\nstudent = StudentModel(courses=['Math', 'Chemistry', 'English'])\nprint(student.model_dump())\n#> {'courses': 'Math Chemistry English'}\n```\n\nAttributes:\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `func` | `SerializerFunction` | The serializer function. |\n| `return_type` | `Any` | The return type for the function. If omitted it will be inferred from the type annotation. |\n| `when_used` | `WhenUsed` | Determines when this serializer should be used. Accepts a string with values `'always'`, `'unless-none'`, `'json'`, and `'json-unless-none'`. Defaults to 'always'. |", "url": "https://docs.pydantic.dev/latest/api/functional_serializers/index.html#plainserializer-dataclass-indexhtmlpydanticfunctionalserializersplainserializer-permanent-link", "page": "api/functional_serializers/index.html", "source_site": "pydantic"}
{"title": "WrapSerializer `dataclass` [Â¶](index.html#pydantic.functional_serializers.WrapSerializer \"Permanent link\")", "anchor": "wrapserializer-dataclass-indexhtmlpydanticfunctionalserializerswrapserializer-permanent-link", "md_text": "```\nWrapSerializer(\n    func: WrapSerializerFunction,\n    return_type: Any = PydanticUndefined,\n    when_used: WhenUsed = \"always\",\n)\n```\n\nWrap serializers receive the raw inputs along with a handler function that applies the standard serialization\nlogic, and can modify the resulting value before returning it as the final output of serialization.\n\nFor example, here's a scenario in which a wrap serializer transforms timezones to UTC **and** utilizes the existing `datetime` serialization logic.\n\n```\nfrom datetime import datetime, timezone\nfrom typing import Annotated, Any\n\nfrom pydantic import BaseModel, WrapSerializer\n\nclass EventDatetime(BaseModel):\n    start: datetime\n    end: datetime\n\ndef convert_to_utc(value: Any, handler, info) -> dict[str, datetime]:\n    # Note that `handler` can actually help serialize the `value` for\n    # further custom serialization in case it's a subclass.\n    partial_result = handler(value, info)\n    if info.mode == 'json':\n        return {\n            k: datetime.fromisoformat(v).astimezone(timezone.utc)\n            for k, v in partial_result.items()\n        }\n    return {k: v.astimezone(timezone.utc) for k, v in partial_result.items()}\n\nUTCEventDatetime = Annotated[EventDatetime, WrapSerializer(convert_to_utc)]\n\nclass EventModel(BaseModel):\n    event_datetime: UTCEventDatetime\n\ndt = EventDatetime(\n    start='2024-01-01T07:00:00-08:00', end='2024-01-03T20:00:00+06:00'\n)\nevent = EventModel(event_datetime=dt)\nprint(event.model_dump())\n'''\n{\n    'event_datetime': {\n        'start': datetime.datetime(\n            2024, 1, 1, 15, 0, tzinfo=datetime.timezone.utc\n        ),\n        'end': datetime.datetime(\n            2024, 1, 3, 14, 0, tzinfo=datetime.timezone.utc\n        ),\n    }\n}\n'''\n\nprint(event.model_dump_json())\n'''\n{\"event_datetime\":{\"start\":\"2024-01-01T15:00:00Z\",\"end\":\"2024-01-03T14:00:00Z\"}}\n'''\n```\n\nAttributes:\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `func` | `WrapSerializerFunction` | The serializer function to be wrapped. |\n| `return_type` | `Any` | The return type for the function. If omitted it will be inferred from the type annotation. |\n| `when_used` | `WhenUsed` | Determines when this serializer should be used. Accepts a string with values `'always'`, `'unless-none'`, `'json'`, and `'json-unless-none'`. Defaults to 'always'. |", "url": "https://docs.pydantic.dev/latest/api/functional_serializers/index.html#wrapserializer-dataclass-indexhtmlpydanticfunctionalserializerswrapserializer-permanent-link", "page": "api/functional_serializers/index.html", "source_site": "pydantic"}
{"title": "SerializeAsAny `dataclass` [Â¶](index.html#pydantic.functional_serializers.SerializeAsAny \"Permanent link\")", "anchor": "serializeasany-dataclass-indexhtmlpydanticfunctionalserializersserializeasany-permanent-link", "md_text": "```\nSerializeAsAny()\n```\n\nAnnotation used to mark a type as having duck-typing serialization behavior.\n\nSee [usage documentation](../../concepts/serialization/index.html#serializing-with-duck-typing) for more details.", "url": "https://docs.pydantic.dev/latest/api/functional_serializers/index.html#serializeasany-dataclass-indexhtmlpydanticfunctionalserializersserializeasany-permanent-link", "page": "api/functional_serializers/index.html", "source_site": "pydantic"}
{"title": "field\\_serializer [Â¶](index.html#pydantic.functional_serializers.field_serializer \"Permanent link\")", "anchor": "fieldserializer-indexhtmlpydanticfunctionalserializersfieldserializer-permanent-link", "md_text": "```\nfield_serializer(\n    field: str,\n    /,\n    *fields: str,\n    mode: Literal[\"wrap\"],\n    return_type: Any = ...,\n    when_used: WhenUsed = ...,\n    check_fields: bool | None = ...,\n) -> Callable[\n    [_FieldWrapSerializerT], _FieldWrapSerializerT\n]\n\nfield_serializer(\n    field: str,\n    /,\n    *fields: str,\n    mode: Literal[\"plain\"] = ...,\n    return_type: Any = ...,\n    when_used: WhenUsed = ...,\n    check_fields: bool | None = ...,\n) -> Callable[\n    [_FieldPlainSerializerT], _FieldPlainSerializerT\n]\n\nfield_serializer(\n    *fields: str,\n    mode: Literal[\"plain\", \"wrap\"] = \"plain\",\n    return_type: Any = PydanticUndefined,\n    when_used: WhenUsed = \"always\",\n    check_fields: bool | None = None\n) -> (\n    Callable[[_FieldWrapSerializerT], _FieldWrapSerializerT]\n    | Callable[\n        [_FieldPlainSerializerT], _FieldPlainSerializerT\n    ]\n)\n```\n\nDecorator that enables custom field serialization.\n\nIn the below example, a field of type `set` is used to mitigate duplication. A `field_serializer` is used to serialize the data as a sorted list.\n\n```\nfrom pydantic import BaseModel, field_serializer\n\nclass StudentModel(BaseModel):\n    name: str = 'Jane'\n    courses: set[str]\n\n    @field_serializer('courses', when_used='json')\n    def serialize_courses_in_order(self, courses: set[str]):\n        return sorted(courses)\n\nstudent = StudentModel(courses={'Math', 'Chemistry', 'English'})\nprint(student.model_dump_json())\n#> {\"name\":\"Jane\",\"courses\":[\"Chemistry\",\"English\",\"Math\"]}\n```\n\nSee [the usage documentation](../../concepts/serialization/index.html#serializers) for more information.\n\nFour signatures are supported:\n\n* `(self, value: Any, info: FieldSerializationInfo)`\n* `(self, value: Any, nxt: SerializerFunctionWrapHandler, info: FieldSerializationInfo)`\n* `(value: Any, info: SerializationInfo)`\n* `(value: Any, nxt: SerializerFunctionWrapHandler, info: SerializationInfo)`\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `fields` | `str` | Which field(s) the method should be called on. | `()` |\n| `mode` | `Literal['plain', 'wrap']` | The serialization mode.   * `plain` means the function will be called instead of the default serialization logic, * `wrap` means the function will be called with an argument to optionally call the   default serialization logic. | `'plain'` |\n| `return_type` | `Any` | Optional return type for the function, if omitted it will be inferred from the type annotation. | `PydanticUndefined` |\n| `when_used` | `WhenUsed` | Determines the serializer will be used for serialization. | `'always'` |\n| `check_fields` | `bool | None` | Whether to check that the fields actually exist on the model. | `None` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `Callable[[_FieldWrapSerializerT], _FieldWrapSerializerT] | Callable[[_FieldPlainSerializerT], _FieldPlainSerializerT]` | The decorator function. |\n\nSource code in `pydantic/functional_serializers.py`", "url": "https://docs.pydantic.dev/latest/api/functional_serializers/index.html#fieldserializer-indexhtmlpydanticfunctionalserializersfieldserializer-permanent-link", "page": "api/functional_serializers/index.html", "source_site": "pydantic"}
{"title": "field\\_serializer [Â¶](index.html#pydantic.functional_serializers.field_serializer \"Permanent link\")", "anchor": "fieldserializer-indexhtmlpydanticfunctionalserializersfieldserializer-permanent-link", "md_text": "|  |  |\n| --- | --- |\n| ``` 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 ``` | ``` def field_serializer(     *fields: str,     mode: Literal['plain', 'wrap'] = 'plain',     # TODO PEP 747 (grep for 'return_type' on the whole code base):     return_type: Any = PydanticUndefined,     when_used: WhenUsed = 'always',     check_fields: bool | None = None, ) -> (     Callable[[_FieldWrapSerializerT], _FieldWrapSerializerT]     | Callable[[_FieldPlainSerializerT], _FieldPlainSerializerT] ):     \"\"\"Decorator that enables custom field serialization.      In the below example, a field of type `set` is used to mitigate duplication. A `field_serializer` is used to serialize the data as a sorted list.      ```python     from pydantic import BaseModel, field_serializer      class StudentModel(BaseModel):         name: str = 'Jane'         courses: set[str]          @field_serializer('courses', when_used='json')         def serialize_courses_in_order(self, courses: set[str]):             return sorted(courses)      student = StudentModel(courses={'Math', 'Chemistry', 'English'})     print(student.model_dump_json())     #> {\"name\":\"Jane\",\"courses\":[\"Chemistry\",\"English\",\"Math\"]}     ```      See [the usage documentation](../concepts/serialization.md#serializers) for more information.      Four signatures are supported:      - `(self, value: Any, info: FieldSerializationInfo)`     - `(self, value: Any, nxt: SerializerFunctionWrapHandler, info: FieldSerializationInfo)`     - `(value: Any, info: SerializationInfo)`     - `(value: Any, nxt: SerializerFunctionWrapHandler, info: SerializationInfo)`      Args:         fields: Which field(s) the method should be called on.         mode: The serialization mode.              - `plain` means the function will be called instead of the default serialization logic,             - `wrap` means the function will be called with an argument to optionally call the                default serialization logic.         return_type: Optional return type for the function, if omitted it will be inferred from the type annotation.         when_used: Determines the serializer will be used for serialization.         check_fields: Whether to check that the fields actually exist on the model.      Returns:         The decorator function.     \"\"\"      def dec(f: FieldSerializer) -> _decorators.PydanticDescriptorProxy[Any]:         dec_info = _decorators.FieldSerializerDecoratorInfo(             fields=fields,             mode=mode,             return_type=return_type,             when_used=when_used,             check_fields=check_fields,         )         return _decorators.PydanticDescriptorProxy(f, dec_info)  # pyright: ignore[reportArgumentType]      return dec  # pyright: ignore[reportReturnType] ``` |", "url": "https://docs.pydantic.dev/latest/api/functional_serializers/index.html#fieldserializer-indexhtmlpydanticfunctionalserializersfieldserializer-permanent-link", "page": "api/functional_serializers/index.html", "source_site": "pydantic"}
{"title": "model\\_serializer [Â¶](index.html#pydantic.functional_serializers.model_serializer \"Permanent link\")", "anchor": "modelserializer-indexhtmlpydanticfunctionalserializersmodelserializer-permanent-link", "md_text": "```\nmodel_serializer(\n    f: _ModelPlainSerializerT,\n) -> _ModelPlainSerializerT\n\nmodel_serializer(\n    *,\n    mode: Literal[\"wrap\"],\n    when_used: WhenUsed = \"always\",\n    return_type: Any = ...\n) -> Callable[\n    [_ModelWrapSerializerT], _ModelWrapSerializerT\n]\n\nmodel_serializer(\n    *,\n    mode: Literal[\"plain\"] = ...,\n    when_used: WhenUsed = \"always\",\n    return_type: Any = ...\n) -> Callable[\n    [_ModelPlainSerializerT], _ModelPlainSerializerT\n]\n\nmodel_serializer(\n    f: (\n        _ModelPlainSerializerT\n        | _ModelWrapSerializerT\n        | None\n    ) = None,\n    /,\n    *,\n    mode: Literal[\"plain\", \"wrap\"] = \"plain\",\n    when_used: WhenUsed = \"always\",\n    return_type: Any = PydanticUndefined,\n) -> (\n    _ModelPlainSerializerT\n    | Callable[\n        [_ModelWrapSerializerT], _ModelWrapSerializerT\n    ]\n    | Callable[\n        [_ModelPlainSerializerT], _ModelPlainSerializerT\n    ]\n)\n```\n\nDecorator that enables custom model serialization.\n\nThis is useful when a model need to be serialized in a customized manner, allowing for flexibility beyond just specific fields.\n\nAn example would be to serialize temperature to the same temperature scale, such as degrees Celsius.\n\n```\nfrom typing import Literal\n\nfrom pydantic import BaseModel, model_serializer\n\nclass TemperatureModel(BaseModel):\n    unit: Literal['C', 'F']\n    value: int\n\n    @model_serializer()\n    def serialize_model(self):\n        if self.unit == 'F':\n            return {'unit': 'C', 'value': int((self.value - 32) / 1.8)}\n        return {'unit': self.unit, 'value': self.value}\n\ntemperature = TemperatureModel(unit='F', value=212)\nprint(temperature.model_dump())\n#> {'unit': 'C', 'value': 100}\n```\n\nTwo signatures are supported for `mode='plain'`, which is the default:\n\n* `(self)`\n* `(self, info: SerializationInfo)`\n\nAnd two other signatures for `mode='wrap'`:\n\n* `(self, nxt: SerializerFunctionWrapHandler)`\n* `(self, nxt: SerializerFunctionWrapHandler, info: SerializationInfo)`\n\n  See [the usage documentation](../../concepts/serialization/index.html#serializers) for more information.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `f` | `_ModelPlainSerializerT | _ModelWrapSerializerT | None` | The function to be decorated. | `None` |\n| `mode` | `Literal['plain', 'wrap']` | The serialization mode.   * `'plain'` means the function will be called instead of the default serialization logic * `'wrap'` means the function will be called with an argument to optionally call the default   serialization logic. | `'plain'` |\n| `when_used` | `WhenUsed` | Determines when this serializer should be used. | `'always'` |\n| `return_type` | `Any` | The return type for the function. If omitted it will be inferred from the type annotation. | `PydanticUndefined` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `_ModelPlainSerializerT | Callable[[_ModelWrapSerializerT], _ModelWrapSerializerT] | Callable[[_ModelPlainSerializerT], _ModelPlainSerializerT]` | The decorator function. |\n\nSource code in `pydantic/functional_serializers.py`", "url": "https://docs.pydantic.dev/latest/api/functional_serializers/index.html#modelserializer-indexhtmlpydanticfunctionalserializersmodelserializer-permanent-link", "page": "api/functional_serializers/index.html", "source_site": "pydantic"}
{"title": "model\\_serializer [Â¶](index.html#pydantic.functional_serializers.model_serializer \"Permanent link\")", "anchor": "modelserializer-indexhtmlpydanticfunctionalserializersmodelserializer-permanent-link", "md_text": "|  |  |\n| --- | --- |\n| ``` 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 ``` | ``` def model_serializer(     f: _ModelPlainSerializerT | _ModelWrapSerializerT | None = None,     /,     *,     mode: Literal['plain', 'wrap'] = 'plain',     when_used: WhenUsed = 'always',     return_type: Any = PydanticUndefined, ) -> (     _ModelPlainSerializerT     | Callable[[_ModelWrapSerializerT], _ModelWrapSerializerT]     | Callable[[_ModelPlainSerializerT], _ModelPlainSerializerT] ):     \"\"\"Decorator that enables custom model serialization.      This is useful when a model need to be serialized in a customized manner, allowing for flexibility beyond just specific fields.      An example would be to serialize temperature to the same temperature scale, such as degrees Celsius.      ```python     from typing import Literal      from pydantic import BaseModel, model_serializer      class TemperatureModel(BaseModel):         unit: Literal['C', 'F']         value: int          @model_serializer()         def serialize_model(self):             if self.unit == 'F':                 return {'unit': 'C', 'value': int((self.value - 32) / 1.8)}             return {'unit': self.unit, 'value': self.value}      temperature = TemperatureModel(unit='F', value=212)     print(temperature.model_dump())     #> {'unit': 'C', 'value': 100}     ```      Two signatures are supported for `mode='plain'`, which is the default:      - `(self)`     - `(self, info: SerializationInfo)`      And two other signatures for `mode='wrap'`:      - `(self, nxt: SerializerFunctionWrapHandler)`     - `(self, nxt: SerializerFunctionWrapHandler, info: SerializationInfo)`          See [the usage documentation](../concepts/serialization.md#serializers) for more information.      Args:         f: The function to be decorated.         mode: The serialization mode.              - `'plain'` means the function will be called instead of the default serialization logic             - `'wrap'` means the function will be called with an argument to optionally call the default                 serialization logic.         when_used: Determines when this serializer should be used.         return_type: The return type for the function. If omitted it will be inferred from the type annotation.      Returns:         The decorator function.     \"\"\"      def dec(f: ModelSerializer) -> _decorators.PydanticDescriptorProxy[Any]:         dec_info = _decorators.ModelSerializerDecoratorInfo(mode=mode, return_type=return_type, when_used=when_used)         return _decorators.PydanticDescriptorProxy(f, dec_info)      if f is None:         return dec  # pyright: ignore[reportReturnType]     else:         return dec(f)  # pyright: ignore[reportReturnType] ``` |\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/api/functional_serializers/index.html#modelserializer-indexhtmlpydanticfunctionalserializersmodelserializer-permanent-link", "page": "api/functional_serializers/index.html", "source_site": "pydantic"}
{"title": "pydantic.\\_\\_version\\_\\_ `module-attribute` [Â¶](index.html#pydantic.__version__ \"Permanent link\")", "anchor": "pydanticversion-module-attribute-indexhtmlpydanticversion-permanent-link", "md_text": "```\n__version__ = VERSION\n```", "url": "https://docs.pydantic.dev/latest/api/version/index.html#pydanticversion-module-attribute-indexhtmlpydanticversion-permanent-link", "page": "api/version/index.html", "source_site": "pydantic"}
{"title": "pydantic.version.version\\_info [Â¶](index.html#pydantic.version.version_info \"Permanent link\")", "anchor": "pydanticversionversioninfo-indexhtmlpydanticversionversioninfo-permanent-link", "md_text": "```\nversion_info() -> str\n```\n\nReturn complete version information for Pydantic and its dependencies.\n\nSource code in `pydantic/version.py`\n\n|  |  |\n| --- | --- |\n| ``` 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 ``` | ``` def version_info() -> str:     \"\"\"Return complete version information for Pydantic and its dependencies.\"\"\"     import importlib.metadata     import platform     from pathlib import Path      import pydantic_core._pydantic_core as pdc      from ._internal import _git as git      # get data about packages that are closely related to pydantic, use pydantic or often conflict with pydantic     package_names = {         'email-validator',         'fastapi',         'mypy',         'pydantic-extra-types',         'pydantic-settings',         'pyright',         'typing_extensions',     }     related_packages = []      for dist in importlib.metadata.distributions():         name = dist.metadata['Name']         if name in package_names:             related_packages.append(f'{name}-{dist.version}')      pydantic_dir = Path(__file__).parents[1].resolve()     most_recent_commit = (         git.git_revision(pydantic_dir) if git.is_git_repo(pydantic_dir) and git.have_git() else 'unknown'     )      info = {         'pydantic version': VERSION,         'pydantic-core version': __pydantic_core_version__,         'pydantic-core build': getattr(pdc, 'build_info', None) or pdc.build_profile,  # pyright: ignore[reportPrivateImportUsage]         'python version': sys.version,         'platform': platform.platform(),         'related packages': ' '.join(related_packages),         'commit': most_recent_commit,     }     return '\\n'.join('{:>30} {}'.format(k + ':', str(v).replace('\\n', ' ')) for k, v in info.items()) ``` |\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/api/version/index.html#pydanticversionversioninfo-indexhtmlpydanticversionversioninfo-permanent-link", "page": "api/version/index.html", "source_site": "pydantic"}
{"title": "pydantic.BaseModel [Â¶](index.html#pydantic.BaseModel \"Permanent link\")", "anchor": "pydanticbasemodel-indexhtmlpydanticbasemodel-permanent-link", "md_text": "[Models](../../concepts/models/index.html)\n\nA base class for creating Pydantic models.\n\nAttributes:\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `__class_vars__` | `set[str]` | The names of the class variables defined on the model. |\n| `__private_attributes__` | `Dict[str, ModelPrivateAttr]` | Metadata about the private attributes of the model. |\n| `__signature__` | `Signature` | The synthesized `__init__` [`Signature`](https://docs.python.org/3/library/inspect.html#inspect.Signature) of the model. |\n| `__pydantic_complete__` | `bool` | Whether model building is completed, or if there are still undefined fields. |\n| `__pydantic_core_schema__` | `CoreSchema` | The core schema of the model. |\n| `__pydantic_custom_init__` | `bool` | Whether the model has a custom `__init__` function. |\n| `__pydantic_decorators__` | `DecoratorInfos` | Metadata containing the decorators defined on the model. This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1. |\n| `__pydantic_generic_metadata__` | `PydanticGenericMetadata` | Metadata for generic models; contains data used for a similar purpose to **args**, **origin**, **parameters** in typing-module generics. May eventually be replaced by these. |\n| `__pydantic_parent_namespace__` | `Dict[str, Any] | None` | Parent namespace of the model, used for automatic rebuilding of models. |\n| `__pydantic_post_init__` | `None | Literal['model_post_init']` | The name of the post-init method for the model, if defined. |\n| `__pydantic_root_model__` | `bool` | Whether the model is a [`RootModel`](../root_model/index.html#pydantic.root_model.RootModel). |\n| `__pydantic_serializer__` | `SchemaSerializer` | The `pydantic-core` `SchemaSerializer` used to dump instances of the model. |\n| `__pydantic_validator__` | `SchemaValidator | PluggableSchemaValidator` | The `pydantic-core` `SchemaValidator` used to validate instances of the model. |\n| `__pydantic_fields__` | `Dict[str, FieldInfo]` | A dictionary of field names and their corresponding [`FieldInfo`](../fields/index.html#pydantic.fields.FieldInfo) objects. |\n| `__pydantic_computed_fields__` | `Dict[str, ComputedFieldInfo]` | A dictionary of computed field names and their corresponding [`ComputedFieldInfo`](../fields/index.html#pydantic.fields.ComputedFieldInfo) objects. |\n| `__pydantic_extra__` | `Dict[str, Any] | None` | A dictionary containing extra values, if [`extra`](../config/index.html#pydantic.config.ConfigDict.extra) is set to `'allow'`. |\n| `__pydantic_fields_set__` | `set[str]` | The names of fields explicitly set during instantiation. |\n| `__pydantic_private__` | `Dict[str, Any] | None` | Values of private attributes set on the model instance. |\n\nSource code in `pydantic/main.py`", "url": "https://docs.pydantic.dev/latest/api/base_model/index.html#pydanticbasemodel-indexhtmlpydanticbasemodel-permanent-link", "page": "api/base_model/index.html", "source_site": "pydantic"}
{"title": "pydantic.BaseModel [Â¶](index.html#pydantic.BaseModel \"Permanent link\")", "anchor": "pydanticbasemodel-indexhtmlpydanticbasemodel-permanent-link", "md_text": "|  |  |\n| --- | --- |\n| ```  118  119  120  121  122  123  124  125  126  127  128  129  130  131  132  133  134  135  136  137  138  139  140  141  142  143  144  145  146  147  148  149  150  151  152  153  154  155  156  157  158  159  160  161  162  163  164  165  166  167  168  169  170  171  172  173  174  175  176  177  178  179  180  181  182  183  184  185  186  187  188  189  190  191  192  193  194  195  196  197  198  199  200  201  202  203  204  205  206  207  208  209  210  211  212  213  214  215  216  217  218  219  220  221  222  223  224  225  226  227  228  229  230  231  232  233  234  235  236  237  238  239  240  241  242  243  244  245  246  247  248  249  250  251  252  253  254  255  256  257  258  259  260  261  262  263  264  265  266  267  268  269  270  271  272  273  274  275  276  277  278  279  280  281  282  283  284  285  286  287  288  289  290  291  292  293  294  295  296  297  298  299  300  301  302  303  304  305  306  307  308  309  310  311  312  313  314  315  316  317  318  319  320  321  322  323  324  325  326  327  328  329  330  331  332  333  334  335  336  337  338  339  340  341  342  343  344  345  346  347  348  349  350  351  352  353  354  355  356  357  358  359  360  361  362  363  364  365  366  367  368  369  370  371  372  373  374  375  376  377  378  379  380  381  382  383  384  385  386  387  388  389  390  391  392  393  394  395  396  397  398  399  400  401  402  403  404  405  406  407  408  409  410  411  412  413  414  415  416  417  418  419  420  421  422  423  424  425  426  427  428  429  430  431  432  433  434  435  436  437  438  439  440  441  442  443  444  445  446  447  448  449  450  451  452  453  454  455  456  457  458  459  460  461  462  463  464  465  466  467  468  469  470  471  472  473  474  475  476  477  478  479  480  481  482  483  484  485  486  487  488  489  490  491  492  493  494  495  496  497  498  499  500  501  502  503  504  505  506  507  508  509  510  511  512  513  514  515  516  517  518  519  520  521  522  523  524  525  526  527  528  529  530  531  532  533  534  535  536  537  538  539  540  541  542  543  544  545  546  547  548  549  550  551  552  553  554  555  556  557  558  559  560  561  562  563  564  565  566  567  568  569  570  571  572  573  574  575  576  577  578  579  580  581  582  583  584  585  586  587  588  589  590  591  592  593  594  595  596  597  598  599  600  601  602  603  604  605  606  607  608  609  610  611  612  613  614  615  616  617  618  619  620  621  622  623  624  625  626  627  628  629  630  631  632  633  634  635  636  637  638  639  640  641  642  643  644  645  646  647  648  649  650  651  652  653  654  655  656  657  658  659  660  661  662  663  664  665  666  667  668  669  670  671  672  673  674  675  676  677  678  679  680  681  682  683  684  685  686  687  688  689  690  691  692  693  694  695  696  697  698  699  700  701  702  703  704  705  706  707  708  709  710  711  712  713  714  715  716  717  718  719  720  721  722  723  724  725  726  727  728  729  730  731  732  733  734  735  736  737  738  739  740  741  742  743  744  745  746  747  748  749  750  751  752  753  754  755  756  757  758  759  760  761  762  763  764  765  766  767  768  769  770  771  772  773  774  775  776  777  778  779  780  781  782  783  784  785  786  787  788  789  790  791  792  793  794  795  796  797  798  799  800  801  802  803  804  805  806  807  808  809  810  811  812  813  814  815  816  817  818  819  820  821  822  823  824  825  826  827  828  829  830  831  832  833  834  835  836  837  838  839  840  841  842  843  844  845  846  847  848  849  850  851  852  853  854  855  856  857  858  859  860  861  862  863  864  865  866  867  868  869  870  871  872  873  874  875  876  877  878  879  880  881  882  883  884  885  886  887  888  889  890  891  892  893  894  895  896  897  898  899  900  901  902  903  904  905  906  907  908  909  910  911  912  913  914  915  916  917  918  919  920  921  922  923  924  925  926  927  928  929  930  931  932  933  934  935  936  937  938  939  940  941  942  943  944  945  946  947  948  949  950  951  952  953  954  955  956  957  958  959  960  961  962  963  964  965  966  967  968  969  970  971  972  973  974  975  976  977  978  979  980  981  982  983  984  985  986  987  988  989  990  991  992  993  994  995  996  997  998  999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 1542 1543 1544 1545 1546 1547 1548 1549 1550 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 ``` | ``` class BaseModel(metaclass=_model_construction.ModelMetaclass):     \"\"\"!!! abstract \"Usage Documentation\"         [Models](../concepts/models.md)      A base class for creating Pydantic models.      Attributes:         __class_vars__: The names of the class variables defined on the model.         __private_attributes__: Metadata about the private attributes of the model.         __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.          __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.         __pydantic_core_schema__: The core schema of the model.         __pydantic_custom_init__: Whether the model has a custom `__init__` function.         __pydantic_decorators__: Metadata containing the decorators defined on the model.             This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.         __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to             __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.         __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.         __pydantic_post_init__: The name of the post-init method for the model, if defined.         __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].         __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.         __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.          __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.         __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.          __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]             is set to `'allow'`.         __pydantic_fields_set__: The names of fields explicitly set during instantiation.         __pydantic_private__: Values of private attributes set on the model instance.     \"\"\"      # Note: Many of the below class vars are defined in the metaclass, but we define them here for type checking purposes.      model_config: ClassVar[ConfigDict] = ConfigDict()     \"\"\"     Configuration for the model, should be a dictionary conforming to [`ConfigDict`][pydantic.config.ConfigDict].     \"\"\"      __class_vars__: ClassVar[set[str]]     \"\"\"The names of the class variables defined on the model.\"\"\"      __private_attributes__: ClassVar[Dict[str, ModelPrivateAttr]]  # noqa: UP006     \"\"\"Metadata about the private attributes of the model.\"\"\"      __signature__: ClassVar[Signature]     \"\"\"The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\"\"\"      __pydantic_complete__: ClassVar[bool] = False     \"\"\"Whether model building is completed, or if there are still undefined fields.\"\"\"      __pydantic_core_schema__: ClassVar[CoreSchema]     \"\"\"The core schema of the model.\"\"\"      __pydantic_custom_init__: ClassVar[bool]     \"\"\"Whether the model has a custom `__init__` method.\"\"\"      # Must be set for `GenerateSchema.model_schema` to work for a plain `BaseModel` annotation.     __pydantic_decorators__: ClassVar[_decorators.DecoratorInfos] = _decorators.DecoratorInfos()     \"\"\"Metadata containing the decorators defined on the model.     This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\"\"\"      __pydantic_generic_metadata__: ClassVar[_generics.PydanticGenericMetadata]     \"\"\"Metadata for generic models; contains data used for a similar purpose to     __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\"\"\"      __pydantic_parent_namespace__: ClassVar[Dict[str, Any] | None] = None  # noqa: UP006     \"\"\"Parent namespace of the model, used for automatic rebuilding of models.\"\"\"      __pydantic_post_init__: ClassVar[None | Literal['model_post_init']]     \"\"\"The name of the post-init method for the model, if defined.\"\"\"      __pydantic_root_model__: ClassVar[bool] = False     \"\"\"Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\"\"\"      __pydantic_serializer__: ClassVar[SchemaSerializer]     \"\"\"The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\"\"\"      __pydantic_validator__: ClassVar[SchemaValidator | PluggableSchemaValidator]     \"\"\"The `pydantic-core` `SchemaValidator` used to validate instances of the model.\"\"\"      __pydantic_fields__: ClassVar[Dict[str, FieldInfo]]  # noqa: UP006     \"\"\"A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.     This replaces `Model.__fields__` from Pydantic V1.     \"\"\"      __pydantic_setattr_handlers__: ClassVar[Dict[str, Callable[[BaseModel, str, Any], None]]]  # noqa: UP006     \"\"\"`__setattr__` handlers. Memoizing the handlers leads to a dramatic performance improvement in `__setattr__`\"\"\"      __pydantic_computed_fields__: ClassVar[Dict[str, ComputedFieldInfo]]  # noqa: UP006     \"\"\"A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\"\"\"      __pydantic_extra__: Dict[str, Any] | None = _model_construction.NoInitField(init=False)  # noqa: UP006     \"\"\"A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra] is set to `'allow'`.\"\"\"      __pydantic_fields_set__: set[str] = _model_construction.NoInitField(init=False)     \"\"\"The names of fields explicitly set during instantiation.\"\"\"      __pydantic_private__: Dict[str, Any] | None = _model_construction.NoInitField(init=False)  # noqa: UP006     \"\"\"Values of private attributes set on the model instance.\"\"\"      if not TYPE_CHECKING:         # Prevent `BaseModel` from being instantiated directly         # (defined in an `if not TYPE_CHECKING` block for clarity and to avoid type checking errors):         __pydantic_core_schema__ = _mock_val_ser.MockCoreSchema(             'Pydantic models should inherit from BaseModel, BaseModel cannot be instantiated directly',             code='base-model-instantiated',         )         __pydantic_validator__ = _mock_val_ser.MockValSer(             'Pydantic models should inherit from BaseModel, BaseModel cannot be instantiated directly',             val_or_ser='validator',             code='base-model-instantiated',         )         __pydantic_serializer__ = _mock_val_ser.MockValSer(             'Pydantic models should inherit from BaseModel, BaseModel cannot be instantiated directly',             val_or_ser='serializer',             code='base-model-instantiated',         )      __slots__ = '__dict__', '__pydantic_fields_set__', '__pydantic_extra__', '__pydantic_private__'      def __init__(self, /, **data: Any) -> None:         \"\"\"Create a new model by parsing and validating input data from keyword arguments.          Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be         validated to form a valid model.          `self` is explicitly positional-only to allow `self` as a field name.         \"\"\"         # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks         __tracebackhide__ = True         validated_self = self.__pydantic_validator__.validate_python(data, self_instance=self)         if self is not validated_self:             warnings.warn(                 'A custom validator is returning a value other than `self`.\\n'                 \"Returning anything other than `self` from a top level model validator isn't supported when validating via `__init__`.\\n\"                 'See the `model_validator` docs (https://docs.pydantic.dev/latest/concepts/validators/#model-validators) for more details.',                 stacklevel=2,             )      # The following line sets a flag that we use to determine when `__init__` gets overridden by the user     __init__.__pydantic_base_init__ = True  # pyright: ignore[reportFunctionMemberAccess]      @_utils.deprecated_instance_property     @classmethod     def model_fields(cls) -> dict[str, FieldInfo]:         \"\"\"A mapping of field names to their respective [`FieldInfo`][pydantic.fields.FieldInfo] instances.          !!! warning             Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.             Instead, you should access this attribute from the model class.         \"\"\"         return getattr(cls, '__pydantic_fields__', {})      @_utils.deprecated_instance_property     @classmethod     def model_computed_fields(cls) -> dict[str, ComputedFieldInfo]:         \"\"\"A mapping of computed field names to their respective [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] instances.          !!! warning             Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.             Instead, you should access this attribute from the model class.         \"\"\"         return getattr(cls, '__pydantic_computed_fields__', {})      @property     def model_extra(self) -> dict[str, Any] | None:         \"\"\"Get extra fields set during validation.          Returns:             A dictionary of extra fields, or `None` if `config.extra` is not set to `\"allow\"`.         \"\"\"         return self.__pydantic_extra__      @property     def model_fields_set(self) -> set[str]:         \"\"\"Returns the set of fields that have been explicitly set on this model instance.          Returns:             A set of strings representing the fields that have been set,                 i.e. that were not filled from defaults.         \"\"\"         return self.__pydantic_fields_set__      @classmethod     def model_construct(cls, _fields_set: set[str] | None = None, **values: Any) -> Self:  # noqa: C901         \"\"\"Creates a new instance of the `Model` class with validated data.          Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.         Default values are respected, but no other validation is performed.          !!! note             `model_construct()` generally respects the `model_config.extra` setting on the provided model.             That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`             and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.             Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in             an error if extra values are passed, but they will be ignored.          Args:             _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,                 this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.                 Otherwise, the field names from the `values` argument will be used.             values: Trusted or pre-validated data dictionary.          Returns:             A new instance of the `Model` class with validated data.         \"\"\"         m = cls.__new__(cls)         fields_values: dict[str, Any] = {}         fields_set = set()          for name, field in cls.__pydantic_fields__.items():             if field.alias is not None and field.alias in values:                 fields_values[name] = values.pop(field.alias)                 fields_set.add(name)              if (name not in fields_set) and (field.validation_alias is not None):                 validation_aliases: list[str | AliasPath] = (                     field.validation_alias.choices                     if isinstance(field.validation_alias, AliasChoices)                     else [field.validation_alias]                 )                  for alias in validation_aliases:                     if isinstance(alias, str) and alias in values:                         fields_values[name] = values.pop(alias)                         fields_set.add(name)                         break                     elif isinstance(alias, AliasPath):                         value = alias.search_dict_for_path(values)                         if value is not PydanticUndefined:                             fields_values[name] = value                             fields_set.add(name)                             break              if name not in fields_set:                 if name in values:                     fields_values[name] = values.pop(name)                     fields_set.add(name)                 elif not field.is_required():                     fields_values[name] = field.get_default(call_default_factory=True, validated_data=fields_values)         if _fields_set is None:             _fields_set = fields_set          _extra: dict[str, Any] | None = values if cls.model_config.get('extra') == 'allow' else None         _object_setattr(m, '__dict__', fields_values)         _object_setattr(m, '__pydantic_fields_set__', _fields_set)         if not cls.__pydantic_root_model__:             _object_setattr(m, '__pydantic_extra__', _extra)          if cls.__pydantic_post_init__:             m.model_post_init(None)             # update private attributes with values set             if hasattr(m, '__pydantic_private__') and m.__pydantic_private__ is not None:                 for k, v in values.items():                     if k in m.__private_attributes__:                         m.__pydantic_private__[k] = v          elif not cls.__pydantic_root_model__:             # Note: if there are any private attributes, cls.__pydantic_post_init__ would exist             # Since it doesn't, that means that `__pydantic_private__` should be set to None             _object_setattr(m, '__pydantic_private__', None)          return m      def model_copy(self, *, update: Mapping[str, Any] | None = None, deep: bool = False) -> Self:         \"\"\"!!! abstract \"Usage Documentation\"             [`model_copy`](../concepts/models.md#model-copy)          Returns a copy of the model.          !!! note             The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This             might have unexpected side effects if you store anything in it, on top of the model             fields (e.g. the value of [cached properties][functools.cached_property]).          Args:             update: Values to change/add in the new model. Note: the data is not validated                 before creating the new model. You should trust this data.             deep: Set to `True` to make a deep copy of the model.          Returns:             New model instance.         \"\"\"         copied = self.__deepcopy__() if deep else self.__copy__()         if update:             if self.model_config.get('extra') == 'allow':                 for k, v in update.items():                     if k in self.__pydantic_fields__:                         copied.__dict__[k] = v                     else:                         if copied.__pydantic_extra__ is None:                             copied.__pydantic_extra__ = {}                         copied.__pydantic_extra__[k] = v             else:                 copied.__dict__.update(update)             copied.__pydantic_fields_set__.update(update.keys())         return copied      def model_dump(         self,         *,         mode: Literal['json', 'python'] | str = 'python',         include: IncEx | None = None,         exclude: IncEx | None = None,         context: Any | None = None,         by_alias: bool | None = None,         exclude_unset: bool = False,         exclude_defaults: bool = False,         exclude_none: bool = False,         exclude_computed_fields: bool = False,         round_trip: bool = False,         warnings: bool | Literal['none', 'warn', 'error'] = True,         fallback: Callable[[Any], Any] | None = None,         serialize_as_any: bool = False,     ) -> dict[str, Any]:         \"\"\"!!! abstract \"Usage Documentation\"             [`model_dump`](../concepts/serialization.md#python-mode)          Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.          Args:             mode: The mode in which `to_python` should run.                 If mode is 'json', the output will only contain JSON serializable types.                 If mode is 'python', the output may contain non-JSON-serializable Python objects.             include: A set of fields to include in the output.             exclude: A set of fields to exclude from the output.             context: Additional context to pass to the serializer.             by_alias: Whether to use the field's alias in the dictionary key if defined.             exclude_unset: Whether to exclude fields that have not been explicitly set.             exclude_defaults: Whether to exclude fields that are set to their default value.             exclude_none: Whether to exclude fields that have a value of `None`.             exclude_computed_fields: Whether to exclude computed fields.                 While this can be useful for round-tripping, it is usually recommended to use the dedicated                 `round_trip` parameter instead.             round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].             warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,                 \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].             fallback: A function to call when an unknown value is encountered. If not provided,                 a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.             serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.          Returns:             A dictionary representation of the model.         \"\"\"         return self.__pydantic_serializer__.to_python(             self,             mode=mode,             by_alias=by_alias,             include=include,             exclude=exclude,             context=context,             exclude_unset=exclude_unset,             exclude_defaults=exclude_defaults,             exclude_none=exclude_none,             exclude_computed_fields=exclude_computed_fields,             round_trip=round_trip,             warnings=warnings,             fallback=fallback,             serialize_as_any=serialize_as_any,         )      def model_dump_json(         self,         *,         indent: int | None = None,         ensure_ascii: bool = False,         include: IncEx | None = None,         exclude: IncEx | None = None,         context: Any | None = None,         by_alias: bool | None = None,         exclude_unset: bool = False,         exclude_defaults: bool = False,         exclude_none: bool = False,         exclude_computed_fields: bool = False,         round_trip: bool = False,         warnings: bool | Literal['none', 'warn', 'error'] = True,         fallback: Callable[[Any], Any] | None = None,         serialize_as_any: bool = False,     ) -> str:         \"\"\"!!! abstract \"Usage Documentation\"             [`model_dump_json`](../concepts/serialization.md#json-mode)          Generates a JSON representation of the model using Pydantic's `to_json` method.          Args:             indent: Indentation to use in the JSON output. If None is passed, the output will be compact.             ensure_ascii: If `True`, the output is guaranteed to have all incoming non-ASCII characters escaped.                 If `False` (the default), these characters will be output as-is.             include: Field(s) to include in the JSON output.             exclude: Field(s) to exclude from the JSON output.             context: Additional context to pass to the serializer.             by_alias: Whether to serialize using field aliases.             exclude_unset: Whether to exclude fields that have not been explicitly set.             exclude_defaults: Whether to exclude fields that are set to their default value.             exclude_none: Whether to exclude fields that have a value of `None`.             exclude_computed_fields: Whether to exclude computed fields.                 While this can be useful for round-tripping, it is usually recommended to use the dedicated                 `round_trip` parameter instead.             round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].             warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,                 \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].             fallback: A function to call when an unknown value is encountered. If not provided,                 a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.             serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.          Returns:             A JSON string representation of the model.         \"\"\"         return self.__pydantic_serializer__.to_json(             self,             indent=indent,             ensure_ascii=ensure_ascii,             include=include,             exclude=exclude,             context=context,             by_alias=by_alias,             exclude_unset=exclude_unset,             exclude_defaults=exclude_defaults,             exclude_none=exclude_none,             exclude_computed_fields=exclude_computed_fields,             round_trip=round_trip,             warnings=warnings,             fallback=fallback,             serialize_as_any=serialize_as_any,         ).decode()      @classmethod     def model_json_schema(         cls,         by_alias: bool = True,         ref_template: str = DEFAULT_REF_TEMPLATE,         schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,         mode: JsonSchemaMode = 'validation',         *,         union_format: Literal['any_of', 'primitive_type_array'] = 'any_of',     ) -> dict[str, Any]:         \"\"\"Generates a JSON schema for a model class.          Args:             by_alias: Whether to use attribute aliases or not.             ref_template: The reference template.             union_format: The format to use when combining schemas from unions together. Can be one of:                  - `'any_of'`: Use the [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)                 keyword to combine schemas (the default).                 - `'primitive_type_array'`: Use the [`type`](https://json-schema.org/understanding-json-schema/reference/type)                 keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive                 type (`string`, `boolean`, `null`, `integer` or `number`) or contains constraints/metadata, falls back to                 `any_of`.             schema_generator: To override the logic used to generate the JSON schema, as a subclass of                 `GenerateJsonSchema` with your desired modifications             mode: The mode in which to generate the schema.          Returns:             The JSON schema for the given model class.         \"\"\"         return model_json_schema(             cls,             by_alias=by_alias,             ref_template=ref_template,             union_format=union_format,             schema_generator=schema_generator,             mode=mode,         )      @classmethod     def model_parametrized_name(cls, params: tuple[type[Any], ...]) -> str:         \"\"\"Compute the class name for parametrizations of generic classes.          This method can be overridden to achieve a custom naming scheme for generic BaseModels.          Args:             params: Tuple of types of the class. Given a generic class                 `Model` with 2 type variables and a concrete model `Model[str, int]`,                 the value `(str, int)` would be passed to `params`.          Returns:             String representing the new class where `params` are passed to `cls` as type variables.          Raises:             TypeError: Raised when trying to generate concrete names for non-generic models.         \"\"\"         if not issubclass(cls, Generic):             raise TypeError('Concrete names should only be generated for generic models.')          # Any strings received should represent forward references, so we handle them specially below.         # If we eventually move toward wrapping them in a ForwardRef in __class_getitem__ in the future,         # we may be able to remove this special case.         param_names = [param if isinstance(param, str) else _repr.display_as_type(param) for param in params]         params_component = ', '.join(param_names)         return f'{cls.__name__}[{params_component}]'      def model_post_init(self, context: Any, /) -> None:         \"\"\"Override this method to perform additional initialization after `__init__` and `model_construct`.         This is useful if you want to do some validation that requires the entire model to be initialized.         \"\"\"      @classmethod     def model_rebuild(         cls,         *,         force: bool = False,         raise_errors: bool = True,         _parent_namespace_depth: int = 2,         _types_namespace: MappingNamespace | None = None,     ) -> bool | None:         \"\"\"Try to rebuild the pydantic-core schema for the model.          This may be necessary when one of the annotations is a ForwardRef which could not be resolved during         the initial attempt to build the schema, and automatic rebuilding fails.          Args:             force: Whether to force the rebuilding of the model schema, defaults to `False`.             raise_errors: Whether to raise errors, defaults to `True`.             _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.             _types_namespace: The types namespace, defaults to `None`.          Returns:             Returns `None` if the schema is already \"complete\" and rebuilding was not required.             If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.         \"\"\"         already_complete = cls.__pydantic_complete__         if already_complete and not force:             return None          cls.__pydantic_complete__ = False          for attr in ('__pydantic_core_schema__', '__pydantic_validator__', '__pydantic_serializer__'):             if attr in cls.__dict__ and not isinstance(getattr(cls, attr), _mock_val_ser.MockValSer):                 # Deleting the validator/serializer is necessary as otherwise they can get reused in                 # pydantic-core. We do so only if they aren't mock instances, otherwise â€” as `model_rebuild()`                 # isn't thread-safe â€” concurrent model instantiations can lead to the parent validator being used.                 # Same applies for the core schema that can be reused in schema generation.                 delattr(cls, attr)          if _types_namespace is not None:             rebuild_ns = _types_namespace         elif _parent_namespace_depth > 0:             rebuild_ns = _typing_extra.parent_frame_namespace(parent_depth=_parent_namespace_depth, force=True) or {}         else:             rebuild_ns = {}          parent_ns = _model_construction.unpack_lenient_weakvaluedict(cls.__pydantic_parent_namespace__) or {}          ns_resolver = _namespace_utils.NsResolver(             parent_namespace={**rebuild_ns, **parent_ns},         )          return _model_construction.complete_model_class(             cls,             _config.ConfigWrapper(cls.model_config, check=False),             ns_resolver,             raise_errors=raise_errors,             # If the model was already complete, we don't need to call the hook again.             call_on_complete_hook=not already_complete,         )      @classmethod     def model_validate(         cls,         obj: Any,         *,         strict: bool | None = None,         extra: ExtraValues | None = None,         from_attributes: bool | None = None,         context: Any | None = None,         by_alias: bool | None = None,         by_name: bool | None = None,     ) -> Self:         \"\"\"Validate a pydantic model instance.          Args:             obj: The object to validate.             strict: Whether to enforce types strictly.             extra: Whether to ignore, allow, or forbid extra data during model validation.                 See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.             from_attributes: Whether to extract data from object attributes.             context: Additional context to pass to the validator.             by_alias: Whether to use the field's alias when validating against the provided input data.             by_name: Whether to use the field's name when validating against the provided input data.          Raises:             ValidationError: If the object could not be validated.          Returns:             The validated model instance.         \"\"\"         # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks         __tracebackhide__ = True          if by_alias is False and by_name is not True:             raise PydanticUserError(                 'At least one of `by_alias` or `by_name` must be set to True.',                 code='validate-by-alias-and-name-false',             )          return cls.__pydantic_validator__.validate_python(             obj,             strict=strict,             extra=extra,             from_attributes=from_attributes,             context=context,             by_alias=by_alias,             by_name=by_name,         )      @classmethod     def model_validate_json(         cls,         json_data: str | bytes | bytearray,         *,         strict: bool | None = None,         extra: ExtraValues | None = None,         context: Any | None = None,         by_alias: bool | None = None,         by_name: bool | None = None,     ) -> Self:         \"\"\"!!! abstract \"Usage Documentation\"             [JSON Parsing](../concepts/json.md#json-parsing)          Validate the given JSON data against the Pydantic model.          Args:             json_data: The JSON data to validate.             strict: Whether to enforce types strictly.             extra: Whether to ignore, allow, or forbid extra data during model validation.                 See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.             context: Extra variables to pass to the validator.             by_alias: Whether to use the field's alias when validating against the provided input data.             by_name: Whether to use the field's name when validating against the provided input data.          Returns:             The validated Pydantic model.          Raises:             ValidationError: If `json_data` is not a JSON string or the object could not be validated.         \"\"\"         # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks         __tracebackhide__ = True          if by_alias is False and by_name is not True:             raise PydanticUserError(                 'At least one of `by_alias` or `by_name` must be set to True.',                 code='validate-by-alias-and-name-false',             )          return cls.__pydantic_validator__.validate_json(             json_data, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name         )      @classmethod     def model_validate_strings(         cls,         obj: Any,         *,         strict: bool | None = None,         extra: ExtraValues | None = None,         context: Any | None = None,         by_alias: bool | None = None,         by_name: bool | None = None,     ) -> Self:         \"\"\"Validate the given object with string data against the Pydantic model.          Args:             obj: The object containing string data to validate.             strict: Whether to enforce types strictly.             extra: Whether to ignore, allow, or forbid extra data during model validation.                 See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.             context: Extra variables to pass to the validator.             by_alias: Whether to use the field's alias when validating against the provided input data.             by_name: Whether to use the field's name when validating against the provided input data.          Returns:             The validated Pydantic model.         \"\"\"         # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks         __tracebackhide__ = True          if by_alias is False and by_name is not True:             raise PydanticUserError(                 'At least one of `by_alias` or `by_name` must be set to True.',                 code='validate-by-alias-and-name-false',             )          return cls.__pydantic_validator__.validate_strings(             obj, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name         )      @classmethod     def __get_pydantic_core_schema__(cls, source: type[BaseModel], handler: GetCoreSchemaHandler, /) -> CoreSchema:         # This warning is only emitted when calling `super().__get_pydantic_core_schema__` from a model subclass.         # In the generate schema logic, this method (`BaseModel.__get_pydantic_core_schema__`) is special cased to         # *not* be called if not overridden.         warnings.warn(             'The `__get_pydantic_core_schema__` method of the `BaseModel` class is deprecated. If you are calling '             '`super().__get_pydantic_core_schema__` when overriding the method on a Pydantic model, consider using '             '`handler(source)` instead. However, note that overriding this method on models can lead to unexpected '             'side effects.',             PydanticDeprecatedSince211,             stacklevel=2,         )         # Logic copied over from `GenerateSchema._model_schema`:         schema = cls.__dict__.get('__pydantic_core_schema__')         if schema is not None and not isinstance(schema, _mock_val_ser.MockCoreSchema):             return cls.__pydantic_core_schema__          return handler(source)      @classmethod     def __get_pydantic_json_schema__(         cls,         core_schema: CoreSchema,         handler: GetJsonSchemaHandler,         /,     ) -> JsonSchemaValue:         \"\"\"Hook into generating the model's JSON schema.          Args:             core_schema: A `pydantic-core` CoreSchema.                 You can ignore this argument and call the handler with a new CoreSchema,                 wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),                 or just call the handler with the original schema.             handler: Call into Pydantic's internal JSON schema generation.                 This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema                 generation fails.                 Since this gets called by `BaseModel.model_json_schema` you can override the                 `schema_generator` argument to that function to change JSON schema generation globally                 for a type.          Returns:             A JSON schema, as a Python object.         \"\"\"         return handler(core_schema)      @classmethod     def __pydantic_init_subclass__(cls, **kwargs: Any) -> None:         \"\"\"This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`         only after basic class initialization is complete. In particular, attributes like `model_fields` will         be present when this is called, but forward annotations are not guaranteed to be resolved yet,         meaning that creating an instance of the class may fail.          This is necessary because `__init_subclass__` will always be called by `type.__new__`,         and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that         `type.__new__` was called in such a manner that the class would already be sufficiently initialized.          This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,         any kwargs passed to the class definition that aren't used internally by Pydantic.          Args:             **kwargs: Any keyword arguments passed to the class definition that aren't used internally                 by Pydantic.          Note:             You may want to override [`__pydantic_on_complete__()`][pydantic.main.BaseModel.__pydantic_on_complete__]             instead, which is called once the class and its fields are fully initialized and ready for validation.         \"\"\"      @classmethod     def __pydantic_on_complete__(cls) -> None:         \"\"\"This is called once the class and its fields are fully initialized and ready to be used.          This typically happens when the class is created (just before         [`__pydantic_init_subclass__()`][pydantic.main.BaseModel.__pydantic_init_subclass__] is called on the superclass),         except when forward annotations are used that could not immediately be resolved.         In that case, it will be called later, when the model is rebuilt automatically or explicitly using         [`model_rebuild()`][pydantic.main.BaseModel.model_rebuild].         \"\"\"      def __class_getitem__(         cls, typevar_values: type[Any] | tuple[type[Any], ...]     ) -> type[BaseModel] | _forward_ref.PydanticRecursiveRef:         cached = _generics.get_cached_generic_type_early(cls, typevar_values)         if cached is not None:             return cached          if cls is BaseModel:             raise TypeError('Type parameters should be placed on typing.Generic, not BaseModel')         if not hasattr(cls, '__parameters__'):             raise TypeError(f'{cls} cannot be parametrized because it does not inherit from typing.Generic')         if not cls.__pydantic_generic_metadata__['parameters'] and Generic not in cls.__bases__:             raise TypeError(f'{cls} is not a generic class')          if not isinstance(typevar_values, tuple):             typevar_values = (typevar_values,)          # For a model `class Model[T, U, V = int](BaseModel): ...` parametrized with `(str, bool)`,         # this gives us `{T: str, U: bool, V: int}`:         typevars_map = _generics.map_generic_model_arguments(cls, typevar_values)         # We also update the provided args to use defaults values (`(str, bool)` becomes `(str, bool, int)`):         typevar_values = tuple(v for v in typevars_map.values())          if _utils.all_identical(typevars_map.keys(), typevars_map.values()) and typevars_map:             submodel = cls  # if arguments are equal to parameters it's the same object             _generics.set_cached_generic_type(cls, typevar_values, submodel)         else:             parent_args = cls.__pydantic_generic_metadata__['args']             if not parent_args:                 args = typevar_values             else:                 args = tuple(_generics.replace_types(arg, typevars_map) for arg in parent_args)              origin = cls.__pydantic_generic_metadata__['origin'] or cls             model_name = origin.model_parametrized_name(args)             params = tuple(                 dict.fromkeys(_generics.iter_contained_typevars(typevars_map.values()))             )  # use dict as ordered set              with _generics.generic_recursion_self_type(origin, args) as maybe_self_type:                 cached = _generics.get_cached_generic_type_late(cls, typevar_values, origin, args)                 if cached is not None:                     return cached                  if maybe_self_type is not None:                     return maybe_self_type                  # Attempt to rebuild the origin in case new types have been defined                 try:                     # depth 2 gets you above this __class_getitem__ call.                     # Note that we explicitly provide the parent ns, otherwise                     # `model_rebuild` will use the parent ns no matter if it is the ns of a module.                     # We don't want this here, as this has unexpected effects when a model                     # is being parametrized during a forward annotation evaluation.                     parent_ns = _typing_extra.parent_frame_namespace(parent_depth=2) or {}                     origin.model_rebuild(_types_namespace=parent_ns)                 except PydanticUndefinedAnnotation:                     # It's okay if it fails, it just means there are still undefined types                     # that could be evaluated later.                     pass                  submodel = _generics.create_generic_submodel(model_name, origin, args, params)                  _generics.set_cached_generic_type(cls, typevar_values, submodel, origin, args)          return submodel      def __copy__(self) -> Self:         \"\"\"Returns a shallow copy of the model.\"\"\"         cls = type(self)         m = cls.__new__(cls)         _object_setattr(m, '__dict__', copy(self.__dict__))         _object_setattr(m, '__pydantic_extra__', copy(self.__pydantic_extra__))         _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))          if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:             _object_setattr(m, '__pydantic_private__', None)         else:             _object_setattr(                 m,                 '__pydantic_private__',                 {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined},             )          return m      def __deepcopy__(self, memo: dict[int, Any] | None = None) -> Self:         \"\"\"Returns a deep copy of the model.\"\"\"         cls = type(self)         m = cls.__new__(cls)         _object_setattr(m, '__dict__', deepcopy(self.__dict__, memo=memo))         _object_setattr(m, '__pydantic_extra__', deepcopy(self.__pydantic_extra__, memo=memo))         # This next line doesn't need a deepcopy because __pydantic_fields_set__ is a set[str],         # and attempting a deepcopy would be marginally slower.         _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))          if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:             _object_setattr(m, '__pydantic_private__', None)         else:             _object_setattr(                 m,                 '__pydantic_private__',                 deepcopy({k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}, memo=memo),             )          return m      if not TYPE_CHECKING:         # We put `__getattr__` in a non-TYPE_CHECKING block because otherwise, mypy allows arbitrary attribute access         # The same goes for __setattr__ and __delattr__, see: https://github.com/pydantic/pydantic/issues/8643          def __getattr__(self, item: str) -> Any:             private_attributes = object.__getattribute__(self, '__private_attributes__')             if item in private_attributes:                 attribute = private_attributes[item]                 if hasattr(attribute, '__get__'):                     return attribute.__get__(self, type(self))  # type: ignore                  try:                     # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items                     return self.__pydantic_private__[item]  # type: ignore                 except KeyError as exc:                     raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc             else:                 # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.                 # See `BaseModel.__repr_args__` for more details                 try:                     pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')                 except AttributeError:                     pydantic_extra = None                  if pydantic_extra and item in pydantic_extra:                     return pydantic_extra[item]                 else:                     if hasattr(self.__class__, item):                         return super().__getattribute__(item)  # Raises AttributeError if appropriate                     else:                         # this is the current error                         raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')          def __setattr__(self, name: str, value: Any) -> None:             if (setattr_handler := self.__pydantic_setattr_handlers__.get(name)) is not None:                 setattr_handler(self, name, value)             # if None is returned from _setattr_handler, the attribute was set directly             elif (setattr_handler := self._setattr_handler(name, value)) is not None:                 setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields                 self.__pydantic_setattr_handlers__[name] = setattr_handler  # memoize the handler for faster access          def _setattr_handler(self, name: str, value: Any) -> Callable[[BaseModel, str, Any], None] | None:             \"\"\"Get a handler for setting an attribute on the model instance.              Returns:                 A handler for setting an attribute on the model instance. Used for memoization of the handler.                 Memoizing the handlers leads to a dramatic performance improvement in `__setattr__`                 Returns `None` when memoization is not safe, then the attribute is set directly.             \"\"\"             cls = self.__class__             if name in cls.__class_vars__:                 raise AttributeError(                     f'{name!r} is a ClassVar of `{cls.__name__}` and cannot be set on an instance. '                     f'If you want to set a value on the class, use `{cls.__name__}.{name} = value`.'                 )             elif not _fields.is_valid_field_name(name):                 if (attribute := cls.__private_attributes__.get(name)) is not None:                     if hasattr(attribute, '__set__'):                         return lambda model, _name, val: attribute.__set__(model, val)                     else:                         return _SIMPLE_SETATTR_HANDLERS['private']                 else:                     _object_setattr(self, name, value)                     return None  # Can not return memoized handler with possibly freeform attr names              attr = getattr(cls, name, None)             # NOTE: We currently special case properties and `cached_property`, but we might need             # to generalize this to all data/non-data descriptors at some point. For non-data descriptors             # (such as `cached_property`), it isn't obvious though. `cached_property` caches the value             # to the instance's `__dict__`, but other non-data descriptors might do things differently.             if isinstance(attr, cached_property):                 return _SIMPLE_SETATTR_HANDLERS['cached_property']              _check_frozen(cls, name, value)              # We allow properties to be set only on non frozen models for now (to match dataclasses).             # This can be changed if it ever gets requested.             if isinstance(attr, property):                 return lambda model, _name, val: attr.__set__(model, val)             elif cls.model_config.get('validate_assignment'):                 return _SIMPLE_SETATTR_HANDLERS['validate_assignment']             elif name not in cls.__pydantic_fields__:                 if cls.model_config.get('extra') != 'allow':                     # TODO - matching error                     raise ValueError(f'\"{cls.__name__}\" object has no field \"{name}\"')                 elif attr is None:                     # attribute does not exist, so put it in extra                     self.__pydantic_extra__[name] = value                     return None  # Can not return memoized handler with possibly freeform attr names                 else:                     # attribute _does_ exist, and was not in extra, so update it                     return _SIMPLE_SETATTR_HANDLERS['extra_known']             else:                 return _SIMPLE_SETATTR_HANDLERS['model_field']          def __delattr__(self, item: str) -> Any:             cls = self.__class__              if item in self.__private_attributes__:                 attribute = self.__private_attributes__[item]                 if hasattr(attribute, '__delete__'):                     attribute.__delete__(self)  # type: ignore                     return                  try:                     # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items                     del self.__pydantic_private__[item]  # type: ignore                     return                 except KeyError as exc:                     raise AttributeError(f'{cls.__name__!r} object has no attribute {item!r}') from exc              # Allow cached properties to be deleted (even if the class is frozen):             attr = getattr(cls, item, None)             if isinstance(attr, cached_property):                 return object.__delattr__(self, item)              _check_frozen(cls, name=item, value=None)              if item in self.__pydantic_fields__:                 object.__delattr__(self, item)             elif self.__pydantic_extra__ is not None and item in self.__pydantic_extra__:                 del self.__pydantic_extra__[item]             else:                 try:                     object.__delattr__(self, item)                 except AttributeError:                     raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')          # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by         # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:         def __replace__(self, **changes: Any) -> Self:             return self.model_copy(update=changes)      def __getstate__(self) -> dict[Any, Any]:         private = self.__pydantic_private__         if private:             private = {k: v for k, v in private.items() if v is not PydanticUndefined}         return {             '__dict__': self.__dict__,             '__pydantic_extra__': self.__pydantic_extra__,             '__pydantic_fields_set__': self.__pydantic_fields_set__,             '__pydantic_private__': private,         }      def __setstate__(self, state: dict[Any, Any]) -> None:         _object_setattr(self, '__pydantic_fields_set__', state.get('__pydantic_fields_set__', {}))         _object_setattr(self, '__pydantic_extra__', state.get('__pydantic_extra__', {}))         _object_setattr(self, '__pydantic_private__', state.get('__pydantic_private__', {}))         _object_setattr(self, '__dict__', state.get('__dict__', {}))      if not TYPE_CHECKING:          def __eq__(self, other: Any) -> bool:             if isinstance(other, BaseModel):                 # When comparing instances of generic types for equality, as long as all field values are equal,                 # only require their generic origin types to be equal, rather than exact type equality.                 # This prevents headaches like MyGeneric(x=1) != MyGeneric[Any](x=1).                 self_type = self.__pydantic_generic_metadata__['origin'] or self.__class__                 other_type = other.__pydantic_generic_metadata__['origin'] or other.__class__                  # Perform common checks first                 if not (                     self_type == other_type                     and getattr(self, '__pydantic_private__', None) == getattr(other, '__pydantic_private__', None)                     and self.__pydantic_extra__ == other.__pydantic_extra__                 ):                     return False                  # We only want to compare pydantic fields but ignoring fields is costly.                 # We'll perform a fast check first, and fallback only when needed                 # See GH-7444 and GH-7825 for rationale and a performance benchmark                  # First, do the fast (and sometimes faulty) __dict__ comparison                 if self.__dict__ == other.__dict__:                     # If the check above passes, then pydantic fields are equal, we can return early                     return True                  # We don't want to trigger unnecessary costly filtering of __dict__ on all unequal objects, so we return                 # early if there are no keys to ignore (we would just return False later on anyway)                 model_fields = type(self).__pydantic_fields__.keys()                 if self.__dict__.keys() <= model_fields and other.__dict__.keys() <= model_fields:                     return False                  # If we reach here, there are non-pydantic-fields keys, mapped to unequal values, that we need to ignore                 # Resort to costly filtering of the __dict__ objects                 # We use operator.itemgetter because it is much faster than dict comprehensions                 # NOTE: Contrary to standard python class and instances, when the Model class has a default value for an                 # attribute and the model instance doesn't have a corresponding attribute, accessing the missing attribute                 # raises an error in BaseModel.__getattr__ instead of returning the class attribute                 # So we can use operator.itemgetter() instead of operator.attrgetter()                 getter = operator.itemgetter(*model_fields) if model_fields else lambda _: _utils._SENTINEL                 try:                     return getter(self.__dict__) == getter(other.__dict__)                 except KeyError:                     # In rare cases (such as when using the deprecated BaseModel.copy() method),                     # the __dict__ may not contain all model fields, which is how we can get here.                     # getter(self.__dict__) is much faster than any 'safe' method that accounts                     # for missing keys, and wrapping it in a `try` doesn't slow things down much                     # in the common case.                     self_fields_proxy = _utils.SafeGetItemProxy(self.__dict__)                     other_fields_proxy = _utils.SafeGetItemProxy(other.__dict__)                     return getter(self_fields_proxy) == getter(other_fields_proxy)              # other instance is not a BaseModel             else:                 return NotImplemented  # delegate to the other item in the comparison      if TYPE_CHECKING:         # We put `__init_subclass__` in a TYPE_CHECKING block because, even though we want the type-checking benefits         # described in the signature of `__init_subclass__` below, we don't want to modify the default behavior of         # subclass initialization.          def __init_subclass__(cls, **kwargs: Unpack[ConfigDict]):             \"\"\"This signature is included purely to help type-checkers check arguments to class declaration, which             provides a way to conveniently set model_config key/value pairs.              ```python             from pydantic import BaseModel              class MyModel(BaseModel, extra='allow'): ...             ```              However, this may be deceiving, since the _actual_ calls to `__init_subclass__` will not receive any             of the config arguments, and will only receive any keyword arguments passed during class initialization             that are _not_ expected keys in ConfigDict. (This is due to the way `ModelMetaclass.__new__` works.)              Args:                 **kwargs: Keyword arguments passed to the class definition, which set model_config              Note:                 You may want to override `__pydantic_init_subclass__` instead, which behaves similarly but is called                 *after* the class is fully initialized.             \"\"\"      def __iter__(self) -> TupleGenerator:         \"\"\"So `dict(model)` works.\"\"\"         yield from [(k, v) for (k, v) in self.__dict__.items() if not k.startswith('_')]         extra = self.__pydantic_extra__         if extra:             yield from extra.items()      def __repr__(self) -> str:         return f'{self.__repr_name__()}({self.__repr_str__(\", \")})'      def __repr_args__(self) -> _repr.ReprArgs:         # Eagerly create the repr of computed fields, as this may trigger access of cached properties and as such         # modify the instance's `__dict__`. If we don't do it now, it could happen when iterating over the `__dict__`         # below if the instance happens to be referenced in a field, and would modify the `__dict__` size *during* iteration.         computed_fields_repr_args = [             (k, getattr(self, k)) for k, v in self.__pydantic_computed_fields__.items() if v.repr         ]          for k, v in self.__dict__.items():             field = self.__pydantic_fields__.get(k)             if field and field.repr:                 if v is not self:                     yield k, v                 else:                     yield k, self.__repr_recursion__(v)         # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.         # This can happen if a `ValidationError` is raised during initialization and the instance's         # repr is generated as part of the exception handling. Therefore, we use `getattr` here         # with a fallback, even though the type hints indicate the attribute will always be present.         try:             pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')         except AttributeError:             pydantic_extra = None          if pydantic_extra is not None:             yield from ((k, v) for k, v in pydantic_extra.items())         yield from computed_fields_repr_args      # take logic from `_repr.Representation` without the side effects of inheritance, see #5740     __repr_name__ = _repr.Representation.__repr_name__     __repr_recursion__ = _repr.Representation.__repr_recursion__     __repr_str__ = _repr.Representation.__repr_str__     __pretty__ = _repr.Representation.__pretty__     __rich_repr__ = _repr.Representation.__rich_repr__      def __str__(self) -> str:         return self.__repr_str__(' ')      # ##### Deprecated methods from v1 #####     @property     @typing_extensions.deprecated(         'The `__fields__` attribute is deprecated, use the `model_fields` class property instead.', category=None     )     def __fields__(self) -> dict[str, FieldInfo]:         warnings.warn(             'The `__fields__` attribute is deprecated, use the `model_fields` class property instead.',             category=PydanticDeprecatedSince20,             stacklevel=2,         )         return getattr(type(self), '__pydantic_fields__', {})      @property     @typing_extensions.deprecated(         'The `__fields_set__` attribute is deprecated, use `model_fields_set` instead.',         category=None,     )     def __fields_set__(self) -> set[str]:         warnings.warn(             'The `__fields_set__` attribute is deprecated, use `model_fields_set` instead.',             category=PydanticDeprecatedSince20,             stacklevel=2,         )         return self.__pydantic_fields_set__      @typing_extensions.deprecated('The `dict` method is deprecated; use `model_dump` instead.', category=None)     def dict(  # noqa: D102         self,         *,         include: IncEx | None = None,         exclude: IncEx | None = None,         by_alias: bool = False,         exclude_unset: bool = False,         exclude_defaults: bool = False,         exclude_none: bool = False,     ) -> Dict[str, Any]:  # noqa UP006         warnings.warn(             'The `dict` method is deprecated; use `model_dump` instead.',             category=PydanticDeprecatedSince20,             stacklevel=2,         )         return self.model_dump(             include=include,             exclude=exclude,             by_alias=by_alias,             exclude_unset=exclude_unset,             exclude_defaults=exclude_defaults,             exclude_none=exclude_none,         )      @typing_extensions.deprecated('The `json` method is deprecated; use `model_dump_json` instead.', category=None)     def json(  # noqa: D102         self,         *,         include: IncEx | None = None,         exclude: IncEx | None = None,         by_alias: bool = False,         exclude_unset: bool = False,         exclude_defaults: bool = False,         exclude_none: bool = False,         encoder: Callable[[Any], Any] | None = PydanticUndefined,  # type: ignore[assignment]         models_as_dict: bool = PydanticUndefined,  # type: ignore[assignment]         **dumps_kwargs: Any,     ) -> str:         warnings.warn(             'The `json` method is deprecated; use `model_dump_json` instead.',             category=PydanticDeprecatedSince20,             stacklevel=2,         )         if encoder is not PydanticUndefined:             raise TypeError('The `encoder` argument is no longer supported; use field serializers instead.')         if models_as_dict is not PydanticUndefined:             raise TypeError('The `models_as_dict` argument is no longer supported; use a model serializer instead.')         if dumps_kwargs:             raise TypeError('`dumps_kwargs` keyword arguments are no longer supported.')         return self.model_dump_json(             include=include,             exclude=exclude,             by_alias=by_alias,             exclude_unset=exclude_unset,             exclude_defaults=exclude_defaults,             exclude_none=exclude_none,         )      @classmethod     @typing_extensions.deprecated('The `parse_obj` method is deprecated; use `model_validate` instead.', category=None)     def parse_obj(cls, obj: Any) -> Self:  # noqa: D102         warnings.warn(             'The `parse_obj` method is deprecated; use `model_validate` instead.',             category=PydanticDeprecatedSince20,             stacklevel=2,         )         return cls.model_validate(obj)      @classmethod     @typing_extensions.deprecated(         'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '         'otherwise load the data then use `model_validate` instead.',         category=None,     )     def parse_raw(  # noqa: D102         cls,         b: str | bytes,         *,         content_type: str | None = None,         encoding: str = 'utf8',         proto: DeprecatedParseProtocol | None = None,         allow_pickle: bool = False,     ) -> Self:  # pragma: no cover         warnings.warn(             'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '             'otherwise load the data then use `model_validate` instead.',             category=PydanticDeprecatedSince20,             stacklevel=2,         )         from .deprecated import parse          try:             obj = parse.load_str_bytes(                 b,                 proto=proto,                 content_type=content_type,                 encoding=encoding,                 allow_pickle=allow_pickle,             )         except (ValueError, TypeError) as exc:             import json              # try to match V1             if isinstance(exc, UnicodeDecodeError):                 type_str = 'value_error.unicodedecode'             elif isinstance(exc, json.JSONDecodeError):                 type_str = 'value_error.jsondecode'             elif isinstance(exc, ValueError):                 type_str = 'value_error'             else:                 type_str = 'type_error'              # ctx is missing here, but since we've added `input` to the error, we're not pretending it's the same             error: pydantic_core.InitErrorDetails = {                 # The type: ignore on the next line is to ignore the requirement of LiteralString                 'type': pydantic_core.PydanticCustomError(type_str, str(exc)),  # type: ignore                 'loc': ('__root__',),                 'input': b,             }             raise pydantic_core.ValidationError.from_exception_data(cls.__name__, [error])         return cls.model_validate(obj)      @classmethod     @typing_extensions.deprecated(         'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '         'use `model_validate_json`, otherwise `model_validate` instead.',         category=None,     )     def parse_file(  # noqa: D102         cls,         path: str | Path,         *,         content_type: str | None = None,         encoding: str = 'utf8',         proto: DeprecatedParseProtocol | None = None,         allow_pickle: bool = False,     ) -> Self:         warnings.warn(             'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '             'use `model_validate_json`, otherwise `model_validate` instead.',             category=PydanticDeprecatedSince20,             stacklevel=2,         )         from .deprecated import parse          obj = parse.load_file(             path,             proto=proto,             content_type=content_type,             encoding=encoding,             allow_pickle=allow_pickle,         )         return cls.parse_obj(obj)      @classmethod     @typing_extensions.deprecated(         'The `from_orm` method is deprecated; set '         \"`model_config['from_attributes']=True` and use `model_validate` instead.\",         category=None,     )     def from_orm(cls, obj: Any) -> Self:  # noqa: D102         warnings.warn(             'The `from_orm` method is deprecated; set '             \"`model_config['from_attributes']=True` and use `model_validate` instead.\",             category=PydanticDeprecatedSince20,             stacklevel=2,         )         if not cls.model_config.get('from_attributes', None):             raise PydanticUserError(                 'You must set the config attribute `from_attributes=True` to use from_orm', code=None             )         return cls.model_validate(obj)      @classmethod     @typing_extensions.deprecated('The `construct` method is deprecated; use `model_construct` instead.', category=None)     def construct(cls, _fields_set: set[str] | None = None, **values: Any) -> Self:  # noqa: D102         warnings.warn(             'The `construct` method is deprecated; use `model_construct` instead.',             category=PydanticDeprecatedSince20,             stacklevel=2,         )         return cls.model_construct(_fields_set=_fields_set, **values)      @typing_extensions.deprecated(         'The `copy` method is deprecated; use `model_copy` instead. '         'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',         category=None,     )     def copy(         self,         *,         include: AbstractSetIntStr | MappingIntStrAny | None = None,         exclude: AbstractSetIntStr | MappingIntStrAny | None = None,         update: Dict[str, Any] | None = None,  # noqa UP006         deep: bool = False,     ) -> Self:  # pragma: no cover         \"\"\"Returns a copy of the model.          !!! warning \"Deprecated\"             This method is now deprecated; use `model_copy` instead.          If you need `include` or `exclude`, use:          ```python {test=\"skip\" lint=\"skip\"}         data = self.model_dump(include=include, exclude=exclude, round_trip=True)         data = {**data, **(update or {})}         copied = self.model_validate(data)         ```          Args:             include: Optional set or mapping specifying which fields to include in the copied model.             exclude: Optional set or mapping specifying which fields to exclude in the copied model.             update: Optional dictionary of field-value pairs to override field values in the copied model.             deep: If True, the values of fields that are Pydantic models will be deep-copied.          Returns:             A copy of the model with included, excluded and updated fields as specified.         \"\"\"         warnings.warn(             'The `copy` method is deprecated; use `model_copy` instead. '             'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',             category=PydanticDeprecatedSince20,             stacklevel=2,         )         from .deprecated import copy_internals          values = dict(             copy_internals._iter(                 self, to_dict=False, by_alias=False, include=include, exclude=exclude, exclude_unset=False             ),             **(update or {}),         )         if self.__pydantic_private__ is None:             private = None         else:             private = {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}          if self.__pydantic_extra__ is None:             extra: dict[str, Any] | None = None         else:             extra = self.__pydantic_extra__.copy()             for k in list(self.__pydantic_extra__):                 if k not in values:  # k was in the exclude                     extra.pop(k)             for k in list(values):                 if k in self.__pydantic_extra__:  # k must have come from extra                     extra[k] = values.pop(k)          # new `__pydantic_fields_set__` can have unset optional fields with a set value in `update` kwarg         if update:             fields_set = self.__pydantic_fields_set__ | update.keys()         else:             fields_set = set(self.__pydantic_fields_set__)          # removing excluded fields from `__pydantic_fields_set__`         if exclude:             fields_set -= set(exclude)          return copy_internals._copy_and_set_values(self, values, fields_set, extra, private, deep=deep)      @classmethod     @typing_extensions.deprecated('The `schema` method is deprecated; use `model_json_schema` instead.', category=None)     def schema(  # noqa: D102         cls, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE     ) -> Dict[str, Any]:  # noqa UP006         warnings.warn(             'The `schema` method is deprecated; use `model_json_schema` instead.',             category=PydanticDeprecatedSince20,             stacklevel=2,         )         return cls.model_json_schema(by_alias=by_alias, ref_template=ref_template)      @classmethod     @typing_extensions.deprecated(         'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',         category=None,     )     def schema_json(  # noqa: D102         cls, *, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any     ) -> str:  # pragma: no cover         warnings.warn(             'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',             category=PydanticDeprecatedSince20,             stacklevel=2,         )         import json          from .deprecated.json import pydantic_encoder          return json.dumps(             cls.model_json_schema(by_alias=by_alias, ref_template=ref_template),             default=pydantic_encoder,             **dumps_kwargs,         )      @classmethod     @typing_extensions.deprecated('The `validate` method is deprecated; use `model_validate` instead.', category=None)     def validate(cls, value: Any) -> Self:  # noqa: D102         warnings.warn(             'The `validate` method is deprecated; use `model_validate` instead.',             category=PydanticDeprecatedSince20,             stacklevel=2,         )         return cls.model_validate(value)      @classmethod     @typing_extensions.deprecated(         'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',         category=None,     )     def update_forward_refs(cls, **localns: Any) -> None:  # noqa: D102         warnings.warn(             'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',             category=PydanticDeprecatedSince20,             stacklevel=2,         )         if localns:  # pragma: no cover             raise TypeError('`localns` arguments are not longer accepted.')         cls.model_rebuild(force=True)      @typing_extensions.deprecated(         'The private method `_iter` will be removed and should no longer be used.', category=None     )     def _iter(self, *args: Any, **kwargs: Any) -> Any:         warnings.warn(             'The private method `_iter` will be removed and should no longer be used.',             category=PydanticDeprecatedSince20,             stacklevel=2,         )         from .deprecated import copy_internals          return copy_internals._iter(self, *args, **kwargs)      @typing_extensions.deprecated(         'The private method `_copy_and_set_values` will be removed and should no longer be used.',         category=None,     )     def _copy_and_set_values(self, *args: Any, **kwargs: Any) -> Any:         warnings.warn(             'The private method `_copy_and_set_values` will be removed and should no longer be used.',             category=PydanticDeprecatedSince20,             stacklevel=2,         )         from .deprecated import copy_internals          return copy_internals._copy_and_set_values(self, *args, **kwargs)      @classmethod     @typing_extensions.deprecated(         'The private method `_get_value` will be removed and should no longer be used.',         category=None,     )     def _get_value(cls, *args: Any, **kwargs: Any) -> Any:         warnings.warn(             'The private method `_get_value` will be removed and should no longer be used.',             category=PydanticDeprecatedSince20,             stacklevel=2,         )         from .deprecated import copy_internals          return copy_internals._get_value(cls, *args, **kwargs)      @typing_extensions.deprecated(         'The private method `_calculate_keys` will be removed and should no longer be used.',         category=None,     )     def _calculate_keys(self, *args: Any, **kwargs: Any) -> Any:         warnings.warn(             'The private method `_calculate_keys` will be removed and should no longer be used.',             category=PydanticDeprecatedSince20,             stacklevel=2,         )         from .deprecated import copy_internals          return copy_internals._calculate_keys(self, *args, **kwargs) ``` |", "url": "https://docs.pydantic.dev/latest/api/base_model/index.html#pydanticbasemodel-indexhtmlpydanticbasemodel-permanent-link", "page": "api/base_model/index.html", "source_site": "pydantic"}
{"title": "\\_\\_init\\_\\_ [Â¶](index.html#pydantic.BaseModel.__init__ \"Permanent link\")", "anchor": "init-indexhtmlpydanticbasemodelinit-permanent-link", "md_text": "```\n__init__(**data: Any) -> None\n```\n\nRaises [`ValidationError`](../pydantic_core/index.html#pydantic_core.ValidationError) if the input data cannot be\nvalidated to form a valid model.\n\n`self` is explicitly positional-only to allow `self` as a field name.\n\nSource code in `pydantic/main.py`\n\n|  |  |\n| --- | --- |\n| ``` 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 ``` | ``` def __init__(self, /, **data: Any) -> None:     \"\"\"Create a new model by parsing and validating input data from keyword arguments.      Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be     validated to form a valid model.      `self` is explicitly positional-only to allow `self` as a field name.     \"\"\"     # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks     __tracebackhide__ = True     validated_self = self.__pydantic_validator__.validate_python(data, self_instance=self)     if self is not validated_self:         warnings.warn(             'A custom validator is returning a value other than `self`.\\n'             \"Returning anything other than `self` from a top level model validator isn't supported when validating via `__init__`.\\n\"             'See the `model_validator` docs (https://docs.pydantic.dev/latest/concepts/validators/#model-validators) for more details.',             stacklevel=2,         ) ``` |", "url": "https://docs.pydantic.dev/latest/api/base_model/index.html#init-indexhtmlpydanticbasemodelinit-permanent-link", "page": "api/base_model/index.html", "source_site": "pydantic"}
{"title": "model\\_config `class-attribute` [Â¶](index.html#pydantic.BaseModel.model_config \"Permanent link\")", "anchor": "modelconfig-class-attribute-indexhtmlpydanticbasemodelmodelconfig-permanent-link", "md_text": "```\nmodel_config: ConfigDict = ConfigDict()\n```\n\nConfiguration for the model, should be a dictionary conforming to [`ConfigDict`](../config/index.html#pydantic.config.ConfigDict).", "url": "https://docs.pydantic.dev/latest/api/base_model/index.html#modelconfig-class-attribute-indexhtmlpydanticbasemodelmodelconfig-permanent-link", "page": "api/base_model/index.html", "source_site": "pydantic"}
{"title": "model\\_fields `classmethod` [Â¶](index.html#pydantic.BaseModel.model_fields \"Permanent link\")", "anchor": "modelfields-classmethod-indexhtmlpydanticbasemodelmodelfields-permanent-link", "md_text": "```\nmodel_fields() -> dict[str, FieldInfo]\n```\n\nA mapping of field names to their respective [`FieldInfo`](../fields/index.html#pydantic.fields.FieldInfo) instances.\n\nAccessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\nInstead, you should access this attribute from the model class.\n\nSource code in `pydantic/main.py`\n\n|  |  |\n| --- | --- |\n| ``` 262 263 264 265 266 267 268 269 270 271 ``` | ``` @_utils.deprecated_instance_property @classmethod def model_fields(cls) -> dict[str, FieldInfo]:     \"\"\"A mapping of field names to their respective [`FieldInfo`][pydantic.fields.FieldInfo] instances.      !!! warning         Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.         Instead, you should access this attribute from the model class.     \"\"\"     return getattr(cls, '__pydantic_fields__', {}) ``` |", "url": "https://docs.pydantic.dev/latest/api/base_model/index.html#modelfields-classmethod-indexhtmlpydanticbasemodelmodelfields-permanent-link", "page": "api/base_model/index.html", "source_site": "pydantic"}
{"title": "model\\_computed\\_fields `classmethod` [Â¶](index.html#pydantic.BaseModel.model_computed_fields \"Permanent link\")", "anchor": "modelcomputedfields-classmethod-indexhtmlpydanticbasemodelmodelcomputedfields-permanent-link", "md_text": "```\nmodel_computed_fields() -> dict[str, ComputedFieldInfo]\n```\n\nA mapping of computed field names to their respective [`ComputedFieldInfo`](../fields/index.html#pydantic.fields.ComputedFieldInfo) instances.\n\nAccessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\nInstead, you should access this attribute from the model class.\n\nSource code in `pydantic/main.py`\n\n|  |  |\n| --- | --- |\n| ``` 273 274 275 276 277 278 279 280 281 282 ``` | ``` @_utils.deprecated_instance_property @classmethod def model_computed_fields(cls) -> dict[str, ComputedFieldInfo]:     \"\"\"A mapping of computed field names to their respective [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] instances.      !!! warning         Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.         Instead, you should access this attribute from the model class.     \"\"\"     return getattr(cls, '__pydantic_computed_fields__', {}) ``` |", "url": "https://docs.pydantic.dev/latest/api/base_model/index.html#modelcomputedfields-classmethod-indexhtmlpydanticbasemodelmodelcomputedfields-permanent-link", "page": "api/base_model/index.html", "source_site": "pydantic"}
{"title": "\\_\\_pydantic\\_core\\_schema\\_\\_ `class-attribute` [Â¶](index.html#pydantic.BaseModel.__pydantic_core_schema__ \"Permanent link\")", "anchor": "pydanticcoreschema-class-attribute-indexhtmlpydanticbasemodelpydanticcoreschema-permanent-link", "md_text": "```\n__pydantic_core_schema__: CoreSchema\n```\n\nThe core schema of the model.", "url": "https://docs.pydantic.dev/latest/api/base_model/index.html#pydanticcoreschema-class-attribute-indexhtmlpydanticbasemodelpydanticcoreschema-permanent-link", "page": "api/base_model/index.html", "source_site": "pydantic"}
{"title": "model\\_extra `property` [Â¶](index.html#pydantic.BaseModel.model_extra \"Permanent link\")", "anchor": "modelextra-property-indexhtmlpydanticbasemodelmodelextra-permanent-link", "md_text": "```\nmodel_extra: dict[str, Any] | None\n```\n\nGet extra fields set during validation.\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `dict[str, Any] | None` | A dictionary of extra fields, or `None` if `config.extra` is not set to `\"allow\"`. |", "url": "https://docs.pydantic.dev/latest/api/base_model/index.html#modelextra-property-indexhtmlpydanticbasemodelmodelextra-permanent-link", "page": "api/base_model/index.html", "source_site": "pydantic"}
{"title": "model\\_fields\\_set `property` [Â¶](index.html#pydantic.BaseModel.model_fields_set \"Permanent link\")", "anchor": "modelfieldsset-property-indexhtmlpydanticbasemodelmodelfieldsset-permanent-link", "md_text": "```\nmodel_fields_set: set[str]\n```\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `set[str]` | A set of strings representing the fields that have been set, i.e. that were not filled from defaults. |", "url": "https://docs.pydantic.dev/latest/api/base_model/index.html#modelfieldsset-property-indexhtmlpydanticbasemodelmodelfieldsset-permanent-link", "page": "api/base_model/index.html", "source_site": "pydantic"}
{"title": "model\\_construct `classmethod` [Â¶](index.html#pydantic.BaseModel.model_construct \"Permanent link\")", "anchor": "modelconstruct-classmethod-indexhtmlpydanticbasemodelmodelconstruct-permanent-link", "md_text": "```\nmodel_construct(\n    _fields_set: set[str] | None = None, **values: Any\n) -> Self\n```\n\nCreates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n`model_construct()` generally respects the `model_config.extra` setting on the provided model.\nThat is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\nand `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\nan error if extra values are passed, but they will be ignored.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `_fields_set` | `set[str] | None` | A set of field names that were originally explicitly set during instantiation. If provided, this is directly used for the [`model_fields_set`](index.html#pydantic.BaseModel.model_fields_set) attribute. Otherwise, the field names from the `values` argument will be used. | `None` |\n| `values` | `Any` | Trusted or pre-validated data dictionary. | `{}` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `Self` | A new instance of the `Model` class with validated data. |\n\nSource code in `pydantic/main.py`", "url": "https://docs.pydantic.dev/latest/api/base_model/index.html#modelconstruct-classmethod-indexhtmlpydanticbasemodelmodelconstruct-permanent-link", "page": "api/base_model/index.html", "source_site": "pydantic"}
{"title": "model\\_construct `classmethod` [Â¶](index.html#pydantic.BaseModel.model_construct \"Permanent link\")", "anchor": "modelconstruct-classmethod-indexhtmlpydanticbasemodelmodelconstruct-permanent-link", "md_text": "|  |  |\n| --- | --- |\n| ``` 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 ``` | ``` @classmethod def model_construct(cls, _fields_set: set[str] | None = None, **values: Any) -> Self:  # noqa: C901     \"\"\"Creates a new instance of the `Model` class with validated data.      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.     Default values are respected, but no other validation is performed.      !!! note         `model_construct()` generally respects the `model_config.extra` setting on the provided model.         That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`         and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.         Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in         an error if extra values are passed, but they will be ignored.      Args:         _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,             this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.             Otherwise, the field names from the `values` argument will be used.         values: Trusted or pre-validated data dictionary.      Returns:         A new instance of the `Model` class with validated data.     \"\"\"     m = cls.__new__(cls)     fields_values: dict[str, Any] = {}     fields_set = set()      for name, field in cls.__pydantic_fields__.items():         if field.alias is not None and field.alias in values:             fields_values[name] = values.pop(field.alias)             fields_set.add(name)          if (name not in fields_set) and (field.validation_alias is not None):             validation_aliases: list[str | AliasPath] = (                 field.validation_alias.choices                 if isinstance(field.validation_alias, AliasChoices)                 else [field.validation_alias]             )              for alias in validation_aliases:                 if isinstance(alias, str) and alias in values:                     fields_values[name] = values.pop(alias)                     fields_set.add(name)                     break                 elif isinstance(alias, AliasPath):                     value = alias.search_dict_for_path(values)                     if value is not PydanticUndefined:                         fields_values[name] = value                         fields_set.add(name)                         break          if name not in fields_set:             if name in values:                 fields_values[name] = values.pop(name)                 fields_set.add(name)             elif not field.is_required():                 fields_values[name] = field.get_default(call_default_factory=True, validated_data=fields_values)     if _fields_set is None:         _fields_set = fields_set      _extra: dict[str, Any] | None = values if cls.model_config.get('extra') == 'allow' else None     _object_setattr(m, '__dict__', fields_values)     _object_setattr(m, '__pydantic_fields_set__', _fields_set)     if not cls.__pydantic_root_model__:         _object_setattr(m, '__pydantic_extra__', _extra)      if cls.__pydantic_post_init__:         m.model_post_init(None)         # update private attributes with values set         if hasattr(m, '__pydantic_private__') and m.__pydantic_private__ is not None:             for k, v in values.items():                 if k in m.__private_attributes__:                     m.__pydantic_private__[k] = v      elif not cls.__pydantic_root_model__:         # Note: if there are any private attributes, cls.__pydantic_post_init__ would exist         # Since it doesn't, that means that `__pydantic_private__` should be set to None         _object_setattr(m, '__pydantic_private__', None)      return m ``` |", "url": "https://docs.pydantic.dev/latest/api/base_model/index.html#modelconstruct-classmethod-indexhtmlpydanticbasemodelmodelconstruct-permanent-link", "page": "api/base_model/index.html", "source_site": "pydantic"}
{"title": "model\\_copy [Â¶](index.html#pydantic.BaseModel.model_copy \"Permanent link\")", "anchor": "modelcopy-indexhtmlpydanticbasemodelmodelcopy-permanent-link", "md_text": "```\nmodel_copy(\n    *,\n    update: Mapping[str, Any] | None = None,\n    deep: bool = False\n) -> Self\n```\n\n[`model_copy`](../../concepts/models/index.html#model-copy)\n\nReturns a copy of the model.\n\nThe underlying instance's [`__dict__`](https://docs.python.org/3/reference/datamodel.html#object.__dict__) attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties](https://docs.python.org/3/library/functools.html#functools.cached_property)).\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `update` | `Mapping[str, Any] | None` | Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data. | `None` |\n| `deep` | `bool` | Set to `True` to make a deep copy of the model. | `False` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `Self` | New model instance. |\n\nSource code in `pydantic/main.py`\n\n|  |  |\n| --- | --- |\n| ``` 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 ``` | ``` def model_copy(self, *, update: Mapping[str, Any] | None = None, deep: bool = False) -> Self:     \"\"\"!!! abstract \"Usage Documentation\"         [`model_copy`](../concepts/models.md#model-copy)      Returns a copy of the model.      !!! note         The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This         might have unexpected side effects if you store anything in it, on top of the model         fields (e.g. the value of [cached properties][functools.cached_property]).      Args:         update: Values to change/add in the new model. Note: the data is not validated             before creating the new model. You should trust this data.         deep: Set to `True` to make a deep copy of the model.      Returns:         New model instance.     \"\"\"     copied = self.__deepcopy__() if deep else self.__copy__()     if update:         if self.model_config.get('extra') == 'allow':             for k, v in update.items():                 if k in self.__pydantic_fields__:                     copied.__dict__[k] = v                 else:                     if copied.__pydantic_extra__ is None:                         copied.__pydantic_extra__ = {}                     copied.__pydantic_extra__[k] = v         else:             copied.__dict__.update(update)         copied.__pydantic_fields_set__.update(update.keys())     return copied ``` |", "url": "https://docs.pydantic.dev/latest/api/base_model/index.html#modelcopy-indexhtmlpydanticbasemodelmodelcopy-permanent-link", "page": "api/base_model/index.html", "source_site": "pydantic"}
{"title": "model\\_dump [Â¶](index.html#pydantic.BaseModel.model_dump \"Permanent link\")", "anchor": "modeldump-indexhtmlpydanticbasemodelmodeldump-permanent-link", "md_text": "```\nmodel_dump(\n    *,\n    mode: Literal[\"json\", \"python\"] | str = \"python\",\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: (\n        bool | Literal[\"none\", \"warn\", \"error\"]\n    ) = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False\n) -> dict[str, Any]\n```\n\n[`model_dump`](../../concepts/serialization/index.html#python-mode)\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `mode` | `Literal['json', 'python'] | str` | The mode in which `to_python` should run. If mode is 'json', the output will only contain JSON serializable types. If mode is 'python', the output may contain non-JSON-serializable Python objects. | `'python'` |\n| `include` | `IncEx | None` | A set of fields to include in the output. | `None` |\n| `exclude` | `IncEx | None` | A set of fields to exclude from the output. | `None` |\n| `context` | `Any | None` | Additional context to pass to the serializer. | `None` |\n| `by_alias` | `bool | None` | Whether to use the field's alias in the dictionary key if defined. | `None` |\n| `exclude_unset` | `bool` | Whether to exclude fields that have not been explicitly set. | `False` |\n| `exclude_defaults` | `bool` | Whether to exclude fields that are set to their default value. | `False` |\n| `exclude_none` | `bool` | Whether to exclude fields that have a value of `None`. | `False` |\n| `exclude_computed_fields` | `bool` | Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated `round_trip` parameter instead. | `False` |\n| `round_trip` | `bool` | If True, dumped values should be valid as input for non-idempotent types such as Json[T]. | `False` |\n| `warnings` | `bool | Literal['none', 'warn', 'error']` | How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a [`PydanticSerializationError`](../pydantic_core/index.html#pydantic_core.PydanticSerializationError). | `True` |\n| `fallback` | `Callable[[Any], Any] | None` | A function to call when an unknown value is encountered. If not provided, a [`PydanticSerializationError`](../pydantic_core/index.html#pydantic_core.PydanticSerializationError) error is raised. | `None` |\n| `serialize_as_any` | `bool` | Whether to serialize fields with duck-typing serialization behavior. | `False` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `dict[str, Any]` | A dictionary representation of the model. |\n\nSource code in `pydantic/main.py`", "url": "https://docs.pydantic.dev/latest/api/base_model/index.html#modeldump-indexhtmlpydanticbasemodelmodeldump-permanent-link", "page": "api/base_model/index.html", "source_site": "pydantic"}
{"title": "model\\_dump [Â¶](index.html#pydantic.BaseModel.model_dump \"Permanent link\")", "anchor": "modeldump-indexhtmlpydanticbasemodelmodeldump-permanent-link", "md_text": "|  |  |\n| --- | --- |\n| ``` 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 ``` | ``` def model_dump(     self,     *,     mode: Literal['json', 'python'] | str = 'python',     include: IncEx | None = None,     exclude: IncEx | None = None,     context: Any | None = None,     by_alias: bool | None = None,     exclude_unset: bool = False,     exclude_defaults: bool = False,     exclude_none: bool = False,     exclude_computed_fields: bool = False,     round_trip: bool = False,     warnings: bool | Literal['none', 'warn', 'error'] = True,     fallback: Callable[[Any], Any] | None = None,     serialize_as_any: bool = False, ) -> dict[str, Any]:     \"\"\"!!! abstract \"Usage Documentation\"         [`model_dump`](../concepts/serialization.md#python-mode)      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.      Args:         mode: The mode in which `to_python` should run.             If mode is 'json', the output will only contain JSON serializable types.             If mode is 'python', the output may contain non-JSON-serializable Python objects.         include: A set of fields to include in the output.         exclude: A set of fields to exclude from the output.         context: Additional context to pass to the serializer.         by_alias: Whether to use the field's alias in the dictionary key if defined.         exclude_unset: Whether to exclude fields that have not been explicitly set.         exclude_defaults: Whether to exclude fields that are set to their default value.         exclude_none: Whether to exclude fields that have a value of `None`.         exclude_computed_fields: Whether to exclude computed fields.             While this can be useful for round-tripping, it is usually recommended to use the dedicated             `round_trip` parameter instead.         round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].         warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,             \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].         fallback: A function to call when an unknown value is encountered. If not provided,             a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.         serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.      Returns:         A dictionary representation of the model.     \"\"\"     return self.__pydantic_serializer__.to_python(         self,         mode=mode,         by_alias=by_alias,         include=include,         exclude=exclude,         context=context,         exclude_unset=exclude_unset,         exclude_defaults=exclude_defaults,         exclude_none=exclude_none,         exclude_computed_fields=exclude_computed_fields,         round_trip=round_trip,         warnings=warnings,         fallback=fallback,         serialize_as_any=serialize_as_any,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/base_model/index.html#modeldump-indexhtmlpydanticbasemodelmodeldump-permanent-link", "page": "api/base_model/index.html", "source_site": "pydantic"}
{"title": "model\\_dump\\_json [Â¶](index.html#pydantic.BaseModel.model_dump_json \"Permanent link\")", "anchor": "modeldumpjson-indexhtmlpydanticbasemodelmodeldumpjson-permanent-link", "md_text": "```\nmodel_dump_json(\n    *,\n    indent: int | None = None,\n    ensure_ascii: bool = False,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: (\n        bool | Literal[\"none\", \"warn\", \"error\"]\n    ) = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False\n) -> str\n```\n\n[`model_dump_json`](../../concepts/serialization/index.html#json-mode)\n\nGenerates a JSON representation of the model using Pydantic's `to_json` method.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `indent` | `int | None` | Indentation to use in the JSON output. If None is passed, the output will be compact. | `None` |\n| `ensure_ascii` | `bool` | If `True`, the output is guaranteed to have all incoming non-ASCII characters escaped. If `False` (the default), these characters will be output as-is. | `False` |\n| `include` | `IncEx | None` | Field(s) to include in the JSON output. | `None` |\n| `exclude` | `IncEx | None` | Field(s) to exclude from the JSON output. | `None` |\n| `context` | `Any | None` | Additional context to pass to the serializer. | `None` |\n| `by_alias` | `bool | None` | Whether to serialize using field aliases. | `None` |\n| `exclude_unset` | `bool` | Whether to exclude fields that have not been explicitly set. | `False` |\n| `exclude_defaults` | `bool` | Whether to exclude fields that are set to their default value. | `False` |\n| `exclude_none` | `bool` | Whether to exclude fields that have a value of `None`. | `False` |\n| `exclude_computed_fields` | `bool` | Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated `round_trip` parameter instead. | `False` |\n| `round_trip` | `bool` | If True, dumped values should be valid as input for non-idempotent types such as Json[T]. | `False` |\n| `warnings` | `bool | Literal['none', 'warn', 'error']` | How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a [`PydanticSerializationError`](../pydantic_core/index.html#pydantic_core.PydanticSerializationError). | `True` |\n| `fallback` | `Callable[[Any], Any] | None` | A function to call when an unknown value is encountered. If not provided, a [`PydanticSerializationError`](../pydantic_core/index.html#pydantic_core.PydanticSerializationError) error is raised. | `None` |\n| `serialize_as_any` | `bool` | Whether to serialize fields with duck-typing serialization behavior. | `False` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `str` | A JSON string representation of the model. |\n\nSource code in `pydantic/main.py`", "url": "https://docs.pydantic.dev/latest/api/base_model/index.html#modeldumpjson-indexhtmlpydanticbasemodelmodeldumpjson-permanent-link", "page": "api/base_model/index.html", "source_site": "pydantic"}
{"title": "model\\_dump\\_json [Â¶](index.html#pydantic.BaseModel.model_dump_json \"Permanent link\")", "anchor": "modeldumpjson-indexhtmlpydanticbasemodelmodeldumpjson-permanent-link", "md_text": "|  |  |\n| --- | --- |\n| ``` 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 ``` | ``` def model_dump_json(     self,     *,     indent: int | None = None,     ensure_ascii: bool = False,     include: IncEx | None = None,     exclude: IncEx | None = None,     context: Any | None = None,     by_alias: bool | None = None,     exclude_unset: bool = False,     exclude_defaults: bool = False,     exclude_none: bool = False,     exclude_computed_fields: bool = False,     round_trip: bool = False,     warnings: bool | Literal['none', 'warn', 'error'] = True,     fallback: Callable[[Any], Any] | None = None,     serialize_as_any: bool = False, ) -> str:     \"\"\"!!! abstract \"Usage Documentation\"         [`model_dump_json`](../concepts/serialization.md#json-mode)      Generates a JSON representation of the model using Pydantic's `to_json` method.      Args:         indent: Indentation to use in the JSON output. If None is passed, the output will be compact.         ensure_ascii: If `True`, the output is guaranteed to have all incoming non-ASCII characters escaped.             If `False` (the default), these characters will be output as-is.         include: Field(s) to include in the JSON output.         exclude: Field(s) to exclude from the JSON output.         context: Additional context to pass to the serializer.         by_alias: Whether to serialize using field aliases.         exclude_unset: Whether to exclude fields that have not been explicitly set.         exclude_defaults: Whether to exclude fields that are set to their default value.         exclude_none: Whether to exclude fields that have a value of `None`.         exclude_computed_fields: Whether to exclude computed fields.             While this can be useful for round-tripping, it is usually recommended to use the dedicated             `round_trip` parameter instead.         round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].         warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,             \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].         fallback: A function to call when an unknown value is encountered. If not provided,             a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.         serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.      Returns:         A JSON string representation of the model.     \"\"\"     return self.__pydantic_serializer__.to_json(         self,         indent=indent,         ensure_ascii=ensure_ascii,         include=include,         exclude=exclude,         context=context,         by_alias=by_alias,         exclude_unset=exclude_unset,         exclude_defaults=exclude_defaults,         exclude_none=exclude_none,         exclude_computed_fields=exclude_computed_fields,         round_trip=round_trip,         warnings=warnings,         fallback=fallback,         serialize_as_any=serialize_as_any,     ).decode() ``` |", "url": "https://docs.pydantic.dev/latest/api/base_model/index.html#modeldumpjson-indexhtmlpydanticbasemodelmodeldumpjson-permanent-link", "page": "api/base_model/index.html", "source_site": "pydantic"}
{"title": "model\\_json\\_schema `classmethod` [Â¶](index.html#pydantic.BaseModel.model_json_schema \"Permanent link\")", "anchor": "modeljsonschema-classmethod-indexhtmlpydanticbasemodelmodeljsonschema-permanent-link", "md_text": "```\nmodel_json_schema(\n    by_alias: bool = True,\n    ref_template: str = DEFAULT_REF_TEMPLATE,\n    schema_generator: type[\n        GenerateJsonSchema\n    ] = GenerateJsonSchema,\n    mode: JsonSchemaMode = \"validation\",\n    *,\n    union_format: Literal[\n        \"any_of\", \"primitive_type_array\"\n    ] = \"any_of\"\n) -> dict[str, Any]\n```\n\nGenerates a JSON schema for a model class.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `by_alias` | `bool` | Whether to use attribute aliases or not. | `True` |\n| `ref_template` | `str` | The reference template. | `DEFAULT_REF_TEMPLATE` |\n| `union_format` | `Literal['any_of', 'primitive_type_array']` | The format to use when combining schemas from unions together. Can be one of:   * `'any_of'`: Use the [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)   keyword to combine schemas (the default). * `'primitive_type_array'`: Use the [`type`](https://json-schema.org/understanding-json-schema/reference/type)   keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive   type (`string`, `boolean`, `null`, `integer` or `number`) or contains constraints/metadata, falls back to   `any_of`. | `'any_of'` |\n| `schema_generator` | `type[GenerateJsonSchema]` | To override the logic used to generate the JSON schema, as a subclass of `GenerateJsonSchema` with your desired modifications | `GenerateJsonSchema` |\n| `mode` | `JsonSchemaMode` | The mode in which to generate the schema. | `'validation'` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `dict[str, Any]` | The JSON schema for the given model class. |\n\nSource code in `pydantic/main.py`\n\n|  |  |\n| --- | --- |\n| ``` 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 ``` | ``` @classmethod def model_json_schema(     cls,     by_alias: bool = True,     ref_template: str = DEFAULT_REF_TEMPLATE,     schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,     mode: JsonSchemaMode = 'validation',     *,     union_format: Literal['any_of', 'primitive_type_array'] = 'any_of', ) -> dict[str, Any]:     \"\"\"Generates a JSON schema for a model class.      Args:         by_alias: Whether to use attribute aliases or not.         ref_template: The reference template.         union_format: The format to use when combining schemas from unions together. Can be one of:              - `'any_of'`: Use the [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)             keyword to combine schemas (the default).             - `'primitive_type_array'`: Use the [`type`](https://json-schema.org/understanding-json-schema/reference/type)             keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive             type (`string`, `boolean`, `null`, `integer` or `number`) or contains constraints/metadata, falls back to             `any_of`.         schema_generator: To override the logic used to generate the JSON schema, as a subclass of             `GenerateJsonSchema` with your desired modifications         mode: The mode in which to generate the schema.      Returns:         The JSON schema for the given model class.     \"\"\"     return model_json_schema(         cls,         by_alias=by_alias,         ref_template=ref_template,         union_format=union_format,         schema_generator=schema_generator,         mode=mode,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/base_model/index.html#modeljsonschema-classmethod-indexhtmlpydanticbasemodelmodeljsonschema-permanent-link", "page": "api/base_model/index.html", "source_site": "pydantic"}
{"title": "model\\_parametrized\\_name `classmethod` [Â¶](index.html#pydantic.BaseModel.model_parametrized_name \"Permanent link\")", "anchor": "modelparametrizedname-classmethod-indexhtmlpydanticbasemodelmodelparametrizedname-permanent-link", "md_text": "```\nmodel_parametrized_name(\n    params: tuple[type[Any], ...]\n) -> str\n```\n\nCompute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `params` | `tuple[type[Any], ...]` | Tuple of types of the class. Given a generic class `Model` with 2 type variables and a concrete model `Model[str, int]`, the value `(str, int)` would be passed to `params`. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `str` | String representing the new class where `params` are passed to `cls` as type variables. |\n\nRaises:\n\n| Type | Description |\n| --- | --- |\n| `TypeError` | Raised when trying to generate concrete names for non-generic models. |\n\nSource code in `pydantic/main.py`\n\n|  |  |\n| --- | --- |\n| ``` 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 ``` | ``` @classmethod def model_parametrized_name(cls, params: tuple[type[Any], ...]) -> str:     \"\"\"Compute the class name for parametrizations of generic classes.      This method can be overridden to achieve a custom naming scheme for generic BaseModels.      Args:         params: Tuple of types of the class. Given a generic class             `Model` with 2 type variables and a concrete model `Model[str, int]`,             the value `(str, int)` would be passed to `params`.      Returns:         String representing the new class where `params` are passed to `cls` as type variables.      Raises:         TypeError: Raised when trying to generate concrete names for non-generic models.     \"\"\"     if not issubclass(cls, Generic):         raise TypeError('Concrete names should only be generated for generic models.')      # Any strings received should represent forward references, so we handle them specially below.     # If we eventually move toward wrapping them in a ForwardRef in __class_getitem__ in the future,     # we may be able to remove this special case.     param_names = [param if isinstance(param, str) else _repr.display_as_type(param) for param in params]     params_component = ', '.join(param_names)     return f'{cls.__name__}[{params_component}]' ``` |", "url": "https://docs.pydantic.dev/latest/api/base_model/index.html#modelparametrizedname-classmethod-indexhtmlpydanticbasemodelmodelparametrizedname-permanent-link", "page": "api/base_model/index.html", "source_site": "pydantic"}
{"title": "model\\_post\\_init [Â¶](index.html#pydantic.BaseModel.model_post_init \"Permanent link\")", "anchor": "modelpostinit-indexhtmlpydanticbasemodelmodelpostinit-permanent-link", "md_text": "```\nmodel_post_init(context: Any) -> None\n```\n\nOverride this method to perform additional initialization after `__init__` and `model_construct`.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\n\nSource code in `pydantic/main.py`\n\n|  |  |\n| --- | --- |\n| ``` 612 613 614 615 ``` | ``` def model_post_init(self, context: Any, /) -> None:     \"\"\"Override this method to perform additional initialization after `__init__` and `model_construct`.     This is useful if you want to do some validation that requires the entire model to be initialized.     \"\"\" ``` |", "url": "https://docs.pydantic.dev/latest/api/base_model/index.html#modelpostinit-indexhtmlpydanticbasemodelmodelpostinit-permanent-link", "page": "api/base_model/index.html", "source_site": "pydantic"}
{"title": "model\\_rebuild `classmethod` [Â¶](index.html#pydantic.BaseModel.model_rebuild \"Permanent link\")", "anchor": "modelrebuild-classmethod-indexhtmlpydanticbasemodelmodelrebuild-permanent-link", "md_text": "```\nmodel_rebuild(\n    *,\n    force: bool = False,\n    raise_errors: bool = True,\n    _parent_namespace_depth: int = 2,\n    _types_namespace: MappingNamespace | None = None\n) -> bool | None\n```\n\nTry to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `force` | `bool` | Whether to force the rebuilding of the model schema, defaults to `False`. | `False` |\n| `raise_errors` | `bool` | Whether to raise errors, defaults to `True`. | `True` |\n| `_parent_namespace_depth` | `int` | The depth level of the parent namespace, defaults to 2. | `2` |\n| `_types_namespace` | `MappingNamespace | None` | The types namespace, defaults to `None`. | `None` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `bool | None` | Returns `None` if the schema is already \"complete\" and rebuilding was not required. |\n| `bool | None` | If rebuilding *was* required, returns `True` if rebuilding was successful, otherwise `False`. |\n\nSource code in `pydantic/main.py`\n\n|  |  |\n| --- | --- |\n| ``` 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 ``` | ``` @classmethod def model_rebuild(     cls,     *,     force: bool = False,     raise_errors: bool = True,     _parent_namespace_depth: int = 2,     _types_namespace: MappingNamespace | None = None, ) -> bool | None:     \"\"\"Try to rebuild the pydantic-core schema for the model.      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during     the initial attempt to build the schema, and automatic rebuilding fails.      Args:         force: Whether to force the rebuilding of the model schema, defaults to `False`.         raise_errors: Whether to raise errors, defaults to `True`.         _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.         _types_namespace: The types namespace, defaults to `None`.      Returns:         Returns `None` if the schema is already \"complete\" and rebuilding was not required.         If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.     \"\"\"     already_complete = cls.__pydantic_complete__     if already_complete and not force:         return None      cls.__pydantic_complete__ = False      for attr in ('__pydantic_core_schema__', '__pydantic_validator__', '__pydantic_serializer__'):         if attr in cls.__dict__ and not isinstance(getattr(cls, attr), _mock_val_ser.MockValSer):             # Deleting the validator/serializer is necessary as otherwise they can get reused in             # pydantic-core. We do so only if they aren't mock instances, otherwise â€” as `model_rebuild()`             # isn't thread-safe â€” concurrent model instantiations can lead to the parent validator being used.             # Same applies for the core schema that can be reused in schema generation.             delattr(cls, attr)      if _types_namespace is not None:         rebuild_ns = _types_namespace     elif _parent_namespace_depth > 0:         rebuild_ns = _typing_extra.parent_frame_namespace(parent_depth=_parent_namespace_depth, force=True) or {}     else:         rebuild_ns = {}      parent_ns = _model_construction.unpack_lenient_weakvaluedict(cls.__pydantic_parent_namespace__) or {}      ns_resolver = _namespace_utils.NsResolver(         parent_namespace={**rebuild_ns, **parent_ns},     )      return _model_construction.complete_model_class(         cls,         _config.ConfigWrapper(cls.model_config, check=False),         ns_resolver,         raise_errors=raise_errors,         # If the model was already complete, we don't need to call the hook again.         call_on_complete_hook=not already_complete,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/base_model/index.html#modelrebuild-classmethod-indexhtmlpydanticbasemodelmodelrebuild-permanent-link", "page": "api/base_model/index.html", "source_site": "pydantic"}
{"title": "model\\_validate `classmethod` [Â¶](index.html#pydantic.BaseModel.model_validate \"Permanent link\")", "anchor": "modelvalidate-classmethod-indexhtmlpydanticbasemodelmodelvalidate-permanent-link", "md_text": "```\nmodel_validate(\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    from_attributes: bool | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None\n) -> Self\n```\n\nValidate a pydantic model instance.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `obj` | `Any` | The object to validate. | *required* |\n| `strict` | `bool | None` | Whether to enforce types strictly. | `None` |\n| `extra` | `ExtraValues | None` | Whether to ignore, allow, or forbid extra data during model validation. See the [`extra` configuration value](../config/index.html#pydantic.config.ConfigDict.extra) for details. | `None` |\n| `from_attributes` | `bool | None` | Whether to extract data from object attributes. | `None` |\n| `context` | `Any | None` | Additional context to pass to the validator. | `None` |\n| `by_alias` | `bool | None` | Whether to use the field's alias when validating against the provided input data. | `None` |\n| `by_name` | `bool | None` | Whether to use the field's name when validating against the provided input data. | `None` |\n\nRaises:\n\n| Type | Description |\n| --- | --- |\n| `ValidationError` | If the object could not be validated. |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `Self` | The validated model instance. |\n\nSource code in `pydantic/main.py`\n\n|  |  |\n| --- | --- |\n| ``` 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 ``` | ``` @classmethod def model_validate(     cls,     obj: Any,     *,     strict: bool | None = None,     extra: ExtraValues | None = None,     from_attributes: bool | None = None,     context: Any | None = None,     by_alias: bool | None = None,     by_name: bool | None = None, ) -> Self:     \"\"\"Validate a pydantic model instance.      Args:         obj: The object to validate.         strict: Whether to enforce types strictly.         extra: Whether to ignore, allow, or forbid extra data during model validation.             See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.         from_attributes: Whether to extract data from object attributes.         context: Additional context to pass to the validator.         by_alias: Whether to use the field's alias when validating against the provided input data.         by_name: Whether to use the field's name when validating against the provided input data.      Raises:         ValidationError: If the object could not be validated.      Returns:         The validated model instance.     \"\"\"     # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks     __tracebackhide__ = True      if by_alias is False and by_name is not True:         raise PydanticUserError(             'At least one of `by_alias` or `by_name` must be set to True.',             code='validate-by-alias-and-name-false',         )      return cls.__pydantic_validator__.validate_python(         obj,         strict=strict,         extra=extra,         from_attributes=from_attributes,         context=context,         by_alias=by_alias,         by_name=by_name,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/base_model/index.html#modelvalidate-classmethod-indexhtmlpydanticbasemodelmodelvalidate-permanent-link", "page": "api/base_model/index.html", "source_site": "pydantic"}
{"title": "model\\_validate\\_json `classmethod` [Â¶](index.html#pydantic.BaseModel.model_validate_json \"Permanent link\")", "anchor": "modelvalidatejson-classmethod-indexhtmlpydanticbasemodelmodelvalidatejson-permanent-link", "md_text": "```\nmodel_validate_json(\n    json_data: str | bytes | bytearray,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None\n) -> Self\n```\n\n[JSON Parsing](../../concepts/json/index.html#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `json_data` | `str | bytes | bytearray` | The JSON data to validate. | *required* |\n| `strict` | `bool | None` | Whether to enforce types strictly. | `None` |\n| `extra` | `ExtraValues | None` | Whether to ignore, allow, or forbid extra data during model validation. See the [`extra` configuration value](../config/index.html#pydantic.config.ConfigDict.extra) for details. | `None` |\n| `context` | `Any | None` | Extra variables to pass to the validator. | `None` |\n| `by_alias` | `bool | None` | Whether to use the field's alias when validating against the provided input data. | `None` |\n| `by_name` | `bool | None` | Whether to use the field's name when validating against the provided input data. | `None` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `Self` | The validated Pydantic model. |\n\nRaises:\n\n| Type | Description |\n| --- | --- |\n| `ValidationError` | If `json_data` is not a JSON string or the object could not be validated. |\n\nSource code in `pydantic/main.py`\n\n|  |  |\n| --- | --- |\n| ``` 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 ``` | ``` @classmethod def model_validate_json(     cls,     json_data: str | bytes | bytearray,     *,     strict: bool | None = None,     extra: ExtraValues | None = None,     context: Any | None = None,     by_alias: bool | None = None,     by_name: bool | None = None, ) -> Self:     \"\"\"!!! abstract \"Usage Documentation\"         [JSON Parsing](../concepts/json.md#json-parsing)      Validate the given JSON data against the Pydantic model.      Args:         json_data: The JSON data to validate.         strict: Whether to enforce types strictly.         extra: Whether to ignore, allow, or forbid extra data during model validation.             See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.         context: Extra variables to pass to the validator.         by_alias: Whether to use the field's alias when validating against the provided input data.         by_name: Whether to use the field's name when validating against the provided input data.      Returns:         The validated Pydantic model.      Raises:         ValidationError: If `json_data` is not a JSON string or the object could not be validated.     \"\"\"     # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks     __tracebackhide__ = True      if by_alias is False and by_name is not True:         raise PydanticUserError(             'At least one of `by_alias` or `by_name` must be set to True.',             code='validate-by-alias-and-name-false',         )      return cls.__pydantic_validator__.validate_json(         json_data, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/base_model/index.html#modelvalidatejson-classmethod-indexhtmlpydanticbasemodelmodelvalidatejson-permanent-link", "page": "api/base_model/index.html", "source_site": "pydantic"}
{"title": "model\\_validate\\_strings `classmethod` [Â¶](index.html#pydantic.BaseModel.model_validate_strings \"Permanent link\")", "anchor": "modelvalidatestrings-classmethod-indexhtmlpydanticbasemodelmodelvalidatestrings-permanent-link", "md_text": "```\nmodel_validate_strings(\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None\n) -> Self\n```\n\nValidate the given object with string data against the Pydantic model.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `obj` | `Any` | The object containing string data to validate. | *required* |\n| `strict` | `bool | None` | Whether to enforce types strictly. | `None` |\n| `extra` | `ExtraValues | None` | Whether to ignore, allow, or forbid extra data during model validation. See the [`extra` configuration value](../config/index.html#pydantic.config.ConfigDict.extra) for details. | `None` |\n| `context` | `Any | None` | Extra variables to pass to the validator. | `None` |\n| `by_alias` | `bool | None` | Whether to use the field's alias when validating against the provided input data. | `None` |\n| `by_name` | `bool | None` | Whether to use the field's name when validating against the provided input data. | `None` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `Self` | The validated Pydantic model. |\n\nSource code in `pydantic/main.py`\n\n|  |  |\n| --- | --- |\n| ``` 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 ``` | ``` @classmethod def model_validate_strings(     cls,     obj: Any,     *,     strict: bool | None = None,     extra: ExtraValues | None = None,     context: Any | None = None,     by_alias: bool | None = None,     by_name: bool | None = None, ) -> Self:     \"\"\"Validate the given object with string data against the Pydantic model.      Args:         obj: The object containing string data to validate.         strict: Whether to enforce types strictly.         extra: Whether to ignore, allow, or forbid extra data during model validation.             See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.         context: Extra variables to pass to the validator.         by_alias: Whether to use the field's alias when validating against the provided input data.         by_name: Whether to use the field's name when validating against the provided input data.      Returns:         The validated Pydantic model.     \"\"\"     # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks     __tracebackhide__ = True      if by_alias is False and by_name is not True:         raise PydanticUserError(             'At least one of `by_alias` or `by_name` must be set to True.',             code='validate-by-alias-and-name-false',         )      return cls.__pydantic_validator__.validate_strings(         obj, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/base_model/index.html#modelvalidatestrings-classmethod-indexhtmlpydanticbasemodelmodelvalidatestrings-permanent-link", "page": "api/base_model/index.html", "source_site": "pydantic"}
{"title": "pydantic.create\\_model [Â¶](index.html#pydantic.create_model \"Permanent link\")", "anchor": "pydanticcreatemodel-indexhtmlpydanticcreatemodel-permanent-link", "md_text": "```\ncreate_model(\n    model_name: str,\n    /,\n    *,\n    __config__: ConfigDict | None = None,\n    __doc__: str | None = None,\n    __base__: None = None,\n    __module__: str = __name__,\n    __validators__: (\n        dict[str, Callable[..., Any]] | None\n    ) = None,\n    __cls_kwargs__: dict[str, Any] | None = None,\n    __qualname__: str | None = None,\n    **field_definitions: Any | tuple[str, Any],\n) -> type[BaseModel]\n\ncreate_model(\n    model_name: str,\n    /,\n    *,\n    __config__: ConfigDict | None = None,\n    __doc__: str | None = None,\n    __base__: type[ModelT] | tuple[type[ModelT], ...],\n    __module__: str = __name__,\n    __validators__: (\n        dict[str, Callable[..., Any]] | None\n    ) = None,\n    __cls_kwargs__: dict[str, Any] | None = None,\n    __qualname__: str | None = None,\n    **field_definitions: Any | tuple[str, Any],\n) -> type[ModelT]\n\ncreate_model(\n    model_name: str,\n    /,\n    *,\n    __config__: ConfigDict | None = None,\n    __doc__: str | None = None,\n    __base__: (\n        type[ModelT] | tuple[type[ModelT], ...] | None\n    ) = None,\n    __module__: str | None = None,\n    __validators__: (\n        dict[str, Callable[..., Any]] | None\n    ) = None,\n    __cls_kwargs__: dict[str, Any] | None = None,\n    __qualname__: str | None = None,\n    **field_definitions: Any | tuple[str, Any],\n) -> type[ModelT]\n```\n\n[Dynamic Model Creation](../../concepts/models/index.html#dynamic-model-creation)\n\nDynamically creates and returns a new Pydantic model, in other words, `create_model` dynamically creates a\nsubclass of [`BaseModel`](index.html#pydantic.BaseModel).\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `model_name` | `str` | The name of the newly created model. | *required* |\n| `__config__` | `ConfigDict | None` | The configuration of the new model. | `None` |\n| `__doc__` | `str | None` | The docstring of the new model. | `None` |\n| `__base__` | `type[ModelT] | tuple[type[ModelT], ...] | None` | The base class or classes for the new model. | `None` |\n| `__module__` | `str | None` | The name of the module that the model belongs to; if `None`, the value is taken from `sys._getframe(1)` | `None` |\n| `__validators__` | `dict[str, Callable[..., Any]] | None` | A dictionary of methods that validate fields. The keys are the names of the validation methods to be added to the model, and the values are the validation methods themselves. You can read more about functional validators [here](https://docs.pydantic.dev/2.9/concepts/validators/#field-validators). | `None` |\n| `__cls_kwargs__` | `dict[str, Any] | None` | A dictionary of keyword arguments for class creation, such as `metaclass`. | `None` |\n| `__qualname__` | `str | None` | The qualified name of the newly created model. | `None` |\n| `**field_definitions` | `Any | tuple[str, Any]` | Field definitions of the new model. Either:   * a single element, representing the type annotation of the field. * a two-tuple, the first element being the type and the second element the assigned value   (either a default or the [`Field()`](../fields/index.html#pydantic.fields.Field) function). | `{}` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `type[ModelT]` | The new [model](index.html#pydantic.BaseModel). |\n\nRaises:\n\n| Type | Description |\n| --- | --- |\n| `PydanticUserError` | If `__base__` and `__config__` are both passed. |\n\nSource code in `pydantic/main.py`", "url": "https://docs.pydantic.dev/latest/api/base_model/index.html#pydanticcreatemodel-indexhtmlpydanticcreatemodel-permanent-link", "page": "api/base_model/index.html", "source_site": "pydantic"}
{"title": "pydantic.create\\_model [Â¶](index.html#pydantic.create_model \"Permanent link\")", "anchor": "pydanticcreatemodel-indexhtmlpydanticcreatemodel-permanent-link", "md_text": "|  |  |\n| --- | --- |\n| ``` 1716 1717 1718 1719 1720 1721 1722 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1738 1739 1740 1741 1742 1743 1744 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763 1764 1765 1766 1767 1768 1769 1770 1771 1772 1773 1774 1775 1776 1777 1778 1779 1780 1781 1782 1783 1784 1785 1786 1787 1788 1789 1790 1791 1792 1793 1794 1795 1796 1797 1798 1799 1800 1801 1802 1803 1804 1805 1806 1807 1808 1809 1810 1811 ``` | ``` def create_model(  # noqa: C901     model_name: str,     /,     *,     __config__: ConfigDict | None = None,     __doc__: str | None = None,     __base__: type[ModelT] | tuple[type[ModelT], ...] | None = None,     __module__: str | None = None,     __validators__: dict[str, Callable[..., Any]] | None = None,     __cls_kwargs__: dict[str, Any] | None = None,     __qualname__: str | None = None,     # TODO PEP 747: replace `Any` by the TypeForm:     **field_definitions: Any | tuple[str, Any], ) -> type[ModelT]:     \"\"\"!!! abstract \"Usage Documentation\"         [Dynamic Model Creation](../concepts/models.md#dynamic-model-creation)      Dynamically creates and returns a new Pydantic model, in other words, `create_model` dynamically creates a     subclass of [`BaseModel`][pydantic.BaseModel].      Args:         model_name: The name of the newly created model.         __config__: The configuration of the new model.         __doc__: The docstring of the new model.         __base__: The base class or classes for the new model.         __module__: The name of the module that the model belongs to;             if `None`, the value is taken from `sys._getframe(1)`         __validators__: A dictionary of methods that validate fields. The keys are the names of the validation methods to             be added to the model, and the values are the validation methods themselves. You can read more about functional             validators [here](https://docs.pydantic.dev/2.9/concepts/validators/#field-validators).         __cls_kwargs__: A dictionary of keyword arguments for class creation, such as `metaclass`.         __qualname__: The qualified name of the newly created model.         **field_definitions: Field definitions of the new model. Either:              - a single element, representing the type annotation of the field.             - a two-tuple, the first element being the type and the second element the assigned value               (either a default or the [`Field()`][pydantic.Field] function).      Returns:         The new [model][pydantic.BaseModel].      Raises:         PydanticUserError: If `__base__` and `__config__` are both passed.     \"\"\"     if __base__ is None:         __base__ = (cast('type[ModelT]', BaseModel),)     elif not isinstance(__base__, tuple):         __base__ = (__base__,)      __cls_kwargs__ = __cls_kwargs__ or {}      fields: dict[str, Any] = {}     annotations: dict[str, Any] = {}      for f_name, f_def in field_definitions.items():         if isinstance(f_def, tuple):             if len(f_def) != 2:                 raise PydanticUserError(                     f'Field definition for {f_name!r} should a single element representing the type or a two-tuple, the first element '                     'being the type and the second element the assigned value (either a default or the `Field()` function).',                     code='create-model-field-definitions',                 )              annotations[f_name] = f_def[0]             fields[f_name] = f_def[1]         else:             annotations[f_name] = f_def      if __module__ is None:         f = sys._getframe(1)         __module__ = f.f_globals['__name__']      namespace: dict[str, Any] = {'__annotations__': annotations, '__module__': __module__}     if __doc__:         namespace['__doc__'] = __doc__     if __qualname__ is not None:         namespace['__qualname__'] = __qualname__     if __validators__:         namespace.update(__validators__)     namespace.update(fields)     if __config__:         namespace['model_config'] = __config__     resolved_bases = types.resolve_bases(__base__)     meta, ns, kwds = types.prepare_class(model_name, resolved_bases, kwds=__cls_kwargs__)     if resolved_bases is not __base__:         ns['__orig_bases__'] = __base__     namespace.update(ns)      return meta(         model_name,         resolved_bases,         namespace,         __pydantic_reset_parent_namespace__=False,         _create_model_module=__module__,         **kwds,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/base_model/index.html#pydanticcreatemodel-indexhtmlpydanticcreatemodel-permanent-link", "page": "api/base_model/index.html", "source_site": "pydantic"}
{"title": "pydantic.create\\_model [Â¶](index.html#pydantic.create_model \"Permanent link\")", "anchor": "pydanticcreatemodel-indexhtmlpydanticcreatemodel-permanent-link", "md_text": "Was this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/api/base_model/index.html#pydanticcreatemodel-indexhtmlpydanticcreatemodel-permanent-link", "page": "api/base_model/index.html", "source_site": "pydantic"}
{"title": "DateTime [Â¶](index.html#pydantic_extra_types.pendulum_dt.DateTime \"Permanent link\")", "anchor": "datetime-indexhtmlpydanticextratypespendulumdtdatetime-permanent-link", "md_text": "Bases: `DateTime`\n\nA `pendulum.DateTime` object. At runtime, this type decomposes into pendulum.DateTime automatically.\nThis type exists because Pydantic throws a fit on unknown types.\n\n```\nfrom pydantic import BaseModel\nfrom pydantic_extra_types.pendulum_dt import DateTime\n\n\nclass test_model(BaseModel):\n    dt: DateTime\n\n\nprint(test_model(dt='2021-01-01T00:00:00+00:00'))\n\n# > test_model(dt=DateTime(2021, 1, 1, 0, 0, 0, tzinfo=FixedTimezone(0, name=\"+00:00\")))\n```", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_pendulum_dt/index.html#datetime-indexhtmlpydanticextratypespendulumdtdatetime-permanent-link", "page": "api/pydantic_extra_types_pendulum_dt/index.html", "source_site": "pydantic"}
{"title": "Time [Â¶](index.html#pydantic_extra_types.pendulum_dt.Time \"Permanent link\")", "anchor": "time-indexhtmlpydanticextratypespendulumdttime-permanent-link", "md_text": "Bases: `Time`\n\nA `pendulum.Time` object. At runtime, this type decomposes into pendulum.Time automatically.\nThis type exists because Pydantic throws a fit on unknown types.\n\n```\nfrom pydantic import BaseModel\nfrom pydantic_extra_types.pendulum_dt import Time\n\n\nclass test_model(BaseModel):\n    dt: Time\n\n\nprint(test_model(dt='00:00:00'))\n\n# > test_model(dt=Time(0, 0, 0))\n```", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_pendulum_dt/index.html#time-indexhtmlpydanticextratypespendulumdttime-permanent-link", "page": "api/pydantic_extra_types_pendulum_dt/index.html", "source_site": "pydantic"}
{"title": "Date [Â¶](index.html#pydantic_extra_types.pendulum_dt.Date \"Permanent link\")", "anchor": "date-indexhtmlpydanticextratypespendulumdtdate-permanent-link", "md_text": "Bases: `Date`\n\nA `pendulum.Date` object. At runtime, this type decomposes into pendulum.Date automatically.\nThis type exists because Pydantic throws a fit on unknown types.\n\n```\nfrom pydantic import BaseModel\nfrom pydantic_extra_types.pendulum_dt import Date\n\n\nclass test_model(BaseModel):\n    dt: Date\n\n\nprint(test_model(dt='2021-01-01'))\n\n# > test_model(dt=Date(2021, 1, 1))\n```", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_pendulum_dt/index.html#date-indexhtmlpydanticextratypespendulumdtdate-permanent-link", "page": "api/pydantic_extra_types_pendulum_dt/index.html", "source_site": "pydantic"}
{"title": "Duration [Â¶](index.html#pydantic_extra_types.pendulum_dt.Duration \"Permanent link\")", "anchor": "duration-indexhtmlpydanticextratypespendulumdtduration-permanent-link", "md_text": "Bases: `Duration`\n\nA `pendulum.Duration` object. At runtime, this type decomposes into pendulum.Duration automatically.\nThis type exists because Pydantic throws a fit on unknown types.\n\n```\nfrom pydantic import BaseModel\nfrom pydantic_extra_types.pendulum_dt import Duration\n\n\nclass test_model(BaseModel):\n    delta_t: Duration\n\n\nprint(test_model(delta_t='P1DT25H'))\n\n# > test_model(delta_t=Duration(days=2, hours=1))\n```", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_pendulum_dt/index.html#duration-indexhtmlpydanticextratypespendulumdtduration-permanent-link", "page": "api/pydantic_extra_types_pendulum_dt/index.html", "source_site": "pydantic"}
{"title": "to\\_iso8601\\_string [Â¶](index.html#pydantic_extra_types.pendulum_dt.Duration.to_iso8601_string \"Permanent link\")", "anchor": "toiso8601string-indexhtmlpydanticextratypespendulumdtdurationtoiso8601string-permanent-link", "md_text": "```\nto_iso8601_string() -> str\n```\n\nConvert a Duration object to an ISO 8601 string.\n\nIn addition to the standard ISO 8601 format, this method also supports the representation of fractions of a second and negative durations.\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `str` | The ISO 8601 string representation of the duration. |\n\nSource code in `pydantic_extra_types/pendulum_dt.py`\n\n|  |  |\n| --- | --- |\n| ``` 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 ``` | ``` def to_iso8601_string(self) -> str:     \"\"\"     Convert a Duration object to an ISO 8601 string.      In addition to the standard ISO 8601 format, this method also supports the representation of fractions of a second and negative durations.      Returns:         The ISO 8601 string representation of the duration.     \"\"\"     # Extracting components from the Duration object     years = self.years     months = self.months     days = self._days     hours = self.hours     minutes = self.minutes     seconds = self.remaining_seconds     milliseconds = self.microseconds // 1000     microseconds = self.microseconds % 1000      # Constructing the ISO 8601 duration string     iso_duration = 'P'     if years or months or days:         if years:             iso_duration += f'{years}Y'         if months:             iso_duration += f'{months}M'         if days:             iso_duration += f'{days}D'      if hours or minutes or seconds or milliseconds or microseconds:         iso_duration += 'T'         if hours:             iso_duration += f'{hours}H'         if minutes:             iso_duration += f'{minutes}M'         if seconds or milliseconds or microseconds:             iso_duration += f'{seconds}'             if milliseconds or microseconds:                 iso_duration += f'.{milliseconds:03d}'             if microseconds:                 iso_duration += f'{microseconds:03d}'             iso_duration += 'S'      # Prefix with '-' if the duration is negative     if self.total_seconds() < 0:         iso_duration = '-' + iso_duration      if iso_duration == 'P':         iso_duration = 'P0D'      return iso_duration ``` |\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_pendulum_dt/index.html#toiso8601string-indexhtmlpydanticextratypespendulumdtdurationtoiso8601string-permanent-link", "page": "api/pydantic_extra_types_pendulum_dt/index.html", "source_site": "pydantic"}
{"title": "MAX\\_EMAIL\\_LENGTH `module-attribute` [Â¶](index.html#pydantic.networks.MAX_EMAIL_LENGTH \"Permanent link\")", "anchor": "maxemaillength-module-attribute-indexhtmlpydanticnetworksmaxemaillength-permanent-link", "md_text": "```\nMAX_EMAIL_LENGTH = 2048\n```\n\nMaximum length for an email.\nA somewhat arbitrary but very generous number compared to what is allowed by most implementations.", "url": "https://docs.pydantic.dev/latest/api/networks/index.html#maxemaillength-module-attribute-indexhtmlpydanticnetworksmaxemaillength-permanent-link", "page": "api/networks/index.html", "source_site": "pydantic"}
{"title": "UrlConstraints `dataclass` [Â¶](index.html#pydantic.networks.UrlConstraints \"Permanent link\")", "anchor": "urlconstraints-dataclass-indexhtmlpydanticnetworksurlconstraints-permanent-link", "md_text": "```\nUrlConstraints(\n    max_length: int | None = None,\n    allowed_schemes: list[str] | None = None,\n    host_required: bool | None = None,\n    default_host: str | None = None,\n    default_port: int | None = None,\n    default_path: str | None = None,\n    preserve_empty_path: bool | None = None,\n)\n```\n\nUrl constraints.\n\nAttributes:\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `max_length` | `int | None` | The maximum length of the url. Defaults to `None`. |\n| `allowed_schemes` | `list[str] | None` | The allowed schemes. Defaults to `None`. |\n| `host_required` | `bool | None` | Whether the host is required. Defaults to `None`. |\n| `default_host` | `str | None` | The default host. Defaults to `None`. |\n| `default_port` | `int | None` | The default port. Defaults to `None`. |\n| `default_path` | `str | None` | The default path. Defaults to `None`. |\n| `preserve_empty_path` | `bool | None` | Whether to preserve empty URL paths. Defaults to `None`. |", "url": "https://docs.pydantic.dev/latest/api/networks/index.html#urlconstraints-dataclass-indexhtmlpydanticnetworksurlconstraints-permanent-link", "page": "api/networks/index.html", "source_site": "pydantic"}
{"title": "defined\\_constraints `property` [Â¶](index.html#pydantic.networks.UrlConstraints.defined_constraints \"Permanent link\")", "anchor": "definedconstraints-property-indexhtmlpydanticnetworksurlconstraintsdefinedconstraints-permanent-link", "md_text": "```\ndefined_constraints: dict[str, Any]\n```\n\nFetch a key / value mapping of constraints to values that are not None. Used for core schema updates.", "url": "https://docs.pydantic.dev/latest/api/networks/index.html#definedconstraints-property-indexhtmlpydanticnetworksurlconstraintsdefinedconstraints-permanent-link", "page": "api/networks/index.html", "source_site": "pydantic"}
{"title": "AnyUrl [Â¶](index.html#pydantic.networks.AnyUrl \"Permanent link\")", "anchor": "anyurl-indexhtmlpydanticnetworksanyurl-permanent-link", "md_text": "```\nAnyUrl(url: str | Url | _BaseUrl)\n```\n\nBases: `_BaseUrl`\n\nBase type for all URLs.\n\n* Any scheme allowed\n* Top-level domain (TLD) not required\n* Host not required\n\nAssuming an input URL of `http://samuel:[emailÂ protected]:8000/the/path/?query=here#fragment=is;this=bit`,\nthe types export the following properties:\n\n* `scheme`: the URL scheme (`http`), always set.\n* `host`: the URL host (`example.com`).\n* `username`: optional username if included (`samuel`).\n* `password`: optional password if included (`pass`).\n* `port`: optional port (`8000`).\n* `path`: optional path (`/the/path/`).\n* `query`: optional URL query (for example, `GET` arguments or \"search string\", such as `query=here`).\n* `fragment`: optional fragment (`fragment=is;this=bit`).\n\nSource code in `pydantic/networks.py`\n\n|  |  |\n| --- | --- |\n| ``` 130 131 ``` | ``` def __init__(self, url: str | _CoreUrl | _BaseUrl) -> None:     self._url = _build_type_adapter(self.__class__).validate_python(url)._url ``` |", "url": "https://docs.pydantic.dev/latest/api/networks/index.html#anyurl-indexhtmlpydanticnetworksanyurl-permanent-link", "page": "api/networks/index.html", "source_site": "pydantic"}
{"title": "AnyHttpUrl [Â¶](index.html#pydantic.networks.AnyHttpUrl \"Permanent link\")", "anchor": "anyhttpurl-indexhtmlpydanticnetworksanyhttpurl-permanent-link", "md_text": "```\nAnyHttpUrl(url: str | Url | _BaseUrl)\n```\n\nBases: `AnyUrl`\n\nA type that will accept any http or https URL.\n\n* TLD not required\n* Host not required\n\nSource code in `pydantic/networks.py`\n\n|  |  |\n| --- | --- |\n| ``` 130 131 ``` | ``` def __init__(self, url: str | _CoreUrl | _BaseUrl) -> None:     self._url = _build_type_adapter(self.__class__).validate_python(url)._url ``` |", "url": "https://docs.pydantic.dev/latest/api/networks/index.html#anyhttpurl-indexhtmlpydanticnetworksanyhttpurl-permanent-link", "page": "api/networks/index.html", "source_site": "pydantic"}
{"title": "HttpUrl [Â¶](index.html#pydantic.networks.HttpUrl \"Permanent link\")", "anchor": "httpurl-indexhtmlpydanticnetworkshttpurl-permanent-link", "md_text": "```\nHttpUrl(url: str | Url | _BaseUrl)\n```\n\nBases: `AnyUrl`\n\nA type that will accept any http or https URL.\n\n* TLD not required\n* Host not required\n* Max length 2083\n\n```\nfrom pydantic import BaseModel, HttpUrl, ValidationError\n\nclass MyModel(BaseModel):\n    url: HttpUrl\n\nm = MyModel(url='http://www.example.com')  # (1)!\nprint(m.url)\n#> http://www.example.com/\n\ntry:\n    MyModel(url='ftp://invalid.url')\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for MyModel\n    url\n      URL scheme should be 'http' or 'https' [type=url_scheme, input_value='ftp://invalid.url', input_type=str]\n    '''\n\ntry:\n    MyModel(url='not a url')\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for MyModel\n    url\n      Input should be a valid URL, relative URL without a base [type=url_parsing, input_value='not a url', input_type=str]\n    '''\n```\n\n1. Note: mypy would prefer `m = MyModel(url=HttpUrl('http://www.example.com'))`, but Pydantic will convert the string to an HttpUrl instance anyway.\n\n\"International domains\" (e.g. a URL where the host or TLD includes non-ascii characters) will be encoded via\n[punycode](https://en.wikipedia.org/wiki/Punycode) (see\n[this article](https://www.xudongz.com/blog/2017/idn-phishing/) for a good description of why this is important):\n\n```\nfrom pydantic import BaseModel, HttpUrl\n\nclass MyModel(BaseModel):\n    url: HttpUrl\n\nm1 = MyModel(url='http://punyÂ£code.com')\nprint(m1.url)\n#> http://xn--punycode-eja.com/\nm2 = MyModel(url='https://www.Ð°Ñ€Ñ€ÓÐµ.com/')\nprint(m2.url)\n#> https://www.xn--80ak6aa92e.com/\nm3 = MyModel(url='https://www.example.ç å®/')\nprint(m3.url)\n#> https://www.example.xn--pbt977c/\n```\n\nIn Pydantic, underscores are allowed in all parts of a domain except the TLD.\nTechnically this might be wrong - in theory the hostname cannot have underscores, but subdomains can.\n\nTo explain this; consider the following two cases:\n\n* `exam_ple.co.uk`: the hostname is `exam_ple`, which should not be allowed since it contains an underscore.\n* `foo_bar.example.com` the hostname is `example`, which should be allowed since the underscore is in the subdomain.\n\nWithout having an exhaustive list of TLDs, it would be impossible to differentiate between these two. Therefore\nunderscores are allowed, but you can always do further validation in a validator if desired.\n\nAlso, Chrome, Firefox, and Safari all currently accept `http://exam_ple.com` as a URL, so we're in good\n(or at least big) company.\n\nSource code in `pydantic/networks.py`\n\n|  |  |\n| --- | --- |\n| ``` 130 131 ``` | ``` def __init__(self, url: str | _CoreUrl | _BaseUrl) -> None:     self._url = _build_type_adapter(self.__class__).validate_python(url)._url ``` |", "url": "https://docs.pydantic.dev/latest/api/networks/index.html#httpurl-indexhtmlpydanticnetworkshttpurl-permanent-link", "page": "api/networks/index.html", "source_site": "pydantic"}
{"title": "AnyWebsocketUrl [Â¶](index.html#pydantic.networks.AnyWebsocketUrl \"Permanent link\")", "anchor": "anywebsocketurl-indexhtmlpydanticnetworksanywebsocketurl-permanent-link", "md_text": "```\nAnyWebsocketUrl(url: str | Url | _BaseUrl)\n```\n\nBases: `AnyUrl`\n\nA type that will accept any ws or wss URL.\n\n* TLD not required\n* Host not required\n\nSource code in `pydantic/networks.py`\n\n|  |  |\n| --- | --- |\n| ``` 130 131 ``` | ``` def __init__(self, url: str | _CoreUrl | _BaseUrl) -> None:     self._url = _build_type_adapter(self.__class__).validate_python(url)._url ``` |", "url": "https://docs.pydantic.dev/latest/api/networks/index.html#anywebsocketurl-indexhtmlpydanticnetworksanywebsocketurl-permanent-link", "page": "api/networks/index.html", "source_site": "pydantic"}
{"title": "WebsocketUrl [Â¶](index.html#pydantic.networks.WebsocketUrl \"Permanent link\")", "anchor": "websocketurl-indexhtmlpydanticnetworkswebsocketurl-permanent-link", "md_text": "```\nWebsocketUrl(url: str | Url | _BaseUrl)\n```\n\nBases: `AnyUrl`\n\nA type that will accept any ws or wss URL.\n\n* TLD not required\n* Host not required\n* Max length 2083\n\nSource code in `pydantic/networks.py`\n\n|  |  |\n| --- | --- |\n| ``` 130 131 ``` | ``` def __init__(self, url: str | _CoreUrl | _BaseUrl) -> None:     self._url = _build_type_adapter(self.__class__).validate_python(url)._url ``` |", "url": "https://docs.pydantic.dev/latest/api/networks/index.html#websocketurl-indexhtmlpydanticnetworkswebsocketurl-permanent-link", "page": "api/networks/index.html", "source_site": "pydantic"}
{"title": "FileUrl [Â¶](index.html#pydantic.networks.FileUrl \"Permanent link\")", "anchor": "fileurl-indexhtmlpydanticnetworksfileurl-permanent-link", "md_text": "```\nFileUrl(url: str | Url | _BaseUrl)\n```\n\nBases: `AnyUrl`\n\nA type that will accept any file URL.\n\n* Host not required\n\nSource code in `pydantic/networks.py`\n\n|  |  |\n| --- | --- |\n| ``` 130 131 ``` | ``` def __init__(self, url: str | _CoreUrl | _BaseUrl) -> None:     self._url = _build_type_adapter(self.__class__).validate_python(url)._url ``` |", "url": "https://docs.pydantic.dev/latest/api/networks/index.html#fileurl-indexhtmlpydanticnetworksfileurl-permanent-link", "page": "api/networks/index.html", "source_site": "pydantic"}
{"title": "FtpUrl [Â¶](index.html#pydantic.networks.FtpUrl \"Permanent link\")", "anchor": "ftpurl-indexhtmlpydanticnetworksftpurl-permanent-link", "md_text": "```\nFtpUrl(url: str | Url | _BaseUrl)\n```\n\nBases: `AnyUrl`\n\nA type that will accept ftp URL.\n\n* TLD not required\n* Host not required\n\nSource code in `pydantic/networks.py`\n\n|  |  |\n| --- | --- |\n| ``` 130 131 ``` | ``` def __init__(self, url: str | _CoreUrl | _BaseUrl) -> None:     self._url = _build_type_adapter(self.__class__).validate_python(url)._url ``` |", "url": "https://docs.pydantic.dev/latest/api/networks/index.html#ftpurl-indexhtmlpydanticnetworksftpurl-permanent-link", "page": "api/networks/index.html", "source_site": "pydantic"}
{"title": "PostgresDsn [Â¶](index.html#pydantic.networks.PostgresDsn \"Permanent link\")", "anchor": "postgresdsn-indexhtmlpydanticnetworkspostgresdsn-permanent-link", "md_text": "```\nPostgresDsn(url: str | MultiHostUrl | _BaseMultiHostUrl)\n```\n\nBases: `_BaseMultiHostUrl`\n\nA type that will accept any Postgres DSN.\n\n* User info required\n* TLD not required\n* Host required\n* Supports multiple hosts\n\nIf further validation is required, these properties can be used by validators to enforce specific behaviour:\n\n```\nfrom pydantic import (\n    BaseModel,\n    HttpUrl,\n    PostgresDsn,\n    ValidationError,\n    field_validator,\n)\n\nclass MyModel(BaseModel):\n    url: HttpUrl\n\nm = MyModel(url='http://www.example.com')\n\n# the repr() method for a url will display all properties of the url\nprint(repr(m.url))\n#> HttpUrl('http://www.example.com/')\nprint(m.url.scheme)\n#> http\nprint(m.url.host)\n#> www.example.com\nprint(m.url.port)\n#> 80\n\nclass MyDatabaseModel(BaseModel):\n    db: PostgresDsn\n\n    @field_validator('db')\n    def check_db_name(cls, v):\n        assert v.path and len(v.path) > 1, 'database must be provided'\n        return v\n\nm = MyDatabaseModel(db='postgres://user:pass@localhost:5432/foobar')\nprint(m.db)\n#> postgres://user:pass@localhost:5432/foobar\n\ntry:\n    MyDatabaseModel(db='postgres://user:pass@localhost:5432')\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for MyDatabaseModel\n    db\n      Assertion failed, database must be provided\n    assert (None)\n     +  where None = PostgresDsn('postgres://user:pass@localhost:5432').path [type=assertion_error, input_value='postgres://user:pass@localhost:5432', input_type=str]\n    '''\n```\n\nSource code in `pydantic/networks.py`\n\n|  |  |\n| --- | --- |\n| ``` 350 351 ``` | ``` def __init__(self, url: str | _CoreMultiHostUrl | _BaseMultiHostUrl) -> None:     self._url = _build_type_adapter(self.__class__).validate_python(url)._url ``` |", "url": "https://docs.pydantic.dev/latest/api/networks/index.html#postgresdsn-indexhtmlpydanticnetworkspostgresdsn-permanent-link", "page": "api/networks/index.html", "source_site": "pydantic"}
{"title": "host `property` [Â¶](index.html#pydantic.networks.PostgresDsn.host \"Permanent link\")", "anchor": "host-property-indexhtmlpydanticnetworkspostgresdsnhost-permanent-link", "md_text": "```\nhost: str\n```\n\nThe required URL host.", "url": "https://docs.pydantic.dev/latest/api/networks/index.html#host-property-indexhtmlpydanticnetworkspostgresdsnhost-permanent-link", "page": "api/networks/index.html", "source_site": "pydantic"}
{"title": "CockroachDsn [Â¶](index.html#pydantic.networks.CockroachDsn \"Permanent link\")", "anchor": "cockroachdsn-indexhtmlpydanticnetworkscockroachdsn-permanent-link", "md_text": "```\nCockroachDsn(url: str | Url | _BaseUrl)\n```\n\nBases: `AnyUrl`\n\nA type that will accept any Cockroach DSN.\n\n* User info required\n* TLD not required\n* Host required\n\nSource code in `pydantic/networks.py`\n\n|  |  |\n| --- | --- |\n| ``` 130 131 ``` | ``` def __init__(self, url: str | _CoreUrl | _BaseUrl) -> None:     self._url = _build_type_adapter(self.__class__).validate_python(url)._url ``` |", "url": "https://docs.pydantic.dev/latest/api/networks/index.html#cockroachdsn-indexhtmlpydanticnetworkscockroachdsn-permanent-link", "page": "api/networks/index.html", "source_site": "pydantic"}
{"title": "host `property` [Â¶](index.html#pydantic.networks.CockroachDsn.host \"Permanent link\")", "anchor": "host-property-indexhtmlpydanticnetworkscockroachdsnhost-permanent-link", "md_text": "```\nhost: str\n```\n\nThe required URL host.", "url": "https://docs.pydantic.dev/latest/api/networks/index.html#host-property-indexhtmlpydanticnetworkscockroachdsnhost-permanent-link", "page": "api/networks/index.html", "source_site": "pydantic"}
{"title": "AmqpDsn [Â¶](index.html#pydantic.networks.AmqpDsn \"Permanent link\")", "anchor": "amqpdsn-indexhtmlpydanticnetworksamqpdsn-permanent-link", "md_text": "```\nAmqpDsn(url: str | Url | _BaseUrl)\n```\n\nBases: `AnyUrl`\n\nA type that will accept any AMQP DSN.\n\n* User info required\n* TLD not required\n* Host not required\n\nSource code in `pydantic/networks.py`\n\n|  |  |\n| --- | --- |\n| ``` 130 131 ``` | ``` def __init__(self, url: str | _CoreUrl | _BaseUrl) -> None:     self._url = _build_type_adapter(self.__class__).validate_python(url)._url ``` |", "url": "https://docs.pydantic.dev/latest/api/networks/index.html#amqpdsn-indexhtmlpydanticnetworksamqpdsn-permanent-link", "page": "api/networks/index.html", "source_site": "pydantic"}
{"title": "RedisDsn [Â¶](index.html#pydantic.networks.RedisDsn \"Permanent link\")", "anchor": "redisdsn-indexhtmlpydanticnetworksredisdsn-permanent-link", "md_text": "```\nRedisDsn(url: str | Url | _BaseUrl)\n```\n\nBases: `AnyUrl`\n\nA type that will accept any Redis DSN.\n\n* User info required\n* TLD not required\n* Host required (e.g., `rediss://:pass@localhost`)\n\nSource code in `pydantic/networks.py`\n\n|  |  |\n| --- | --- |\n| ``` 130 131 ``` | ``` def __init__(self, url: str | _CoreUrl | _BaseUrl) -> None:     self._url = _build_type_adapter(self.__class__).validate_python(url)._url ``` |", "url": "https://docs.pydantic.dev/latest/api/networks/index.html#redisdsn-indexhtmlpydanticnetworksredisdsn-permanent-link", "page": "api/networks/index.html", "source_site": "pydantic"}
{"title": "host `property` [Â¶](index.html#pydantic.networks.RedisDsn.host \"Permanent link\")", "anchor": "host-property-indexhtmlpydanticnetworksredisdsnhost-permanent-link", "md_text": "```\nhost: str\n```\n\nThe required URL host.", "url": "https://docs.pydantic.dev/latest/api/networks/index.html#host-property-indexhtmlpydanticnetworksredisdsnhost-permanent-link", "page": "api/networks/index.html", "source_site": "pydantic"}
{"title": "MongoDsn [Â¶](index.html#pydantic.networks.MongoDsn \"Permanent link\")", "anchor": "mongodsn-indexhtmlpydanticnetworksmongodsn-permanent-link", "md_text": "```\nMongoDsn(url: str | MultiHostUrl | _BaseMultiHostUrl)\n```\n\nBases: `_BaseMultiHostUrl`\n\nA type that will accept any MongoDB DSN.\n\n* User info not required\n* Database name not required\n* Port not required\n* User info may be passed without user part (e.g., `mongodb://mongodb0.example.com:27017`).\n\nSource code in `pydantic/networks.py`\n\n|  |  |\n| --- | --- |\n| ``` 350 351 ``` | ``` def __init__(self, url: str | _CoreMultiHostUrl | _BaseMultiHostUrl) -> None:     self._url = _build_type_adapter(self.__class__).validate_python(url)._url ``` |", "url": "https://docs.pydantic.dev/latest/api/networks/index.html#mongodsn-indexhtmlpydanticnetworksmongodsn-permanent-link", "page": "api/networks/index.html", "source_site": "pydantic"}
{"title": "KafkaDsn [Â¶](index.html#pydantic.networks.KafkaDsn \"Permanent link\")", "anchor": "kafkadsn-indexhtmlpydanticnetworkskafkadsn-permanent-link", "md_text": "```\nKafkaDsn(url: str | Url | _BaseUrl)\n```\n\nBases: `AnyUrl`\n\nA type that will accept any Kafka DSN.\n\n* User info required\n* TLD not required\n* Host not required\n\nSource code in `pydantic/networks.py`\n\n|  |  |\n| --- | --- |\n| ``` 130 131 ``` | ``` def __init__(self, url: str | _CoreUrl | _BaseUrl) -> None:     self._url = _build_type_adapter(self.__class__).validate_python(url)._url ``` |", "url": "https://docs.pydantic.dev/latest/api/networks/index.html#kafkadsn-indexhtmlpydanticnetworkskafkadsn-permanent-link", "page": "api/networks/index.html", "source_site": "pydantic"}
{"title": "NatsDsn [Â¶](index.html#pydantic.networks.NatsDsn \"Permanent link\")", "anchor": "natsdsn-indexhtmlpydanticnetworksnatsdsn-permanent-link", "md_text": "```\nNatsDsn(url: str | MultiHostUrl | _BaseMultiHostUrl)\n```\n\nBases: `_BaseMultiHostUrl`\n\nA type that will accept any NATS DSN.\n\nNATS is a connective technology built for the ever increasingly hyper-connected world.\nIt is a single technology that enables applications to securely communicate across\nany combination of cloud vendors, on-premise, edge, web and mobile, and devices.\nMore: https://nats.io\n\nSource code in `pydantic/networks.py`\n\n|  |  |\n| --- | --- |\n| ``` 350 351 ``` | ``` def __init__(self, url: str | _CoreMultiHostUrl | _BaseMultiHostUrl) -> None:     self._url = _build_type_adapter(self.__class__).validate_python(url)._url ``` |", "url": "https://docs.pydantic.dev/latest/api/networks/index.html#natsdsn-indexhtmlpydanticnetworksnatsdsn-permanent-link", "page": "api/networks/index.html", "source_site": "pydantic"}
{"title": "MySQLDsn [Â¶](index.html#pydantic.networks.MySQLDsn \"Permanent link\")", "anchor": "mysqldsn-indexhtmlpydanticnetworksmysqldsn-permanent-link", "md_text": "```\nMySQLDsn(url: str | Url | _BaseUrl)\n```\n\nBases: `AnyUrl`\n\nA type that will accept any MySQL DSN.\n\n* User info required\n* TLD not required\n* Host not required\n\nSource code in `pydantic/networks.py`\n\n|  |  |\n| --- | --- |\n| ``` 130 131 ``` | ``` def __init__(self, url: str | _CoreUrl | _BaseUrl) -> None:     self._url = _build_type_adapter(self.__class__).validate_python(url)._url ``` |", "url": "https://docs.pydantic.dev/latest/api/networks/index.html#mysqldsn-indexhtmlpydanticnetworksmysqldsn-permanent-link", "page": "api/networks/index.html", "source_site": "pydantic"}
{"title": "MariaDBDsn [Â¶](index.html#pydantic.networks.MariaDBDsn \"Permanent link\")", "anchor": "mariadbdsn-indexhtmlpydanticnetworksmariadbdsn-permanent-link", "md_text": "```\nMariaDBDsn(url: str | Url | _BaseUrl)\n```\n\nBases: `AnyUrl`\n\nA type that will accept any MariaDB DSN.\n\n* User info required\n* TLD not required\n* Host not required\n\nSource code in `pydantic/networks.py`\n\n|  |  |\n| --- | --- |\n| ``` 130 131 ``` | ``` def __init__(self, url: str | _CoreUrl | _BaseUrl) -> None:     self._url = _build_type_adapter(self.__class__).validate_python(url)._url ``` |", "url": "https://docs.pydantic.dev/latest/api/networks/index.html#mariadbdsn-indexhtmlpydanticnetworksmariadbdsn-permanent-link", "page": "api/networks/index.html", "source_site": "pydantic"}
{"title": "ClickHouseDsn [Â¶](index.html#pydantic.networks.ClickHouseDsn \"Permanent link\")", "anchor": "clickhousedsn-indexhtmlpydanticnetworksclickhousedsn-permanent-link", "md_text": "```\nClickHouseDsn(url: str | Url | _BaseUrl)\n```\n\nBases: `AnyUrl`\n\nA type that will accept any ClickHouse DSN.\n\n* User info required\n* TLD not required\n* Host not required\n\nSource code in `pydantic/networks.py`\n\n|  |  |\n| --- | --- |\n| ``` 130 131 ``` | ``` def __init__(self, url: str | _CoreUrl | _BaseUrl) -> None:     self._url = _build_type_adapter(self.__class__).validate_python(url)._url ``` |", "url": "https://docs.pydantic.dev/latest/api/networks/index.html#clickhousedsn-indexhtmlpydanticnetworksclickhousedsn-permanent-link", "page": "api/networks/index.html", "source_site": "pydantic"}
{"title": "SnowflakeDsn [Â¶](index.html#pydantic.networks.SnowflakeDsn \"Permanent link\")", "anchor": "snowflakedsn-indexhtmlpydanticnetworkssnowflakedsn-permanent-link", "md_text": "```\nSnowflakeDsn(url: str | Url | _BaseUrl)\n```\n\nBases: `AnyUrl`\n\nA type that will accept any Snowflake DSN.\n\n* User info required\n* TLD not required\n* Host required\n\nSource code in `pydantic/networks.py`\n\n|  |  |\n| --- | --- |\n| ``` 130 131 ``` | ``` def __init__(self, url: str | _CoreUrl | _BaseUrl) -> None:     self._url = _build_type_adapter(self.__class__).validate_python(url)._url ``` |", "url": "https://docs.pydantic.dev/latest/api/networks/index.html#snowflakedsn-indexhtmlpydanticnetworkssnowflakedsn-permanent-link", "page": "api/networks/index.html", "source_site": "pydantic"}
{"title": "host `property` [Â¶](index.html#pydantic.networks.SnowflakeDsn.host \"Permanent link\")", "anchor": "host-property-indexhtmlpydanticnetworkssnowflakedsnhost-permanent-link", "md_text": "```\nhost: str\n```\n\nThe required URL host.", "url": "https://docs.pydantic.dev/latest/api/networks/index.html#host-property-indexhtmlpydanticnetworkssnowflakedsnhost-permanent-link", "page": "api/networks/index.html", "source_site": "pydantic"}
{"title": "EmailStr [Â¶](index.html#pydantic.networks.EmailStr \"Permanent link\")", "anchor": "emailstr-indexhtmlpydanticnetworksemailstr-permanent-link", "md_text": "Info\n\nTo use this type, you need to install the optional\n[`email-validator`](https://github.com/JoshData/python-email-validator) package:\n\n```\npip install email-validator\n```\n\nValidate email addresses.\n\n```\nfrom pydantic import BaseModel, EmailStr\n\nclass Model(BaseModel):\n    email: EmailStr\n\nprint(Model(email='[emailÂ protected]'))\n#> email='[emailÂ protected]'\n```", "url": "https://docs.pydantic.dev/latest/api/networks/index.html#emailstr-indexhtmlpydanticnetworksemailstr-permanent-link", "page": "api/networks/index.html", "source_site": "pydantic"}
{"title": "NameEmail [Â¶](index.html#pydantic.networks.NameEmail \"Permanent link\")", "anchor": "nameemail-indexhtmlpydanticnetworksnameemail-permanent-link", "md_text": "```\nNameEmail(name: str, email: str)\n```\n\nBases: `Representation`\n\nInfo\n\nTo use this type, you need to install the optional\n[`email-validator`](https://github.com/JoshData/python-email-validator) package:\n\n```\npip install email-validator\n```\n\nValidate a name and email address combination, as specified by\n[RFC 5322](https://datatracker.ietf.org/doc/html/rfc5322#section-3.4).\n\nThe `NameEmail` has two properties: `name` and `email`.\nIn case the `name` is not provided, it's inferred from the email address.\n\n```\nfrom pydantic import BaseModel, NameEmail\n\nclass User(BaseModel):\n    email: NameEmail\n\nuser = User(email='Fred Bloggs <[emailÂ protected]>')\nprint(user.email)\n#> Fred Bloggs <[emailÂ protected]>\nprint(user.email.name)\n#> Fred Bloggs\n\nuser = User(email='[emailÂ protected]')\nprint(user.email)\n#> fred.bloggs <[emailÂ protected]>\nprint(user.email.name)\n#> fred.bloggs\n```\n\nSource code in `pydantic/networks.py`\n\n|  |  |\n| --- | --- |\n| ``` 1043 1044 1045 ``` | ``` def __init__(self, name: str, email: str):     self.name = name     self.email = email ``` |", "url": "https://docs.pydantic.dev/latest/api/networks/index.html#nameemail-indexhtmlpydanticnetworksnameemail-permanent-link", "page": "api/networks/index.html", "source_site": "pydantic"}
{"title": "IPvAnyAddress [Â¶](index.html#pydantic.networks.IPvAnyAddress \"Permanent link\")", "anchor": "ipvanyaddress-indexhtmlpydanticnetworksipvanyaddress-permanent-link", "md_text": "Validate an IPv4 or IPv6 address.\n\n```\nfrom pydantic import BaseModel\nfrom pydantic.networks import IPvAnyAddress\n\nclass IpModel(BaseModel):\n    ip: IPvAnyAddress\n\nprint(IpModel(ip='127.0.0.1'))\n#> ip=IPv4Address('127.0.0.1')\n\ntry:\n    IpModel(ip='http://www.example.com')\nexcept ValueError as e:\n    print(e.errors())\n    '''\n    [\n        {\n            'type': 'ip_any_address',\n            'loc': ('ip',),\n            'msg': 'value is not a valid IPv4 or IPv6 address',\n            'input': 'http://www.example.com',\n        }\n    ]\n    '''\n```", "url": "https://docs.pydantic.dev/latest/api/networks/index.html#ipvanyaddress-indexhtmlpydanticnetworksipvanyaddress-permanent-link", "page": "api/networks/index.html", "source_site": "pydantic"}
{"title": "IPvAnyInterface [Â¶](index.html#pydantic.networks.IPvAnyInterface \"Permanent link\")", "anchor": "ipvanyinterface-indexhtmlpydanticnetworksipvanyinterface-permanent-link", "md_text": "Validate an IPv4 or IPv6 interface.", "url": "https://docs.pydantic.dev/latest/api/networks/index.html#ipvanyinterface-indexhtmlpydanticnetworksipvanyinterface-permanent-link", "page": "api/networks/index.html", "source_site": "pydantic"}
{"title": "IPvAnyNetwork [Â¶](index.html#pydantic.networks.IPvAnyNetwork \"Permanent link\")", "anchor": "ipvanynetwork-indexhtmlpydanticnetworksipvanynetwork-permanent-link", "md_text": "Validate an IPv4 or IPv6 network.", "url": "https://docs.pydantic.dev/latest/api/networks/index.html#ipvanynetwork-indexhtmlpydanticnetworksipvanynetwork-permanent-link", "page": "api/networks/index.html", "source_site": "pydantic"}
{"title": "validate\\_email [Â¶](index.html#pydantic.networks.validate_email \"Permanent link\")", "anchor": "validateemail-indexhtmlpydanticnetworksvalidateemail-permanent-link", "md_text": "```\nvalidate_email(value: str) -> tuple[str, str]\n```\n\nEmail address validation using [email-validator](https://pypi.org/project/email-validator/).\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `tuple[str, str]` | A tuple containing the local part of the email (or the name for \"pretty\" email addresses) and the normalized email. |\n\nRaises:\n\n| Type | Description |\n| --- | --- |\n| `PydanticCustomError` | If the email is invalid. |\n\nNote\n\nNote that:\n\n* Raw IP address (literal) domain parts are not allowed.\n* `\"John Doe <[emailÂ protected]>\"` style \"pretty\" email addresses are processed.\n* Spaces are striped from the beginning and end of addresses, but no error is raised.\n\nSource code in `pydantic/networks.py`\n\n|  |  |\n| --- | --- |\n| ``` 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 ``` | ``` def validate_email(value: str) -> tuple[str, str]:     \"\"\"Email address validation using [email-validator](https://pypi.org/project/email-validator/).      Returns:         A tuple containing the local part of the email (or the name for \"pretty\" email addresses)             and the normalized email.      Raises:         PydanticCustomError: If the email is invalid.      Note:         Note that:          * Raw IP address (literal) domain parts are not allowed.         * `\"John Doe <[emailÂ protected]>\"` style \"pretty\" email addresses are processed.         * Spaces are striped from the beginning and end of addresses, but no error is raised.     \"\"\"     if email_validator is None:         import_email_validator()      if len(value) > MAX_EMAIL_LENGTH:         raise PydanticCustomError(             'value_error',             'value is not a valid email address: {reason}',             {'reason': f'Length must not exceed {MAX_EMAIL_LENGTH} characters'},         )      m = pretty_email_regex.fullmatch(value)     name: str | None = None     if m:         unquoted_name, quoted_name, value = m.groups()         name = unquoted_name or quoted_name      email = value.strip()      try:         parts = email_validator.validate_email(email, check_deliverability=False)     except email_validator.EmailNotValidError as e:         raise PydanticCustomError(             'value_error', 'value is not a valid email address: {reason}', {'reason': str(e.args[0])}         ) from e      email = parts.normalized     assert email is not None     name = name or parts.local_part     return name, email ``` |\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/api/networks/index.html#validateemail-indexhtmlpydanticnetworksvalidateemail-permanent-link", "page": "api/networks/index.html", "source_site": "pydantic"}
{"title": "dataclass [Â¶](index.html#pydantic.dataclasses.dataclass \"Permanent link\")", "anchor": "dataclass-indexhtmlpydanticdataclassesdataclass-permanent-link", "md_text": "```\ndataclass(\n    *,\n    init: Literal[False] = False,\n    repr: bool = True,\n    eq: bool = True,\n    order: bool = False,\n    unsafe_hash: bool = False,\n    frozen: bool = False,\n    config: ConfigDict | type[object] | None = None,\n    validate_on_init: bool | None = None,\n    kw_only: bool = ...,\n    slots: bool = ...\n) -> Callable[[type[_T]], type[PydanticDataclass]]\n\ndataclass(\n    _cls: type[_T],\n    *,\n    init: Literal[False] = False,\n    repr: bool = True,\n    eq: bool = True,\n    order: bool = False,\n    unsafe_hash: bool = False,\n    frozen: bool | None = None,\n    config: ConfigDict | type[object] | None = None,\n    validate_on_init: bool | None = None,\n    kw_only: bool = ...,\n    slots: bool = ...\n) -> type[PydanticDataclass]\n\ndataclass(\n    *,\n    init: Literal[False] = False,\n    repr: bool = True,\n    eq: bool = True,\n    order: bool = False,\n    unsafe_hash: bool = False,\n    frozen: bool | None = None,\n    config: ConfigDict | type[object] | None = None,\n    validate_on_init: bool | None = None\n) -> Callable[[type[_T]], type[PydanticDataclass]]\n\ndataclass(\n    _cls: type[_T],\n    *,\n    init: Literal[False] = False,\n    repr: bool = True,\n    eq: bool = True,\n    order: bool = False,\n    unsafe_hash: bool = False,\n    frozen: bool | None = None,\n    config: ConfigDict | type[object] | None = None,\n    validate_on_init: bool | None = None\n) -> type[PydanticDataclass]\n\ndataclass(\n    _cls: type[_T] | None = None,\n    *,\n    init: Literal[False] = False,\n    repr: bool = True,\n    eq: bool = True,\n    order: bool = False,\n    unsafe_hash: bool = False,\n    frozen: bool | None = None,\n    config: ConfigDict | type[object] | None = None,\n    validate_on_init: bool | None = None,\n    kw_only: bool = False,\n    slots: bool = False\n) -> (\n    Callable[[type[_T]], type[PydanticDataclass]]\n    | type[PydanticDataclass]\n)\n```\n\n[`dataclasses`](../../concepts/dataclasses/index.html)\n\nA decorator used to create a Pydantic-enhanced dataclass, similar to the standard Python `dataclass`,\nbut with added validation.\n\nThis function should be used similarly to `dataclasses.dataclass`.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `_cls` | `type[_T] | None` | The target `dataclass`. | `None` |\n| `init` | `Literal[False]` | Included for signature compatibility with `dataclasses.dataclass`, and is passed through to `dataclasses.dataclass` when appropriate. If specified, must be set to `False`, as pydantic inserts its own `__init__` function. | `False` |\n| `repr` | `bool` | A boolean indicating whether to include the field in the `__repr__` output. | `True` |\n| `eq` | `bool` | Determines if a `__eq__` method should be generated for the class. | `True` |\n| `order` | `bool` | Determines if comparison magic methods should be generated, such as `__lt__`, but not `__eq__`. | `False` |\n| `unsafe_hash` | `bool` | Determines if a `__hash__` method should be included in the class, as in `dataclasses.dataclass`. | `False` |\n| `frozen` | `bool | None` | Determines if the generated class should be a 'frozen' `dataclass`, which does not allow its attributes to be modified after it has been initialized. If not set, the value from the provided `config` argument will be used (and will default to `False` otherwise). | `None` |\n| `config` | `ConfigDict | type[object] | None` | The Pydantic config to use for the `dataclass`. | `None` |\n| `validate_on_init` | `bool | None` | A deprecated parameter included for backwards compatibility; in V2, all Pydantic dataclasses are validated on init. | `None` |\n| `kw_only` | `bool` | Determines if `__init__` method parameters must be specified by keyword only. Defaults to `False`. | `False` |\n| `slots` | `bool` | Determines if the generated class should be a 'slots' `dataclass`, which does not allow the addition of new attributes after instantiation. | `False` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `Callable[[type[_T]], type[PydanticDataclass]] | type[PydanticDataclass]` | A decorator that accepts a class as its argument and returns a Pydantic `dataclass`. |\n\nRaises:\n\n| Type | Description |\n| --- | --- |\n| `AssertionError` | Raised if `init` is not `False` or `validate_on_init` is `False`. |\n\nSource code in `pydantic/dataclasses.py`", "url": "https://docs.pydantic.dev/latest/api/dataclasses/index.html#dataclass-indexhtmlpydanticdataclassesdataclass-permanent-link", "page": "api/dataclasses/index.html", "source_site": "pydantic"}
{"title": "dataclass [Â¶](index.html#pydantic.dataclasses.dataclass \"Permanent link\")", "anchor": "dataclass-indexhtmlpydanticdataclassesdataclass-permanent-link", "md_text": "|  |  |\n| --- | --- |\n| ```  98  99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 ``` | ``` @dataclass_transform(field_specifiers=(dataclasses.field, Field, PrivateAttr)) def dataclass(     _cls: type[_T] | None = None,     *,     init: Literal[False] = False,     repr: bool = True,     eq: bool = True,     order: bool = False,     unsafe_hash: bool = False,     frozen: bool | None = None,     config: ConfigDict | type[object] | None = None,     validate_on_init: bool | None = None,     kw_only: bool = False,     slots: bool = False, ) -> Callable[[type[_T]], type[PydanticDataclass]] | type[PydanticDataclass]:     \"\"\"!!! abstract \"Usage Documentation\"         [`dataclasses`](../concepts/dataclasses.md)      A decorator used to create a Pydantic-enhanced dataclass, similar to the standard Python `dataclass`,     but with added validation.      This function should be used similarly to `dataclasses.dataclass`.      Args:         _cls: The target `dataclass`.         init: Included for signature compatibility with `dataclasses.dataclass`, and is passed through to             `dataclasses.dataclass` when appropriate. If specified, must be set to `False`, as pydantic inserts its             own  `__init__` function.         repr: A boolean indicating whether to include the field in the `__repr__` output.         eq: Determines if a `__eq__` method should be generated for the class.         order: Determines if comparison magic methods should be generated, such as `__lt__`, but not `__eq__`.         unsafe_hash: Determines if a `__hash__` method should be included in the class, as in `dataclasses.dataclass`.         frozen: Determines if the generated class should be a 'frozen' `dataclass`, which does not allow its             attributes to be modified after it has been initialized. If not set, the value from the provided `config` argument will be used (and will default to `False` otherwise).         config: The Pydantic config to use for the `dataclass`.         validate_on_init: A deprecated parameter included for backwards compatibility; in V2, all Pydantic dataclasses             are validated on init.         kw_only: Determines if `__init__` method parameters must be specified by keyword only. Defaults to `False`.         slots: Determines if the generated class should be a 'slots' `dataclass`, which does not allow the addition of             new attributes after instantiation.      Returns:         A decorator that accepts a class as its argument and returns a Pydantic `dataclass`.      Raises:         AssertionError: Raised if `init` is not `False` or `validate_on_init` is `False`.     \"\"\"     assert init is False, 'pydantic.dataclasses.dataclass only supports init=False'     assert validate_on_init is not False, 'validate_on_init=False is no longer supported'      if sys.version_info >= (3, 10):         kwargs = {'kw_only': kw_only, 'slots': slots}     else:         kwargs = {}      def create_dataclass(cls: type[Any]) -> type[PydanticDataclass]:         \"\"\"Create a Pydantic dataclass from a regular dataclass.          Args:             cls: The class to create the Pydantic dataclass from.          Returns:             A Pydantic dataclass.         \"\"\"         from ._internal._utils import is_model_class          if is_model_class(cls):             raise PydanticUserError(                 f'Cannot create a Pydantic dataclass from {cls.__name__} as it is already a Pydantic model',                 code='dataclass-on-model',             )          original_cls = cls          # we warn on conflicting config specifications, but only if the class doesn't have a dataclass base         # because a dataclass base might provide a __pydantic_config__ attribute that we don't want to warn about         has_dataclass_base = any(dataclasses.is_dataclass(base) for base in cls.__bases__)         if not has_dataclass_base and config is not None and hasattr(cls, '__pydantic_config__'):             warn(                 f'`config` is set via both the `dataclass` decorator and `__pydantic_config__` for dataclass {cls.__name__}. '                 f'The `config` specification from `dataclass` decorator will take priority.',                 category=UserWarning,                 stacklevel=2,             )          # if config is not explicitly provided, try to read it from the type         config_dict = config if config is not None else getattr(cls, '__pydantic_config__', None)         config_wrapper = _config.ConfigWrapper(config_dict)         decorators = _decorators.DecoratorInfos.build(cls)         decorators.update_from_config(config_wrapper)          # Keep track of the original __doc__ so that we can restore it after applying the dataclasses decorator         # Otherwise, classes with no __doc__ will have their signature added into the JSON schema description,         # since dataclasses.dataclass will set this as the __doc__         original_doc = cls.__doc__          if _pydantic_dataclasses.is_stdlib_dataclass(cls):             # Vanilla dataclasses include a default docstring (representing the class signature),             # which we don't want to preserve.             original_doc = None              # We don't want to add validation to the existing std lib dataclass, so we will subclass it             #   If the class is generic, we need to make sure the subclass also inherits from Generic             #   with all the same parameters.             bases = (cls,)             if issubclass(cls, Generic):                 generic_base = Generic[cls.__parameters__]  # type: ignore                 bases = bases + (generic_base,)             cls = types.new_class(cls.__name__, bases)          # Respect frozen setting from dataclass constructor and fallback to config setting if not provided         if frozen is not None:             frozen_ = frozen             if config_wrapper.frozen:                 # It's not recommended to define both, as the setting from the dataclass decorator will take priority.                 warn(                     f'`frozen` is set via both the `dataclass` decorator and `config` for dataclass {cls.__name__!r}.'                     'This is not recommended. The `frozen` specification on `dataclass` will take priority.',                     category=UserWarning,                     stacklevel=2,                 )         else:             frozen_ = config_wrapper.frozen or False          # Make Pydantic's `Field()` function compatible with stdlib dataclasses. As we'll decorate         # `cls` with the stdlib `@dataclass` decorator first, there are two attributes, `kw_only` and         # `repr` that need to be understood *during* the stdlib creation. We do so in two steps:          # 1. On the decorated class, wrap `Field()` assignment with `dataclass.field()`, with the         # two attributes set (done in `as_dataclass_field()`)         cls_anns = _typing_extra.safe_get_annotations(cls)         for field_name in cls_anns:             # We should look for assignments in `__dict__` instead, but for now we follow             # the same behavior as stdlib dataclasses (see https://github.com/python/cpython/issues/88609)             field_value = getattr(cls, field_name, None)             if isinstance(field_value, FieldInfo):                 setattr(cls, field_name, _pydantic_dataclasses.as_dataclass_field(field_value))          # 2. For bases of `cls` that are stdlib dataclasses, we temporarily patch their fields         # (see the docstring of the context manager):         with _pydantic_dataclasses.patch_base_fields(cls):             cls = dataclasses.dataclass(  # pyright: ignore[reportCallIssue]                 cls,                 # the value of init here doesn't affect anything except that it makes it easier to generate a signature                 init=True,                 repr=repr,                 eq=eq,                 order=order,                 unsafe_hash=unsafe_hash,                 frozen=frozen_,                 **kwargs,             )          if config_wrapper.validate_assignment:             original_setattr = cls.__setattr__              @functools.wraps(cls.__setattr__)             def validated_setattr(instance: PydanticDataclass, name: str, value: Any, /) -> None:                 if frozen_:                     return original_setattr(instance, name, value)  # pyright: ignore[reportCallIssue]                 inst_cls = type(instance)                 attr = getattr(inst_cls, name, None)                  if isinstance(attr, property):                     attr.__set__(instance, value)                 elif isinstance(attr, functools.cached_property):                     instance.__dict__.__setitem__(name, value)                 else:                     inst_cls.__pydantic_validator__.validate_assignment(instance, name, value)              cls.__setattr__ = validated_setattr.__get__(None, cls)  # type: ignore              if slots and not hasattr(cls, '__setstate__'):                 # If slots is set, `pickle` (relied on by `copy.copy()`) will use                 # `__setattr__()` to reconstruct the dataclass. However, the custom                 # `__setattr__()` set above relies on `validate_assignment()`, which                 # in turn expects all the field values to be already present on the                 # instance, resulting in attribute errors.                 # As such, we make use of `object.__setattr__()` instead.                 # Note that we do so only if `__setstate__()` isn't already set (this is the                 # case if on top of `slots`, `frozen` is used).                  # Taken from `dataclasses._dataclass_get/setstate()`:                 def _dataclass_getstate(self: Any) -> list[Any]:                     return [getattr(self, f.name) for f in dataclasses.fields(self)]                  def _dataclass_setstate(self: Any, state: list[Any]) -> None:                     for field, value in zip(dataclasses.fields(self), state):                         object.__setattr__(self, field.name, value)                  cls.__getstate__ = _dataclass_getstate  # pyright: ignore[reportAttributeAccessIssue]                 cls.__setstate__ = _dataclass_setstate  # pyright: ignore[reportAttributeAccessIssue]          # This is an undocumented attribute to distinguish stdlib/Pydantic dataclasses.         # It should be set as early as possible:         cls.__is_pydantic_dataclass__ = True         cls.__pydantic_decorators__ = decorators  # type: ignore         cls.__doc__ = original_doc         # Can be non-existent for dynamically created classes:         firstlineno = getattr(original_cls, '__firstlineno__', None)         cls.__module__ = original_cls.__module__         if sys.version_info >= (3, 13) and firstlineno is not None:             # As per https://docs.python.org/3/reference/datamodel.html#type.__firstlineno__:             # Setting the `__module__` attribute removes the `__firstlineno__` item from the typeâ€™s dictionary.             original_cls.__firstlineno__ = firstlineno             cls.__firstlineno__ = firstlineno         cls.__qualname__ = original_cls.__qualname__         cls.__pydantic_fields_complete__ = classmethod(_pydantic_fields_complete)         cls.__pydantic_complete__ = False  # `complete_dataclass` will set it to `True` if successful.         # TODO `parent_namespace` is currently None, but we could do the same thing as Pydantic models:         # fetch the parent ns using `parent_frame_namespace` (if the dataclass was defined in a function),         # and possibly cache it (see the `__pydantic_parent_namespace__` logic for models).         _pydantic_dataclasses.complete_dataclass(cls, config_wrapper, raise_errors=False)         return cls      return create_dataclass if _cls is None else create_dataclass(_cls) ``` |", "url": "https://docs.pydantic.dev/latest/api/dataclasses/index.html#dataclass-indexhtmlpydanticdataclassesdataclass-permanent-link", "page": "api/dataclasses/index.html", "source_site": "pydantic"}
{"title": "rebuild\\_dataclass [Â¶](index.html#pydantic.dataclasses.rebuild_dataclass \"Permanent link\")", "anchor": "rebuilddataclass-indexhtmlpydanticdataclassesrebuilddataclass-permanent-link", "md_text": "```\nrebuild_dataclass(\n    cls: type[PydanticDataclass],\n    *,\n    force: bool = False,\n    raise_errors: bool = True,\n    _parent_namespace_depth: int = 2,\n    _types_namespace: MappingNamespace | None = None\n) -> bool | None\n```\n\nTry to rebuild the pydantic-core schema for the dataclass.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nThis is analogous to `BaseModel.model_rebuild`.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `cls` | `type[PydanticDataclass]` | The class to rebuild the pydantic-core schema for. | *required* |\n| `force` | `bool` | Whether to force the rebuilding of the schema, defaults to `False`. | `False` |\n| `raise_errors` | `bool` | Whether to raise errors, defaults to `True`. | `True` |\n| `_parent_namespace_depth` | `int` | The depth level of the parent namespace, defaults to 2. | `2` |\n| `_types_namespace` | `MappingNamespace | None` | The types namespace, defaults to `None`. | `None` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `bool | None` | Returns `None` if the schema is already \"complete\" and rebuilding was not required. |\n| `bool | None` | If rebuilding *was* required, returns `True` if rebuilding was successful, otherwise `False`. |\n\nSource code in `pydantic/dataclasses.py`\n\n|  |  |\n| --- | --- |\n| ``` 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 ``` | ``` def rebuild_dataclass(     cls: type[PydanticDataclass],     *,     force: bool = False,     raise_errors: bool = True,     _parent_namespace_depth: int = 2,     _types_namespace: MappingNamespace | None = None, ) -> bool | None:     \"\"\"Try to rebuild the pydantic-core schema for the dataclass.      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during     the initial attempt to build the schema, and automatic rebuilding fails.      This is analogous to `BaseModel.model_rebuild`.      Args:         cls: The class to rebuild the pydantic-core schema for.         force: Whether to force the rebuilding of the schema, defaults to `False`.         raise_errors: Whether to raise errors, defaults to `True`.         _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.         _types_namespace: The types namespace, defaults to `None`.      Returns:         Returns `None` if the schema is already \"complete\" and rebuilding was not required.         If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.     \"\"\"     if not force and cls.__pydantic_complete__:         return None      for attr in ('__pydantic_core_schema__', '__pydantic_validator__', '__pydantic_serializer__'):         if attr in cls.__dict__:             # Deleting the validator/serializer is necessary as otherwise they can get reused in             # pydantic-core. Same applies for the core schema that can be reused in schema generation.             delattr(cls, attr)      cls.__pydantic_complete__ = False      if _types_namespace is not None:         rebuild_ns = _types_namespace     elif _parent_namespace_depth > 0:         rebuild_ns = _typing_extra.parent_frame_namespace(parent_depth=_parent_namespace_depth, force=True) or {}     else:         rebuild_ns = {}      ns_resolver = _namespace_utils.NsResolver(         parent_namespace=rebuild_ns,     )      return _pydantic_dataclasses.complete_dataclass(         cls,         _config.ConfigWrapper(cls.__pydantic_config__, check=False),         raise_errors=raise_errors,         ns_resolver=ns_resolver,         # We could provide a different config instead (with `'defer_build'` set to `True`)         # of this explicit `_force_build` argument, but because config can come from the         # decorator parameter or the `__pydantic_config__` attribute, `complete_dataclass`         # will overwrite `__pydantic_config__` with the provided config above:         _force_build=True,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/dataclasses/index.html#rebuilddataclass-indexhtmlpydanticdataclassesrebuilddataclass-permanent-link", "page": "api/dataclasses/index.html", "source_site": "pydantic"}
{"title": "is\\_pydantic\\_dataclass [Â¶](index.html#pydantic.dataclasses.is_pydantic_dataclass \"Permanent link\")", "anchor": "ispydanticdataclass-indexhtmlpydanticdataclassesispydanticdataclass-permanent-link", "md_text": "```\nis_pydantic_dataclass(\n    class_: type[Any],\n) -> TypeGuard[type[PydanticDataclass]]\n```\n\nWhether a class is a pydantic dataclass.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `class_` | `type[Any]` | The class. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `TypeGuard[type[PydanticDataclass]]` | `True` if the class is a pydantic dataclass, `False` otherwise. |\n\nSource code in `pydantic/dataclasses.py`\n\n|  |  |\n| --- | --- |\n| ``` 401 402 403 404 405 406 407 408 409 410 411 412 413 ``` | ``` def is_pydantic_dataclass(class_: type[Any], /) -> TypeGuard[type[PydanticDataclass]]:     \"\"\"Whether a class is a pydantic dataclass.      Args:         class_: The class.      Returns:         `True` if the class is a pydantic dataclass, `False` otherwise.     \"\"\"     try:         return '__is_pydantic_dataclass__' in class_.__dict__ and dataclasses.is_dataclass(class_)     except AttributeError:         return False ``` |\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/api/dataclasses/index.html#ispydanticdataclass-indexhtmlpydanticdataclassesispydanticdataclass-permanent-link", "page": "api/dataclasses/index.html", "source_site": "pydantic"}
{"title": "PhoneNumber [Â¶](index.html#pydantic_extra_types.phone_numbers.PhoneNumber \"Permanent link\")", "anchor": "phonenumber-indexhtmlpydanticextratypesphonenumbersphonenumber-permanent-link", "md_text": "Bases: `str`\n\nA wrapper around the `phonenumbers.PhoneNumber` object.\n\nIt provides class-level configuration points you can change by subclassing:\n\n#### Examples[Â¶](index.html#pydantic_extra_types.phone_numbers.PhoneNumber--examples \"Permanent link\")\n\n##### Normal usage:[Â¶](index.html#pydantic_extra_types.phone_numbers.PhoneNumber--normal-usage \"Permanent link\")\n\n```\n    from pydantic import BaseModel\n    from pydantic_extra_types.phone_numbers import PhoneNumber\n\n    class Contact(BaseModel):\n        name: str\n        phone: PhoneNumber\n\n    c = Contact(name='Alice', phone='+1 650-253-0000')\n    print(c.phone)\n    >> tel:+1-650-253-0000 (formatted using RFC3966 by default)\n```\n\n##### Changing defaults by subclassing:[Â¶](index.html#pydantic_extra_types.phone_numbers.PhoneNumber--changing-defaults-by-subclassing \"Permanent link\")\n\n```\n    from pydantic_extra_types.phone_numbers import PhoneNumber\n\n    class USPhone(PhoneNumber):\n        default_region_code = 'US'\n        supported_regions = ['US']\n        phone_format = 'NATIONAL'\n\n    # Now parsing will accept national numbers for the US\n    p = USPhone('650-253-0000')\n    print(p)\n    >> 650-253-0000\n```\n\n##### Changing defaults by using the provided validator annotation:[Â¶](index.html#pydantic_extra_types.phone_numbers.PhoneNumber--changing-defaults-by-using-the-provided-validator-annotation \"Permanent link\")\n\n```\n    from typing import Annotated, Union\n    import phonenumbers\n    from pydantic import BaseModel\n    from pydantic_extra_types.phone_numbers import PhoneNumberValidator\n\n    E164NumberType = Annotated[\n        Union[str, phonenumbers.PhoneNumber], PhoneNumberValidator(number_format=\"E164\")\n    ]\n\n\n    class Model(BaseModel):\n        phone: E164NumberType\n\n\n    m = Model(phone=\"+1 650-253-0000\")\n    print(m.phone)\n    >> +16502530000\n```", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_phone_numbers/index.html#phonenumber-indexhtmlpydanticextratypesphonenumbersphonenumber-permanent-link", "page": "api/pydantic_extra_types_phone_numbers/index.html", "source_site": "pydantic"}
{"title": "default\\_region\\_code `class-attribute` [Â¶](index.html#pydantic_extra_types.phone_numbers.PhoneNumber.default_region_code \"Permanent link\")", "anchor": "defaultregioncode-class-attribute-indexhtmlpydanticextratypesphonenumbersphonenumberdefaultregioncode-permanent-link", "md_text": "```\ndefault_region_code: str | None = None\n```\n\nThe default region code to use when parsing phone numbers without an international prefix.", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_phone_numbers/index.html#defaultregioncode-class-attribute-indexhtmlpydanticextratypesphonenumbersphonenumberdefaultregioncode-permanent-link", "page": "api/pydantic_extra_types_phone_numbers/index.html", "source_site": "pydantic"}
{"title": "supported\\_regions `class-attribute` `instance-attribute` [Â¶](index.html#pydantic_extra_types.phone_numbers.PhoneNumber.supported_regions \"Permanent link\")", "anchor": "supportedregions-class-attribute-instance-attribute-indexhtmlpydanticextratypesphonenumbersphonenumbersupportedregions-permanent-link", "md_text": "```\nsupported_regions: list[str] = []\n```\n\nThe supported regions. If empty, all regions are supported.", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_phone_numbers/index.html#supportedregions-class-attribute-instance-attribute-indexhtmlpydanticextratypesphonenumbersphonenumbersupportedregions-permanent-link", "page": "api/pydantic_extra_types_phone_numbers/index.html", "source_site": "pydantic"}
{"title": "phone\\_format `class-attribute` `instance-attribute` [Â¶](index.html#pydantic_extra_types.phone_numbers.PhoneNumber.phone_format \"Permanent link\")", "anchor": "phoneformat-class-attribute-instance-attribute-indexhtmlpydanticextratypesphonenumbersphonenumberphoneformat-permanent-link", "md_text": "```\nphone_format: str = 'RFC3966'\n```\n\nThe format of the phone number.", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_phone_numbers/index.html#phoneformat-class-attribute-instance-attribute-indexhtmlpydanticextratypesphonenumbersphonenumberphoneformat-permanent-link", "page": "api/pydantic_extra_types_phone_numbers/index.html", "source_site": "pydantic"}
{"title": "PhoneNumberValidator `dataclass` [Â¶](index.html#pydantic_extra_types.phone_numbers.PhoneNumberValidator \"Permanent link\")", "anchor": "phonenumbervalidator-dataclass-indexhtmlpydanticextratypesphonenumbersphonenumbervalidator-permanent-link", "md_text": "```\nPhoneNumberValidator(\n    default_region: str | None = None,\n    number_format: str = \"RFC3966\",\n    supported_regions: Sequence[str] | None = None,\n)\n```\n\nAn annotation to validate `phonenumbers.PhoneNumber` objects.\n\nExample\n\n```\nfrom typing import Annotated, Union\n\nimport phonenumbers\nfrom pydantic import BaseModel\nfrom pydantic_extra_types.phone_numbers import PhoneNumberValidator\n\nMyNumberType = Annotated[Union[str, phonenumbers.PhoneNumber], PhoneNumberValidator()]\n\nUSNumberType = Annotated[\n    Union[str, phonenumbers.PhoneNumber], PhoneNumberValidator(supported_regions=['US'], default_region='US')\n]\n\n\nclass SomeModel(BaseModel):\n    phone_number: MyNumberType\n    us_number: USNumberType\n```", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_phone_numbers/index.html#phonenumbervalidator-dataclass-indexhtmlpydanticextratypesphonenumbersphonenumbervalidator-permanent-link", "page": "api/pydantic_extra_types_phone_numbers/index.html", "source_site": "pydantic"}
{"title": "default\\_region `class-attribute` `instance-attribute` [Â¶](index.html#pydantic_extra_types.phone_numbers.PhoneNumberValidator.default_region \"Permanent link\")", "anchor": "defaultregion-class-attribute-instance-attribute-indexhtmlpydanticextratypesphonenumbersphonenumbervalidatordefaultregion-permanent-link", "md_text": "```\ndefault_region: str | None = None\n```\n\nThe default region code to use when parsing phone numbers without an international prefix.\n\nIf `None` (the default), the region must be supplied in the phone number as an international prefix.", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_phone_numbers/index.html#defaultregion-class-attribute-instance-attribute-indexhtmlpydanticextratypesphonenumbersphonenumbervalidatordefaultregion-permanent-link", "page": "api/pydantic_extra_types_phone_numbers/index.html", "source_site": "pydantic"}
{"title": "number\\_format `class-attribute` `instance-attribute` [Â¶](index.html#pydantic_extra_types.phone_numbers.PhoneNumberValidator.number_format \"Permanent link\")", "anchor": "numberformat-class-attribute-instance-attribute-indexhtmlpydanticextratypesphonenumbersphonenumbervalidatornumberformat-permanent-link", "md_text": "```\nnumber_format: str = 'RFC3966'\n```\n\nThe format of the phone number to return. See `phonenumbers.PhoneNumberFormat` for valid values.", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_phone_numbers/index.html#numberformat-class-attribute-instance-attribute-indexhtmlpydanticextratypesphonenumbersphonenumbervalidatornumberformat-permanent-link", "page": "api/pydantic_extra_types_phone_numbers/index.html", "source_site": "pydantic"}
{"title": "supported\\_regions `class-attribute` `instance-attribute` [Â¶](index.html#pydantic_extra_types.phone_numbers.PhoneNumberValidator.supported_regions \"Permanent link\")", "anchor": "supportedregions-class-attribute-instance-attribute-indexhtmlpydanticextratypesphonenumbersphonenumbervalidatorsupportedregions-permanent-link", "md_text": "```\nsupported_regions: Sequence[str] | None = None\n```\n\nThe supported regions. If empty (the default), all regions are supported.\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_phone_numbers/index.html#supportedregions-class-attribute-instance-attribute-indexhtmlpydanticextratypesphonenumbersphonenumbervalidatorsupportedregions-permanent-link", "page": "api/pydantic_extra_types_phone_numbers/index.html", "source_site": "pydantic"}
{"title": "ISBN [Â¶](index.html#pydantic_extra_types.isbn.ISBN \"Permanent link\")", "anchor": "isbn-indexhtmlpydanticextratypesisbnisbn-permanent-link", "md_text": "Bases: `str`\n\nRepresents a ISBN and provides methods for conversion, validation, and serialization.\n\n```\nfrom pydantic import BaseModel\n\nfrom pydantic_extra_types.isbn import ISBN\n\n\nclass Book(BaseModel):\n    isbn: ISBN\n\n\nbook = Book(isbn='8537809667')\nprint(book)\n# > isbn='9788537809662'\n```", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_isbn/index.html#isbn-indexhtmlpydanticextratypesisbnisbn-permanent-link", "page": "api/pydantic_extra_types_isbn/index.html", "source_site": "pydantic"}
{"title": "validate\\_isbn\\_format `staticmethod` [Â¶](index.html#pydantic_extra_types.isbn.ISBN.validate_isbn_format \"Permanent link\")", "anchor": "validateisbnformat-staticmethod-indexhtmlpydanticextratypesisbnisbnvalidateisbnformat-permanent-link", "md_text": "```\nvalidate_isbn_format(value: str) -> None\n```\n\nValidate a ISBN format from the provided str value.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `value` | `str` | The str value representing the ISBN in 10 or 13 digits. | *required* |\n\nRaises:\n\n| Type | Description |\n| --- | --- |\n| `PydanticCustomError` | If the ISBN is not valid. |\n\nSource code in `pydantic_extra_types/isbn.py`\n\n|  |  |\n| --- | --- |\n| ``` 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 ``` | ``` @staticmethod def validate_isbn_format(value: str) -> None:     \"\"\"Validate a ISBN format from the provided str value.      Args:         value: The str value representing the ISBN in 10 or 13 digits.      Raises:         PydanticCustomError: If the ISBN is not valid.     \"\"\"     isbn_length = len(value)      if isbn_length not in (10, 13):         raise PydanticCustomError('isbn_length', f'Length for ISBN must be 10 or 13 digits, not {isbn_length}')      if isbn_length == 10:         if not value[:-1].isdigit() or ((value[-1] != 'X') and (not value[-1].isdigit())):             raise PydanticCustomError('isbn10_invalid_characters', 'First 9 digits of ISBN-10 must be integers')         if isbn10_digit_calc(value) != value[-1]:             raise PydanticCustomError('isbn_invalid_digit_check_isbn10', 'Provided digit is invalid for given ISBN')      if isbn_length == 13:         if not value.isdigit():             raise PydanticCustomError('isbn13_invalid_characters', 'All digits of ISBN-13 must be integers')         if value[:3] not in ('978', '979'):             raise PydanticCustomError(                 'isbn_invalid_early_characters', 'The first 3 digits of ISBN-13 must be 978 or 979'             )         if isbn13_digit_calc(value) != value[-1]:             raise PydanticCustomError('isbn_invalid_digit_check_isbn13', 'Provided digit is invalid for given ISBN') ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_isbn/index.html#validateisbnformat-staticmethod-indexhtmlpydanticextratypesisbnisbnvalidateisbnformat-permanent-link", "page": "api/pydantic_extra_types_isbn/index.html", "source_site": "pydantic"}
{"title": "convert\\_isbn10\\_to\\_isbn13 `staticmethod` [Â¶](index.html#pydantic_extra_types.isbn.ISBN.convert_isbn10_to_isbn13 \"Permanent link\")", "anchor": "convertisbn10toisbn13-staticmethod-indexhtmlpydanticextratypesisbnisbnconvertisbn10toisbn13-permanent-link", "md_text": "```\nconvert_isbn10_to_isbn13(value: str) -> str\n```\n\nConvert an ISBN-10 to ISBN-13.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `value` | `str` | The ISBN-10 value to be converted. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `str` | The converted ISBN or the original value if no conversion is necessary. |\n\nSource code in `pydantic_extra_types/isbn.py`\n\n|  |  |\n| --- | --- |\n| ``` 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 ``` | ``` @staticmethod def convert_isbn10_to_isbn13(value: str) -> str:     \"\"\"Convert an ISBN-10 to ISBN-13.      Args:         value: The ISBN-10 value to be converted.      Returns:         The converted ISBN or the original value if no conversion is necessary.     \"\"\"     if len(value) == 10:         base_isbn = f'978{value[:-1]}'         isbn13_digit = isbn13_digit_calc(base_isbn)         return ISBN(f'{base_isbn}{isbn13_digit}')      return ISBN(value) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_isbn/index.html#convertisbn10toisbn13-staticmethod-indexhtmlpydanticextratypesisbnisbnconvertisbn10toisbn13-permanent-link", "page": "api/pydantic_extra_types_isbn/index.html", "source_site": "pydantic"}
{"title": "isbn10\\_digit\\_calc [Â¶](index.html#pydantic_extra_types.isbn.isbn10_digit_calc \"Permanent link\")", "anchor": "isbn10digitcalc-indexhtmlpydanticextratypesisbnisbn10digitcalc-permanent-link", "md_text": "```\nisbn10_digit_calc(isbn: str) -> str\n```\n\nCalculate the ISBN-10 check digit from the provided str value. More information on the validation algorithm on [Wikipedia](https://en.wikipedia.org/wiki/ISBN#Check_digits)\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `isbn` | `str` | The str value representing the ISBN in 10 digits. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `str` | The calculated last digit of the ISBN-10 value. |\n\nSource code in `pydantic_extra_types/isbn.py`\n\n|  |  |\n| --- | --- |\n| ``` 15 16 17 18 19 20 21 22 23 24 25 26 27 ``` | ``` def isbn10_digit_calc(isbn: str) -> str:     \"\"\"Calculate the ISBN-10 check digit from the provided str value. More information on the validation algorithm on [Wikipedia](https://en.wikipedia.org/wiki/ISBN#Check_digits)      Args:         isbn: The str value representing the ISBN in 10 digits.      Returns:         The calculated last digit of the ISBN-10 value.     \"\"\"     total = sum(int(digit) * (10 - idx) for idx, digit in enumerate(isbn[:9]))     diff = (11 - total) % 11     valid_check_digit = 'X' if diff == 10 else str(diff)     return valid_check_digit ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_isbn/index.html#isbn10digitcalc-indexhtmlpydanticextratypesisbnisbn10digitcalc-permanent-link", "page": "api/pydantic_extra_types_isbn/index.html", "source_site": "pydantic"}
{"title": "isbn13\\_digit\\_calc [Â¶](index.html#pydantic_extra_types.isbn.isbn13_digit_calc \"Permanent link\")", "anchor": "isbn13digitcalc-indexhtmlpydanticextratypesisbnisbn13digitcalc-permanent-link", "md_text": "```\nisbn13_digit_calc(isbn: str) -> str\n```\n\nCalc a ISBN-13 last digit from the provided str value. More information on the validation algorithm on [Wikipedia](https://en.wikipedia.org/wiki/ISBN#Check_digits)\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `isbn` | `str` | The str value representing the ISBN in 13 digits. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `str` | The calculated last digit of the ISBN-13 value. |\n\nSource code in `pydantic_extra_types/isbn.py`\n\n|  |  |\n| --- | --- |\n| ``` 30 31 32 33 34 35 36 37 38 39 40 41 42 43 ``` | ``` def isbn13_digit_calc(isbn: str) -> str:     \"\"\"Calc a ISBN-13 last digit from the provided str value. More information on the validation algorithm on [Wikipedia](https://en.wikipedia.org/wiki/ISBN#Check_digits)      Args:         isbn: The str value representing the ISBN in 13 digits.      Returns:         The calculated last digit of the ISBN-13 value.     \"\"\"     total = sum(int(digit) * factor for digit, factor in zip(isbn[:12], it.cycle((1, 3))))      check_digit = (10 - total) % 10      return str(check_digit) ``` |\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_isbn/index.html#isbn13digitcalc-indexhtmlpydanticextratypesisbnisbn13digitcalc-permanent-link", "page": "api/pydantic_extra_types_isbn/index.html", "source_site": "pydantic"}
{"title": "CoreSchemaOrFieldType `module-attribute` [Â¶](index.html#pydantic.json_schema.CoreSchemaOrFieldType \"Permanent link\")", "anchor": "coreschemaorfieldtype-module-attribute-indexhtmlpydanticjsonschemacoreschemaorfieldtype-permanent-link", "md_text": "```\nCoreSchemaOrFieldType = Literal[\n    CoreSchemaType, CoreSchemaFieldType\n]\n```\n\nA type alias for defined schema types that represents a union of\n`core_schema.CoreSchemaType` and\n`core_schema.CoreSchemaFieldType`.", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#coreschemaorfieldtype-module-attribute-indexhtmlpydanticjsonschemacoreschemaorfieldtype-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "JsonSchemaValue `module-attribute` [Â¶](index.html#pydantic.json_schema.JsonSchemaValue \"Permanent link\")", "anchor": "jsonschemavalue-module-attribute-indexhtmlpydanticjsonschemajsonschemavalue-permanent-link", "md_text": "```\nJsonSchemaValue = dict[str, Any]\n```\n\nA type alias for a JSON schema value. This is a dictionary of string keys to arbitrary JSON values.", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#jsonschemavalue-module-attribute-indexhtmlpydanticjsonschemajsonschemavalue-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "JsonSchemaMode `module-attribute` [Â¶](index.html#pydantic.json_schema.JsonSchemaMode \"Permanent link\")", "anchor": "jsonschemamode-module-attribute-indexhtmlpydanticjsonschemajsonschemamode-permanent-link", "md_text": "```\nJsonSchemaMode = Literal['validation', 'serialization']\n```\n\nA type alias that represents the mode of a JSON schema; either 'validation' or 'serialization'.\n\nFor some types, the inputs to validation differ from the outputs of serialization. For example,\ncomputed fields will only be present when serializing, and should not be provided when\nvalidating. This flag provides a way to indicate whether you want the JSON schema required\nfor validation inputs, or that will be matched by serialization outputs.", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#jsonschemamode-module-attribute-indexhtmlpydanticjsonschemajsonschemamode-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "JsonSchemaWarningKind `module-attribute` [Â¶](index.html#pydantic.json_schema.JsonSchemaWarningKind \"Permanent link\")", "anchor": "jsonschemawarningkind-module-attribute-indexhtmlpydanticjsonschemajsonschemawarningkind-permanent-link", "md_text": "```\nJsonSchemaWarningKind = Literal[\n    \"skipped-choice\",\n    \"non-serializable-default\",\n    \"skipped-discriminator\",\n]\n```\n\nA type alias representing the kinds of warnings that can be emitted during JSON schema generation.\n\nSee [`GenerateJsonSchema.render_warning_message`](index.html#pydantic.json_schema.GenerateJsonSchema.render_warning_message)\nfor more details.", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#jsonschemawarningkind-module-attribute-indexhtmlpydanticjsonschemajsonschemawarningkind-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "NoDefault `module-attribute` [Â¶](index.html#pydantic.json_schema.NoDefault \"Permanent link\")", "anchor": "nodefault-module-attribute-indexhtmlpydanticjsonschemanodefault-permanent-link", "md_text": "```\nNoDefault = object()\n```\n\nA sentinel value used to indicate that no default value should be used when generating a JSON Schema\nfor a core schema with a default value.", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#nodefault-module-attribute-indexhtmlpydanticjsonschemanodefault-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "DEFAULT\\_REF\\_TEMPLATE `module-attribute` [Â¶](index.html#pydantic.json_schema.DEFAULT_REF_TEMPLATE \"Permanent link\")", "anchor": "defaultreftemplate-module-attribute-indexhtmlpydanticjsonschemadefaultreftemplate-permanent-link", "md_text": "```\nDEFAULT_REF_TEMPLATE = '#/$defs/{model}'\n```\n\nThe default format string used to generate reference names.", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#defaultreftemplate-module-attribute-indexhtmlpydanticjsonschemadefaultreftemplate-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "PydanticJsonSchemaWarning [Â¶](index.html#pydantic.json_schema.PydanticJsonSchemaWarning \"Permanent link\")", "anchor": "pydanticjsonschemawarning-indexhtmlpydanticjsonschemapydanticjsonschemawarning-permanent-link", "md_text": "Bases: `UserWarning`\n\nThis class is used to emit warnings produced during JSON schema generation.\nSee the [`GenerateJsonSchema.emit_warning`](index.html#pydantic.json_schema.GenerateJsonSchema.emit_warning) and\n[`GenerateJsonSchema.render_warning_message`](index.html#pydantic.json_schema.GenerateJsonSchema.render_warning_message)\nmethods for more details; these can be overridden to control warning behavior.", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#pydanticjsonschemawarning-indexhtmlpydanticjsonschemapydanticjsonschemawarning-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "GenerateJsonSchema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema \"Permanent link\")", "anchor": "generatejsonschema-indexhtmlpydanticjsonschemageneratejsonschema-permanent-link", "md_text": "```\nGenerateJsonSchema(\n    by_alias: bool = True,\n    ref_template: str = DEFAULT_REF_TEMPLATE,\n    union_format: Literal[\n        \"any_of\", \"primitive_type_array\"\n    ] = \"any_of\",\n)\n```\n\n[Customizing the JSON Schema Generation Process](../../concepts/json_schema/index.html#customizing-the-json-schema-generation-process)\n\nA class for generating JSON schemas.\n\nThis class generates JSON schemas based on configured parameters. The default schema dialect\nis <https://json-schema.org/draft/2020-12/schema>.\nThe class uses `by_alias` to configure how fields with\nmultiple names are handled and `ref_template` to format reference names.\n\nAttributes:\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `schema_dialect` |  | The JSON schema dialect used to generate the schema. See [Declaring a Dialect](https://json-schema.org/understanding-json-schema/reference/schema.html#id4) in the JSON Schema documentation for more information about dialects. |\n| `ignored_warning_kinds` | `set[JsonSchemaWarningKind]` | Warnings to ignore when generating the schema. `self.render_warning_message` will do nothing if its argument `kind` is in `ignored_warning_kinds`; this value can be modified on subclasses to easily control which warnings are emitted. |\n| `by_alias` |  | Whether to use field aliases when generating the schema. |\n| `ref_template` |  | The format string used when generating reference names. |\n| `core_to_json_refs` | `dict[CoreModeRef, JsonRef]` | A mapping of core refs to JSON refs. |\n| `core_to_defs_refs` | `dict[CoreModeRef, DefsRef]` | A mapping of core refs to definition refs. |\n| `defs_to_core_refs` | `dict[DefsRef, CoreModeRef]` | A mapping of definition refs to core refs. |\n| `json_to_defs_refs` | `dict[JsonRef, DefsRef]` | A mapping of JSON refs to definition refs. |\n| `definitions` | `dict[DefsRef, JsonSchemaValue]` | Definitions in the schema. |\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `by_alias` | `bool` | Whether to use field aliases in the generated schemas. | `True` |\n| `ref_template` | `str` | The format string to use when generating reference names. | `DEFAULT_REF_TEMPLATE` |\n| `union_format` | `Literal['any_of', 'primitive_type_array']` | The format to use when combining schemas from unions together. Can be one of:   * `'any_of'`: Use the [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)   keyword to combine schemas (the default). * `'primitive_type_array'`: Use the [`type`](https://json-schema.org/understanding-json-schema/reference/type)   keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive   type (`string`, `boolean`, `null`, `integer` or `number`) or contains constraints/metadata, falls back to   `any_of`. | `'any_of'` |\n\nRaises:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaError` | If the instance of the class is inadvertently reused after generating a schema. |\n\nSource code in `pydantic/json_schema.py`", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#generatejsonschema-indexhtmlpydanticjsonschemageneratejsonschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "GenerateJsonSchema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema \"Permanent link\")", "anchor": "generatejsonschema-indexhtmlpydanticjsonschemageneratejsonschema-permanent-link", "md_text": "|  |  |\n| --- | --- |\n| ``` 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 ``` | ``` def __init__(     self,     by_alias: bool = True,     ref_template: str = DEFAULT_REF_TEMPLATE,     union_format: Literal['any_of', 'primitive_type_array'] = 'any_of', ) -> None:     self.by_alias = by_alias     self.ref_template = ref_template     self.union_format: Literal['any_of', 'primitive_type_array'] = union_format      self.core_to_json_refs: dict[CoreModeRef, JsonRef] = {}     self.core_to_defs_refs: dict[CoreModeRef, DefsRef] = {}     self.defs_to_core_refs: dict[DefsRef, CoreModeRef] = {}     self.json_to_defs_refs: dict[JsonRef, DefsRef] = {}      self.definitions: dict[DefsRef, JsonSchemaValue] = {}     self._config_wrapper_stack = _config.ConfigWrapperStack(_config.ConfigWrapper({}))      self._mode: JsonSchemaMode = 'validation'      # The following includes a mapping of a fully-unique defs ref choice to a list of preferred     # alternatives, which are generally simpler, such as only including the class name.     # At the end of schema generation, we use these to produce a JSON schema with more human-readable     # definitions, which would also work better in a generated OpenAPI client, etc.     self._prioritized_defsref_choices: dict[DefsRef, list[DefsRef]] = {}     self._collision_counter: dict[str, int] = defaultdict(int)     self._collision_index: dict[str, int] = {}      self._schema_type_to_method = self.build_schema_type_to_method()      # When we encounter definitions we need to try to build them immediately     # so that they are available schemas that reference them     # But it's possible that CoreSchema was never going to be used     # (e.g. because the CoreSchema that references short circuits is JSON schema generation without needing     #  the reference) so instead of failing altogether if we can't build a definition we     # store the error raised and re-throw it if we end up needing that def     self._core_defs_invalid_for_json_schema: dict[DefsRef, PydanticInvalidForJsonSchema] = {}      # This changes to True after generating a schema, to prevent issues caused by accidental reuse     # of a single instance of a schema generator     self._used = False ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#generatejsonschema-indexhtmlpydanticjsonschemageneratejsonschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "ValidationsMapping [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.ValidationsMapping \"Permanent link\")", "anchor": "validationsmapping-indexhtmlpydanticjsonschemageneratejsonschemavalidationsmapping-permanent-link", "md_text": "This class just contains mappings from core\\_schema attribute names to the corresponding\nJSON schema attribute names. While I suspect it is unlikely to be necessary, you can in\nprinciple override this class in a subclass of GenerateJsonSchema (by inheriting from\nGenerateJsonSchema.ValidationsMapping) to change these mappings.", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#validationsmapping-indexhtmlpydanticjsonschemageneratejsonschemavalidationsmapping-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "build\\_schema\\_type\\_to\\_method [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.build_schema_type_to_method \"Permanent link\")", "anchor": "buildschematypetomethod-indexhtmlpydanticjsonschemageneratejsonschemabuildschematypetomethod-permanent-link", "md_text": "```\nbuild_schema_type_to_method() -> dict[\n    CoreSchemaOrFieldType,\n    Callable[[CoreSchemaOrField], JsonSchemaValue],\n]\n```\n\nBuilds a dictionary mapping fields to methods for generating JSON schemas.\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `dict[CoreSchemaOrFieldType, Callable[[CoreSchemaOrField], JsonSchemaValue]]` | A dictionary containing the mapping of `CoreSchemaOrFieldType` to a handler method. |\n\nRaises:\n\n| Type | Description |\n| --- | --- |\n| `TypeError` | If no method has been defined for generating a JSON schema for a given pydantic core schema type. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 ``` | ``` def build_schema_type_to_method(     self, ) -> dict[CoreSchemaOrFieldType, Callable[[CoreSchemaOrField], JsonSchemaValue]]:     \"\"\"Builds a dictionary mapping fields to methods for generating JSON schemas.      Returns:         A dictionary containing the mapping of `CoreSchemaOrFieldType` to a handler method.      Raises:         TypeError: If no method has been defined for generating a JSON schema for a given pydantic core schema type.     \"\"\"     mapping: dict[CoreSchemaOrFieldType, Callable[[CoreSchemaOrField], JsonSchemaValue]] = {}     core_schema_types: list[CoreSchemaOrFieldType] = list(get_literal_values(CoreSchemaOrFieldType))     for key in core_schema_types:         method_name = f'{key.replace(\"-\", \"_\")}_schema'         try:             mapping[key] = getattr(self, method_name)         except AttributeError as e:  # pragma: no cover             if os.getenv('PYDANTIC_PRIVATE_ALLOW_UNHANDLED_SCHEMA_TYPES'):                 continue             raise TypeError(                 f'No method for generating JsonSchema for core_schema.type={key!r} '                 f'(expected: {type(self).__name__}.{method_name})'             ) from e     return mapping ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#buildschematypetomethod-indexhtmlpydanticjsonschemageneratejsonschemabuildschematypetomethod-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "generate\\_definitions [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.generate_definitions \"Permanent link\")", "anchor": "generatedefinitions-indexhtmlpydanticjsonschemageneratejsonschemageneratedefinitions-permanent-link", "md_text": "```\ngenerate_definitions(\n    inputs: Sequence[\n        tuple[JsonSchemaKeyT, JsonSchemaMode, CoreSchema]\n    ]\n) -> tuple[\n    dict[\n        tuple[JsonSchemaKeyT, JsonSchemaMode],\n        JsonSchemaValue,\n    ],\n    dict[DefsRef, JsonSchemaValue],\n]\n```\n\nGenerates JSON schema definitions from a list of core schemas, pairing the generated definitions with a\nmapping that links the input keys to the definition references.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `inputs` | `Sequence[tuple[JsonSchemaKeyT, JsonSchemaMode, CoreSchema]]` | A sequence of tuples, where:   * The first element is a JSON schema key type. * The second element is the JSON mode: either 'validation' or 'serialization'. * The third element is a core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `tuple[dict[tuple[JsonSchemaKeyT, JsonSchemaMode], JsonSchemaValue], dict[DefsRef, JsonSchemaValue]]` | A tuple where:   * The first element is a dictionary whose keys are tuples of JSON schema key type and JSON mode, and   whose values are the JSON schema corresponding to that pair of inputs. (These schemas may have   JsonRef references to definitions that are defined in the second returned element.) * The second element is a dictionary whose keys are definition references for the JSON schemas   from the first returned element, and whose values are the actual JSON schema definitions. |\n\nRaises:\n\n| Type | Description |\n| --- | --- |\n| `PydanticUserError` | Raised if the JSON schema generator has already been used to generate a JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 ``` | ``` def generate_definitions(     self, inputs: Sequence[tuple[JsonSchemaKeyT, JsonSchemaMode, core_schema.CoreSchema]] ) -> tuple[dict[tuple[JsonSchemaKeyT, JsonSchemaMode], JsonSchemaValue], dict[DefsRef, JsonSchemaValue]]:     \"\"\"Generates JSON schema definitions from a list of core schemas, pairing the generated definitions with a     mapping that links the input keys to the definition references.      Args:         inputs: A sequence of tuples, where:              - The first element is a JSON schema key type.             - The second element is the JSON mode: either 'validation' or 'serialization'.             - The third element is a core schema.      Returns:         A tuple where:              - The first element is a dictionary whose keys are tuples of JSON schema key type and JSON mode, and                 whose values are the JSON schema corresponding to that pair of inputs. (These schemas may have                 JsonRef references to definitions that are defined in the second returned element.)             - The second element is a dictionary whose keys are definition references for the JSON schemas                 from the first returned element, and whose values are the actual JSON schema definitions.      Raises:         PydanticUserError: Raised if the JSON schema generator has already been used to generate a JSON schema.     \"\"\"     if self._used:         raise PydanticUserError(             'This JSON schema generator has already been used to generate a JSON schema. '             f'You must create a new instance of {type(self).__name__} to generate a new JSON schema.',             code='json-schema-already-used',         )      for _, mode, schema in inputs:         self._mode = mode         self.generate_inner(schema)      definitions_remapping = self._build_definitions_remapping()      json_schemas_map: dict[tuple[JsonSchemaKeyT, JsonSchemaMode], DefsRef] = {}     for key, mode, schema in inputs:         self._mode = mode         json_schema = self.generate_inner(schema)         json_schemas_map[(key, mode)] = definitions_remapping.remap_json_schema(json_schema)      json_schema = {'$defs': self.definitions}     json_schema = definitions_remapping.remap_json_schema(json_schema)     self._used = True     return json_schemas_map, self.sort(json_schema['$defs'])  # type: ignore ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#generatedefinitions-indexhtmlpydanticjsonschemageneratejsonschemageneratedefinitions-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "generate [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.generate \"Permanent link\")", "anchor": "generate-indexhtmlpydanticjsonschemageneratejsonschemagenerate-permanent-link", "md_text": "```\ngenerate(\n    schema: CoreSchema, mode: JsonSchemaMode = \"validation\"\n) -> JsonSchemaValue\n```\n\nGenerates a JSON schema for a specified schema in a specified mode.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `CoreSchema` | A Pydantic model. | *required* |\n| `mode` | `JsonSchemaMode` | The mode in which to generate the schema. Defaults to 'validation'. | `'validation'` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | A JSON schema representing the specified schema. |\n\nRaises:\n\n| Type | Description |\n| --- | --- |\n| `PydanticUserError` | If the JSON schema generator has already been used to generate a JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 ``` | ``` def generate(self, schema: CoreSchema, mode: JsonSchemaMode = 'validation') -> JsonSchemaValue:     \"\"\"Generates a JSON schema for a specified schema in a specified mode.      Args:         schema: A Pydantic model.         mode: The mode in which to generate the schema. Defaults to 'validation'.      Returns:         A JSON schema representing the specified schema.      Raises:         PydanticUserError: If the JSON schema generator has already been used to generate a JSON schema.     \"\"\"     self._mode = mode     if self._used:         raise PydanticUserError(             'This JSON schema generator has already been used to generate a JSON schema. '             f'You must create a new instance of {type(self).__name__} to generate a new JSON schema.',             code='json-schema-already-used',         )      json_schema: JsonSchemaValue = self.generate_inner(schema)     json_ref_counts = self.get_json_ref_counts(json_schema)      ref = cast(JsonRef, json_schema.get('$ref'))     while ref is not None:  # may need to unpack multiple levels         ref_json_schema = self.get_schema_from_definitions(ref)         if json_ref_counts[ref] == 1 and ref_json_schema is not None and len(json_schema) == 1:             # \"Unpack\" the ref since this is the only reference and there are no sibling keys             json_schema = ref_json_schema.copy()  # copy to prevent recursive dict reference             json_ref_counts[ref] -= 1             ref = cast(JsonRef, json_schema.get('$ref'))         ref = None      self._garbage_collect_definitions(json_schema)     definitions_remapping = self._build_definitions_remapping()      if self.definitions:         json_schema['$defs'] = self.definitions      json_schema = definitions_remapping.remap_json_schema(json_schema)      # For now, we will not set the $schema key. However, if desired, this can be easily added by overriding     # this method and adding the following line after a call to super().generate(schema):     # json_schema['$schema'] = self.schema_dialect      self._used = True     return self.sort(json_schema) ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#generate-indexhtmlpydanticjsonschemageneratejsonschemagenerate-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "generate\\_inner [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.generate_inner \"Permanent link\")", "anchor": "generateinner-indexhtmlpydanticjsonschemageneratejsonschemagenerateinner-permanent-link", "md_text": "```\ngenerate_inner(\n    schema: CoreSchemaOrField,\n) -> JsonSchemaValue\n```\n\nGenerates a JSON schema for a given core schema.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `CoreSchemaOrField` | The given core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nTODO: the nested function definitions here seem like bad practice, I'd like to unpack these\nin a future PR. It'd be great if we could shorten the call stack a bit for JSON schema generation,\nand I think there's potential for that here.\n\nSource code in `pydantic/json_schema.py`", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#generateinner-indexhtmlpydanticjsonschemageneratejsonschemagenerateinner-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "generate\\_inner [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.generate_inner \"Permanent link\")", "anchor": "generateinner-indexhtmlpydanticjsonschemageneratejsonschemagenerateinner-permanent-link", "md_text": "|  |  |\n| --- | --- |\n| ``` 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 ``` | ``` def generate_inner(self, schema: CoreSchemaOrField) -> JsonSchemaValue:  # noqa: C901     \"\"\"Generates a JSON schema for a given core schema.      Args:         schema: The given core schema.      Returns:         The generated JSON schema.      TODO: the nested function definitions here seem like bad practice, I'd like to unpack these     in a future PR. It'd be great if we could shorten the call stack a bit for JSON schema generation,     and I think there's potential for that here.     \"\"\"     # If a schema with the same CoreRef has been handled, just return a reference to it     # Note that this assumes that it will _never_ be the case that the same CoreRef is used     # on types that should have different JSON schemas     if 'ref' in schema:         core_ref = CoreRef(schema['ref'])  # type: ignore[typeddict-item]         core_mode_ref = (core_ref, self.mode)         if core_mode_ref in self.core_to_defs_refs and self.core_to_defs_refs[core_mode_ref] in self.definitions:             return {'$ref': self.core_to_json_refs[core_mode_ref]}      def populate_defs(core_schema: CoreSchema, json_schema: JsonSchemaValue) -> JsonSchemaValue:         if 'ref' in core_schema:             core_ref = CoreRef(core_schema['ref'])  # type: ignore[typeddict-item]             defs_ref, ref_json_schema = self.get_cache_defs_ref_schema(core_ref)             json_ref = JsonRef(ref_json_schema['$ref'])             # Replace the schema if it's not a reference to itself             # What we want to avoid is having the def be just a ref to itself             # which is what would happen if we blindly assigned any             if json_schema.get('$ref', None) != json_ref:                 self.definitions[defs_ref] = json_schema                 self._core_defs_invalid_for_json_schema.pop(defs_ref, None)             json_schema = ref_json_schema         return json_schema      def handler_func(schema_or_field: CoreSchemaOrField) -> JsonSchemaValue:         \"\"\"Generate a JSON schema based on the input schema.          Args:             schema_or_field: The core schema to generate a JSON schema from.          Returns:             The generated JSON schema.          Raises:             TypeError: If an unexpected schema type is encountered.         \"\"\"         # Generate the core-schema-type-specific bits of the schema generation:         json_schema: JsonSchemaValue | None = None         if self.mode == 'serialization' and 'serialization' in schema_or_field:             # In this case, we skip the JSON Schema generation of the schema             # and use the `'serialization'` schema instead (canonical example:             # `Annotated[int, PlainSerializer(str)]`).             ser_schema = schema_or_field['serialization']  # type: ignore             json_schema = self.ser_schema(ser_schema)              # It might be that the 'serialization'` is skipped depending on `when_used`.             # This is only relevant for `nullable` schemas though, so we special case here.             if (                 json_schema is not None                 and ser_schema.get('when_used') in ('unless-none', 'json-unless-none')                 and schema_or_field['type'] == 'nullable'             ):                 json_schema = self.get_union_of_schemas([{'type': 'null'}, json_schema])         if json_schema is None:             if _core_utils.is_core_schema(schema_or_field) or _core_utils.is_core_schema_field(schema_or_field):                 generate_for_schema_type = self._schema_type_to_method[schema_or_field['type']]                 json_schema = generate_for_schema_type(schema_or_field)             else:                 raise TypeError(f'Unexpected schema type: schema={schema_or_field}')         return json_schema      current_handler = _schema_generation_shared.GenerateJsonSchemaHandler(self, handler_func)      metadata = cast(_core_metadata.CoreMetadata, schema.get('metadata', {}))      # TODO: I dislike that we have to wrap these basic dict updates in callables, is there any way around this?      if js_updates := metadata.get('pydantic_js_updates'):          def js_updates_handler_func(             schema_or_field: CoreSchemaOrField,             current_handler: GetJsonSchemaHandler = current_handler,         ) -> JsonSchemaValue:             json_schema = {**current_handler(schema_or_field), **js_updates}             return json_schema          current_handler = _schema_generation_shared.GenerateJsonSchemaHandler(self, js_updates_handler_func)      if js_extra := metadata.get('pydantic_js_extra'):          def js_extra_handler_func(             schema_or_field: CoreSchemaOrField,             current_handler: GetJsonSchemaHandler = current_handler,         ) -> JsonSchemaValue:             json_schema = current_handler(schema_or_field)             if isinstance(js_extra, dict):                 json_schema.update(to_jsonable_python(js_extra))             elif callable(js_extra):                 # similar to typing issue in _update_class_schema when we're working with callable js extra                 js_extra(json_schema)  # type: ignore             return json_schema          current_handler = _schema_generation_shared.GenerateJsonSchemaHandler(self, js_extra_handler_func)      for js_modify_function in metadata.get('pydantic_js_functions', ()):          def new_handler_func(             schema_or_field: CoreSchemaOrField,             current_handler: GetJsonSchemaHandler = current_handler,             js_modify_function: GetJsonSchemaFunction = js_modify_function,         ) -> JsonSchemaValue:             json_schema = js_modify_function(schema_or_field, current_handler)             if _core_utils.is_core_schema(schema_or_field):                 json_schema = populate_defs(schema_or_field, json_schema)             original_schema = current_handler.resolve_ref_schema(json_schema)             ref = json_schema.pop('$ref', None)             if ref and json_schema:                 original_schema.update(json_schema)             return original_schema          current_handler = _schema_generation_shared.GenerateJsonSchemaHandler(self, new_handler_func)      for js_modify_function in metadata.get('pydantic_js_annotation_functions', ()):          def new_handler_func(             schema_or_field: CoreSchemaOrField,             current_handler: GetJsonSchemaHandler = current_handler,             js_modify_function: GetJsonSchemaFunction = js_modify_function,         ) -> JsonSchemaValue:             return js_modify_function(schema_or_field, current_handler)          current_handler = _schema_generation_shared.GenerateJsonSchemaHandler(self, new_handler_func)      json_schema = current_handler(schema)     if _core_utils.is_core_schema(schema):         json_schema = populate_defs(schema, json_schema)     return json_schema ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#generateinner-indexhtmlpydanticjsonschemageneratejsonschemagenerateinner-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "sort [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.sort \"Permanent link\")", "anchor": "sort-indexhtmlpydanticjsonschemageneratejsonschemasort-permanent-link", "md_text": "```\nsort(\n    value: JsonSchemaValue, parent_key: str | None = None\n) -> JsonSchemaValue\n```\n\nOverride this method to customize the sorting of the JSON schema (e.g., don't sort at all, sort all keys unconditionally, etc.)\n\nBy default, alphabetically sort the keys in the JSON schema, skipping the 'properties' and 'default' keys to preserve field definition order.\nThis sort is recursive, so it will sort all nested dictionaries as well.\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 583 584 585 586 587 588 589 590 591 592 593 594 595 ``` | ``` def sort(self, value: JsonSchemaValue, parent_key: str | None = None) -> JsonSchemaValue:     \"\"\"Override this method to customize the sorting of the JSON schema (e.g., don't sort at all, sort all keys unconditionally, etc.)      By default, alphabetically sort the keys in the JSON schema, skipping the 'properties' and 'default' keys to preserve field definition order.     This sort is recursive, so it will sort all nested dictionaries as well.     \"\"\"     sorted_dict: dict[str, JsonSchemaValue] = {}     keys = value.keys()     if parent_key not in ('properties', 'default'):         keys = sorted(keys)     for key in keys:         sorted_dict[key] = self._sort_recursive(value[key], parent_key=key)     return sorted_dict ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#sort-indexhtmlpydanticjsonschemageneratejsonschemasort-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "invalid\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.invalid_schema \"Permanent link\")", "anchor": "invalidschema-indexhtmlpydanticjsonschemageneratejsonschemainvalidschema-permanent-link", "md_text": "```\ninvalid_schema(schema: InvalidSchema) -> JsonSchemaValue\n```\n\nPlaceholder - should never be called.\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 615 616 617 618 ``` | ``` def invalid_schema(self, schema: core_schema.InvalidSchema) -> JsonSchemaValue:     \"\"\"Placeholder - should never be called.\"\"\"      raise RuntimeError('Cannot generate schema for invalid_schema. This is a bug! Please report it.') ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#invalidschema-indexhtmlpydanticjsonschemageneratejsonschemainvalidschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "any\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.any_schema \"Permanent link\")", "anchor": "anyschema-indexhtmlpydanticjsonschemageneratejsonschemaanyschema-permanent-link", "md_text": "```\nany_schema(schema: AnySchema) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches any value.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `AnySchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 620 621 622 623 624 625 626 627 628 629 ``` | ``` def any_schema(self, schema: core_schema.AnySchema) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches any value.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     return {} ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#anyschema-indexhtmlpydanticjsonschemageneratejsonschemaanyschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "none\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.none_schema \"Permanent link\")", "anchor": "noneschema-indexhtmlpydanticjsonschemageneratejsonschemanoneschema-permanent-link", "md_text": "```\nnone_schema(schema: NoneSchema) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches `None`.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `NoneSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 631 632 633 634 635 636 637 638 639 640 ``` | ``` def none_schema(self, schema: core_schema.NoneSchema) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches `None`.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     return {'type': 'null'} ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#noneschema-indexhtmlpydanticjsonschemageneratejsonschemanoneschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "bool\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.bool_schema \"Permanent link\")", "anchor": "boolschema-indexhtmlpydanticjsonschemageneratejsonschemaboolschema-permanent-link", "md_text": "```\nbool_schema(schema: BoolSchema) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches a bool value.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `BoolSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 642 643 644 645 646 647 648 649 650 651 ``` | ``` def bool_schema(self, schema: core_schema.BoolSchema) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches a bool value.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     return {'type': 'boolean'} ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#boolschema-indexhtmlpydanticjsonschemageneratejsonschemaboolschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "int\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.int_schema \"Permanent link\")", "anchor": "intschema-indexhtmlpydanticjsonschemageneratejsonschemaintschema-permanent-link", "md_text": "```\nint_schema(schema: IntSchema) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches an int value.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `IntSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 653 654 655 656 657 658 659 660 661 662 663 664 665 ``` | ``` def int_schema(self, schema: core_schema.IntSchema) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches an int value.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     json_schema: dict[str, Any] = {'type': 'integer'}     self.update_with_validations(json_schema, schema, self.ValidationsMapping.numeric)     json_schema = {k: v for k, v in json_schema.items() if v not in {math.inf, -math.inf}}     return json_schema ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#intschema-indexhtmlpydanticjsonschemageneratejsonschemaintschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "float\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.float_schema \"Permanent link\")", "anchor": "floatschema-indexhtmlpydanticjsonschemageneratejsonschemafloatschema-permanent-link", "md_text": "```\nfloat_schema(schema: FloatSchema) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches a float value.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `FloatSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 667 668 669 670 671 672 673 674 675 676 677 678 679 ``` | ``` def float_schema(self, schema: core_schema.FloatSchema) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches a float value.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     json_schema: dict[str, Any] = {'type': 'number'}     self.update_with_validations(json_schema, schema, self.ValidationsMapping.numeric)     json_schema = {k: v for k, v in json_schema.items() if v not in {math.inf, -math.inf}}     return json_schema ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#floatschema-indexhtmlpydanticjsonschemageneratejsonschemafloatschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "decimal\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.decimal_schema \"Permanent link\")", "anchor": "decimalschema-indexhtmlpydanticjsonschemageneratejsonschemadecimalschema-permanent-link", "md_text": "```\ndecimal_schema(schema: DecimalSchema) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches a decimal value.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `DecimalSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 ``` | ``` def decimal_schema(self, schema: core_schema.DecimalSchema) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches a decimal value.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"      def get_decimal_pattern(schema: core_schema.DecimalSchema) -> str:         max_digits = schema.get('max_digits')         decimal_places = schema.get('decimal_places')          pattern = (             r'^(?!^[-+.]*$)[+-]?0*'  # check it is not empty string and not one or sequence of \".+-\" characters.         )          # Case 1: Both max_digits and decimal_places are set         if max_digits is not None and decimal_places is not None:             integer_places = max(0, max_digits - decimal_places)             pattern += (                 rf'(?:'                 rf'\\d{{0,{integer_places}}}'                 rf'|'                 rf'(?=[\\d.]{{1,{max_digits + 1}}}0*$)'                 rf'\\d{{0,{integer_places}}}\\.\\d{{0,{decimal_places}}}0*$'                 rf')'             )          # Case 2: Only max_digits is set         elif max_digits is not None and decimal_places is None:             pattern += (                 rf'(?:'                 rf'\\d{{0,{max_digits}}}'                 rf'|'                 rf'(?=[\\d.]{{1,{max_digits + 1}}}0*$)'                 rf'\\d*\\.\\d*0*$'                 rf')'             )          # Case 3: Only decimal_places is set         elif max_digits is None and decimal_places is not None:             pattern += rf'\\d*\\.?\\d{{0,{decimal_places}}}0*$'          # Case 4: Both are None (no restrictions)         else:             pattern += r'\\d*\\.?\\d*$'  # look for arbitrary integer or decimal          return pattern      json_schema = self.str_schema(core_schema.str_schema(pattern=get_decimal_pattern(schema)))     if self.mode == 'validation':         multiple_of = schema.get('multiple_of')         le = schema.get('le')         ge = schema.get('ge')         lt = schema.get('lt')         gt = schema.get('gt')         json_schema = {             'anyOf': [                 self.float_schema(                     core_schema.float_schema(                         allow_inf_nan=schema.get('allow_inf_nan'),                         multiple_of=None if multiple_of is None else float(multiple_of),                         le=None if le is None else float(le),                         ge=None if ge is None else float(ge),                         lt=None if lt is None else float(lt),                         gt=None if gt is None else float(gt),                     )                 ),                 json_schema,             ],         }     return json_schema ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#decimalschema-indexhtmlpydanticjsonschemageneratejsonschemadecimalschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "str\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.str_schema \"Permanent link\")", "anchor": "strschema-indexhtmlpydanticjsonschemageneratejsonschemastrschema-permanent-link", "md_text": "```\nstr_schema(schema: StringSchema) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches a string value.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `StringSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 ``` | ``` def str_schema(self, schema: core_schema.StringSchema) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches a string value.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     json_schema = {'type': 'string'}     self.update_with_validations(json_schema, schema, self.ValidationsMapping.string)     if isinstance(json_schema.get('pattern'), Pattern):         # TODO: should we add regex flags to the pattern?         json_schema['pattern'] = json_schema.get('pattern').pattern  # type: ignore     return json_schema ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#strschema-indexhtmlpydanticjsonschemageneratejsonschemastrschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "bytes\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.bytes_schema \"Permanent link\")", "anchor": "bytesschema-indexhtmlpydanticjsonschemageneratejsonschemabytesschema-permanent-link", "md_text": "```\nbytes_schema(schema: BytesSchema) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches a bytes value.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `BytesSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 772 773 774 775 776 777 778 779 780 781 782 783 ``` | ``` def bytes_schema(self, schema: core_schema.BytesSchema) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches a bytes value.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     json_schema = {'type': 'string', 'format': 'base64url' if self._config.ser_json_bytes == 'base64' else 'binary'}     self.update_with_validations(json_schema, schema, self.ValidationsMapping.bytes)     return json_schema ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#bytesschema-indexhtmlpydanticjsonschemageneratejsonschemabytesschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "date\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.date_schema \"Permanent link\")", "anchor": "dateschema-indexhtmlpydanticjsonschemageneratejsonschemadateschema-permanent-link", "md_text": "```\ndate_schema(schema: DateSchema) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches a date value.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `DateSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 785 786 787 788 789 790 791 792 793 794 ``` | ``` def date_schema(self, schema: core_schema.DateSchema) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches a date value.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     return {'type': 'string', 'format': 'date'} ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#dateschema-indexhtmlpydanticjsonschemageneratejsonschemadateschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "time\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.time_schema \"Permanent link\")", "anchor": "timeschema-indexhtmlpydanticjsonschemageneratejsonschematimeschema-permanent-link", "md_text": "```\ntime_schema(schema: TimeSchema) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches a time value.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `TimeSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 796 797 798 799 800 801 802 803 804 805 ``` | ``` def time_schema(self, schema: core_schema.TimeSchema) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches a time value.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     return {'type': 'string', 'format': 'time'} ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#timeschema-indexhtmlpydanticjsonschemageneratejsonschematimeschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "datetime\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.datetime_schema \"Permanent link\")", "anchor": "datetimeschema-indexhtmlpydanticjsonschemageneratejsonschemadatetimeschema-permanent-link", "md_text": "```\ndatetime_schema(schema: DatetimeSchema) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches a datetime value.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `DatetimeSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 807 808 809 810 811 812 813 814 815 816 ``` | ``` def datetime_schema(self, schema: core_schema.DatetimeSchema) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches a datetime value.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     return {'type': 'string', 'format': 'date-time'} ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#datetimeschema-indexhtmlpydanticjsonschemageneratejsonschemadatetimeschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "timedelta\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.timedelta_schema \"Permanent link\")", "anchor": "timedeltaschema-indexhtmlpydanticjsonschemageneratejsonschematimedeltaschema-permanent-link", "md_text": "```\ntimedelta_schema(\n    schema: TimedeltaSchema,\n) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches a timedelta value.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `TimedeltaSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 818 819 820 821 822 823 824 825 826 827 828 829 ``` | ``` def timedelta_schema(self, schema: core_schema.TimedeltaSchema) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches a timedelta value.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     if self._config.ser_json_timedelta == 'float':         return {'type': 'number'}     return {'type': 'string', 'format': 'duration'} ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#timedeltaschema-indexhtmlpydanticjsonschemageneratejsonschematimedeltaschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "literal\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.literal_schema \"Permanent link\")", "anchor": "literalschema-indexhtmlpydanticjsonschemageneratejsonschemaliteralschema-permanent-link", "md_text": "```\nliteral_schema(schema: LiteralSchema) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches a literal value.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `LiteralSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 ``` | ``` def literal_schema(self, schema: core_schema.LiteralSchema) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches a literal value.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     expected = [to_jsonable_python(v.value if isinstance(v, Enum) else v) for v in schema['expected']]      result: dict[str, Any] = {}     if len(expected) == 1:         result['const'] = expected[0]     else:         result['enum'] = expected      types = {type(e) for e in expected}     if types == {str}:         result['type'] = 'string'     elif types == {int}:         result['type'] = 'integer'     elif types == {float}:         result['type'] = 'number'     elif types == {bool}:         result['type'] = 'boolean'     elif types == {list}:         result['type'] = 'array'     elif types == {type(None)}:         result['type'] = 'null'     return result ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#literalschema-indexhtmlpydanticjsonschemageneratejsonschemaliteralschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "missing\\_sentinel\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.missing_sentinel_schema \"Permanent link\")", "anchor": "missingsentinelschema-indexhtmlpydanticjsonschemageneratejsonschemamissingsentinelschema-permanent-link", "md_text": "```\nmissing_sentinel_schema(\n    schema: MissingSentinelSchema,\n) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches the `MISSING` sentinel value.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `MissingSentinelSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 863 864 865 866 867 868 869 870 871 872 ``` | ``` def missing_sentinel_schema(self, schema: core_schema.MissingSentinelSchema) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches the `MISSING` sentinel value.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     raise PydanticOmit ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#missingsentinelschema-indexhtmlpydanticjsonschemageneratejsonschemamissingsentinelschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "enum\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.enum_schema \"Permanent link\")", "anchor": "enumschema-indexhtmlpydanticjsonschemageneratejsonschemaenumschema-permanent-link", "md_text": "```\nenum_schema(schema: EnumSchema) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches an Enum value.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `EnumSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 ``` | ``` def enum_schema(self, schema: core_schema.EnumSchema) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches an Enum value.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     enum_type = schema['cls']     description = None if not enum_type.__doc__ else inspect.cleandoc(enum_type.__doc__)     if (         description == 'An enumeration.'     ):  # This is the default value provided by enum.EnumMeta.__new__; don't use it         description = None     result: dict[str, Any] = {'title': enum_type.__name__, 'description': description}     result = {k: v for k, v in result.items() if v is not None}      expected = [to_jsonable_python(v.value) for v in schema['members']]      result['enum'] = expected      types = {type(e) for e in expected}     if isinstance(enum_type, str) or types == {str}:         result['type'] = 'string'     elif isinstance(enum_type, int) or types == {int}:         result['type'] = 'integer'     elif isinstance(enum_type, float) or types == {float}:         result['type'] = 'number'     elif types == {bool}:         result['type'] = 'boolean'     elif types == {list}:         result['type'] = 'array'      return result ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#enumschema-indexhtmlpydanticjsonschemageneratejsonschemaenumschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "is\\_instance\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.is_instance_schema \"Permanent link\")", "anchor": "isinstanceschema-indexhtmlpydanticjsonschemageneratejsonschemaisinstanceschema-permanent-link", "md_text": "```\nis_instance_schema(\n    schema: IsInstanceSchema,\n) -> JsonSchemaValue\n```\n\nHandles JSON schema generation for a core schema that checks if a value is an instance of a class.\n\nUnless overridden in a subclass, this raises an error.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `IsInstanceSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 910 911 912 913 914 915 916 917 918 919 920 921 ``` | ``` def is_instance_schema(self, schema: core_schema.IsInstanceSchema) -> JsonSchemaValue:     \"\"\"Handles JSON schema generation for a core schema that checks if a value is an instance of a class.      Unless overridden in a subclass, this raises an error.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     return self.handle_invalid_for_json_schema(schema, f'core_schema.IsInstanceSchema ({schema[\"cls\"]})') ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#isinstanceschema-indexhtmlpydanticjsonschemageneratejsonschemaisinstanceschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "is\\_subclass\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.is_subclass_schema \"Permanent link\")", "anchor": "issubclassschema-indexhtmlpydanticjsonschemageneratejsonschemaissubclassschema-permanent-link", "md_text": "```\nis_subclass_schema(\n    schema: IsSubclassSchema,\n) -> JsonSchemaValue\n```\n\nHandles JSON schema generation for a core schema that checks if a value is a subclass of a class.\n\nFor backwards compatibility with v1, this does not raise an error, but can be overridden to change this.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `IsSubclassSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 923 924 925 926 927 928 929 930 931 932 933 934 935 ``` | ``` def is_subclass_schema(self, schema: core_schema.IsSubclassSchema) -> JsonSchemaValue:     \"\"\"Handles JSON schema generation for a core schema that checks if a value is a subclass of a class.      For backwards compatibility with v1, this does not raise an error, but can be overridden to change this.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     # Note: This is for compatibility with V1; you can override if you want different behavior.     return {} ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#issubclassschema-indexhtmlpydanticjsonschemageneratejsonschemaissubclassschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "callable\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.callable_schema \"Permanent link\")", "anchor": "callableschema-indexhtmlpydanticjsonschemageneratejsonschemacallableschema-permanent-link", "md_text": "```\ncallable_schema(schema: CallableSchema) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches a callable value.\n\nUnless overridden in a subclass, this raises an error.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `CallableSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 937 938 939 940 941 942 943 944 945 946 947 948 ``` | ``` def callable_schema(self, schema: core_schema.CallableSchema) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches a callable value.      Unless overridden in a subclass, this raises an error.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     return self.handle_invalid_for_json_schema(schema, 'core_schema.CallableSchema') ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#callableschema-indexhtmlpydanticjsonschemageneratejsonschemacallableschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "list\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.list_schema \"Permanent link\")", "anchor": "listschema-indexhtmlpydanticjsonschemageneratejsonschemalistschema-permanent-link", "md_text": "```\nlist_schema(schema: ListSchema) -> JsonSchemaValue\n```\n\nReturns a schema that matches a list schema.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `ListSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 950 951 952 953 954 955 956 957 958 959 960 961 962 ``` | ``` def list_schema(self, schema: core_schema.ListSchema) -> JsonSchemaValue:     \"\"\"Returns a schema that matches a list schema.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     items_schema = {} if 'items_schema' not in schema else self.generate_inner(schema['items_schema'])     json_schema = {'type': 'array', 'items': items_schema}     self.update_with_validations(json_schema, schema, self.ValidationsMapping.array)     return json_schema ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#listschema-indexhtmlpydanticjsonschemageneratejsonschemalistschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "tuple\\_positional\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.tuple_positional_schema \"Permanent link\")", "anchor": "tuplepositionalschema-indexhtmlpydanticjsonschemageneratejsonschematuplepositionalschema-permanent-link", "md_text": "```\ntuple_positional_schema(\n    schema: TupleSchema,\n) -> JsonSchemaValue\n```\n\nReplaced by `tuple_schema`.\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 964 965 966 967 968 969 970 971 972 973 ``` | ``` @deprecated('`tuple_positional_schema` is deprecated. Use `tuple_schema` instead.', category=None) @final def tuple_positional_schema(self, schema: core_schema.TupleSchema) -> JsonSchemaValue:     \"\"\"Replaced by `tuple_schema`.\"\"\"     warnings.warn(         '`tuple_positional_schema` is deprecated. Use `tuple_schema` instead.',         PydanticDeprecatedSince26,         stacklevel=2,     )     return self.tuple_schema(schema) ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#tuplepositionalschema-indexhtmlpydanticjsonschemageneratejsonschematuplepositionalschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "tuple\\_variable\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.tuple_variable_schema \"Permanent link\")", "anchor": "tuplevariableschema-indexhtmlpydanticjsonschemageneratejsonschematuplevariableschema-permanent-link", "md_text": "```\ntuple_variable_schema(\n    schema: TupleSchema,\n) -> JsonSchemaValue\n```\n\nReplaced by `tuple_schema`.\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 975 976 977 978 979 980 981 982 983 984 ``` | ``` @deprecated('`tuple_variable_schema` is deprecated. Use `tuple_schema` instead.', category=None) @final def tuple_variable_schema(self, schema: core_schema.TupleSchema) -> JsonSchemaValue:     \"\"\"Replaced by `tuple_schema`.\"\"\"     warnings.warn(         '`tuple_variable_schema` is deprecated. Use `tuple_schema` instead.',         PydanticDeprecatedSince26,         stacklevel=2,     )     return self.tuple_schema(schema) ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#tuplevariableschema-indexhtmlpydanticjsonschemageneratejsonschematuplevariableschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "tuple\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.tuple_schema \"Permanent link\")", "anchor": "tupleschema-indexhtmlpydanticjsonschemageneratejsonschematupleschema-permanent-link", "md_text": "```\ntuple_schema(schema: TupleSchema) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches a tuple schema e.g. `tuple[int,\nstr, bool]` or `tuple[int, ...]`.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `TupleSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ```  986  987  988  989  990  991  992  993  994  995  996  997  998  999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 ``` | ``` def tuple_schema(self, schema: core_schema.TupleSchema) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches a tuple schema e.g. `tuple[int,     str, bool]` or `tuple[int, ...]`.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     json_schema: JsonSchemaValue = {'type': 'array'}     if 'variadic_item_index' in schema:         variadic_item_index = schema['variadic_item_index']         if variadic_item_index > 0:             json_schema['minItems'] = variadic_item_index             json_schema['prefixItems'] = [                 self.generate_inner(item) for item in schema['items_schema'][:variadic_item_index]             ]         if variadic_item_index + 1 == len(schema['items_schema']):             # if the variadic item is the last item, then represent it faithfully             json_schema['items'] = self.generate_inner(schema['items_schema'][variadic_item_index])         else:             # otherwise, 'items' represents the schema for the variadic             # item plus the suffix, so just allow anything for simplicity             # for now             json_schema['items'] = True     else:         prefixItems = [self.generate_inner(item) for item in schema['items_schema']]         if prefixItems:             json_schema['prefixItems'] = prefixItems         json_schema['minItems'] = len(prefixItems)         json_schema['maxItems'] = len(prefixItems)     self.update_with_validations(json_schema, schema, self.ValidationsMapping.array)     return json_schema ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#tupleschema-indexhtmlpydanticjsonschemageneratejsonschematupleschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "set\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.set_schema \"Permanent link\")", "anchor": "setschema-indexhtmlpydanticjsonschemageneratejsonschemasetschema-permanent-link", "md_text": "```\nset_schema(schema: SetSchema) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches a set schema.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `SetSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 ``` | ``` def set_schema(self, schema: core_schema.SetSchema) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches a set schema.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     return self._common_set_schema(schema) ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#setschema-indexhtmlpydanticjsonschemageneratejsonschemasetschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "frozenset\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.frozenset_schema \"Permanent link\")", "anchor": "frozensetschema-indexhtmlpydanticjsonschemageneratejsonschemafrozensetschema-permanent-link", "md_text": "```\nfrozenset_schema(\n    schema: FrozenSetSchema,\n) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches a frozenset schema.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `FrozenSetSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 ``` | ``` def frozenset_schema(self, schema: core_schema.FrozenSetSchema) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches a frozenset schema.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     return self._common_set_schema(schema) ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#frozensetschema-indexhtmlpydanticjsonschemageneratejsonschemafrozensetschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "generator\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.generator_schema \"Permanent link\")", "anchor": "generatorschema-indexhtmlpydanticjsonschemageneratejsonschemageneratorschema-permanent-link", "md_text": "```\ngenerator_schema(\n    schema: GeneratorSchema,\n) -> JsonSchemaValue\n```\n\nReturns a JSON schema that represents the provided GeneratorSchema.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `GeneratorSchema` | The schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 ``` | ``` def generator_schema(self, schema: core_schema.GeneratorSchema) -> JsonSchemaValue:     \"\"\"Returns a JSON schema that represents the provided GeneratorSchema.      Args:         schema: The schema.      Returns:         The generated JSON schema.     \"\"\"     items_schema = {} if 'items_schema' not in schema else self.generate_inner(schema['items_schema'])     json_schema = {'type': 'array', 'items': items_schema}     self.update_with_validations(json_schema, schema, self.ValidationsMapping.array)     return json_schema ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#generatorschema-indexhtmlpydanticjsonschemageneratejsonschemageneratorschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "dict\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.dict_schema \"Permanent link\")", "anchor": "dictschema-indexhtmlpydanticjsonschemageneratejsonschemadictschema-permanent-link", "md_text": "```\ndict_schema(schema: DictSchema) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches a dict schema.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `DictSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 ``` | ``` def dict_schema(self, schema: core_schema.DictSchema) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches a dict schema.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     json_schema: JsonSchemaValue = {'type': 'object'}      keys_schema = self.generate_inner(schema['keys_schema']).copy() if 'keys_schema' in schema else {}     if '$ref' not in keys_schema:         keys_pattern = keys_schema.pop('pattern', None)         # Don't give a title to patternProperties/propertyNames:         keys_schema.pop('title', None)     else:         # Here, we assume that if the keys schema is a definition reference,         # it can't be a simple string core schema (and thus no pattern can exist).         # However, this is only in practice (in theory, a definition reference core         # schema could be generated for a simple string schema).         # Note that we avoid calling `self.resolve_ref_schema`, as it might not exist yet.         keys_pattern = None      values_schema = self.generate_inner(schema['values_schema']).copy() if 'values_schema' in schema else {}     # don't give a title to additionalProperties:     values_schema.pop('title', None)      if values_schema or keys_pattern is not None:         if keys_pattern is None:             json_schema['additionalProperties'] = values_schema         else:             json_schema['patternProperties'] = {keys_pattern: values_schema}     else:  # for `dict[str, Any]`, we allow any key and any value, since `str` is the default key type         json_schema['additionalProperties'] = True      if (         # The len check indicates that constraints are probably present:         (keys_schema.get('type') == 'string' and len(keys_schema) > 1)         # If this is a definition reference schema, it most likely has constraints:         or '$ref' in keys_schema     ):         keys_schema.pop('type', None)         json_schema['propertyNames'] = keys_schema      self.update_with_validations(json_schema, schema, self.ValidationsMapping.object)     return json_schema ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#dictschema-indexhtmlpydanticjsonschemageneratejsonschemadictschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "function\\_before\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.function_before_schema \"Permanent link\")", "anchor": "functionbeforeschema-indexhtmlpydanticjsonschemageneratejsonschemafunctionbeforeschema-permanent-link", "md_text": "```\nfunction_before_schema(\n    schema: BeforeValidatorFunctionSchema,\n) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches a function-before schema.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `BeforeValidatorFunctionSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 ``` | ``` def function_before_schema(self, schema: core_schema.BeforeValidatorFunctionSchema) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches a function-before schema.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     if self.mode == 'validation' and (input_schema := schema.get('json_schema_input_schema')):         return self.generate_inner(input_schema)      return self.generate_inner(schema['schema']) ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#functionbeforeschema-indexhtmlpydanticjsonschemageneratejsonschemafunctionbeforeschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "function\\_after\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.function_after_schema \"Permanent link\")", "anchor": "functionafterschema-indexhtmlpydanticjsonschemageneratejsonschemafunctionafterschema-permanent-link", "md_text": "```\nfunction_after_schema(\n    schema: AfterValidatorFunctionSchema,\n) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches a function-after schema.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `AfterValidatorFunctionSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 ``` | ``` def function_after_schema(self, schema: core_schema.AfterValidatorFunctionSchema) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches a function-after schema.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     return self.generate_inner(schema['schema']) ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#functionafterschema-indexhtmlpydanticjsonschemageneratejsonschemafunctionafterschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "function\\_plain\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.function_plain_schema \"Permanent link\")", "anchor": "functionplainschema-indexhtmlpydanticjsonschemageneratejsonschemafunctionplainschema-permanent-link", "md_text": "```\nfunction_plain_schema(\n    schema: PlainValidatorFunctionSchema,\n) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches a function-plain schema.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `PlainValidatorFunctionSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 ``` | ``` def function_plain_schema(self, schema: core_schema.PlainValidatorFunctionSchema) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches a function-plain schema.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     if self.mode == 'validation' and (input_schema := schema.get('json_schema_input_schema')):         return self.generate_inner(input_schema)      return self.handle_invalid_for_json_schema(         schema, f'core_schema.PlainValidatorFunctionSchema ({schema[\"function\"]})'     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#functionplainschema-indexhtmlpydanticjsonschemageneratejsonschemafunctionplainschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "function\\_wrap\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.function_wrap_schema \"Permanent link\")", "anchor": "functionwrapschema-indexhtmlpydanticjsonschemageneratejsonschemafunctionwrapschema-permanent-link", "md_text": "```\nfunction_wrap_schema(\n    schema: WrapValidatorFunctionSchema,\n) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches a function-wrap schema.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `WrapValidatorFunctionSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 ``` | ``` def function_wrap_schema(self, schema: core_schema.WrapValidatorFunctionSchema) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches a function-wrap schema.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     if self.mode == 'validation' and (input_schema := schema.get('json_schema_input_schema')):         return self.generate_inner(input_schema)      return self.generate_inner(schema['schema']) ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#functionwrapschema-indexhtmlpydanticjsonschemageneratejsonschemafunctionwrapschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "default\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.default_schema \"Permanent link\")", "anchor": "defaultschema-indexhtmlpydanticjsonschemageneratejsonschemadefaultschema-permanent-link", "md_text": "```\ndefault_schema(\n    schema: WithDefaultSchema,\n) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches a schema with a default value.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `WithDefaultSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 ``` | ``` def default_schema(self, schema: core_schema.WithDefaultSchema) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches a schema with a default value.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     json_schema = self.generate_inner(schema['schema'])      default = self.get_default_value(schema)     if default is NoDefault or default is MISSING:         return json_schema      # we reflect the application of custom plain, no-info serializers to defaults for     # JSON Schemas viewed in serialization mode:     # TODO: improvements along with https://github.com/pydantic/pydantic/issues/8208     if self.mode == 'serialization':         # `_get_ser_schema_for_default_value()` is used to unpack potentially nested validator schemas:         ser_schema = _get_ser_schema_for_default_value(schema['schema'])         if (             ser_schema is not None             and (ser_func := ser_schema.get('function'))             and not (default is None and ser_schema.get('when_used') in ('unless-none', 'json-unless-none'))         ):             try:                 default = ser_func(default)  # type: ignore             except Exception:                 # It might be that the provided default needs to be validated (read: parsed) first                 # (assuming `validate_default` is enabled). However, we can't perform                 # such validation during JSON Schema generation so we don't support                 # this pattern for now.                 # (One example is when using `foo: ByteSize = '1MB'`, which validates and                 # serializes as an int. In this case, `ser_func` is `int` and `int('1MB')` fails).                 self.emit_warning(                     'non-serializable-default',                     f'Unable to serialize value {default!r} with the plain serializer; excluding default from JSON schema',                 )                 return json_schema      try:         encoded_default = self.encode_default(default)     except pydantic_core.PydanticSerializationError:         self.emit_warning(             'non-serializable-default',             f'Default value {default} is not JSON serializable; excluding default from JSON schema',         )         # Return the inner schema, as though there was no default         return json_schema      json_schema['default'] = encoded_default     return json_schema ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#defaultschema-indexhtmlpydanticjsonschemageneratejsonschemadefaultschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "get\\_default\\_value [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.get_default_value \"Permanent link\")", "anchor": "getdefaultvalue-indexhtmlpydanticjsonschemageneratejsonschemagetdefaultvalue-permanent-link", "md_text": "```\nget_default_value(schema: WithDefaultSchema) -> Any\n```\n\nGet the default value to be used when generating a JSON Schema for a core schema with a default.\n\nThe default implementation is to use the statically defined default value. This method can be overridden\nif you want to make use of the default factory.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `WithDefaultSchema` | The `'with-default'` core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `Any` | The default value to use, or [`NoDefault`](index.html#pydantic.json_schema.NoDefault) if no default value is available. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 ``` | ``` def get_default_value(self, schema: core_schema.WithDefaultSchema) -> Any:     \"\"\"Get the default value to be used when generating a JSON Schema for a core schema with a default.      The default implementation is to use the statically defined default value. This method can be overridden     if you want to make use of the default factory.      Args:         schema: The `'with-default'` core schema.      Returns:         The default value to use, or [`NoDefault`][pydantic.json_schema.NoDefault] if no default             value is available.     \"\"\"     return schema.get('default', NoDefault) ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#getdefaultvalue-indexhtmlpydanticjsonschemageneratejsonschemagetdefaultvalue-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "nullable\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.nullable_schema \"Permanent link\")", "anchor": "nullableschema-indexhtmlpydanticjsonschemageneratejsonschemanullableschema-permanent-link", "md_text": "```\nnullable_schema(schema: NullableSchema) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches a schema that allows null values.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `NullableSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 ``` | ``` def nullable_schema(self, schema: core_schema.NullableSchema) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches a schema that allows null values.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     null_schema = {'type': 'null'}     inner_json_schema = self.generate_inner(schema['schema'])      if inner_json_schema == null_schema:         return null_schema     else:         return self.get_union_of_schemas([inner_json_schema, null_schema]) ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#nullableschema-indexhtmlpydanticjsonschemageneratejsonschemanullableschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "union\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.union_schema \"Permanent link\")", "anchor": "unionschema-indexhtmlpydanticjsonschemageneratejsonschemaunionschema-permanent-link", "md_text": "```\nunion_schema(schema: UnionSchema) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches a schema that allows values matching any of the given schemas.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `UnionSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 ``` | ``` def union_schema(self, schema: core_schema.UnionSchema) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches a schema that allows values matching any of the given schemas.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     generated: list[JsonSchemaValue] = []      choices = schema['choices']     for choice in choices:         # choice will be a tuple if an explicit label was provided         choice_schema = choice[0] if isinstance(choice, tuple) else choice         try:             generated.append(self.generate_inner(choice_schema))         except PydanticOmit:             continue         except PydanticInvalidForJsonSchema as exc:             self.emit_warning('skipped-choice', exc.message)     if len(generated) == 1:         return generated[0]     return self.get_union_of_schemas(generated) ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#unionschema-indexhtmlpydanticjsonschemageneratejsonschemaunionschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "get\\_union\\_of\\_schemas [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.get_union_of_schemas \"Permanent link\")", "anchor": "getunionofschemas-indexhtmlpydanticjsonschemageneratejsonschemagetunionofschemas-permanent-link", "md_text": "```\nget_union_of_schemas(\n    schemas: list[JsonSchemaValue],\n) -> JsonSchemaValue\n```\n\nReturns the JSON Schema representation for the union of the provided JSON Schemas.\n\nThe result depends on the configured `'union_format'`.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schemas` | `list[JsonSchemaValue]` | The list of JSON Schemas to be included in the union. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The JSON Schema representing the union of schemas. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 ``` | ``` def get_union_of_schemas(self, schemas: list[JsonSchemaValue]) -> JsonSchemaValue:     \"\"\"Returns the JSON Schema representation for the union of the provided JSON Schemas.      The result depends on the configured `'union_format'`.      Args:         schemas: The list of JSON Schemas to be included in the union.      Returns:         The JSON Schema representing the union of schemas.     \"\"\"     if self.union_format == 'primitive_type_array':         types: list[str] = []         for schema in schemas:             schema_types: list[str] | str | None = schema.get('type')             if schema_types is None:                 # No type, meaning it can be a ref or an empty schema.                 break             if not isinstance(schema_types, list):                 schema_types = [schema_types]             if not all(t in _PRIMITIVE_JSON_SCHEMA_TYPES for t in schema_types):                 break             if len(schema) != 1:                 # We only want to include types that don't have any constraints. For instance,                 # if `schemas = [{'type': 'string', 'maxLength': 3}, {'type': 'string', 'minLength': 5}]`,                 # we don't want to produce `{'type': 'string', 'maxLength': 3, 'minLength': 5}`.                 # Same if we have some metadata (e.g. `title`) on a specific union member, we want to preserve it.                 break              types.extend(schema_types)         else:             # If we got there, all the schemas where valid to be used with the `'primitive_type_array` format             return {'type': list(dict.fromkeys(types))}      return self.get_flattened_anyof(schemas) ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#getunionofschemas-indexhtmlpydanticjsonschemageneratejsonschemagetunionofschemas-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "tagged\\_union\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.tagged_union_schema \"Permanent link\")", "anchor": "taggedunionschema-indexhtmlpydanticjsonschemageneratejsonschemataggedunionschema-permanent-link", "md_text": "```\ntagged_union_schema(\n    schema: TaggedUnionSchema,\n) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches a schema that allows values matching any of the given schemas, where\nthe schemas are tagged with a discriminator field that indicates which schema should be used to validate\nthe value.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `TaggedUnionSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 ``` | ``` def tagged_union_schema(self, schema: core_schema.TaggedUnionSchema) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches a schema that allows values matching any of the given schemas, where     the schemas are tagged with a discriminator field that indicates which schema should be used to validate     the value.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     generated: dict[str, JsonSchemaValue] = {}     for k, v in schema['choices'].items():         if isinstance(k, Enum):             k = k.value         try:             # Use str(k) since keys must be strings for json; while not technically correct,             # it's the closest that can be represented in valid JSON             generated[str(k)] = self.generate_inner(v).copy()         except PydanticOmit:             continue         except PydanticInvalidForJsonSchema as exc:             self.emit_warning('skipped-choice', exc.message)      one_of_choices = _deduplicate_schemas(generated.values())     json_schema: JsonSchemaValue = {'oneOf': one_of_choices}      # This reflects the v1 behavior; TODO: we should make it possible to exclude OpenAPI stuff from the JSON schema     openapi_discriminator = self._extract_discriminator(schema, one_of_choices)     if openapi_discriminator is not None:         json_schema['discriminator'] = {             'propertyName': openapi_discriminator,             'mapping': {k: v.get('$ref', v) for k, v in generated.items()},         }      return json_schema ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#taggedunionschema-indexhtmlpydanticjsonschemageneratejsonschemataggedunionschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "chain\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.chain_schema \"Permanent link\")", "anchor": "chainschema-indexhtmlpydanticjsonschemageneratejsonschemachainschema-permanent-link", "md_text": "```\nchain_schema(schema: ChainSchema) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches a core\\_schema.ChainSchema.\n\nWhen generating a schema for validation, we return the validation JSON schema for the first step in the chain.\nFor serialization, we return the serialization JSON schema for the last step in the chain.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `ChainSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 ``` | ``` def chain_schema(self, schema: core_schema.ChainSchema) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches a core_schema.ChainSchema.      When generating a schema for validation, we return the validation JSON schema for the first step in the chain.     For serialization, we return the serialization JSON schema for the last step in the chain.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     step_index = 0 if self.mode == 'validation' else -1  # use first step for validation, last for serialization     return self.generate_inner(schema['steps'][step_index]) ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#chainschema-indexhtmlpydanticjsonschemageneratejsonschemachainschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "lax\\_or\\_strict\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.lax_or_strict_schema \"Permanent link\")", "anchor": "laxorstrictschema-indexhtmlpydanticjsonschemageneratejsonschemalaxorstrictschema-permanent-link", "md_text": "```\nlax_or_strict_schema(\n    schema: LaxOrStrictSchema,\n) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches a schema that allows values matching either the lax schema or the\nstrict schema.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `LaxOrStrictSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 ``` | ``` def lax_or_strict_schema(self, schema: core_schema.LaxOrStrictSchema) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches a schema that allows values matching either the lax schema or the     strict schema.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     # TODO: Need to read the default value off of model config or whatever     use_strict = schema.get('strict', False)  # TODO: replace this default False     # If your JSON schema fails to generate it is probably     # because one of the following two branches failed.     if use_strict:         return self.generate_inner(schema['strict_schema'])     else:         return self.generate_inner(schema['lax_schema']) ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#laxorstrictschema-indexhtmlpydanticjsonschemageneratejsonschemalaxorstrictschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "json\\_or\\_python\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.json_or_python_schema \"Permanent link\")", "anchor": "jsonorpythonschema-indexhtmlpydanticjsonschemageneratejsonschemajsonorpythonschema-permanent-link", "md_text": "```\njson_or_python_schema(\n    schema: JsonOrPythonSchema,\n) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches a schema that allows values matching either the JSON schema or the\nPython schema.\n\nThe JSON schema is used instead of the Python schema. If you want to use the Python schema, you should override\nthis method.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `JsonOrPythonSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 ``` | ``` def json_or_python_schema(self, schema: core_schema.JsonOrPythonSchema) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches a schema that allows values matching either the JSON schema or the     Python schema.      The JSON schema is used instead of the Python schema. If you want to use the Python schema, you should override     this method.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     return self.generate_inner(schema['json_schema']) ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#jsonorpythonschema-indexhtmlpydanticjsonschemageneratejsonschemajsonorpythonschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "typed\\_dict\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.typed_dict_schema \"Permanent link\")", "anchor": "typeddictschema-indexhtmlpydanticjsonschemageneratejsonschematypeddictschema-permanent-link", "md_text": "```\ntyped_dict_schema(\n    schema: TypedDictSchema,\n) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches a schema that defines a typed dict.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `TypedDictSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 ``` | ``` def typed_dict_schema(self, schema: core_schema.TypedDictSchema) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches a schema that defines a typed dict.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     total = schema.get('total', True)     named_required_fields: list[tuple[str, bool, CoreSchemaField]] = [         (name, self.field_is_required(field, total), field)         for name, field in schema['fields'].items()         if self.field_is_present(field)     ]     if self.mode == 'serialization':         named_required_fields.extend(self._name_required_computed_fields(schema.get('computed_fields', [])))     cls = schema.get('cls')     config = _get_typed_dict_config(cls)     with self._config_wrapper_stack.push(config):         json_schema = self._named_required_fields_schema(named_required_fields)      # There's some duplication between `extra_behavior` and     # the config's `extra`/core config's `extra_fields_behavior`.     # However, it is common to manually create TypedDictSchemas,     # where you don't necessarily have a class.     # At runtime, `extra_behavior` takes priority over the config     # for validation, so follow the same for the JSON Schema:     if schema.get('extra_behavior') == 'forbid':         json_schema['additionalProperties'] = False     elif schema.get('extra_behavior') == 'allow':         if 'extras_schema' in schema and schema['extras_schema'] != {'type': 'any'}:             json_schema['additionalProperties'] = self.generate_inner(schema['extras_schema'])         else:             json_schema['additionalProperties'] = True      if cls is not None:         # `_update_class_schema()` will not override         # `additionalProperties` if already present:         self._update_class_schema(json_schema, cls, config)     elif 'additionalProperties' not in json_schema:         extra = schema.get('config', {}).get('extra_fields_behavior')         if extra == 'forbid':             json_schema['additionalProperties'] = False         elif extra == 'allow':             json_schema['additionalProperties'] = True      return json_schema ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#typeddictschema-indexhtmlpydanticjsonschemageneratejsonschematypeddictschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "typed\\_dict\\_field\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.typed_dict_field_schema \"Permanent link\")", "anchor": "typeddictfieldschema-indexhtmlpydanticjsonschemageneratejsonschematypeddictfieldschema-permanent-link", "md_text": "```\ntyped_dict_field_schema(\n    schema: TypedDictField,\n) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches a schema that defines a typed dict field.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `TypedDictField` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1545 1546 1547 1548 1549 1550 1551 1552 1553 1554 ``` | ``` def typed_dict_field_schema(self, schema: core_schema.TypedDictField) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches a schema that defines a typed dict field.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     return self.generate_inner(schema['schema']) ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#typeddictfieldschema-indexhtmlpydanticjsonschemageneratejsonschematypeddictfieldschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "dataclass\\_field\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.dataclass_field_schema \"Permanent link\")", "anchor": "dataclassfieldschema-indexhtmlpydanticjsonschemageneratejsonschemadataclassfieldschema-permanent-link", "md_text": "```\ndataclass_field_schema(\n    schema: DataclassField,\n) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches a schema that defines a dataclass field.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `DataclassField` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 ``` | ``` def dataclass_field_schema(self, schema: core_schema.DataclassField) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches a schema that defines a dataclass field.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     return self.generate_inner(schema['schema']) ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#dataclassfieldschema-indexhtmlpydanticjsonschemageneratejsonschemadataclassfieldschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "model\\_field\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.model_field_schema \"Permanent link\")", "anchor": "modelfieldschema-indexhtmlpydanticjsonschemageneratejsonschemamodelfieldschema-permanent-link", "md_text": "```\nmodel_field_schema(schema: ModelField) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches a schema that defines a model field.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `ModelField` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 ``` | ``` def model_field_schema(self, schema: core_schema.ModelField) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches a schema that defines a model field.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     return self.generate_inner(schema['schema']) ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#modelfieldschema-indexhtmlpydanticjsonschemageneratejsonschemamodelfieldschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "computed\\_field\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.computed_field_schema \"Permanent link\")", "anchor": "computedfieldschema-indexhtmlpydanticjsonschemageneratejsonschemacomputedfieldschema-permanent-link", "md_text": "```\ncomputed_field_schema(\n    schema: ComputedField,\n) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches a schema that defines a computed field.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `ComputedField` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 ``` | ``` def computed_field_schema(self, schema: core_schema.ComputedField) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches a schema that defines a computed field.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     return self.generate_inner(schema['return_schema']) ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#computedfieldschema-indexhtmlpydanticjsonschemageneratejsonschemacomputedfieldschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "model\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.model_schema \"Permanent link\")", "anchor": "modelschema-indexhtmlpydanticjsonschemageneratejsonschemamodelschema-permanent-link", "md_text": "```\nmodel_schema(schema: ModelSchema) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches a schema that defines a model.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `ModelSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 ``` | ``` def model_schema(self, schema: core_schema.ModelSchema) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches a schema that defines a model.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     # We do not use schema['model'].model_json_schema() here     # because it could lead to inconsistent refs handling, etc.     cls = cast('type[BaseModel]', schema['cls'])     config = cls.model_config      with self._config_wrapper_stack.push(config):         json_schema = self.generate_inner(schema['schema'])      self._update_class_schema(json_schema, cls, config)      return json_schema ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#modelschema-indexhtmlpydanticjsonschemageneratejsonschemamodelschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "resolve\\_ref\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.resolve_ref_schema \"Permanent link\")", "anchor": "resolverefschema-indexhtmlpydanticjsonschemageneratejsonschemaresolverefschema-permanent-link", "md_text": "```\nresolve_ref_schema(\n    json_schema: JsonSchemaValue,\n) -> JsonSchemaValue\n```\n\nResolve a JsonSchemaValue to the non-ref schema if it is a $ref schema.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `json_schema` | `JsonSchemaValue` | The schema to resolve. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The resolved schema. |\n\nRaises:\n\n| Type | Description |\n| --- | --- |\n| `RuntimeError` | If the schema reference can't be found in definitions. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1681 1682 1683 1684 1685 1686 1687 1688 1689 1690 1691 1692 1693 1694 1695 1696 1697 1698 1699 ``` | ``` def resolve_ref_schema(self, json_schema: JsonSchemaValue) -> JsonSchemaValue:     \"\"\"Resolve a JsonSchemaValue to the non-ref schema if it is a $ref schema.      Args:         json_schema: The schema to resolve.      Returns:         The resolved schema.      Raises:         RuntimeError: If the schema reference can't be found in definitions.     \"\"\"     while '$ref' in json_schema:         ref = json_schema['$ref']         schema_to_update = self.get_schema_from_definitions(JsonRef(ref))         if schema_to_update is None:             raise RuntimeError(f'Cannot update undefined schema for $ref={ref}')         json_schema = schema_to_update     return json_schema ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#resolverefschema-indexhtmlpydanticjsonschemageneratejsonschemaresolverefschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "model\\_fields\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.model_fields_schema \"Permanent link\")", "anchor": "modelfieldsschema-indexhtmlpydanticjsonschemageneratejsonschemamodelfieldsschema-permanent-link", "md_text": "```\nmodel_fields_schema(\n    schema: ModelFieldsSchema,\n) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches a schema that defines a model's fields.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `ModelFieldsSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711 1712 1713 1714 1715 1716 1717 1718 1719 1720 1721 1722 ``` | ``` def model_fields_schema(self, schema: core_schema.ModelFieldsSchema) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches a schema that defines a model's fields.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     named_required_fields: list[tuple[str, bool, CoreSchemaField]] = [         (name, self.field_is_required(field, total=True), field)         for name, field in schema['fields'].items()         if self.field_is_present(field)     ]     if self.mode == 'serialization':         named_required_fields.extend(self._name_required_computed_fields(schema.get('computed_fields', [])))     json_schema = self._named_required_fields_schema(named_required_fields)     extras_schema = schema.get('extras_schema', None)     if extras_schema is not None:         schema_to_update = self.resolve_ref_schema(json_schema)         schema_to_update['additionalProperties'] = self.generate_inner(extras_schema)     return json_schema ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#modelfieldsschema-indexhtmlpydanticjsonschemageneratejsonschemamodelfieldsschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "field\\_is\\_present [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.field_is_present \"Permanent link\")", "anchor": "fieldispresent-indexhtmlpydanticjsonschemageneratejsonschemafieldispresent-permanent-link", "md_text": "```\nfield_is_present(field: CoreSchemaField) -> bool\n```\n\nWhether the field should be included in the generated JSON schema.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `field` | `CoreSchemaField` | The schema for the field itself. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `bool` | `True` if the field should be included in the generated JSON schema, `False` otherwise. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1738 1739 1740 ``` | ``` def field_is_present(self, field: CoreSchemaField) -> bool:     \"\"\"Whether the field should be included in the generated JSON schema.      Args:         field: The schema for the field itself.      Returns:         `True` if the field should be included in the generated JSON schema, `False` otherwise.     \"\"\"     if self.mode == 'serialization':         # If you still want to include the field in the generated JSON schema,         # override this method and return True         return not field.get('serialization_exclude')     elif self.mode == 'validation':         return True     else:         assert_never(self.mode) ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#fieldispresent-indexhtmlpydanticjsonschemageneratejsonschemafieldispresent-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "field\\_is\\_required [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.field_is_required \"Permanent link\")", "anchor": "fieldisrequired-indexhtmlpydanticjsonschemageneratejsonschemafieldisrequired-permanent-link", "md_text": "```\nfield_is_required(\n    field: ModelField | DataclassField | TypedDictField,\n    total: bool,\n) -> bool\n```\n\nWhether the field should be marked as required in the generated JSON schema.\n(Note that this is irrelevant if the field is not present in the JSON schema.).\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `field` | `ModelField | DataclassField | TypedDictField` | The schema for the field itself. | *required* |\n| `total` | `bool` | Only applies to `TypedDictField`s. Indicates if the `TypedDict` this field belongs to is total, in which case any fields that don't explicitly specify `required=False` are required. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `bool` | `True` if the field should be marked as required in the generated JSON schema, `False` otherwise. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1742 1743 1744 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763 1764 1765 ``` | ``` def field_is_required(     self,     field: core_schema.ModelField | core_schema.DataclassField | core_schema.TypedDictField,     total: bool, ) -> bool:     \"\"\"Whether the field should be marked as required in the generated JSON schema.     (Note that this is irrelevant if the field is not present in the JSON schema.).      Args:         field: The schema for the field itself.         total: Only applies to `TypedDictField`s.             Indicates if the `TypedDict` this field belongs to is total, in which case any fields that don't             explicitly specify `required=False` are required.      Returns:         `True` if the field should be marked as required in the generated JSON schema, `False` otherwise.     \"\"\"     if self.mode == 'serialization' and self._config.json_schema_serialization_defaults_required:         return not field.get('serialization_exclude')     else:         if field['type'] == 'typed-dict-field':             return field.get('required', total)         else:             return field['schema']['type'] != 'default' ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#fieldisrequired-indexhtmlpydanticjsonschemageneratejsonschemafieldisrequired-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "dataclass\\_args\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.dataclass_args_schema \"Permanent link\")", "anchor": "dataclassargsschema-indexhtmlpydanticjsonschemageneratejsonschemadataclassargsschema-permanent-link", "md_text": "```\ndataclass_args_schema(\n    schema: DataclassArgsSchema,\n) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches a schema that defines a dataclass's constructor arguments.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `DataclassArgsSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1767 1768 1769 1770 1771 1772 1773 1774 1775 1776 1777 1778 1779 1780 1781 1782 1783 ``` | ``` def dataclass_args_schema(self, schema: core_schema.DataclassArgsSchema) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches a schema that defines a dataclass's constructor arguments.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     named_required_fields: list[tuple[str, bool, CoreSchemaField]] = [         (field['name'], self.field_is_required(field, total=True), field)         for field in schema['fields']         if self.field_is_present(field)     ]     if self.mode == 'serialization':         named_required_fields.extend(self._name_required_computed_fields(schema.get('computed_fields', [])))     return self._named_required_fields_schema(named_required_fields) ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#dataclassargsschema-indexhtmlpydanticjsonschemageneratejsonschemadataclassargsschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "dataclass\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.dataclass_schema \"Permanent link\")", "anchor": "dataclassschema-indexhtmlpydanticjsonschemageneratejsonschemadataclassschema-permanent-link", "md_text": "```\ndataclass_schema(\n    schema: DataclassSchema,\n) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches a schema that defines a dataclass.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `DataclassSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1785 1786 1787 1788 1789 1790 1791 1792 1793 1794 1795 1796 1797 1798 1799 1800 1801 1802 1803 1804 1805 1806 1807 1808 1809 1810 1811 1812 1813 ``` | ``` def dataclass_schema(self, schema: core_schema.DataclassSchema) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches a schema that defines a dataclass.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     from ._internal._dataclasses import is_stdlib_dataclass      cls = schema['cls']     config: ConfigDict = getattr(cls, '__pydantic_config__', cast('ConfigDict', {}))      with self._config_wrapper_stack.push(config):         json_schema = self.generate_inner(schema['schema']).copy()      self._update_class_schema(json_schema, cls, config)      # Dataclass-specific handling of description     if is_stdlib_dataclass(cls):         # vanilla dataclass; don't use cls.__doc__ as it will contain the class signature by default         description = None     else:         description = None if cls.__doc__ is None else inspect.cleandoc(cls.__doc__)     if description:         json_schema['description'] = description      return json_schema ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#dataclassschema-indexhtmlpydanticjsonschemageneratejsonschemadataclassschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "arguments\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.arguments_schema \"Permanent link\")", "anchor": "argumentsschema-indexhtmlpydanticjsonschemageneratejsonschemaargumentsschema-permanent-link", "md_text": "```\narguments_schema(\n    schema: ArgumentsSchema,\n) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches a schema that defines a function's arguments.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `ArgumentsSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1815 1816 1817 1818 1819 1820 1821 1822 1823 1824 1825 1826 1827 1828 1829 1830 1831 1832 1833 1834 1835 1836 1837 1838 1839 1840 1841 1842 1843 1844 1845 1846 1847 1848 1849 ``` | ``` def arguments_schema(self, schema: core_schema.ArgumentsSchema) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches a schema that defines a function's arguments.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     prefer_positional = schema.get('metadata', {}).get('pydantic_js_prefer_positional_arguments')      arguments = schema['arguments_schema']     kw_only_arguments = [a for a in arguments if a.get('mode') == 'keyword_only']     kw_or_p_arguments = [a for a in arguments if a.get('mode') in {'positional_or_keyword', None}]     p_only_arguments = [a for a in arguments if a.get('mode') == 'positional_only']     var_args_schema = schema.get('var_args_schema')     var_kwargs_schema = schema.get('var_kwargs_schema')      if prefer_positional:         positional_possible = not kw_only_arguments and not var_kwargs_schema         if positional_possible:             return self.p_arguments_schema(p_only_arguments + kw_or_p_arguments, var_args_schema)      keyword_possible = not p_only_arguments and not var_args_schema     if keyword_possible:         return self.kw_arguments_schema(kw_or_p_arguments + kw_only_arguments, var_kwargs_schema)      if not prefer_positional:         positional_possible = not kw_only_arguments and not var_kwargs_schema         if positional_possible:             return self.p_arguments_schema(p_only_arguments + kw_or_p_arguments, var_args_schema)      raise PydanticInvalidForJsonSchema(         'Unable to generate JSON schema for arguments validator with positional-only and keyword-only arguments'     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#argumentsschema-indexhtmlpydanticjsonschemageneratejsonschemaargumentsschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "kw\\_arguments\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.kw_arguments_schema \"Permanent link\")", "anchor": "kwargumentsschema-indexhtmlpydanticjsonschemageneratejsonschemakwargumentsschema-permanent-link", "md_text": "```\nkw_arguments_schema(\n    arguments: list[ArgumentsParameter],\n    var_kwargs_schema: CoreSchema | None,\n) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches a schema that defines a function's keyword arguments.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `arguments` | `list[ArgumentsParameter]` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1851 1852 1853 1854 1855 1856 1857 1858 1859 1860 1861 1862 1863 1864 1865 1866 1867 1868 1869 1870 1871 1872 1873 1874 1875 1876 1877 1878 1879 1880 1881 1882 1883 1884 1885 1886 1887 ``` | ``` def kw_arguments_schema(     self, arguments: list[core_schema.ArgumentsParameter], var_kwargs_schema: CoreSchema | None ) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches a schema that defines a function's keyword arguments.      Args:         arguments: The core schema.      Returns:         The generated JSON schema.     \"\"\"     properties: dict[str, JsonSchemaValue] = {}     required: list[str] = []     for argument in arguments:         name = self.get_argument_name(argument)         argument_schema = self.generate_inner(argument['schema']).copy()         if 'title' not in argument_schema and self.field_title_should_be_set(argument['schema']):             argument_schema['title'] = self.get_title_from_name(name)         properties[name] = argument_schema          if argument['schema']['type'] != 'default':             # This assumes that if the argument has a default value,             # the inner schema must be of type WithDefaultSchema.             # I believe this is true, but I am not 100% sure             required.append(name)      json_schema: JsonSchemaValue = {'type': 'object', 'properties': properties}     if required:         json_schema['required'] = required      if var_kwargs_schema:         additional_properties_schema = self.generate_inner(var_kwargs_schema)         if additional_properties_schema:             json_schema['additionalProperties'] = additional_properties_schema     else:         json_schema['additionalProperties'] = False     return json_schema ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#kwargumentsschema-indexhtmlpydanticjsonschemageneratejsonschemakwargumentsschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "p\\_arguments\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.p_arguments_schema \"Permanent link\")", "anchor": "pargumentsschema-indexhtmlpydanticjsonschemageneratejsonschemapargumentsschema-permanent-link", "md_text": "```\np_arguments_schema(\n    arguments: list[ArgumentsParameter],\n    var_args_schema: CoreSchema | None,\n) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches a schema that defines a function's positional arguments.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `arguments` | `list[ArgumentsParameter]` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1889 1890 1891 1892 1893 1894 1895 1896 1897 1898 1899 1900 1901 1902 1903 1904 1905 1906 1907 1908 1909 1910 1911 1912 1913 1914 1915 1916 1917 1918 1919 1920 1921 1922 1923 1924 1925 1926 1927 1928 1929 1930 ``` | ``` def p_arguments_schema(     self, arguments: list[core_schema.ArgumentsParameter], var_args_schema: CoreSchema | None ) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches a schema that defines a function's positional arguments.      Args:         arguments: The core schema.      Returns:         The generated JSON schema.     \"\"\"     prefix_items: list[JsonSchemaValue] = []     min_items = 0      for argument in arguments:         name = self.get_argument_name(argument)          argument_schema = self.generate_inner(argument['schema']).copy()         if 'title' not in argument_schema and self.field_title_should_be_set(argument['schema']):             argument_schema['title'] = self.get_title_from_name(name)         prefix_items.append(argument_schema)          if argument['schema']['type'] != 'default':             # This assumes that if the argument has a default value,             # the inner schema must be of type WithDefaultSchema.             # I believe this is true, but I am not 100% sure             min_items += 1      json_schema: JsonSchemaValue = {'type': 'array'}     if prefix_items:         json_schema['prefixItems'] = prefix_items     if min_items:         json_schema['minItems'] = min_items      if var_args_schema:         items_schema = self.generate_inner(var_args_schema)         if items_schema:             json_schema['items'] = items_schema     else:         json_schema['maxItems'] = len(prefix_items)      return json_schema ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#pargumentsschema-indexhtmlpydanticjsonschemageneratejsonschemapargumentsschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "get\\_argument\\_name [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.get_argument_name \"Permanent link\")", "anchor": "getargumentname-indexhtmlpydanticjsonschemageneratejsonschemagetargumentname-permanent-link", "md_text": "```\nget_argument_name(\n    argument: ArgumentsParameter | ArgumentsV3Parameter,\n) -> str\n```\n\nRetrieves the name of an argument.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `argument` | `ArgumentsParameter | ArgumentsV3Parameter` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `str` | The name of the argument. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1932 1933 1934 1935 1936 1937 1938 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 ``` | ``` def get_argument_name(self, argument: core_schema.ArgumentsParameter | core_schema.ArgumentsV3Parameter) -> str:     \"\"\"Retrieves the name of an argument.      Args:         argument: The core schema.      Returns:         The name of the argument.     \"\"\"     name = argument['name']     if self.by_alias:         alias = argument.get('alias')         if isinstance(alias, str):             name = alias         else:             pass  # might want to do something else?     return name ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#getargumentname-indexhtmlpydanticjsonschemageneratejsonschemagetargumentname-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "arguments\\_v3\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.arguments_v3_schema \"Permanent link\")", "anchor": "argumentsv3schema-indexhtmlpydanticjsonschemageneratejsonschemaargumentsv3schema-permanent-link", "md_text": "```\narguments_v3_schema(\n    schema: ArgumentsV3Schema,\n) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches a schema that defines a function's arguments.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `ArgumentsV3Schema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 ``` | ``` def arguments_v3_schema(self, schema: core_schema.ArgumentsV3Schema) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches a schema that defines a function's arguments.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     arguments = schema['arguments_schema']     properties: dict[str, JsonSchemaValue] = {}     required: list[str] = []     for argument in arguments:         mode = argument.get('mode', 'positional_or_keyword')         name = self.get_argument_name(argument)         argument_schema = self.generate_inner(argument['schema']).copy()         if mode == 'var_args':             argument_schema = {'type': 'array', 'items': argument_schema}         elif mode == 'var_kwargs_uniform':             argument_schema = {'type': 'object', 'additionalProperties': argument_schema}          argument_schema.setdefault('title', self.get_title_from_name(name))         properties[name] = argument_schema          if (             (mode == 'var_kwargs_unpacked_typed_dict' and 'required' in argument_schema)             or mode not in {'var_args', 'var_kwargs_uniform', 'var_kwargs_unpacked_typed_dict'}             and argument['schema']['type'] != 'default'         ):             # This assumes that if the argument has a default value,             # the inner schema must be of type WithDefaultSchema.             # I believe this is true, but I am not 100% sure             required.append(name)      json_schema: JsonSchemaValue = {'type': 'object', 'properties': properties}     if required:         json_schema['required'] = required     return json_schema ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#argumentsv3schema-indexhtmlpydanticjsonschemageneratejsonschemaargumentsv3schema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "call\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.call_schema \"Permanent link\")", "anchor": "callschema-indexhtmlpydanticjsonschemageneratejsonschemacallschema-permanent-link", "md_text": "```\ncall_schema(schema: CallSchema) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches a schema that defines a function call.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `CallSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 ``` | ``` def call_schema(self, schema: core_schema.CallSchema) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches a schema that defines a function call.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     return self.generate_inner(schema['arguments_schema']) ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#callschema-indexhtmlpydanticjsonschemageneratejsonschemacallschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "custom\\_error\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.custom_error_schema \"Permanent link\")", "anchor": "customerrorschema-indexhtmlpydanticjsonschemageneratejsonschemacustomerrorschema-permanent-link", "md_text": "```\ncustom_error_schema(\n    schema: CustomErrorSchema,\n) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches a schema that defines a custom error.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `CustomErrorSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 ``` | ``` def custom_error_schema(self, schema: core_schema.CustomErrorSchema) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches a schema that defines a custom error.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     return self.generate_inner(schema['schema']) ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#customerrorschema-indexhtmlpydanticjsonschemageneratejsonschemacustomerrorschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "json\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.json_schema \"Permanent link\")", "anchor": "jsonschema-indexhtmlpydanticjsonschemageneratejsonschemajsonschema-permanent-link", "md_text": "```\njson_schema(schema: JsonSchema) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches a schema that defines a JSON object.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `JsonSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 2011 2012 2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 2023 2024 2025 2026 ``` | ``` def json_schema(self, schema: core_schema.JsonSchema) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches a schema that defines a JSON object.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     content_core_schema = schema.get('schema') or core_schema.any_schema()     content_json_schema = self.generate_inner(content_core_schema)     if self.mode == 'validation':         return {'type': 'string', 'contentMediaType': 'application/json', 'contentSchema': content_json_schema}     else:         # self.mode == 'serialization'         return content_json_schema ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#jsonschema-indexhtmlpydanticjsonschemageneratejsonschemajsonschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "url\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.url_schema \"Permanent link\")", "anchor": "urlschema-indexhtmlpydanticjsonschemageneratejsonschemaurlschema-permanent-link", "md_text": "```\nurl_schema(schema: UrlSchema) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches a schema that defines a URL.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `UrlSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 2028 2029 2030 2031 2032 2033 2034 2035 2036 2037 2038 2039 ``` | ``` def url_schema(self, schema: core_schema.UrlSchema) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches a schema that defines a URL.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     json_schema = {'type': 'string', 'format': 'uri', 'minLength': 1}     self.update_with_validations(json_schema, schema, self.ValidationsMapping.string)     return json_schema ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#urlschema-indexhtmlpydanticjsonschemageneratejsonschemaurlschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "multi\\_host\\_url\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.multi_host_url_schema \"Permanent link\")", "anchor": "multihosturlschema-indexhtmlpydanticjsonschemageneratejsonschemamultihosturlschema-permanent-link", "md_text": "```\nmulti_host_url_schema(\n    schema: MultiHostUrlSchema,\n) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches a schema that defines a URL that can be used with multiple hosts.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `MultiHostUrlSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 2041 2042 2043 2044 2045 2046 2047 2048 2049 2050 2051 2052 2053 ``` | ``` def multi_host_url_schema(self, schema: core_schema.MultiHostUrlSchema) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches a schema that defines a URL that can be used with multiple hosts.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     # Note: 'multi-host-uri' is a custom/pydantic-specific format, not part of the JSON Schema spec     json_schema = {'type': 'string', 'format': 'multi-host-uri', 'minLength': 1}     self.update_with_validations(json_schema, schema, self.ValidationsMapping.string)     return json_schema ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#multihosturlschema-indexhtmlpydanticjsonschemageneratejsonschemamultihosturlschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "uuid\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.uuid_schema \"Permanent link\")", "anchor": "uuidschema-indexhtmlpydanticjsonschemageneratejsonschemauuidschema-permanent-link", "md_text": "```\nuuid_schema(schema: UuidSchema) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches a UUID.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `UuidSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 2055 2056 2057 2058 2059 2060 2061 2062 2063 2064 ``` | ``` def uuid_schema(self, schema: core_schema.UuidSchema) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches a UUID.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     return {'type': 'string', 'format': 'uuid'} ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#uuidschema-indexhtmlpydanticjsonschemageneratejsonschemauuidschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "definitions\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.definitions_schema \"Permanent link\")", "anchor": "definitionsschema-indexhtmlpydanticjsonschemageneratejsonschemadefinitionsschema-permanent-link", "md_text": "```\ndefinitions_schema(\n    schema: DefinitionsSchema,\n) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches a schema that defines a JSON object with definitions.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `DefinitionsSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 2066 2067 2068 2069 2070 2071 2072 2073 2074 2075 2076 2077 2078 2079 2080 2081 2082 ``` | ``` def definitions_schema(self, schema: core_schema.DefinitionsSchema) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches a schema that defines a JSON object with definitions.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     for definition in schema['definitions']:         try:             self.generate_inner(definition)         except PydanticInvalidForJsonSchema as e:  # noqa: PERF203             core_ref: CoreRef = CoreRef(definition['ref'])  # type: ignore             self._core_defs_invalid_for_json_schema[self.get_defs_ref((core_ref, self.mode))] = e             continue     return self.generate_inner(schema['schema']) ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#definitionsschema-indexhtmlpydanticjsonschemageneratejsonschemadefinitionsschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "definition\\_ref\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.definition_ref_schema \"Permanent link\")", "anchor": "definitionrefschema-indexhtmlpydanticjsonschemageneratejsonschemadefinitionrefschema-permanent-link", "md_text": "```\ndefinition_ref_schema(\n    schema: DefinitionReferenceSchema,\n) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches a schema that references a definition.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `DefinitionReferenceSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 2084 2085 2086 2087 2088 2089 2090 2091 2092 2093 2094 2095 ``` | ``` def definition_ref_schema(self, schema: core_schema.DefinitionReferenceSchema) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches a schema that references a definition.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     core_ref = CoreRef(schema['schema_ref'])     _, ref_json_schema = self.get_cache_defs_ref_schema(core_ref)     return ref_json_schema ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#definitionrefschema-indexhtmlpydanticjsonschemageneratejsonschemadefinitionrefschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "ser\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.ser_schema \"Permanent link\")", "anchor": "serschema-indexhtmlpydanticjsonschemageneratejsonschemaserschema-permanent-link", "md_text": "```\nser_schema(\n    schema: (\n        SerSchema | IncExSeqSerSchema | IncExDictSerSchema\n    ),\n) -> JsonSchemaValue | None\n```\n\nGenerates a JSON schema that matches a schema that defines a serialized object.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `SerSchema | IncExSeqSerSchema | IncExDictSerSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue | None` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 2097 2098 2099 2100 2101 2102 2103 2104 2105 2106 2107 2108 2109 2110 2111 2112 2113 2114 2115 2116 2117 2118 2119 2120 ``` | ``` def ser_schema(     self, schema: core_schema.SerSchema | core_schema.IncExSeqSerSchema | core_schema.IncExDictSerSchema ) -> JsonSchemaValue | None:     \"\"\"Generates a JSON schema that matches a schema that defines a serialized object.      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     schema_type = schema['type']     if schema_type == 'function-plain' or schema_type == 'function-wrap':         # PlainSerializerFunctionSerSchema or WrapSerializerFunctionSerSchema         return_schema = schema.get('return_schema')         if return_schema is not None:             return self.generate_inner(return_schema)     elif schema_type == 'format' or schema_type == 'to-string':         # FormatSerSchema or ToStringSerSchema         return self.str_schema(core_schema.str_schema())     elif schema['type'] == 'model':         # ModelSerSchema         return self.generate_inner(schema['schema'])     return None ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#serschema-indexhtmlpydanticjsonschemageneratejsonschemaserschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "complex\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.complex_schema \"Permanent link\")", "anchor": "complexschema-indexhtmlpydanticjsonschemageneratejsonschemacomplexschema-permanent-link", "md_text": "```\ncomplex_schema(schema: ComplexSchema) -> JsonSchemaValue\n```\n\nGenerates a JSON schema that matches a complex number.\n\nJSON has no standard way to represent complex numbers. Complex number is not a numeric\ntype. Here we represent complex number as strings following the rule defined by Python.\nFor instance, '1+2j' is an accepted complex string. Details can be found in\n[Python's `complex` documentation](https://docs.python.org/3/library/functions.html#complex).\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `ComplexSchema` | The core schema. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The generated JSON schema. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 2122 2123 2124 2125 2126 2127 2128 2129 2130 2131 2132 2133 2134 2135 2136 ``` | ``` def complex_schema(self, schema: core_schema.ComplexSchema) -> JsonSchemaValue:     \"\"\"Generates a JSON schema that matches a complex number.      JSON has no standard way to represent complex numbers. Complex number is not a numeric     type. Here we represent complex number as strings following the rule defined by Python.     For instance, '1+2j' is an accepted complex string. Details can be found in     [Python's `complex` documentation][complex].      Args:         schema: The core schema.      Returns:         The generated JSON schema.     \"\"\"     return {'type': 'string'} ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#complexschema-indexhtmlpydanticjsonschemageneratejsonschemacomplexschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "get\\_title\\_from\\_name [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.get_title_from_name \"Permanent link\")", "anchor": "gettitlefromname-indexhtmlpydanticjsonschemageneratejsonschemagettitlefromname-permanent-link", "md_text": "```\nget_title_from_name(name: str) -> str\n```\n\nRetrieves a title from a name.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `name` | `str` | The name to retrieve a title from. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `str` | The title. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 2140 2141 2142 2143 2144 2145 2146 2147 2148 2149 ``` | ``` def get_title_from_name(self, name: str) -> str:     \"\"\"Retrieves a title from a name.      Args:         name: The name to retrieve a title from.      Returns:         The title.     \"\"\"     return name.title().replace('_', ' ').strip() ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#gettitlefromname-indexhtmlpydanticjsonschemageneratejsonschemagettitlefromname-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "field\\_title\\_should\\_be\\_set [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.field_title_should_be_set \"Permanent link\")", "anchor": "fieldtitleshouldbeset-indexhtmlpydanticjsonschemageneratejsonschemafieldtitleshouldbeset-permanent-link", "md_text": "```\nfield_title_should_be_set(\n    schema: CoreSchemaOrField,\n) -> bool\n```\n\nReturns true if a field with the given schema should have a title set based on the field name.\n\nIntuitively, we want this to return true for schemas that wouldn't otherwise provide their own title\n(e.g., int, float, str), and false for those that would (e.g., BaseModel subclasses).\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `schema` | `CoreSchemaOrField` | The schema to check. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `bool` | `True` if the field should have a title set, `False` otherwise. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 2151 2152 2153 2154 2155 2156 2157 2158 2159 2160 2161 2162 2163 2164 2165 2166 2167 2168 2169 2170 2171 2172 2173 2174 2175 2176 2177 2178 2179 2180 2181 2182 2183 2184 ``` | ``` def field_title_should_be_set(self, schema: CoreSchemaOrField) -> bool:     \"\"\"Returns true if a field with the given schema should have a title set based on the field name.      Intuitively, we want this to return true for schemas that wouldn't otherwise provide their own title     (e.g., int, float, str), and false for those that would (e.g., BaseModel subclasses).      Args:         schema: The schema to check.      Returns:         `True` if the field should have a title set, `False` otherwise.     \"\"\"     if _core_utils.is_core_schema_field(schema):         if schema['type'] == 'computed-field':             field_schema = schema['return_schema']         else:             field_schema = schema['schema']         return self.field_title_should_be_set(field_schema)      elif _core_utils.is_core_schema(schema):         if schema.get('ref'):  # things with refs, such as models and enums, should not have titles set             return False         if schema['type'] in {'default', 'nullable', 'definitions'}:             return self.field_title_should_be_set(schema['schema'])  # type: ignore[typeddict-item]         if _core_utils.is_function_with_inner_schema(schema):             return self.field_title_should_be_set(schema['schema'])         if schema['type'] == 'definition-ref':             # Referenced schemas should not have titles set for the same reason             # schemas with refs should not             return False         return True  # anything else should have title set      else:         raise PydanticInvalidForJsonSchema(f'Unexpected schema type: schema={schema}')  # pragma: no cover ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#fieldtitleshouldbeset-indexhtmlpydanticjsonschemageneratejsonschemafieldtitleshouldbeset-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "normalize\\_name [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.normalize_name \"Permanent link\")", "anchor": "normalizename-indexhtmlpydanticjsonschemageneratejsonschemanormalizename-permanent-link", "md_text": "```\nnormalize_name(name: str) -> str\n```\n\nNormalizes a name to be used as a key in a dictionary.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `name` | `str` | The name to normalize. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `str` | The normalized name. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 2186 2187 2188 2189 2190 2191 2192 2193 2194 2195 ``` | ``` def normalize_name(self, name: str) -> str:     \"\"\"Normalizes a name to be used as a key in a dictionary.      Args:         name: The name to normalize.      Returns:         The normalized name.     \"\"\"     return re.sub(r'[^a-zA-Z0-9.\\-_]', '_', name).replace('.', '__') ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#normalizename-indexhtmlpydanticjsonschemageneratejsonschemanormalizename-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "get\\_defs\\_ref [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.get_defs_ref \"Permanent link\")", "anchor": "getdefsref-indexhtmlpydanticjsonschemageneratejsonschemagetdefsref-permanent-link", "md_text": "```\nget_defs_ref(core_mode_ref: CoreModeRef) -> DefsRef\n```\n\nOverride this method to change the way that definitions keys are generated from a core reference.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `core_mode_ref` | `CoreModeRef` | The core reference. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `DefsRef` | The definitions key. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 2197 2198 2199 2200 2201 2202 2203 2204 2205 2206 2207 2208 2209 2210 2211 2212 2213 2214 2215 2216 2217 2218 2219 2220 2221 2222 2223 2224 2225 2226 2227 2228 2229 2230 2231 2232 2233 2234 2235 2236 2237 2238 2239 2240 2241 2242 2243 ``` | ``` def get_defs_ref(self, core_mode_ref: CoreModeRef) -> DefsRef:     \"\"\"Override this method to change the way that definitions keys are generated from a core reference.      Args:         core_mode_ref: The core reference.      Returns:         The definitions key.     \"\"\"     # Split the core ref into \"components\"; generic origins and arguments are each separate components     core_ref, mode = core_mode_ref     components = re.split(r'([\\][,])', core_ref)     # Remove IDs from each component     components = [x.rsplit(':', 1)[0] for x in components]     core_ref_no_id = ''.join(components)     # Remove everything before the last period from each \"component\"     components = [re.sub(r'(?:[^.[\\]]+\\.)+((?:[^.[\\]]+))', r'\\1', x) for x in components]     short_ref = ''.join(components)      mode_title = _MODE_TITLE_MAPPING[mode]      # It is important that the generated defs_ref values be such that at least one choice will not     # be generated for any other core_ref. Currently, this should be the case because we include     # the id of the source type in the core_ref     name = DefsRef(self.normalize_name(short_ref))     name_mode = DefsRef(self.normalize_name(short_ref) + f'-{mode_title}')     module_qualname = DefsRef(self.normalize_name(core_ref_no_id))     module_qualname_mode = DefsRef(f'{module_qualname}-{mode_title}')     module_qualname_id = DefsRef(self.normalize_name(core_ref))     occurrence_index = self._collision_index.get(module_qualname_id)     if occurrence_index is None:         self._collision_counter[module_qualname] += 1         occurrence_index = self._collision_index[module_qualname_id] = self._collision_counter[module_qualname]      module_qualname_occurrence = DefsRef(f'{module_qualname}__{occurrence_index}')     module_qualname_occurrence_mode = DefsRef(f'{module_qualname_mode}__{occurrence_index}')      self._prioritized_defsref_choices[module_qualname_occurrence_mode] = [         name,         name_mode,         module_qualname,         module_qualname_mode,         module_qualname_occurrence,         module_qualname_occurrence_mode,     ]      return module_qualname_occurrence_mode ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#getdefsref-indexhtmlpydanticjsonschemageneratejsonschemagetdefsref-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "get\\_cache\\_defs\\_ref\\_schema [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.get_cache_defs_ref_schema \"Permanent link\")", "anchor": "getcachedefsrefschema-indexhtmlpydanticjsonschemageneratejsonschemagetcachedefsrefschema-permanent-link", "md_text": "```\nget_cache_defs_ref_schema(\n    core_ref: CoreRef,\n) -> tuple[DefsRef, JsonSchemaValue]\n```\n\nThis method wraps the get\\_defs\\_ref method with some cache-lookup/population logic,\nand returns both the produced defs\\_ref and the JSON schema that will refer to the right definition.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `core_ref` | `CoreRef` | The core reference to get the definitions reference for. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `tuple[DefsRef, JsonSchemaValue]` | A tuple of the definitions reference and the JSON schema that will refer to it. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 2245 2246 2247 2248 2249 2250 2251 2252 2253 2254 2255 2256 2257 2258 2259 2260 2261 2262 2263 2264 2265 2266 2267 2268 2269 2270 2271 ``` | ``` def get_cache_defs_ref_schema(self, core_ref: CoreRef) -> tuple[DefsRef, JsonSchemaValue]:     \"\"\"This method wraps the get_defs_ref method with some cache-lookup/population logic,     and returns both the produced defs_ref and the JSON schema that will refer to the right definition.      Args:         core_ref: The core reference to get the definitions reference for.      Returns:         A tuple of the definitions reference and the JSON schema that will refer to it.     \"\"\"     core_mode_ref = (core_ref, self.mode)     maybe_defs_ref = self.core_to_defs_refs.get(core_mode_ref)     if maybe_defs_ref is not None:         json_ref = self.core_to_json_refs[core_mode_ref]         return maybe_defs_ref, {'$ref': json_ref}      defs_ref = self.get_defs_ref(core_mode_ref)      # populate the ref translation mappings     self.core_to_defs_refs[core_mode_ref] = defs_ref     self.defs_to_core_refs[defs_ref] = core_mode_ref      json_ref = JsonRef(self.ref_template.format(model=defs_ref))     self.core_to_json_refs[core_mode_ref] = json_ref     self.json_to_defs_refs[json_ref] = defs_ref     ref_json_schema = {'$ref': json_ref}     return defs_ref, ref_json_schema ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#getcachedefsrefschema-indexhtmlpydanticjsonschemageneratejsonschemagetcachedefsrefschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "handle\\_ref\\_overrides [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.handle_ref_overrides \"Permanent link\")", "anchor": "handlerefoverrides-indexhtmlpydanticjsonschemageneratejsonschemahandlerefoverrides-permanent-link", "md_text": "```\nhandle_ref_overrides(\n    json_schema: JsonSchemaValue,\n) -> JsonSchemaValue\n```\n\nRemove any sibling keys that are redundant with the referenced schema.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `json_schema` | `JsonSchemaValue` | The schema to remove redundant sibling keys from. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `JsonSchemaValue` | The schema with redundant sibling keys removed. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 2273 2274 2275 2276 2277 2278 2279 2280 2281 2282 2283 2284 2285 2286 2287 2288 2289 2290 2291 2292 2293 2294 2295 2296 2297 2298 ``` | ``` def handle_ref_overrides(self, json_schema: JsonSchemaValue) -> JsonSchemaValue:     \"\"\"Remove any sibling keys that are redundant with the referenced schema.      Args:         json_schema: The schema to remove redundant sibling keys from.      Returns:         The schema with redundant sibling keys removed.     \"\"\"     if '$ref' in json_schema:         # prevent modifications to the input; this copy may be safe to drop if there is significant overhead         json_schema = json_schema.copy()          referenced_json_schema = self.get_schema_from_definitions(JsonRef(json_schema['$ref']))         if referenced_json_schema is None:             # This can happen when building schemas for models with not-yet-defined references.             # It may be a good idea to do a recursive pass at the end of the generation to remove             # any redundant override keys.             return json_schema         for k, v in list(json_schema.items()):             if k == '$ref':                 continue             if k in referenced_json_schema and referenced_json_schema[k] == v:                 del json_schema[k]  # redundant key      return json_schema ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#handlerefoverrides-indexhtmlpydanticjsonschemageneratejsonschemahandlerefoverrides-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "encode\\_default [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.encode_default \"Permanent link\")", "anchor": "encodedefault-indexhtmlpydanticjsonschemageneratejsonschemaencodedefault-permanent-link", "md_text": "```\nencode_default(dft: Any) -> Any\n```\n\nEncode a default value to a JSON-serializable value.\n\nThis is used to encode default values for fields in the generated JSON schema.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `dft` | `Any` | The default value to encode. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `Any` | The encoded default value. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 2311 2312 2313 2314 2315 2316 2317 2318 2319 2320 2321 2322 2323 2324 2325 2326 2327 2328 2329 2330 2331 2332 2333 2334 2335 2336 2337 2338 ``` | ``` def encode_default(self, dft: Any) -> Any:     \"\"\"Encode a default value to a JSON-serializable value.      This is used to encode default values for fields in the generated JSON schema.      Args:         dft: The default value to encode.      Returns:         The encoded default value.     \"\"\"     from .type_adapter import TypeAdapter, _type_has_config      config = self._config     try:         default = (             dft             if _type_has_config(type(dft))             else TypeAdapter(type(dft), config=config.config_dict).dump_python(                 dft, by_alias=self.by_alias, mode='json'             )         )     except PydanticSchemaGenerationError:         raise pydantic_core.PydanticSerializationError(f'Unable to encode default value {dft}')      return pydantic_core.to_jsonable_python(         default, timedelta_mode=config.ser_json_timedelta, bytes_mode=config.ser_json_bytes, by_alias=self.by_alias     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#encodedefault-indexhtmlpydanticjsonschemageneratejsonschemaencodedefault-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "update\\_with\\_validations [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.update_with_validations \"Permanent link\")", "anchor": "updatewithvalidations-indexhtmlpydanticjsonschemageneratejsonschemaupdatewithvalidations-permanent-link", "md_text": "```\nupdate_with_validations(\n    json_schema: JsonSchemaValue,\n    core_schema: CoreSchema,\n    mapping: dict[str, str],\n) -> None\n```\n\nUpdate the json\\_schema with the corresponding validations specified in the core\\_schema,\nusing the provided mapping to translate keys in core\\_schema to the appropriate keys for a JSON schema.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `json_schema` | `JsonSchemaValue` | The JSON schema to update. | *required* |\n| `core_schema` | `CoreSchema` | The core schema to get the validations from. | *required* |\n| `mapping` | `dict[str, str]` | A mapping from core\\_schema attribute names to the corresponding JSON schema attribute names. | *required* |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 2340 2341 2342 2343 2344 2345 2346 2347 2348 2349 2350 2351 2352 2353 ``` | ``` def update_with_validations(     self, json_schema: JsonSchemaValue, core_schema: CoreSchema, mapping: dict[str, str] ) -> None:     \"\"\"Update the json_schema with the corresponding validations specified in the core_schema,     using the provided mapping to translate keys in core_schema to the appropriate keys for a JSON schema.      Args:         json_schema: The JSON schema to update.         core_schema: The core schema to get the validations from.         mapping: A mapping from core_schema attribute names to the corresponding JSON schema attribute names.     \"\"\"     for core_key, json_schema_key in mapping.items():         if core_key in core_schema:             json_schema[json_schema_key] = core_schema[core_key] ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#updatewithvalidations-indexhtmlpydanticjsonschemageneratejsonschemaupdatewithvalidations-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "get\\_json\\_ref\\_counts [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.get_json_ref_counts \"Permanent link\")", "anchor": "getjsonrefcounts-indexhtmlpydanticjsonschemageneratejsonschemagetjsonrefcounts-permanent-link", "md_text": "```\nget_json_ref_counts(\n    json_schema: JsonSchemaValue,\n) -> dict[JsonRef, int]\n```\n\nGet all values corresponding to the key '$ref' anywhere in the json\\_schema.\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 2399 2400 2401 2402 2403 2404 2405 2406 2407 2408 2409 2410 2411 2412 2413 2414 2415 2416 2417 2418 2419 2420 2421 2422 2423 2424 2425 2426 2427 2428 2429 2430 2431 2432 2433 ``` | ``` def get_json_ref_counts(self, json_schema: JsonSchemaValue) -> dict[JsonRef, int]:     \"\"\"Get all values corresponding to the key '$ref' anywhere in the json_schema.\"\"\"     json_refs: dict[JsonRef, int] = Counter()      def _add_json_refs(schema: Any) -> None:         if isinstance(schema, dict):             if '$ref' in schema:                 json_ref = JsonRef(schema['$ref'])                 if not isinstance(json_ref, str):                     return  # in this case, '$ref' might have been the name of a property                 already_visited = json_ref in json_refs                 json_refs[json_ref] += 1                 if already_visited:                     return  # prevent recursion on a definition that was already visited                 try:                     defs_ref = self.json_to_defs_refs[json_ref]                     if defs_ref in self._core_defs_invalid_for_json_schema:                         raise self._core_defs_invalid_for_json_schema[defs_ref]                     _add_json_refs(self.definitions[defs_ref])                 except KeyError:                     if not json_ref.startswith(('http://', 'https://')):                         raise              for k, v in schema.items():                 if k == 'examples' and isinstance(v, list):                     # Skip examples that may contain arbitrary values and references                     # (see the comment in `_get_all_json_refs` for more details).                     continue                 _add_json_refs(v)         elif isinstance(schema, list):             for v in schema:                 _add_json_refs(v)      _add_json_refs(json_schema)     return json_refs ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#getjsonrefcounts-indexhtmlpydanticjsonschemageneratejsonschemagetjsonrefcounts-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "emit\\_warning [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.emit_warning \"Permanent link\")", "anchor": "emitwarning-indexhtmlpydanticjsonschemageneratejsonschemaemitwarning-permanent-link", "md_text": "```\nemit_warning(\n    kind: JsonSchemaWarningKind, detail: str\n) -> None\n```\n\nThis method simply emits PydanticJsonSchemaWarnings based on handling in the `warning_message` method.\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 2438 2439 2440 2441 2442 ``` | ``` def emit_warning(self, kind: JsonSchemaWarningKind, detail: str) -> None:     \"\"\"This method simply emits PydanticJsonSchemaWarnings based on handling in the `warning_message` method.\"\"\"     message = self.render_warning_message(kind, detail)     if message is not None:         warnings.warn(message, PydanticJsonSchemaWarning) ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#emitwarning-indexhtmlpydanticjsonschemageneratejsonschemaemitwarning-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "render\\_warning\\_message [Â¶](index.html#pydantic.json_schema.GenerateJsonSchema.render_warning_message \"Permanent link\")", "anchor": "renderwarningmessage-indexhtmlpydanticjsonschemageneratejsonschemarenderwarningmessage-permanent-link", "md_text": "```\nrender_warning_message(\n    kind: JsonSchemaWarningKind, detail: str\n) -> str | None\n```\n\nThis method is responsible for ignoring warnings as desired, and for formatting the warning messages.\n\nYou can override the value of `ignored_warning_kinds` in a subclass of GenerateJsonSchema\nto modify what warnings are generated. If you want more control, you can override this method;\njust return None in situations where you don't want warnings to be emitted.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `kind` | `JsonSchemaWarningKind` | The kind of warning to render. It can be one of the following:   * 'skipped-choice': A choice field was skipped because it had no valid choices. * 'non-serializable-default': A default value was skipped because it was not JSON-serializable. | *required* |\n| `detail` | `str` | A string with additional details about the warning. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `str | None` | The formatted warning message, or `None` if no warning should be emitted. |\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 2444 2445 2446 2447 2448 2449 2450 2451 2452 2453 2454 2455 2456 2457 2458 2459 2460 2461 2462 2463 ``` | ``` def render_warning_message(self, kind: JsonSchemaWarningKind, detail: str) -> str | None:     \"\"\"This method is responsible for ignoring warnings as desired, and for formatting the warning messages.      You can override the value of `ignored_warning_kinds` in a subclass of GenerateJsonSchema     to modify what warnings are generated. If you want more control, you can override this method;     just return None in situations where you don't want warnings to be emitted.      Args:         kind: The kind of warning to render. It can be one of the following:              - 'skipped-choice': A choice field was skipped because it had no valid choices.             - 'non-serializable-default': A default value was skipped because it was not JSON-serializable.         detail: A string with additional details about the warning.      Returns:         The formatted warning message, or `None` if no warning should be emitted.     \"\"\"     if kind in self.ignored_warning_kinds:         return None     return f'{detail} [{kind}]' ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#renderwarningmessage-indexhtmlpydanticjsonschemageneratejsonschemarenderwarningmessage-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "WithJsonSchema `dataclass` [Â¶](index.html#pydantic.json_schema.WithJsonSchema \"Permanent link\")", "anchor": "withjsonschema-dataclass-indexhtmlpydanticjsonschemawithjsonschema-permanent-link", "md_text": "```\nWithJsonSchema(\n    json_schema: JsonSchemaValue | None,\n    mode: (\n        Literal[\"validation\", \"serialization\"] | None\n    ) = None,\n)\n```\n\n[`WithJsonSchema` Annotation](../../concepts/json_schema/index.html#withjsonschema-annotation)\n\nAdd this as an annotation on a field to override the (base) JSON schema that would be generated for that field.\nThis provides a way to set a JSON schema for types that would otherwise raise errors when producing a JSON schema,\nsuch as Callable, or types that have an is-instance core schema, without needing to go so far as creating a\ncustom subclass of pydantic.json\\_schema.GenerateJsonSchema.\nNote that any *modifications* to the schema that would normally be made (such as setting the title for model fields)\nwill still be performed.\n\nIf `mode` is set this will only apply to that schema generation mode, allowing you\nto set different json schemas for validation and serialization.", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#withjsonschema-dataclass-indexhtmlpydanticjsonschemawithjsonschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "Examples [Â¶](index.html#pydantic.json_schema.Examples \"Permanent link\")", "anchor": "examples-indexhtmlpydanticjsonschemaexamples-permanent-link", "md_text": "```\nExamples(\n    examples: dict[str, Any],\n    mode: (\n        Literal[\"validation\", \"serialization\"] | None\n    ) = None,\n)\n\nExamples(\n    examples: list[Any],\n    mode: (\n        Literal[\"validation\", \"serialization\"] | None\n    ) = None,\n)\n\nExamples(\n    examples: dict[str, Any] | list[Any],\n    mode: (\n        Literal[\"validation\", \"serialization\"] | None\n    ) = None,\n)\n```\n\nAdd examples to a JSON schema.\n\nIf the JSON Schema already contains examples, the provided examples\nwill be appended.\n\nIf `mode` is set this will only apply to that schema generation mode,\nallowing you to add different examples for validation and serialization.\n\nSource code in `pydantic/json_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 2677 2678 2679 2680 2681 2682 2683 2684 2685 2686 2687 ``` | ``` def __init__(     self, examples: dict[str, Any] | list[Any], mode: Literal['validation', 'serialization'] | None = None ) -> None:     if isinstance(examples, dict):         warnings.warn(             'Using a dict for `examples` is deprecated, use a list instead.',             PydanticDeprecatedSince29,             stacklevel=2,         )     self.examples = examples     self.mode = mode ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#examples-indexhtmlpydanticjsonschemaexamples-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "SkipJsonSchema `dataclass` [Â¶](index.html#pydantic.json_schema.SkipJsonSchema \"Permanent link\")", "anchor": "skipjsonschema-dataclass-indexhtmlpydanticjsonschemaskipjsonschema-permanent-link", "md_text": "```\nSkipJsonSchema()\n```\n\n[`SkipJsonSchema` Annotation](../../concepts/json_schema/index.html#skipjsonschema-annotation)\n\nAdd this as an annotation on a field to skip generating a JSON schema for that field.\n\nExample\n\n```\nfrom pprint import pprint\nfrom typing import Union\n\nfrom pydantic import BaseModel\nfrom pydantic.json_schema import SkipJsonSchema\n\nclass Model(BaseModel):\n    a: Union[int, None] = None  # (1)!\n    b: Union[int, SkipJsonSchema[None]] = None  # (2)!\n    c: SkipJsonSchema[Union[int, None]] = None  # (3)!\n\npprint(Model.model_json_schema())\n'''\n{\n    'properties': {\n        'a': {\n            'anyOf': [\n                {'type': 'integer'},\n                {'type': 'null'}\n            ],\n            'default': None,\n            'title': 'A'\n        },\n        'b': {\n            'default': None,\n            'title': 'B',\n            'type': 'integer'\n        }\n    },\n    'title': 'Model',\n    'type': 'object'\n}\n'''\n```\n\n1. The integer and null types are both included in the schema for `a`.\n2. The integer type is the only type included in the schema for `b`.\n3. The entirety of the `c` field is omitted from the schema.", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#skipjsonschema-dataclass-indexhtmlpydanticjsonschemaskipjsonschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "model\\_json\\_schema [Â¶](index.html#pydantic.json_schema.model_json_schema \"Permanent link\")", "anchor": "modeljsonschema-indexhtmlpydanticjsonschemamodeljsonschema-permanent-link", "md_text": "```\nmodel_json_schema(\n    cls: type[BaseModel] | type[PydanticDataclass],\n    by_alias: bool = True,\n    ref_template: str = DEFAULT_REF_TEMPLATE,\n    union_format: Literal[\n        \"any_of\", \"primitive_type_array\"\n    ] = \"any_of\",\n    schema_generator: type[\n        GenerateJsonSchema\n    ] = GenerateJsonSchema,\n    mode: JsonSchemaMode = \"validation\",\n) -> dict[str, Any]\n```\n\nUtility function to generate a JSON Schema for a model.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `cls` | `type[BaseModel] | type[PydanticDataclass]` | The model class to generate a JSON Schema for. | *required* |\n| `by_alias` | `bool` | If `True` (the default), fields will be serialized according to their alias. If `False`, fields will be serialized according to their attribute name. | `True` |\n| `ref_template` | `str` | The template to use for generating JSON Schema references. | `DEFAULT_REF_TEMPLATE` |\n| `union_format` | `Literal['any_of', 'primitive_type_array']` | The format to use when combining schemas from unions together. Can be one of:   * `'any_of'`: Use the [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)   keyword to combine schemas (the default). * `'primitive_type_array'`: Use the [`type`](https://json-schema.org/understanding-json-schema/reference/type)   keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive   type (`string`, `boolean`, `null`, `integer` or `number`) or contains constraints/metadata, falls back to   `any_of`. | `'any_of'` |\n| `schema_generator` | `type[GenerateJsonSchema]` | The class to use for generating the JSON Schema. | `GenerateJsonSchema` |\n| `mode` | `JsonSchemaMode` | The mode to use for generating the JSON Schema. It can be one of the following:   * 'validation': Generate a JSON Schema for validating data. * 'serialization': Generate a JSON Schema for serializing data. | `'validation'` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `dict[str, Any]` | The generated JSON Schema. |\n\nSource code in `pydantic/json_schema.py`", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#modeljsonschema-indexhtmlpydanticjsonschemamodeljsonschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "model\\_json\\_schema [Â¶](index.html#pydantic.json_schema.model_json_schema \"Permanent link\")", "anchor": "modeljsonschema-indexhtmlpydanticjsonschemamodeljsonschema-permanent-link", "md_text": "|  |  |\n| --- | --- |\n| ``` 2497 2498 2499 2500 2501 2502 2503 2504 2505 2506 2507 2508 2509 2510 2511 2512 2513 2514 2515 2516 2517 2518 2519 2520 2521 2522 2523 2524 2525 2526 2527 2528 2529 2530 2531 2532 2533 2534 2535 2536 2537 2538 2539 2540 2541 2542 ``` | ``` def model_json_schema(     cls: type[BaseModel] | type[PydanticDataclass],     by_alias: bool = True,     ref_template: str = DEFAULT_REF_TEMPLATE,     union_format: Literal['any_of', 'primitive_type_array'] = 'any_of',     schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,     mode: JsonSchemaMode = 'validation', ) -> dict[str, Any]:     \"\"\"Utility function to generate a JSON Schema for a model.      Args:         cls: The model class to generate a JSON Schema for.         by_alias: If `True` (the default), fields will be serialized according to their alias.             If `False`, fields will be serialized according to their attribute name.         ref_template: The template to use for generating JSON Schema references.         union_format: The format to use when combining schemas from unions together. Can be one of:              - `'any_of'`: Use the [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)               keyword to combine schemas (the default).             - `'primitive_type_array'`: Use the [`type`](https://json-schema.org/understanding-json-schema/reference/type)               keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive               type (`string`, `boolean`, `null`, `integer` or `number`) or contains constraints/metadata, falls back to               `any_of`.         schema_generator: The class to use for generating the JSON Schema.         mode: The mode to use for generating the JSON Schema. It can be one of the following:              - 'validation': Generate a JSON Schema for validating data.             - 'serialization': Generate a JSON Schema for serializing data.      Returns:         The generated JSON Schema.     \"\"\"     from .main import BaseModel      schema_generator_instance = schema_generator(         by_alias=by_alias, ref_template=ref_template, union_format=union_format     )      if isinstance(cls.__pydantic_core_schema__, _mock_val_ser.MockCoreSchema):         cls.__pydantic_core_schema__.rebuild()      if cls is BaseModel:         raise AttributeError('model_json_schema() must be called on a subclass of BaseModel, not BaseModel itself.')      assert not isinstance(cls.__pydantic_core_schema__, _mock_val_ser.MockCoreSchema), 'this is a bug! please report it'     return schema_generator_instance.generate(cls.__pydantic_core_schema__, mode=mode) ``` |", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#modeljsonschema-indexhtmlpydanticjsonschemamodeljsonschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "models\\_json\\_schema [Â¶](index.html#pydantic.json_schema.models_json_schema \"Permanent link\")", "anchor": "modelsjsonschema-indexhtmlpydanticjsonschemamodelsjsonschema-permanent-link", "md_text": "```\nmodels_json_schema(\n    models: Sequence[\n        tuple[\n            type[BaseModel] | type[PydanticDataclass],\n            JsonSchemaMode,\n        ]\n    ],\n    *,\n    by_alias: bool = True,\n    title: str | None = None,\n    description: str | None = None,\n    ref_template: str = DEFAULT_REF_TEMPLATE,\n    union_format: Literal[\n        \"any_of\", \"primitive_type_array\"\n    ] = \"any_of\",\n    schema_generator: type[\n        GenerateJsonSchema\n    ] = GenerateJsonSchema\n) -> tuple[\n    dict[\n        tuple[\n            type[BaseModel] | type[PydanticDataclass],\n            JsonSchemaMode,\n        ],\n        JsonSchemaValue,\n    ],\n    JsonSchemaValue,\n]\n```\n\nUtility function to generate a JSON Schema for multiple models.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `models` | `Sequence[tuple[type[BaseModel] | type[PydanticDataclass], JsonSchemaMode]]` | A sequence of tuples of the form (model, mode). | *required* |\n| `by_alias` | `bool` | Whether field aliases should be used as keys in the generated JSON Schema. | `True` |\n| `title` | `str | None` | The title of the generated JSON Schema. | `None` |\n| `description` | `str | None` | The description of the generated JSON Schema. | `None` |\n| `ref_template` | `str` | The reference template to use for generating JSON Schema references. | `DEFAULT_REF_TEMPLATE` |\n| `union_format` | `Literal['any_of', 'primitive_type_array']` | The format to use when combining schemas from unions together. Can be one of:   * `'any_of'`: Use the [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)   keyword to combine schemas (the default). * `'primitive_type_array'`: Use the [`type`](https://json-schema.org/understanding-json-schema/reference/type)   keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive   type (`string`, `boolean`, `null`, `integer` or `number`) or contains constraints/metadata, falls back to   `any_of`. | `'any_of'` |\n| `schema_generator` | `type[GenerateJsonSchema]` | The schema generator to use for generating the JSON Schema. | `GenerateJsonSchema` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `tuple[dict[tuple[type[BaseModel] | type[PydanticDataclass], JsonSchemaMode], JsonSchemaValue], JsonSchemaValue]` | A tuple where: - The first element is a dictionary whose keys are tuples of JSON schema key type and JSON mode, and whose values are the JSON schema corresponding to that pair of inputs. (These schemas may have JsonRef references to definitions that are defined in the second returned element.) - The second element is a JSON schema containing all definitions referenced in the first returned element, along with the optional title and description keys. |\n\nSource code in `pydantic/json_schema.py`", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#modelsjsonschema-indexhtmlpydanticjsonschemamodelsjsonschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "models\\_json\\_schema [Â¶](index.html#pydantic.json_schema.models_json_schema \"Permanent link\")", "anchor": "modelsjsonschema-indexhtmlpydanticjsonschemamodelsjsonschema-permanent-link", "md_text": "|  |  |\n| --- | --- |\n| ``` 2545 2546 2547 2548 2549 2550 2551 2552 2553 2554 2555 2556 2557 2558 2559 2560 2561 2562 2563 2564 2565 2566 2567 2568 2569 2570 2571 2572 2573 2574 2575 2576 2577 2578 2579 2580 2581 2582 2583 2584 2585 2586 2587 2588 2589 2590 2591 2592 2593 2594 2595 2596 2597 2598 2599 ``` | ``` def models_json_schema(     models: Sequence[tuple[type[BaseModel] | type[PydanticDataclass], JsonSchemaMode]],     *,     by_alias: bool = True,     title: str | None = None,     description: str | None = None,     ref_template: str = DEFAULT_REF_TEMPLATE,     union_format: Literal['any_of', 'primitive_type_array'] = 'any_of',     schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema, ) -> tuple[dict[tuple[type[BaseModel] | type[PydanticDataclass], JsonSchemaMode], JsonSchemaValue], JsonSchemaValue]:     \"\"\"Utility function to generate a JSON Schema for multiple models.      Args:         models: A sequence of tuples of the form (model, mode).         by_alias: Whether field aliases should be used as keys in the generated JSON Schema.         title: The title of the generated JSON Schema.         description: The description of the generated JSON Schema.         ref_template: The reference template to use for generating JSON Schema references.         union_format: The format to use when combining schemas from unions together. Can be one of:              - `'any_of'`: Use the [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)               keyword to combine schemas (the default).             - `'primitive_type_array'`: Use the [`type`](https://json-schema.org/understanding-json-schema/reference/type)               keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive               type (`string`, `boolean`, `null`, `integer` or `number`) or contains constraints/metadata, falls back to               `any_of`.         schema_generator: The schema generator to use for generating the JSON Schema.      Returns:         A tuple where:             - The first element is a dictionary whose keys are tuples of JSON schema key type and JSON mode, and                 whose values are the JSON schema corresponding to that pair of inputs. (These schemas may have                 JsonRef references to definitions that are defined in the second returned element.)             - The second element is a JSON schema containing all definitions referenced in the first returned                     element, along with the optional title and description keys.     \"\"\"     for cls, _ in models:         if isinstance(cls.__pydantic_core_schema__, _mock_val_ser.MockCoreSchema):             cls.__pydantic_core_schema__.rebuild()      instance = schema_generator(by_alias=by_alias, ref_template=ref_template, union_format=union_format)     inputs: list[tuple[type[BaseModel] | type[PydanticDataclass], JsonSchemaMode, CoreSchema]] = [         (m, mode, m.__pydantic_core_schema__) for m, mode in models     ]     json_schemas_map, definitions = instance.generate_definitions(inputs)      json_schema: dict[str, Any] = {}     if definitions:         json_schema['$defs'] = definitions     if title:         json_schema['title'] = title     if description:         json_schema['description'] = description      return json_schemas_map, json_schema ``` |\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/api/json_schema/index.html#modelsjsonschema-indexhtmlpydanticjsonschemamodelsjsonschema-permanent-link", "page": "api/json_schema/index.html", "source_site": "pydantic"}
{"title": "Field [Â¶](index.html#pydantic.fields.Field \"Permanent link\")", "anchor": "field-indexhtmlpydanticfieldsfield-permanent-link", "md_text": "```\nField(\n    default: ellipsis,\n    *,\n    alias: str | None = _Unset,\n    alias_priority: int | None = _Unset,\n    validation_alias: (\n        str | AliasPath | AliasChoices | None\n    ) = _Unset,\n    serialization_alias: str | None = _Unset,\n    title: str | None = _Unset,\n    field_title_generator: (\n        Callable[[str, FieldInfo], str] | None\n    ) = _Unset,\n    description: str | None = _Unset,\n    examples: list[Any] | None = _Unset,\n    exclude: bool | None = _Unset,\n    exclude_if: Callable[[Any], bool] | None = _Unset,\n    discriminator: str | Discriminator | None = _Unset,\n    deprecated: Deprecated | str | bool | None = _Unset,\n    json_schema_extra: (\n        JsonDict | Callable[[JsonDict], None] | None\n    ) = _Unset,\n    frozen: bool | None = _Unset,\n    validate_default: bool | None = _Unset,\n    repr: bool = _Unset,\n    init: bool | None = _Unset,\n    init_var: bool | None = _Unset,\n    kw_only: bool | None = _Unset,\n    pattern: str | Pattern[str] | None = _Unset,\n    strict: bool | None = _Unset,\n    coerce_numbers_to_str: bool | None = _Unset,\n    gt: SupportsGt | None = _Unset,\n    ge: SupportsGe | None = _Unset,\n    lt: SupportsLt | None = _Unset,\n    le: SupportsLe | None = _Unset,\n    multiple_of: float | None = _Unset,\n    allow_inf_nan: bool | None = _Unset,\n    max_digits: int | None = _Unset,\n    decimal_places: int | None = _Unset,\n    min_length: int | None = _Unset,\n    max_length: int | None = _Unset,\n    union_mode: Literal[\"smart\", \"left_to_right\"] = _Unset,\n    fail_fast: bool | None = _Unset,\n    **extra: Unpack[_EmptyKwargs]\n) -> Any\n\nField(\n    default: Any,\n    *,\n    alias: str | None = _Unset,\n    alias_priority: int | None = _Unset,\n    validation_alias: (\n        str | AliasPath | AliasChoices | None\n    ) = _Unset,\n    serialization_alias: str | None = _Unset,\n    title: str | None = _Unset,\n    field_title_generator: (\n        Callable[[str, FieldInfo], str] | None\n    ) = _Unset,\n    description: str | None = _Unset,\n    examples: list[Any] | None = _Unset,\n    exclude: bool | None = _Unset,\n    exclude_if: Callable[[Any], bool] | None = _Unset,\n    discriminator: str | Discriminator | None = _Unset,\n    deprecated: Deprecated | str | bool | None = _Unset,\n    json_schema_extra: (\n        JsonDict | Callable[[JsonDict], None] | None\n    ) = _Unset,\n    frozen: bool | None = _Unset,\n    validate_default: Literal[True],\n    repr: bool = _Unset,\n    init: bool | None = _Unset,\n    init_var: bool | None = _Unset,\n    kw_only: bool | None = _Unset,\n    pattern: str | Pattern[str] | None = _Unset,\n    strict: bool | None = _Unset,\n    coerce_numbers_to_str: bool | None = _Unset,\n    gt: SupportsGt | None = _Unset,\n    ge: SupportsGe | None = _Unset,\n    lt: SupportsLt | None = _Unset,\n    le: SupportsLe | None = _Unset,\n    multiple_of: float | None = _Unset,\n    allow_inf_nan: bool | None = _Unset,\n    max_digits: int | None = _Unset,\n    decimal_places: int | None = _Unset,\n    min_length: int | None = _Unset,\n    max_length: int | None = _Unset,\n    union_mode: Literal[\"smart\", \"left_to_right\"] = _Unset,\n    fail_fast: bool | None = _Unset,\n    **extra: Unpack[_EmptyKwargs]\n) -> Any", "url": "https://docs.pydantic.dev/latest/api/fields/index.html#field-indexhtmlpydanticfieldsfield-permanent-link", "page": "api/fields/index.html", "source_site": "pydantic"}
{"title": "Field [Â¶](index.html#pydantic.fields.Field \"Permanent link\")", "anchor": "field-indexhtmlpydanticfieldsfield-permanent-link", "md_text": "Field(\n    default: _T,\n    *,\n    alias: str | None = _Unset,\n    alias_priority: int | None = _Unset,\n    validation_alias: (\n        str | AliasPath | AliasChoices | None\n    ) = _Unset,\n    serialization_alias: str | None = _Unset,\n    title: str | None = _Unset,\n    field_title_generator: (\n        Callable[[str, FieldInfo], str] | None\n    ) = _Unset,\n    description: str | None = _Unset,\n    examples: list[Any] | None = _Unset,\n    exclude: bool | None = _Unset,\n    exclude_if: Callable[[Any], bool] | None = _Unset,\n    discriminator: str | Discriminator | None = _Unset,\n    deprecated: Deprecated | str | bool | None = _Unset,\n    json_schema_extra: (\n        JsonDict | Callable[[JsonDict], None] | None\n    ) = _Unset,\n    frozen: bool | None = _Unset,\n    validate_default: Literal[False] = ...,\n    repr: bool = _Unset,\n    init: bool | None = _Unset,\n    init_var: bool | None = _Unset,\n    kw_only: bool | None = _Unset,\n    pattern: str | Pattern[str] | None = _Unset,\n    strict: bool | None = _Unset,\n    coerce_numbers_to_str: bool | None = _Unset,\n    gt: SupportsGt | None = _Unset,\n    ge: SupportsGe | None = _Unset,\n    lt: SupportsLt | None = _Unset,\n    le: SupportsLe | None = _Unset,\n    multiple_of: float | None = _Unset,\n    allow_inf_nan: bool | None = _Unset,\n    max_digits: int | None = _Unset,\n    decimal_places: int | None = _Unset,\n    min_length: int | None = _Unset,\n    max_length: int | None = _Unset,\n    union_mode: Literal[\"smart\", \"left_to_right\"] = _Unset,\n    fail_fast: bool | None = _Unset,\n    **extra: Unpack[_EmptyKwargs]\n) -> _T\n\nField(\n    *,\n    default_factory: (\n        Callable[[], Any] | Callable[[dict[str, Any]], Any]\n    ),\n    alias: str | None = _Unset,\n    alias_priority: int | None = _Unset,\n    validation_alias: (\n        str | AliasPath | AliasChoices | None\n    ) = _Unset,\n    serialization_alias: str | None = _Unset,\n    title: str | None = _Unset,\n    field_title_generator: (\n        Callable[[str, FieldInfo], str] | None\n    ) = _Unset,\n    description: str | None = _Unset,\n    examples: list[Any] | None = _Unset,\n    exclude: bool | None = _Unset,\n    exclude_if: Callable[[Any], bool] | None = _Unset,\n    discriminator: str | Discriminator | None = _Unset,\n    deprecated: Deprecated | str | bool | None = _Unset,\n    json_schema_extra: (\n        JsonDict | Callable[[JsonDict], None] | None\n    ) = _Unset,\n    frozen: bool | None = _Unset,\n    validate_default: Literal[True],\n    repr: bool = _Unset,\n    init: bool | None = _Unset,\n    init_var: bool | None = _Unset,\n    kw_only: bool | None = _Unset,\n    pattern: str | Pattern[str] | None = _Unset,\n    strict: bool | None = _Unset,\n    coerce_numbers_to_str: bool | None = _Unset,\n    gt: SupportsGt | None = _Unset,\n    ge: SupportsGe | None = _Unset,\n    lt: SupportsLt | None = _Unset,\n    le: SupportsLe | None = _Unset,\n    multiple_of: float | None = _Unset,\n    allow_inf_nan: bool | None = _Unset,\n    max_digits: int | None = _Unset,\n    decimal_places: int | None = _Unset,\n    min_length: int | None = _Unset,\n    max_length: int | None = _Unset,\n    union_mode: Literal[\"smart\", \"left_to_right\"] = _Unset,\n    fail_fast: bool | None = _Unset,\n    **extra: Unpack[_EmptyKwargs]\n) -> Any", "url": "https://docs.pydantic.dev/latest/api/fields/index.html#field-indexhtmlpydanticfieldsfield-permanent-link", "page": "api/fields/index.html", "source_site": "pydantic"}
{"title": "Field [Â¶](index.html#pydantic.fields.Field \"Permanent link\")", "anchor": "field-indexhtmlpydanticfieldsfield-permanent-link", "md_text": "Field(\n    *,\n    default_factory: (\n        Callable[[], _T] | Callable[[dict[str, Any]], _T]\n    ),\n    alias: str | None = _Unset,\n    alias_priority: int | None = _Unset,\n    validation_alias: (\n        str | AliasPath | AliasChoices | None\n    ) = _Unset,\n    serialization_alias: str | None = _Unset,\n    title: str | None = _Unset,\n    field_title_generator: (\n        Callable[[str, FieldInfo], str] | None\n    ) = _Unset,\n    description: str | None = _Unset,\n    examples: list[Any] | None = _Unset,\n    exclude: bool | None = _Unset,\n    exclude_if: Callable[[Any], bool] | None = _Unset,\n    discriminator: str | Discriminator | None = _Unset,\n    deprecated: Deprecated | str | bool | None = _Unset,\n    json_schema_extra: (\n        JsonDict | Callable[[JsonDict], None] | None\n    ) = _Unset,\n    frozen: bool | None = _Unset,\n    validate_default: Literal[False] | None = _Unset,\n    repr: bool = _Unset,\n    init: bool | None = _Unset,\n    init_var: bool | None = _Unset,\n    kw_only: bool | None = _Unset,\n    pattern: str | Pattern[str] | None = _Unset,\n    strict: bool | None = _Unset,\n    coerce_numbers_to_str: bool | None = _Unset,\n    gt: SupportsGt | None = _Unset,\n    ge: SupportsGe | None = _Unset,\n    lt: SupportsLt | None = _Unset,\n    le: SupportsLe | None = _Unset,\n    multiple_of: float | None = _Unset,\n    allow_inf_nan: bool | None = _Unset,\n    max_digits: int | None = _Unset,\n    decimal_places: int | None = _Unset,\n    min_length: int | None = _Unset,\n    max_length: int | None = _Unset,\n    union_mode: Literal[\"smart\", \"left_to_right\"] = _Unset,\n    fail_fast: bool | None = _Unset,\n    **extra: Unpack[_EmptyKwargs]\n) -> _T\n\nField(\n    *,\n    alias: str | None = _Unset,\n    alias_priority: int | None = _Unset,\n    validation_alias: (\n        str | AliasPath | AliasChoices | None\n    ) = _Unset,\n    serialization_alias: str | None = _Unset,\n    title: str | None = _Unset,\n    field_title_generator: (\n        Callable[[str, FieldInfo], str] | None\n    ) = _Unset,\n    description: str | None = _Unset,\n    examples: list[Any] | None = _Unset,\n    exclude: bool | None = _Unset,\n    exclude_if: Callable[[Any], bool] | None = _Unset,\n    discriminator: str | Discriminator | None = _Unset,\n    deprecated: Deprecated | str | bool | None = _Unset,\n    json_schema_extra: (\n        JsonDict | Callable[[JsonDict], None] | None\n    ) = _Unset,\n    frozen: bool | None = _Unset,\n    validate_default: bool | None = _Unset,\n    repr: bool = _Unset,\n    init: bool | None = _Unset,\n    init_var: bool | None = _Unset,\n    kw_only: bool | None = _Unset,\n    pattern: str | Pattern[str] | None = _Unset,\n    strict: bool | None = _Unset,\n    coerce_numbers_to_str: bool | None = _Unset,\n    gt: SupportsGt | None = _Unset,\n    ge: SupportsGe | None = _Unset,\n    lt: SupportsLt | None = _Unset,\n    le: SupportsLe | None = _Unset,\n    multiple_of: float | None = _Unset,\n    allow_inf_nan: bool | None = _Unset,\n    max_digits: int | None = _Unset,\n    decimal_places: int | None = _Unset,\n    min_length: int | None = _Unset,\n    max_length: int | None = _Unset,\n    union_mode: Literal[\"smart\", \"left_to_right\"] = _Unset,\n    fail_fast: bool | None = _Unset,\n    **extra: Unpack[_EmptyKwargs]\n) -> Any", "url": "https://docs.pydantic.dev/latest/api/fields/index.html#field-indexhtmlpydanticfieldsfield-permanent-link", "page": "api/fields/index.html", "source_site": "pydantic"}
{"title": "Field [Â¶](index.html#pydantic.fields.Field \"Permanent link\")", "anchor": "field-indexhtmlpydanticfieldsfield-permanent-link", "md_text": "Field(\n    default: Any = PydanticUndefined,\n    *,\n    default_factory: (\n        Callable[[], Any]\n        | Callable[[dict[str, Any]], Any]\n        | None\n    ) = _Unset,\n    alias: str | None = _Unset,\n    alias_priority: int | None = _Unset,\n    validation_alias: (\n        str | AliasPath | AliasChoices | None\n    ) = _Unset,\n    serialization_alias: str | None = _Unset,\n    title: str | None = _Unset,\n    field_title_generator: (\n        Callable[[str, FieldInfo], str] | None\n    ) = _Unset,\n    description: str | None = _Unset,\n    examples: list[Any] | None = _Unset,\n    exclude: bool | None = _Unset,\n    exclude_if: Callable[[Any], bool] | None = _Unset,\n    discriminator: str | Discriminator | None = _Unset,\n    deprecated: Deprecated | str | bool | None = _Unset,\n    json_schema_extra: (\n        JsonDict | Callable[[JsonDict], None] | None\n    ) = _Unset,\n    frozen: bool | None = _Unset,\n    validate_default: bool | None = _Unset,\n    repr: bool = _Unset,\n    init: bool | None = _Unset,\n    init_var: bool | None = _Unset,\n    kw_only: bool | None = _Unset,\n    pattern: str | Pattern[str] | None = _Unset,\n    strict: bool | None = _Unset,\n    coerce_numbers_to_str: bool | None = _Unset,\n    gt: SupportsGt | None = _Unset,\n    ge: SupportsGe | None = _Unset,\n    lt: SupportsLt | None = _Unset,\n    le: SupportsLe | None = _Unset,\n    multiple_of: float | None = _Unset,\n    allow_inf_nan: bool | None = _Unset,\n    max_digits: int | None = _Unset,\n    decimal_places: int | None = _Unset,\n    min_length: int | None = _Unset,\n    max_length: int | None = _Unset,\n    union_mode: Literal[\"smart\", \"left_to_right\"] = _Unset,\n    fail_fast: bool | None = _Unset,\n    **extra: Unpack[_EmptyKwargs]\n) -> Any\n```\n\n[Fields](../../concepts/fields/index.html)\n\nCreate a field for objects that can be configured.\n\nUsed to provide extra information about a field, either for the model schema or complex validation. Some arguments\napply only to number fields (`int`, `float`, `Decimal`) and some apply only to `str`.\n\nNote\n\n* Any `_Unset` objects will be replaced by the corresponding value defined in the `_DefaultValues` dictionary. If a key for the `_Unset` object is not found in the `_DefaultValues` dictionary, it will default to `None`\n\nParameters:", "url": "https://docs.pydantic.dev/latest/api/fields/index.html#field-indexhtmlpydanticfieldsfield-permanent-link", "page": "api/fields/index.html", "source_site": "pydantic"}
{"title": "Field [Â¶](index.html#pydantic.fields.Field \"Permanent link\")", "anchor": "field-indexhtmlpydanticfieldsfield-permanent-link", "md_text": "| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `default` | `Any` | Default value if the field is not set. | `PydanticUndefined` |\n| `default_factory` | `Callable[[], Any] | Callable[[dict[str, Any]], Any] | None` | A callable to generate the default value. The callable can either take 0 arguments (in which case it is called as is) or a single argument containing the already validated data. | `_Unset` |\n| `alias` | `str | None` | The name to use for the attribute when validating or serializing by alias. This is often used for things like converting between snake and camel case. | `_Unset` |\n| `alias_priority` | `int | None` | Priority of the alias. This affects whether an alias generator is used. | `_Unset` |\n| `validation_alias` | `str | AliasPath | AliasChoices | None` | Like `alias`, but only affects validation, not serialization. | `_Unset` |\n| `serialization_alias` | `str | None` | Like `alias`, but only affects serialization, not validation. | `_Unset` |\n| `title` | `str | None` | Human-readable title. | `_Unset` |\n| `field_title_generator` | `Callable[[str, FieldInfo], str] | None` | A callable that takes a field name and returns title for it. | `_Unset` |\n| `description` | `str | None` | Human-readable description. | `_Unset` |\n| `examples` | `list[Any] | None` | Example values for this field. | `_Unset` |\n| `exclude` | `bool | None` | Whether to exclude the field from the model serialization. | `_Unset` |\n| `exclude_if` | `Callable[[Any], bool] | None` | A callable that determines whether to exclude a field during serialization based on its value. | `_Unset` |\n| `discriminator` | `str | Discriminator | None` | Field name or Discriminator for discriminating the type in a tagged union. | `_Unset` |\n| `deprecated` | `Deprecated | str | bool | None` | A deprecation message, an instance of `warnings.deprecated` or the `typing_extensions.deprecated` backport, or a boolean. If `True`, a default deprecation message will be emitted when accessing the field. | `_Unset` |\n| `json_schema_extra` | `JsonDict | Callable[[JsonDict], None] | None` | A dict or callable to provide extra JSON schema properties. | `_Unset` |\n| `frozen` | `bool | None` | Whether the field is frozen. If true, attempts to change the value on an instance will raise an error. | `_Unset` |\n| `validate_default` | `bool | None` | If `True`, apply validation to the default value every time you create an instance. Otherwise, for performance reasons, the default value of the field is trusted and not validated. | `_Unset` |\n| `repr` | `bool` | A boolean indicating whether to include the field in the `__repr__` output. | `_Unset` |\n| `init` | `bool | None` | Whether the field should be included in the constructor of the dataclass. (Only applies to dataclasses.) | `_Unset` |\n| `init_var` | `bool | None` | Whether the field should *only* be included in the constructor of the dataclass. (Only applies to dataclasses.) | `_Unset` |\n| `kw_only` | `bool | None` | Whether the field should be a keyword-only argument in the constructor of the dataclass. (Only applies to dataclasses.) | `_Unset` |\n| `coerce_numbers_to_str` | `bool | None` | Whether to enable coercion of any `Number` type to `str` (not applicable in `strict` mode). | `_Unset` |\n| `strict` | `bool | None` | If `True`, strict validation is applied to the field. See [Strict Mode](../../concepts/strict_mode/index.html) for details. | `_Unset` |\n| `gt` | `SupportsGt | None` | Greater than. If set, value must be greater than this. Only applicable to numbers. | `_Unset` |\n| `ge` | `SupportsGe | None` | Greater than or equal. If set, value must be greater than or equal to this. Only applicable to numbers. | `_Unset` |\n| `lt` | `SupportsLt | None` | Less than. If set, value must be less than this. Only applicable to numbers. | `_Unset` |\n| `le` | `SupportsLe | None` | Less than or equal. If set, value must be less than or equal to this. Only applicable to numbers. | `_Unset` |\n| `multiple_of` | `float | None` | Value must be a multiple of this. Only applicable to numbers. | `_Unset` |\n| `min_length` | `int | None` | Minimum length for iterables. | `_Unset` |\n| `max_length` | `int | None` | Maximum length for iterables. | `_Unset` |\n| `pattern` | `str | Pattern[str] | None` | Pattern for strings (a regular expression). | `_Unset` |\n| `allow_inf_nan` | `bool | None` | Allow `inf`, `-inf`, `nan`. Only applicable to float and [`Decimal`](https://docs.python.org/3/library/decimal.html#decimal.Decimal) numbers. | `_Unset` |\n| `max_digits` | `int | None` | Maximum number of allow digits for strings. | `_Unset` |\n| `decimal_places` | `int | None` | Maximum number of decimal places allowed for numbers. | `_Unset` |\n| `union_mode` | `Literal['smart', 'left_to_right']` | The strategy to apply when validating a union. Can be `smart` (the default), or `left_to_right`. See [Union Mode](../../concepts/unions/index.html#union-modes) for details. | `_Unset` |\n| `fail_fast` | `bool | None` | If `True`, validation will stop on the first error. If `False`, all validation errors will be collected. This option can be applied only to iterable types (list, tuple, set, and frozenset). | `_Unset` |\n| `extra` | `Unpack[_EmptyKwargs]` | (Deprecated) Extra fields that will be included in the JSON schema.  The `extra` kwargs is deprecated. Use `json_schema_extra` instead. | `{}` |", "url": "https://docs.pydantic.dev/latest/api/fields/index.html#field-indexhtmlpydanticfieldsfield-permanent-link", "page": "api/fields/index.html", "source_site": "pydantic"}
{"title": "Field [Â¶](index.html#pydantic.fields.Field \"Permanent link\")", "anchor": "field-indexhtmlpydanticfieldsfield-permanent-link", "md_text": "Returns:\n\n| Type | Description |\n| --- | --- |\n| `Any` | A new [`FieldInfo`](index.html#pydantic.fields.FieldInfo). The return annotation is `Any` so `Field` can be used on type-annotated fields without causing a type error. |\n\nSource code in `pydantic/fields.py`", "url": "https://docs.pydantic.dev/latest/api/fields/index.html#field-indexhtmlpydanticfieldsfield-permanent-link", "page": "api/fields/index.html", "source_site": "pydantic"}
{"title": "Field [Â¶](index.html#pydantic.fields.Field \"Permanent link\")", "anchor": "field-indexhtmlpydanticfieldsfield-permanent-link", "md_text": "|  |  |\n| --- | --- |\n| ``` 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 ``` | ``` def Field(  # noqa: C901     default: Any = PydanticUndefined,     *,     default_factory: Callable[[], Any] | Callable[[dict[str, Any]], Any] | None = _Unset,     alias: str | None = _Unset,     alias_priority: int | None = _Unset,     validation_alias: str | AliasPath | AliasChoices | None = _Unset,     serialization_alias: str | None = _Unset,     title: str | None = _Unset,     field_title_generator: Callable[[str, FieldInfo], str] | None = _Unset,     description: str | None = _Unset,     examples: list[Any] | None = _Unset,     exclude: bool | None = _Unset,     exclude_if: Callable[[Any], bool] | None = _Unset,     discriminator: str | types.Discriminator | None = _Unset,     deprecated: Deprecated | str | bool | None = _Unset,     json_schema_extra: JsonDict | Callable[[JsonDict], None] | None = _Unset,     frozen: bool | None = _Unset,     validate_default: bool | None = _Unset,     repr: bool = _Unset,     init: bool | None = _Unset,     init_var: bool | None = _Unset,     kw_only: bool | None = _Unset,     pattern: str | re.Pattern[str] | None = _Unset,     strict: bool | None = _Unset,     coerce_numbers_to_str: bool | None = _Unset,     gt: annotated_types.SupportsGt | None = _Unset,     ge: annotated_types.SupportsGe | None = _Unset,     lt: annotated_types.SupportsLt | None = _Unset,     le: annotated_types.SupportsLe | None = _Unset,     multiple_of: float | None = _Unset,     allow_inf_nan: bool | None = _Unset,     max_digits: int | None = _Unset,     decimal_places: int | None = _Unset,     min_length: int | None = _Unset,     max_length: int | None = _Unset,     union_mode: Literal['smart', 'left_to_right'] = _Unset,     fail_fast: bool | None = _Unset,     **extra: Unpack[_EmptyKwargs], ) -> Any:     \"\"\"!!! abstract \"Usage Documentation\"         [Fields](../concepts/fields.md)      Create a field for objects that can be configured.      Used to provide extra information about a field, either for the model schema or complex validation. Some arguments     apply only to number fields (`int`, `float`, `Decimal`) and some apply only to `str`.      Note:         - Any `_Unset` objects will be replaced by the corresponding value defined in the `_DefaultValues` dictionary. If a key for the `_Unset` object is not found in the `_DefaultValues` dictionary, it will default to `None`      Args:         default: Default value if the field is not set.         default_factory: A callable to generate the default value. The callable can either take 0 arguments             (in which case it is called as is) or a single argument containing the already validated data.         alias: The name to use for the attribute when validating or serializing by alias.             This is often used for things like converting between snake and camel case.         alias_priority: Priority of the alias. This affects whether an alias generator is used.         validation_alias: Like `alias`, but only affects validation, not serialization.         serialization_alias: Like `alias`, but only affects serialization, not validation.         title: Human-readable title.         field_title_generator: A callable that takes a field name and returns title for it.         description: Human-readable description.         examples: Example values for this field.         exclude: Whether to exclude the field from the model serialization.         exclude_if: A callable that determines whether to exclude a field during serialization based on its value.         discriminator: Field name or Discriminator for discriminating the type in a tagged union.         deprecated: A deprecation message, an instance of `warnings.deprecated` or the `typing_extensions.deprecated` backport,             or a boolean. If `True`, a default deprecation message will be emitted when accessing the field.         json_schema_extra: A dict or callable to provide extra JSON schema properties.         frozen: Whether the field is frozen. If true, attempts to change the value on an instance will raise an error.         validate_default: If `True`, apply validation to the default value every time you create an instance.             Otherwise, for performance reasons, the default value of the field is trusted and not validated.         repr: A boolean indicating whether to include the field in the `__repr__` output.         init: Whether the field should be included in the constructor of the dataclass.             (Only applies to dataclasses.)         init_var: Whether the field should _only_ be included in the constructor of the dataclass.             (Only applies to dataclasses.)         kw_only: Whether the field should be a keyword-only argument in the constructor of the dataclass.             (Only applies to dataclasses.)         coerce_numbers_to_str: Whether to enable coercion of any `Number` type to `str` (not applicable in `strict` mode).         strict: If `True`, strict validation is applied to the field.             See [Strict Mode](../concepts/strict_mode.md) for details.         gt: Greater than. If set, value must be greater than this. Only applicable to numbers.         ge: Greater than or equal. If set, value must be greater than or equal to this. Only applicable to numbers.         lt: Less than. If set, value must be less than this. Only applicable to numbers.         le: Less than or equal. If set, value must be less than or equal to this. Only applicable to numbers.         multiple_of: Value must be a multiple of this. Only applicable to numbers.         min_length: Minimum length for iterables.         max_length: Maximum length for iterables.         pattern: Pattern for strings (a regular expression).         allow_inf_nan: Allow `inf`, `-inf`, `nan`. Only applicable to float and [`Decimal`][decimal.Decimal] numbers.         max_digits: Maximum number of allow digits for strings.         decimal_places: Maximum number of decimal places allowed for numbers.         union_mode: The strategy to apply when validating a union. Can be `smart` (the default), or `left_to_right`.             See [Union Mode](../concepts/unions.md#union-modes) for details.         fail_fast: If `True`, validation will stop on the first error. If `False`, all validation errors will be collected.             This option can be applied only to iterable types (list, tuple, set, and frozenset).         extra: (Deprecated) Extra fields that will be included in the JSON schema.              !!! warning Deprecated                 The `extra` kwargs is deprecated. Use `json_schema_extra` instead.      Returns:         A new [`FieldInfo`][pydantic.fields.FieldInfo]. The return annotation is `Any` so `Field` can be used on             type-annotated fields without causing a type error.     \"\"\"     # Check deprecated and removed params from V1. This logic should eventually be removed.     const = extra.pop('const', None)  # type: ignore     if const is not None:         raise PydanticUserError('`const` is removed, use `Literal` instead', code='removed-kwargs')      min_items = extra.pop('min_items', None)  # type: ignore     if min_items is not None:         warn(             '`min_items` is deprecated and will be removed, use `min_length` instead',             PydanticDeprecatedSince20,             stacklevel=2,         )         if min_length in (None, _Unset):             min_length = min_items  # type: ignore      max_items = extra.pop('max_items', None)  # type: ignore     if max_items is not None:         warn(             '`max_items` is deprecated and will be removed, use `max_length` instead',             PydanticDeprecatedSince20,             stacklevel=2,         )         if max_length in (None, _Unset):             max_length = max_items  # type: ignore      unique_items = extra.pop('unique_items', None)  # type: ignore     if unique_items is not None:         raise PydanticUserError(             (                 '`unique_items` is removed, use `Set` instead'                 '(this feature is discussed in https://github.com/pydantic/pydantic-core/issues/296)'             ),             code='removed-kwargs',         )      allow_mutation = extra.pop('allow_mutation', None)  # type: ignore     if allow_mutation is not None:         warn(             '`allow_mutation` is deprecated and will be removed. use `frozen` instead',             PydanticDeprecatedSince20,             stacklevel=2,         )         if allow_mutation is False:             frozen = True      regex = extra.pop('regex', None)  # type: ignore     if regex is not None:         raise PydanticUserError('`regex` is removed. use `pattern` instead', code='removed-kwargs')      if extra:         warn(             'Using extra keyword arguments on `Field` is deprecated and will be removed.'             ' Use `json_schema_extra` instead.'             f' (Extra keys: {\", \".join(k.__repr__() for k in extra.keys())})',             PydanticDeprecatedSince20,             stacklevel=2,         )         if not json_schema_extra or json_schema_extra is _Unset:             json_schema_extra = extra  # type: ignore      if (         validation_alias         and validation_alias is not _Unset         and not isinstance(validation_alias, (str, AliasChoices, AliasPath))     ):         raise TypeError('Invalid `validation_alias` type. it should be `str`, `AliasChoices`, or `AliasPath`')      if serialization_alias in (_Unset, None) and isinstance(alias, str):         serialization_alias = alias      if validation_alias in (_Unset, None):         validation_alias = alias      include = extra.pop('include', None)  # type: ignore     if include is not None:         warn(             '`include` is deprecated and does nothing. It will be removed, use `exclude` instead',             PydanticDeprecatedSince20,             stacklevel=2,         )      return FieldInfo.from_field(         default,         default_factory=default_factory,         alias=alias,         alias_priority=alias_priority,         validation_alias=validation_alias,         serialization_alias=serialization_alias,         title=title,         field_title_generator=field_title_generator,         description=description,         examples=examples,         exclude=exclude,         exclude_if=exclude_if,         discriminator=discriminator,         deprecated=deprecated,         json_schema_extra=json_schema_extra,         frozen=frozen,         pattern=pattern,         validate_default=validate_default,         repr=repr,         init=init,         init_var=init_var,         kw_only=kw_only,         coerce_numbers_to_str=coerce_numbers_to_str,         strict=strict,         gt=gt,         ge=ge,         lt=lt,         le=le,         multiple_of=multiple_of,         min_length=min_length,         max_length=max_length,         allow_inf_nan=allow_inf_nan,         max_digits=max_digits,         decimal_places=decimal_places,         union_mode=union_mode,         fail_fast=fail_fast,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/fields/index.html#field-indexhtmlpydanticfieldsfield-permanent-link", "page": "api/fields/index.html", "source_site": "pydantic"}
{"title": "FieldInfo [Â¶](index.html#pydantic.fields.FieldInfo \"Permanent link\")", "anchor": "fieldinfo-indexhtmlpydanticfieldsfieldinfo-permanent-link", "md_text": "```\nFieldInfo(**kwargs: Unpack[_FieldInfoInputs])\n```\n\nBases: `Representation`\n\nThis class holds information about a field.\n\n`FieldInfo` is used for any field definition regardless of whether the [`Field()`](index.html#pydantic.fields.Field)\nfunction is explicitly used.\n\nThe `FieldInfo` class is meant to expose information about a field in a Pydantic model or dataclass.\n`FieldInfo` instances shouldn't be instantiated directly, nor mutated.\n\nIf you need to derive a new model from another one and are willing to alter `FieldInfo` instances,\nrefer to this [dynamic model example](../../examples/dynamic_models/index.html).\n\nAttributes:\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `annotation` | `type[Any] | None` | The type annotation of the field. |\n| `default` | `Any` | The default value of the field. |\n| `default_factory` | `Callable[[], Any] | Callable[[dict[str, Any]], Any] | None` | A callable to generate the default value. The callable can either take 0 arguments (in which case it is called as is) or a single argument containing the already validated data. |\n| `alias` | `str | None` | The alias name of the field. |\n| `alias_priority` | `int | None` | The priority of the field's alias. |\n| `validation_alias` | `str | AliasPath | AliasChoices | None` | The validation alias of the field. |\n| `serialization_alias` | `str | None` | The serialization alias of the field. |\n| `title` | `str | None` | The title of the field. |\n| `field_title_generator` | `Callable[[str, FieldInfo], str] | None` | A callable that takes a field name and returns title for it. |\n| `description` | `str | None` | The description of the field. |\n| `examples` | `list[Any] | None` | List of examples of the field. |\n| `exclude` | `bool | None` | Whether to exclude the field from the model serialization. |\n| `exclude_if` | `Callable[[Any], bool] | None` | A callable that determines whether to exclude a field during serialization based on its value. |\n| `discriminator` | `str | Discriminator | None` | Field name or Discriminator for discriminating the type in a tagged union. |\n| `deprecated` | `Deprecated | str | bool | None` | A deprecation message, an instance of `warnings.deprecated` or the `typing_extensions.deprecated` backport, or a boolean. If `True`, a default deprecation message will be emitted when accessing the field. |\n| `json_schema_extra` | `JsonDict | Callable[[JsonDict], None] | None` | A dict or callable to provide extra JSON schema properties. |\n| `frozen` | `bool | None` | Whether the field is frozen. |\n| `validate_default` | `bool | None` | Whether to validate the default value of the field. |\n| `repr` | `bool` | Whether to include the field in representation of the model. |\n| `init` | `bool | None` | Whether the field should be included in the constructor of the dataclass. |\n| `init_var` | `bool | None` | Whether the field should *only* be included in the constructor of the dataclass, and not stored. |\n| `kw_only` | `bool | None` | Whether the field should be a keyword-only argument in the constructor of the dataclass. |\n| `metadata` | `list[Any]` | The metadata list. Contains all the data that isn't expressed as direct `FieldInfo` attributes, including:   * Type-specific constraints, such as `gt` or `min_length` (these are converted to metadata classes such as `annotated_types.Gt`). * Any other arbitrary object used within [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated) metadata   (e.g. [custom types handlers](../../concepts/types/index.html#as-an-annotation) or any object not recognized by Pydantic). |\n\nSee the signature of `pydantic.fields.Field` for more details about the expected arguments.\n\nSource code in `pydantic/fields.py`", "url": "https://docs.pydantic.dev/latest/api/fields/index.html#fieldinfo-indexhtmlpydanticfieldsfieldinfo-permanent-link", "page": "api/fields/index.html", "source_site": "pydantic"}
{"title": "FieldInfo [Â¶](index.html#pydantic.fields.FieldInfo \"Permanent link\")", "anchor": "fieldinfo-indexhtmlpydanticfieldsfieldinfo-permanent-link", "md_text": "|  |  |\n| --- | --- |\n| ``` 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 ``` | ``` def __init__(self, **kwargs: Unpack[_FieldInfoInputs]) -> None:     \"\"\"This class should generally not be initialized directly; instead, use the `pydantic.fields.Field` function     or one of the constructor classmethods.      See the signature of `pydantic.fields.Field` for more details about the expected arguments.     \"\"\"     # Tracking the explicitly set attributes is necessary to correctly merge `Field()` functions     # (e.g. with `Annotated[int, Field(alias='a'), Field(alias=None)]`, even though `None` is the default value,     # we need to track that `alias=None` was explicitly set):     self._attributes_set = {k: v for k, v in kwargs.items() if v is not _Unset and k not in self.metadata_lookup}     kwargs = {k: _DefaultValues.get(k) if v is _Unset else v for k, v in kwargs.items()}  # type: ignore     self.annotation = kwargs.get('annotation')      # Note: in theory, the second `pop()` arguments are not required below, as defaults are already set from `_DefaultsValues`.     default = kwargs.pop('default', PydanticUndefined)     if default is Ellipsis:         self.default = PydanticUndefined         self._attributes_set.pop('default', None)     else:         self.default = default      self.default_factory = kwargs.pop('default_factory', None)      if self.default is not PydanticUndefined and self.default_factory is not None:         raise TypeError('cannot specify both default and default_factory')      self.alias = kwargs.pop('alias', None)     self.validation_alias = kwargs.pop('validation_alias', None)     self.serialization_alias = kwargs.pop('serialization_alias', None)     alias_is_set = any(alias is not None for alias in (self.alias, self.validation_alias, self.serialization_alias))     self.alias_priority = kwargs.pop('alias_priority', None) or 2 if alias_is_set else None     self.title = kwargs.pop('title', None)     self.field_title_generator = kwargs.pop('field_title_generator', None)     self.description = kwargs.pop('description', None)     self.examples = kwargs.pop('examples', None)     self.exclude = kwargs.pop('exclude', None)     self.exclude_if = kwargs.pop('exclude_if', None)     self.discriminator = kwargs.pop('discriminator', None)     # For compatibility with FastAPI<=0.110.0, we preserve the existing value if it is not overridden     self.deprecated = kwargs.pop('deprecated', getattr(self, 'deprecated', None))     self.repr = kwargs.pop('repr', True)     self.json_schema_extra = kwargs.pop('json_schema_extra', None)     self.validate_default = kwargs.pop('validate_default', None)     self.frozen = kwargs.pop('frozen', None)     # currently only used on dataclasses     self.init = kwargs.pop('init', None)     self.init_var = kwargs.pop('init_var', None)     self.kw_only = kwargs.pop('kw_only', None)      self.metadata = self._collect_metadata(kwargs)  # type: ignore      # Private attributes:     self._qualifiers: set[Qualifier] = set()     # Used to rebuild FieldInfo instances:     self._complete = True     self._original_annotation: Any = PydanticUndefined     self._original_assignment: Any = PydanticUndefined     # Used to track whether the `FieldInfo` instance represents the data about a field (and is exposed in `model_fields`/`__pydantic_fields__`),     # or if it is the result of the `Field()` function being used as metadata in an `Annotated` type/as an assignment     # (not an ideal pattern, see https://github.com/pydantic/pydantic/issues/11122):     self._final = False ``` |", "url": "https://docs.pydantic.dev/latest/api/fields/index.html#fieldinfo-indexhtmlpydanticfieldsfieldinfo-permanent-link", "page": "api/fields/index.html", "source_site": "pydantic"}
{"title": "deprecation\\_message `property` [Â¶](index.html#pydantic.fields.FieldInfo.deprecation_message \"Permanent link\")", "anchor": "deprecationmessage-property-indexhtmlpydanticfieldsfieldinfodeprecationmessage-permanent-link", "md_text": "```\ndeprecation_message: str | None\n```\n\nThe deprecation message to be emitted, or `None` if not set.", "url": "https://docs.pydantic.dev/latest/api/fields/index.html#deprecationmessage-property-indexhtmlpydanticfieldsfieldinfodeprecationmessage-permanent-link", "page": "api/fields/index.html", "source_site": "pydantic"}
{"title": "default\\_factory\\_takes\\_validated\\_data `property` [Â¶](index.html#pydantic.fields.FieldInfo.default_factory_takes_validated_data \"Permanent link\")", "anchor": "defaultfactorytakesvalidateddata-property-indexhtmlpydanticfieldsfieldinfodefaultfactorytakesvalidateddata-permanent-link", "md_text": "```\ndefault_factory_takes_validated_data: bool | None\n```\n\nWhether the provided default factory callable has a validated data parameter.\n\nReturns `None` if no default factory is set.", "url": "https://docs.pydantic.dev/latest/api/fields/index.html#defaultfactorytakesvalidateddata-property-indexhtmlpydanticfieldsfieldinfodefaultfactorytakesvalidateddata-permanent-link", "page": "api/fields/index.html", "source_site": "pydantic"}
{"title": "get\\_default [Â¶](index.html#pydantic.fields.FieldInfo.get_default \"Permanent link\")", "anchor": "getdefault-indexhtmlpydanticfieldsfieldinfogetdefault-permanent-link", "md_text": "```\nget_default(\n    *,\n    call_default_factory: Literal[True],\n    validated_data: dict[str, Any] | None = None\n) -> Any\n\nget_default(\n    *, call_default_factory: Literal[False] = ...\n) -> Any\n\nget_default(\n    *,\n    call_default_factory: bool = False,\n    validated_data: dict[str, Any] | None = None\n) -> Any\n```\n\nGet the default value.\n\nWe expose an option for whether to call the default\\_factory (if present), as calling it may\nresult in side effects that we want to avoid. However, there are times when it really should\nbe called (namely, when instantiating a model via `model_construct`).\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `call_default_factory` | `bool` | Whether to call the default factory or not. | `False` |\n| `validated_data` | `dict[str, Any] | None` | The already validated data to be passed to the default factory. | `None` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `Any` | The default value, calling the default factory if requested or `None` if not set. |\n\nSource code in `pydantic/fields.py`\n\n|  |  |\n| --- | --- |\n| ``` 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 ``` | ``` def get_default(self, *, call_default_factory: bool = False, validated_data: dict[str, Any] | None = None) -> Any:     \"\"\"Get the default value.      We expose an option for whether to call the default_factory (if present), as calling it may     result in side effects that we want to avoid. However, there are times when it really should     be called (namely, when instantiating a model via `model_construct`).      Args:         call_default_factory: Whether to call the default factory or not.         validated_data: The already validated data to be passed to the default factory.      Returns:         The default value, calling the default factory if requested or `None` if not set.     \"\"\"     if self.default_factory is None:         return _utils.smart_deepcopy(self.default)     elif call_default_factory:         if self.default_factory_takes_validated_data:             fac = cast('Callable[[dict[str, Any]], Any]', self.default_factory)             if validated_data is None:                 raise ValueError(                     \"The default factory requires the 'validated_data' argument, which was not provided when calling 'get_default'.\"                 )             return fac(validated_data)         else:             fac = cast('Callable[[], Any]', self.default_factory)             return fac()     else:         return None ``` |", "url": "https://docs.pydantic.dev/latest/api/fields/index.html#getdefault-indexhtmlpydanticfieldsfieldinfogetdefault-permanent-link", "page": "api/fields/index.html", "source_site": "pydantic"}
{"title": "is\\_required [Â¶](index.html#pydantic.fields.FieldInfo.is_required \"Permanent link\")", "anchor": "isrequired-indexhtmlpydanticfieldsfieldinfoisrequired-permanent-link", "md_text": "```\nis_required() -> bool\n```\n\nCheck if the field is required (i.e., does not have a default value or factory).\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `bool` | `True` if the field is required, `False` otherwise. |\n\nSource code in `pydantic/fields.py`\n\n|  |  |\n| --- | --- |\n| ``` 751 752 753 754 755 756 757 ``` | ``` def is_required(self) -> bool:     \"\"\"Check if the field is required (i.e., does not have a default value or factory).      Returns:         `True` if the field is required, `False` otherwise.     \"\"\"     return self.default is PydanticUndefined and self.default_factory is None ``` |", "url": "https://docs.pydantic.dev/latest/api/fields/index.html#isrequired-indexhtmlpydanticfieldsfieldinfoisrequired-permanent-link", "page": "api/fields/index.html", "source_site": "pydantic"}
{"title": "asdict [Â¶](index.html#pydantic.fields.FieldInfo.asdict \"Permanent link\")", "anchor": "asdict-indexhtmlpydanticfieldsfieldinfoasdict-permanent-link", "md_text": "```\nasdict() -> _FieldInfoAsDict\n```\n\nReturn a dictionary representation of the `FieldInfo` instance.\n\nThe returned value is a dictionary with three items:\n\n* `annotation`: The type annotation of the field.\n* `metadata`: The metadata list.\n* `attributes`: A mapping of the remaining `FieldInfo` attributes to their values (e.g. `alias`, `title`).\n\nSource code in `pydantic/fields.py`\n\n|  |  |\n| --- | --- |\n| ``` 806 807 808 809 810 811 812 813 814 815 816 817 818 819 ``` | ``` def asdict(self) -> _FieldInfoAsDict:     \"\"\"Return a dictionary representation of the `FieldInfo` instance.      The returned value is a dictionary with three items:      * `annotation`: The type annotation of the field.     * `metadata`: The metadata list.     * `attributes`: A mapping of the remaining `FieldInfo` attributes to their values (e.g. `alias`, `title`).     \"\"\"     return {         'annotation': self.annotation,         'metadata': self.metadata,         'attributes': {attr: getattr(self, attr) for attr in _Attrs},     } ``` |", "url": "https://docs.pydantic.dev/latest/api/fields/index.html#asdict-indexhtmlpydanticfieldsfieldinfoasdict-permanent-link", "page": "api/fields/index.html", "source_site": "pydantic"}
{"title": "PrivateAttr [Â¶](index.html#pydantic.fields.PrivateAttr \"Permanent link\")", "anchor": "privateattr-indexhtmlpydanticfieldsprivateattr-permanent-link", "md_text": "```\nPrivateAttr(\n    default: _T, *, init: Literal[False] = False\n) -> _T\n\nPrivateAttr(\n    *,\n    default_factory: Callable[[], _T],\n    init: Literal[False] = False\n) -> _T\n\nPrivateAttr(*, init: Literal[False] = False) -> Any\n\nPrivateAttr(\n    default: Any = PydanticUndefined,\n    *,\n    default_factory: Callable[[], Any] | None = None,\n    init: Literal[False] = False\n) -> Any\n```\n\n[Private Model Attributes](../../concepts/models/index.html#private-model-attributes)\n\nIndicates that an attribute is intended for private use and not handled during normal validation/serialization.\n\nPrivate attributes are not validated by Pydantic, so it's up to you to ensure they are used in a type-safe manner.\n\nPrivate attributes are stored in `__private_attributes__` on the model.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `default` | `Any` | The attribute's default value. Defaults to Undefined. | `PydanticUndefined` |\n| `default_factory` | `Callable[[], Any] | None` | Callable that will be called when a default value is needed for this attribute. If both `default` and `default_factory` are set, an error will be raised. | `None` |\n| `init` | `Literal[False]` | Whether the attribute should be included in the constructor of the dataclass. Always `False`. | `False` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `Any` | An instance of [`ModelPrivateAttr`](index.html#pydantic.fields.ModelPrivateAttr) class. |\n\nRaises:\n\n| Type | Description |\n| --- | --- |\n| `ValueError` | If both `default` and `default_factory` are set. |\n\nSource code in `pydantic/fields.py`\n\n|  |  |\n| --- | --- |\n| ``` 1481 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 ``` | ``` def PrivateAttr(     default: Any = PydanticUndefined,     *,     default_factory: Callable[[], Any] | None = None,     init: Literal[False] = False, ) -> Any:     \"\"\"!!! abstract \"Usage Documentation\"         [Private Model Attributes](../concepts/models.md#private-model-attributes)      Indicates that an attribute is intended for private use and not handled during normal validation/serialization.      Private attributes are not validated by Pydantic, so it's up to you to ensure they are used in a type-safe manner.      Private attributes are stored in `__private_attributes__` on the model.      Args:         default: The attribute's default value. Defaults to Undefined.         default_factory: Callable that will be             called when a default value is needed for this attribute.             If both `default` and `default_factory` are set, an error will be raised.         init: Whether the attribute should be included in the constructor of the dataclass. Always `False`.      Returns:         An instance of [`ModelPrivateAttr`][pydantic.fields.ModelPrivateAttr] class.      Raises:         ValueError: If both `default` and `default_factory` are set.     \"\"\"     if default is not PydanticUndefined and default_factory is not None:         raise TypeError('cannot specify both default and default_factory')      return ModelPrivateAttr(         default,         default_factory=default_factory,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/fields/index.html#privateattr-indexhtmlpydanticfieldsprivateattr-permanent-link", "page": "api/fields/index.html", "source_site": "pydantic"}
{"title": "ModelPrivateAttr [Â¶](index.html#pydantic.fields.ModelPrivateAttr \"Permanent link\")", "anchor": "modelprivateattr-indexhtmlpydanticfieldsmodelprivateattr-permanent-link", "md_text": "```\nModelPrivateAttr(\n    default: Any = PydanticUndefined,\n    *,\n    default_factory: Callable[[], Any] | None = None\n)\n```\n\nBases: `Representation`\n\nA descriptor for private attributes in class models.\n\nYou generally shouldn't be creating `ModelPrivateAttr` instances directly, instead use\n`pydantic.fields.PrivateAttr`. (This is similar to `FieldInfo` vs. `Field`.)\n\nAttributes:\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `default` |  | The default value of the attribute if not provided. |\n| `default_factory` |  | A callable function that generates the default value of the attribute if not provided. |\n\nSource code in `pydantic/fields.py`\n\n|  |  |\n| --- | --- |\n| ``` 1415 1416 1417 1418 1419 1420 ``` | ``` def __init__(self, default: Any = PydanticUndefined, *, default_factory: Callable[[], Any] | None = None) -> None:     if default is Ellipsis:         self.default = PydanticUndefined     else:         self.default = default     self.default_factory = default_factory ``` |", "url": "https://docs.pydantic.dev/latest/api/fields/index.html#modelprivateattr-indexhtmlpydanticfieldsmodelprivateattr-permanent-link", "page": "api/fields/index.html", "source_site": "pydantic"}
{"title": "\\_\\_getattr\\_\\_ [Â¶](index.html#pydantic.fields.ModelPrivateAttr.__getattr__ \"Permanent link\")", "anchor": "getattr-indexhtmlpydanticfieldsmodelprivateattrgetattr-permanent-link", "md_text": "```\n__getattr__(item: str) -> Any\n```\n\nThis function improves compatibility with custom descriptors by ensuring delegation happens\nas expected when the default value of a private attribute is a descriptor.\n\nSource code in `pydantic/fields.py`\n\n|  |  |\n| --- | --- |\n| ``` 1425 1426 1427 1428 1429 1430 1431 1432 ``` | ``` def __getattr__(self, item: str) -> Any:     \"\"\"This function improves compatibility with custom descriptors by ensuring delegation happens     as expected when the default value of a private attribute is a descriptor.     \"\"\"     if item in {'__get__', '__set__', '__delete__'}:         if hasattr(self.default, item):             return getattr(self.default, item)     raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') ``` |", "url": "https://docs.pydantic.dev/latest/api/fields/index.html#getattr-indexhtmlpydanticfieldsmodelprivateattrgetattr-permanent-link", "page": "api/fields/index.html", "source_site": "pydantic"}
{"title": "\\_\\_set\\_name\\_\\_ [Â¶](index.html#pydantic.fields.ModelPrivateAttr.__set_name__ \"Permanent link\")", "anchor": "setname-indexhtmlpydanticfieldsmodelprivateattrsetname-permanent-link", "md_text": "```\n__set_name__(cls: type[Any], name: str) -> None\n```\n\nPreserve `__set_name__` protocol defined in https://peps.python.org/pep-0487.\n\nSource code in `pydantic/fields.py`\n\n|  |  |\n| --- | --- |\n| ``` 1434 1435 1436 1437 1438 1439 1440 1441 ``` | ``` def __set_name__(self, cls: type[Any], name: str) -> None:     \"\"\"Preserve `__set_name__` protocol defined in https://peps.python.org/pep-0487.\"\"\"     default = self.default     if default is PydanticUndefined:         return     set_name = getattr(default, '__set_name__', None)     if callable(set_name):         set_name(cls, name) ``` |", "url": "https://docs.pydantic.dev/latest/api/fields/index.html#setname-indexhtmlpydanticfieldsmodelprivateattrsetname-permanent-link", "page": "api/fields/index.html", "source_site": "pydantic"}
{"title": "get\\_default [Â¶](index.html#pydantic.fields.ModelPrivateAttr.get_default \"Permanent link\")", "anchor": "getdefault-indexhtmlpydanticfieldsmodelprivateattrgetdefault-permanent-link", "md_text": "```\nget_default() -> Any\n```\n\nRetrieve the default value of the object.\n\nIf `self.default_factory` is `None`, the method will return a deep copy of the `self.default` object.\n\nIf `self.default_factory` is not `None`, it will call `self.default_factory` and return the value returned.\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `Any` | The default value of the object. |\n\nSource code in `pydantic/fields.py`\n\n|  |  |\n| --- | --- |\n| ``` 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 ``` | ``` def get_default(self) -> Any:     \"\"\"Retrieve the default value of the object.      If `self.default_factory` is `None`, the method will return a deep copy of the `self.default` object.      If `self.default_factory` is not `None`, it will call `self.default_factory` and return the value returned.      Returns:         The default value of the object.     \"\"\"     return _utils.smart_deepcopy(self.default) if self.default_factory is None else self.default_factory() ``` |", "url": "https://docs.pydantic.dev/latest/api/fields/index.html#getdefault-indexhtmlpydanticfieldsmodelprivateattrgetdefault-permanent-link", "page": "api/fields/index.html", "source_site": "pydantic"}
{"title": "computed\\_field [Â¶](index.html#pydantic.fields.computed_field \"Permanent link\")", "anchor": "computedfield-indexhtmlpydanticfieldscomputedfield-permanent-link", "md_text": "```\ncomputed_field(func: PropertyT) -> PropertyT\n\ncomputed_field(\n    *,\n    alias: str | None = None,\n    alias_priority: int | None = None,\n    title: str | None = None,\n    field_title_generator: (\n        Callable[[str, ComputedFieldInfo], str] | None\n    ) = None,\n    description: str | None = None,\n    deprecated: Deprecated | str | bool | None = None,\n    examples: list[Any] | None = None,\n    json_schema_extra: (\n        JsonDict | Callable[[JsonDict], None] | None\n    ) = None,\n    repr: bool = True,\n    return_type: Any = PydanticUndefined\n) -> Callable[[PropertyT], PropertyT]\n\ncomputed_field(\n    func: PropertyT | None = None,\n    /,\n    *,\n    alias: str | None = None,\n    alias_priority: int | None = None,\n    title: str | None = None,\n    field_title_generator: (\n        Callable[[str, ComputedFieldInfo], str] | None\n    ) = None,\n    description: str | None = None,\n    deprecated: Deprecated | str | bool | None = None,\n    examples: list[Any] | None = None,\n    json_schema_extra: (\n        JsonDict | Callable[[JsonDict], None] | None\n    ) = None,\n    repr: bool | None = None,\n    return_type: Any = PydanticUndefined,\n) -> PropertyT | Callable[[PropertyT], PropertyT]\n```\n\n[The `computed_field` decorator](../../concepts/fields/index.html#the-computed_field-decorator)\n\nDecorator to include `property` and `cached_property` when serializing models or dataclasses.\n\nThis is useful for fields that are computed from other fields, or for fields that are expensive to compute and should be cached.\n\n```\nfrom pydantic import BaseModel, computed_field\n\nclass Rectangle(BaseModel):\n    width: int\n    length: int\n\n    @computed_field\n    @property\n    def area(self) -> int:\n        return self.width * self.length\n\nprint(Rectangle(width=3, length=2).model_dump())\n#> {'width': 3, 'length': 2, 'area': 6}\n```\n\nIf applied to functions not yet decorated with `@property` or `@cached_property`, the function is\nautomatically wrapped with `property`. Although this is more concise, you will lose IntelliSense in your IDE,\nand confuse static type checkers, thus explicit use of `@property` is recommended.\n\nEven with the `@property` or `@cached_property` applied to your function before `@computed_field`,\nmypy may throw a `Decorated property not supported` error.\nSee [mypy issue #1362](https://github.com/python/mypy/issues/1362), for more information.\nTo avoid this error message, add `# type: ignore[prop-decorator]` to the `@computed_field` line.\n\n[pyright](https://github.com/microsoft/pyright) supports `@computed_field` without error.\n\n```\nimport random\n\nfrom pydantic import BaseModel, computed_field\n\nclass Square(BaseModel):\n    width: float\n\n    @computed_field\n    def area(self) -> float:  # converted to a `property` by `computed_field`\n        return round(self.width**2, 2)\n\n    @area.setter\n    def area(self, new_area: float) -> None:\n        self.width = new_area**0.5\n\n    @computed_field(alias='the magic number', repr=False)\n    def random_number(self) -> int:\n        return random.randint(0, 1_000)\n\nsquare = Square(width=1.3)\n\n# `random_number` does not appear in representation\nprint(repr(square))\n#> Square(width=1.3, area=1.69)\n\nprint(square.random_number)\n#> 3\n\nsquare.area = 4\n\nprint(square.model_dump_json(by_alias=True))\n#> {\"width\":2.0,\"area\":4.0,\"the magic number\":3}\n```\n\nYou can't override a field from a parent class with a `computed_field` in the child class.\n`mypy` complains about this behavior if allowed, and `dataclasses` doesn't allow this pattern either.\nSee the example below:\n\n```\nfrom pydantic import BaseModel, computed_field\n\nclass Parent(BaseModel):\n    a: str\n\ntry:\n\n    class Child(Parent):\n        @computed_field\n        @property\n        def a(self) -> str:\n            return 'new a'\n\nexcept TypeError as e:\n    print(e)\n    '''\n    Field 'a' of class 'Child' overrides symbol of same name in a parent class. This override with a computed_field is incompatible.\n    '''\n```\n\nPrivate properties decorated with `@computed_field` have `repr=False` by default.\n\n```\nfrom functools import cached_property\n\nfrom pydantic import BaseModel, computed_field\n\nclass Model(BaseModel):\n    foo: int\n\n    @computed_field\n    @cached_property\n    def _private_cached_property(self) -> int:\n        return -self.foo\n\n    @computed_field\n    @property\n    def _private_property(self) -> int:\n        return -self.foo\n\nm = Model(foo=1)\nprint(repr(m))\n#> Model(foo=1)\n```\n\nParameters:", "url": "https://docs.pydantic.dev/latest/api/fields/index.html#computedfield-indexhtmlpydanticfieldscomputedfield-permanent-link", "page": "api/fields/index.html", "source_site": "pydantic"}
{"title": "computed\\_field [Â¶](index.html#pydantic.fields.computed_field \"Permanent link\")", "anchor": "computedfield-indexhtmlpydanticfieldscomputedfield-permanent-link", "md_text": "| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `func` | `PropertyT | None` | the function to wrap. | `None` |\n| `alias` | `str | None` | alias to use when serializing this computed field, only used when `by_alias=True` | `None` |\n| `alias_priority` | `int | None` | priority of the alias. This affects whether an alias generator is used | `None` |\n| `title` | `str | None` | Title to use when including this computed field in JSON Schema | `None` |\n| `field_title_generator` | `Callable[[str, ComputedFieldInfo], str] | None` | A callable that takes a field name and returns title for it. | `None` |\n| `description` | `str | None` | Description to use when including this computed field in JSON Schema, defaults to the function's docstring | `None` |\n| `deprecated` | `Deprecated | str | bool | None` | A deprecation message (or an instance of `warnings.deprecated` or the `typing_extensions.deprecated` backport). to be emitted when accessing the field. Or a boolean. This will automatically be set if the property is decorated with the `deprecated` decorator. | `None` |\n| `examples` | `list[Any] | None` | Example values to use when including this computed field in JSON Schema | `None` |\n| `json_schema_extra` | `JsonDict | Callable[[JsonDict], None] | None` | A dict or callable to provide extra JSON schema properties. | `None` |\n| `repr` | `bool | None` | whether to include this computed field in model repr. Default is `False` for private properties and `True` for public properties. | `None` |\n| `return_type` | `Any` | optional return for serialization logic to expect when serializing to JSON, if included this must be correct, otherwise a `TypeError` is raised. If you don't include a return type Any is used, which does runtime introspection to handle arbitrary objects. | `PydanticUndefined` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `PropertyT | Callable[[PropertyT], PropertyT]` | A proxy wrapper for the property. |\n\nSource code in `pydantic/fields.py`", "url": "https://docs.pydantic.dev/latest/api/fields/index.html#computedfield-indexhtmlpydanticfieldscomputedfield-permanent-link", "page": "api/fields/index.html", "source_site": "pydantic"}
{"title": "computed\\_field [Â¶](index.html#pydantic.fields.computed_field \"Permanent link\")", "anchor": "computedfield-indexhtmlpydanticfieldscomputedfield-permanent-link", "md_text": "|  |  |\n| --- | --- |\n| ``` 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 1689 1690 1691 1692 1693 1694 1695 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711 1712 1713 1714 1715 1716 1717 1718 1719 1720 1721 1722 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1738 1739 1740 1741 1742 1743 1744 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763 1764 1765 1766 1767 1768 1769 1770 1771 1772 1773 1774 1775 1776 1777 1778 1779 1780 1781 1782 1783 1784 1785 1786 1787 1788 1789 1790 1791 1792 1793 1794 1795 1796 1797 1798 1799 1800 1801 1802 1803 1804 1805 1806 1807 1808 1809 1810 1811 1812 1813 1814 1815 1816 1817 1818 1819 1820 1821 1822 1823 1824 1825 1826 1827 1828 1829 1830 1831 1832 1833 1834 ``` | ``` def computed_field(     func: PropertyT | None = None,     /,     *,     alias: str | None = None,     alias_priority: int | None = None,     title: str | None = None,     field_title_generator: Callable[[str, ComputedFieldInfo], str] | None = None,     description: str | None = None,     deprecated: Deprecated | str | bool | None = None,     examples: list[Any] | None = None,     json_schema_extra: JsonDict | Callable[[JsonDict], None] | None = None,     repr: bool | None = None,     return_type: Any = PydanticUndefined, ) -> PropertyT | Callable[[PropertyT], PropertyT]:     \"\"\"!!! abstract \"Usage Documentation\"         [The `computed_field` decorator](../concepts/fields.md#the-computed_field-decorator)      Decorator to include `property` and `cached_property` when serializing models or dataclasses.      This is useful for fields that are computed from other fields, or for fields that are expensive to compute and should be cached.      ```python     from pydantic import BaseModel, computed_field      class Rectangle(BaseModel):         width: int         length: int          @computed_field         @property         def area(self) -> int:             return self.width * self.length      print(Rectangle(width=3, length=2).model_dump())     #> {'width': 3, 'length': 2, 'area': 6}     ```      If applied to functions not yet decorated with `@property` or `@cached_property`, the function is     automatically wrapped with `property`. Although this is more concise, you will lose IntelliSense in your IDE,     and confuse static type checkers, thus explicit use of `@property` is recommended.      !!! warning \"Mypy Warning\"         Even with the `@property` or `@cached_property` applied to your function before `@computed_field`,         mypy may throw a `Decorated property not supported` error.         See [mypy issue #1362](https://github.com/python/mypy/issues/1362), for more information.         To avoid this error message, add `# type: ignore[prop-decorator]` to the `@computed_field` line.          [pyright](https://github.com/microsoft/pyright) supports `@computed_field` without error.      ```python     import random      from pydantic import BaseModel, computed_field      class Square(BaseModel):         width: float          @computed_field         def area(self) -> float:  # converted to a `property` by `computed_field`             return round(self.width**2, 2)          @area.setter         def area(self, new_area: float) -> None:             self.width = new_area**0.5          @computed_field(alias='the magic number', repr=False)         def random_number(self) -> int:             return random.randint(0, 1_000)      square = Square(width=1.3)      # `random_number` does not appear in representation     print(repr(square))     #> Square(width=1.3, area=1.69)      print(square.random_number)     #> 3      square.area = 4      print(square.model_dump_json(by_alias=True))     #> {\"width\":2.0,\"area\":4.0,\"the magic number\":3}     ```      !!! warning \"Overriding with `computed_field`\"         You can't override a field from a parent class with a `computed_field` in the child class.         `mypy` complains about this behavior if allowed, and `dataclasses` doesn't allow this pattern either.         See the example below:      ```python     from pydantic import BaseModel, computed_field      class Parent(BaseModel):         a: str      try:          class Child(Parent):             @computed_field             @property             def a(self) -> str:                 return 'new a'      except TypeError as e:         print(e)         '''         Field 'a' of class 'Child' overrides symbol of same name in a parent class. This override with a computed_field is incompatible.         '''     ```      Private properties decorated with `@computed_field` have `repr=False` by default.      ```python     from functools import cached_property      from pydantic import BaseModel, computed_field      class Model(BaseModel):         foo: int          @computed_field         @cached_property         def _private_cached_property(self) -> int:             return -self.foo          @computed_field         @property         def _private_property(self) -> int:             return -self.foo      m = Model(foo=1)     print(repr(m))     #> Model(foo=1)     ```      Args:         func: the function to wrap.         alias: alias to use when serializing this computed field, only used when `by_alias=True`         alias_priority: priority of the alias. This affects whether an alias generator is used         title: Title to use when including this computed field in JSON Schema         field_title_generator: A callable that takes a field name and returns title for it.         description: Description to use when including this computed field in JSON Schema, defaults to the function's             docstring         deprecated: A deprecation message (or an instance of `warnings.deprecated` or the `typing_extensions.deprecated` backport).             to be emitted when accessing the field. Or a boolean. This will automatically be set if the property is decorated with the             `deprecated` decorator.         examples: Example values to use when including this computed field in JSON Schema         json_schema_extra: A dict or callable to provide extra JSON schema properties.         repr: whether to include this computed field in model repr.             Default is `False` for private properties and `True` for public properties.         return_type: optional return for serialization logic to expect when serializing to JSON, if included             this must be correct, otherwise a `TypeError` is raised.             If you don't include a return type Any is used, which does runtime introspection to handle arbitrary             objects.      Returns:         A proxy wrapper for the property.     \"\"\"      def dec(f: Any) -> Any:         nonlocal description, deprecated, return_type, alias_priority         unwrapped = _decorators.unwrap_wrapped_function(f)          if description is None and unwrapped.__doc__:             description = inspect.cleandoc(unwrapped.__doc__)          if deprecated is None and hasattr(unwrapped, '__deprecated__'):             deprecated = unwrapped.__deprecated__          # if the function isn't already decorated with `@property` (or another descriptor), then we wrap it now         f = _decorators.ensure_property(f)         alias_priority = (alias_priority or 2) if alias is not None else None          if repr is None:             repr_: bool = not _wrapped_property_is_private(property_=f)         else:             repr_ = repr          dec_info = ComputedFieldInfo(             f,             return_type,             alias,             alias_priority,             title,             field_title_generator,             description,             deprecated,             examples,             json_schema_extra,             repr_,         )         return _decorators.PydanticDescriptorProxy(f, dec_info)      if func is None:         return dec     else:         return dec(func) ``` |", "url": "https://docs.pydantic.dev/latest/api/fields/index.html#computedfield-indexhtmlpydanticfieldscomputedfield-permanent-link", "page": "api/fields/index.html", "source_site": "pydantic"}
{"title": "ComputedFieldInfo `dataclass` [Â¶](index.html#pydantic.fields.ComputedFieldInfo \"Permanent link\")", "anchor": "computedfieldinfo-dataclass-indexhtmlpydanticfieldscomputedfieldinfo-permanent-link", "md_text": "```\nComputedFieldInfo(\n    wrapped_property: property,\n    return_type: Any,\n    alias: str | None,\n    alias_priority: int | None,\n    title: str | None,\n    field_title_generator: (\n        Callable[[str, ComputedFieldInfo], str] | None\n    ),\n    description: str | None,\n    deprecated: Deprecated | str | bool | None,\n    examples: list[Any] | None,\n    json_schema_extra: (\n        JsonDict | Callable[[JsonDict], None] | None\n    ),\n    repr: bool,\n)\n```\n\nA container for data from `@computed_field` so that we can access it while building the pydantic-core schema.\n\nAttributes:\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `decorator_repr` | `str` | A class variable representing the decorator string, '@computed\\_field'. |\n| `wrapped_property` | `property` | The wrapped computed field property. |\n| `return_type` | `Any` | The type of the computed field property's return value. |\n| `alias` | `str | None` | The alias of the property to be used during serialization. |\n| `alias_priority` | `int | None` | The priority of the alias. This affects whether an alias generator is used. |\n| `title` | `str | None` | Title of the computed field to include in the serialization JSON schema. |\n| `field_title_generator` | `Callable[[str, ComputedFieldInfo], str] | None` | A callable that takes a field name and returns title for it. |\n| `description` | `str | None` | Description of the computed field to include in the serialization JSON schema. |\n| `deprecated` | `Deprecated | str | bool | None` | A deprecation message, an instance of `warnings.deprecated` or the `typing_extensions.deprecated` backport, or a boolean. If `True`, a default deprecation message will be emitted when accessing the field. |\n| `examples` | `list[Any] | None` | Example values of the computed field to include in the serialization JSON schema. |\n| `json_schema_extra` | `JsonDict | Callable[[JsonDict], None] | None` | A dict or callable to provide extra JSON schema properties. |\n| `repr` | `bool` | A boolean indicating whether to include the field in the **repr** output. |", "url": "https://docs.pydantic.dev/latest/api/fields/index.html#computedfieldinfo-dataclass-indexhtmlpydanticfieldscomputedfieldinfo-permanent-link", "page": "api/fields/index.html", "source_site": "pydantic"}
{"title": "deprecation\\_message `property` [Â¶](index.html#pydantic.fields.ComputedFieldInfo.deprecation_message \"Permanent link\")", "anchor": "deprecationmessage-property-indexhtmlpydanticfieldscomputedfieldinfodeprecationmessage-permanent-link", "md_text": "```\ndeprecation_message: str | None\n```\n\nThe deprecation message to be emitted, or `None` if not set.\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/api/fields/index.html#deprecationmessage-property-indexhtmlpydanticfieldscomputedfieldinfodeprecationmessage-permanent-link", "page": "api/fields/index.html", "source_site": "pydantic"}
{"title": "Pipeline API[Â¶](index.html#pipeline-api \"Permanent link\")", "anchor": "pipeline-apiindexhtmlpipeline-api-permanent-link", "md_text": "Experimental pipeline API functionality. Be careful with this API, it's subject to change.", "url": "https://docs.pydantic.dev/latest/api/experimental/index.html#pipeline-apiindexhtmlpipeline-api-permanent-link", "page": "api/experimental/index.html", "source_site": "pydantic"}
{"title": "\\_Pipeline `dataclass` [Â¶](index.html#pydantic.experimental.pipeline._Pipeline \"Permanent link\")", "anchor": "pipeline-dataclass-indexhtmlpydanticexperimentalpipelinepipeline-permanent-link", "md_text": "```\n_Pipeline(_steps: tuple[_Step, ...])\n```\n\nBases: `Generic[_InT, _OutT]`\n\nAbstract representation of a chain of validation, transformation, and parsing steps.", "url": "https://docs.pydantic.dev/latest/api/experimental/index.html#pipeline-dataclass-indexhtmlpydanticexperimentalpipelinepipeline-permanent-link", "page": "api/experimental/index.html", "source_site": "pydantic"}
{"title": "transform [Â¶](index.html#pydantic.experimental.pipeline._Pipeline.transform \"Permanent link\")", "anchor": "transform-indexhtmlpydanticexperimentalpipelinepipelinetransform-permanent-link", "md_text": "```\ntransform(\n    func: Callable[[_OutT], _NewOutT]\n) -> _Pipeline[_InT, _NewOutT]\n```\n\nTransform the output of the previous step.\n\nIf used as the first step in a pipeline, the type of the field is used.\nThat is, the transformation is applied to after the value is parsed to the field's type.\n\nSource code in `pydantic/experimental/pipeline.py`\n\n|  |  |\n| --- | --- |\n| ``` 136 137 138 139 140 141 142 143 144 145 ``` | ``` def transform(     self,     func: Callable[[_OutT], _NewOutT], ) -> _Pipeline[_InT, _NewOutT]:     \"\"\"Transform the output of the previous step.      If used as the first step in a pipeline, the type of the field is used.     That is, the transformation is applied to after the value is parsed to the field's type.     \"\"\"     return _Pipeline[_InT, _NewOutT](self._steps + (_Transform(func),)) ``` |", "url": "https://docs.pydantic.dev/latest/api/experimental/index.html#transform-indexhtmlpydanticexperimentalpipelinepipelinetransform-permanent-link", "page": "api/experimental/index.html", "source_site": "pydantic"}
{"title": "validate\\_as [Â¶](index.html#pydantic.experimental.pipeline._Pipeline.validate_as \"Permanent link\")", "anchor": "validateas-indexhtmlpydanticexperimentalpipelinepipelinevalidateas-permanent-link", "md_text": "```\nvalidate_as(\n    tp: type[_NewOutT], *, strict: bool = ...\n) -> _Pipeline[_InT, _NewOutT]\n\nvalidate_as(\n    tp: EllipsisType, *, strict: bool = ...\n) -> _Pipeline[_InT, Any]\n\nvalidate_as(\n    tp: type[_NewOutT] | EllipsisType,\n    *,\n    strict: bool = False\n) -> _Pipeline[_InT, Any]\n```\n\nValidate / parse the input into a new type.\n\nIf no type is provided, the type of the field is used.\n\nTypes are parsed in Pydantic's `lax` mode by default,\nbut you can enable `strict` mode by passing `strict=True`.\n\nSource code in `pydantic/experimental/pipeline.py`\n\n|  |  |\n| --- | --- |\n| ``` 154 155 156 157 158 159 160 161 162 163 164 ``` | ``` def validate_as(self, tp: type[_NewOutT] | EllipsisType, *, strict: bool = False) -> _Pipeline[_InT, Any]:  # type: ignore     \"\"\"Validate / parse the input into a new type.      If no type is provided, the type of the field is used.      Types are parsed in Pydantic's `lax` mode by default,     but you can enable `strict` mode by passing `strict=True`.     \"\"\"     if isinstance(tp, EllipsisType):         return _Pipeline[_InT, Any](self._steps + (_ValidateAs(_FieldTypeMarker, strict=strict),))     return _Pipeline[_InT, _NewOutT](self._steps + (_ValidateAs(tp, strict=strict),)) ``` |", "url": "https://docs.pydantic.dev/latest/api/experimental/index.html#validateas-indexhtmlpydanticexperimentalpipelinepipelinevalidateas-permanent-link", "page": "api/experimental/index.html", "source_site": "pydantic"}
{"title": "validate\\_as\\_deferred [Â¶](index.html#pydantic.experimental.pipeline._Pipeline.validate_as_deferred \"Permanent link\")", "anchor": "validateasdeferred-indexhtmlpydanticexperimentalpipelinepipelinevalidateasdeferred-permanent-link", "md_text": "```\nvalidate_as_deferred(\n    func: Callable[[], type[_NewOutT]]\n) -> _Pipeline[_InT, _NewOutT]\n```\n\nParse the input into a new type, deferring resolution of the type until the current class\nis fully defined.\n\nThis is useful when you need to reference the class in it's own type annotations.\n\nSource code in `pydantic/experimental/pipeline.py`\n\n|  |  |\n| --- | --- |\n| ``` 166 167 168 169 170 171 172 ``` | ``` def validate_as_deferred(self, func: Callable[[], type[_NewOutT]]) -> _Pipeline[_InT, _NewOutT]:     \"\"\"Parse the input into a new type, deferring resolution of the type until the current class     is fully defined.      This is useful when you need to reference the class in it's own type annotations.     \"\"\"     return _Pipeline[_InT, _NewOutT](self._steps + (_ValidateAsDefer(func),)) ``` |", "url": "https://docs.pydantic.dev/latest/api/experimental/index.html#validateasdeferred-indexhtmlpydanticexperimentalpipelinepipelinevalidateasdeferred-permanent-link", "page": "api/experimental/index.html", "source_site": "pydantic"}
{"title": "constrain [Â¶](index.html#pydantic.experimental.pipeline._Pipeline.constrain \"Permanent link\")", "anchor": "constrain-indexhtmlpydanticexperimentalpipelinepipelineconstrain-permanent-link", "md_text": "```\nconstrain(constraint: Ge) -> _Pipeline[_InT, _NewOutGe]\n\nconstrain(constraint: Gt) -> _Pipeline[_InT, _NewOutGt]\n\nconstrain(constraint: Le) -> _Pipeline[_InT, _NewOutLe]\n\nconstrain(constraint: Lt) -> _Pipeline[_InT, _NewOutLt]\n\nconstrain(constraint: Len) -> _Pipeline[_InT, _NewOutLen]\n\nconstrain(\n    constraint: MultipleOf,\n) -> _Pipeline[_InT, _NewOutT]\n\nconstrain(\n    constraint: Timezone,\n) -> _Pipeline[_InT, _NewOutDatetime]\n\nconstrain(constraint: Predicate) -> _Pipeline[_InT, _OutT]\n\nconstrain(\n    constraint: Interval,\n) -> _Pipeline[_InT, _NewOutInterval]\n\nconstrain(constraint: _Eq) -> _Pipeline[_InT, _OutT]\n\nconstrain(constraint: _NotEq) -> _Pipeline[_InT, _OutT]\n\nconstrain(constraint: _In) -> _Pipeline[_InT, _OutT]\n\nconstrain(constraint: _NotIn) -> _Pipeline[_InT, _OutT]\n\nconstrain(\n    constraint: Pattern[str],\n) -> _Pipeline[_InT, _NewOutT]\n\nconstrain(constraint: _ConstraintAnnotation) -> Any\n```\n\nConstrain a value to meet a certain condition.\n\nWe support most conditions from `annotated_types`, as well as regular expressions.\n\nMost of the time you'll be calling a shortcut method like `gt`, `lt`, `len`, etc\nso you don't need to call this directly.\n\nSource code in `pydantic/experimental/pipeline.py`\n\n|  |  |\n| --- | --- |\n| ``` 225 226 227 228 229 230 231 232 233 ``` | ``` def constrain(self, constraint: _ConstraintAnnotation) -> Any:     \"\"\"Constrain a value to meet a certain condition.      We support most conditions from `annotated_types`, as well as regular expressions.      Most of the time you'll be calling a shortcut method like `gt`, `lt`, `len`, etc     so you don't need to call this directly.     \"\"\"     return _Pipeline[_InT, _OutT](self._steps + (_Constraint(constraint),)) ``` |", "url": "https://docs.pydantic.dev/latest/api/experimental/index.html#constrain-indexhtmlpydanticexperimentalpipelinepipelineconstrain-permanent-link", "page": "api/experimental/index.html", "source_site": "pydantic"}
{"title": "predicate [Â¶](index.html#pydantic.experimental.pipeline._Pipeline.predicate \"Permanent link\")", "anchor": "predicate-indexhtmlpydanticexperimentalpipelinepipelinepredicate-permanent-link", "md_text": "```\npredicate(\n    func: Callable[[_NewOutT], bool]\n) -> _Pipeline[_InT, _NewOutT]\n```\n\nConstrain a value to meet a certain predicate.\n\nSource code in `pydantic/experimental/pipeline.py`\n\n|  |  |\n| --- | --- |\n| ``` 235 236 237 ``` | ``` def predicate(self: _Pipeline[_InT, _NewOutT], func: Callable[[_NewOutT], bool]) -> _Pipeline[_InT, _NewOutT]:     \"\"\"Constrain a value to meet a certain predicate.\"\"\"     return self.constrain(annotated_types.Predicate(func)) ``` |", "url": "https://docs.pydantic.dev/latest/api/experimental/index.html#predicate-indexhtmlpydanticexperimentalpipelinepipelinepredicate-permanent-link", "page": "api/experimental/index.html", "source_site": "pydantic"}
{"title": "gt [Â¶](index.html#pydantic.experimental.pipeline._Pipeline.gt \"Permanent link\")", "anchor": "gt-indexhtmlpydanticexperimentalpipelinepipelinegt-permanent-link", "md_text": "```\ngt(gt: _NewOutGt) -> _Pipeline[_InT, _NewOutGt]\n```\n\nConstrain a value to be greater than a certain value.\n\nSource code in `pydantic/experimental/pipeline.py`\n\n|  |  |\n| --- | --- |\n| ``` 239 240 241 ``` | ``` def gt(self: _Pipeline[_InT, _NewOutGt], gt: _NewOutGt) -> _Pipeline[_InT, _NewOutGt]:     \"\"\"Constrain a value to be greater than a certain value.\"\"\"     return self.constrain(annotated_types.Gt(gt)) ``` |", "url": "https://docs.pydantic.dev/latest/api/experimental/index.html#gt-indexhtmlpydanticexperimentalpipelinepipelinegt-permanent-link", "page": "api/experimental/index.html", "source_site": "pydantic"}
{"title": "lt [Â¶](index.html#pydantic.experimental.pipeline._Pipeline.lt \"Permanent link\")", "anchor": "lt-indexhtmlpydanticexperimentalpipelinepipelinelt-permanent-link", "md_text": "```\nlt(lt: _NewOutLt) -> _Pipeline[_InT, _NewOutLt]\n```\n\nConstrain a value to be less than a certain value.\n\nSource code in `pydantic/experimental/pipeline.py`\n\n|  |  |\n| --- | --- |\n| ``` 243 244 245 ``` | ``` def lt(self: _Pipeline[_InT, _NewOutLt], lt: _NewOutLt) -> _Pipeline[_InT, _NewOutLt]:     \"\"\"Constrain a value to be less than a certain value.\"\"\"     return self.constrain(annotated_types.Lt(lt)) ``` |", "url": "https://docs.pydantic.dev/latest/api/experimental/index.html#lt-indexhtmlpydanticexperimentalpipelinepipelinelt-permanent-link", "page": "api/experimental/index.html", "source_site": "pydantic"}
{"title": "ge [Â¶](index.html#pydantic.experimental.pipeline._Pipeline.ge \"Permanent link\")", "anchor": "ge-indexhtmlpydanticexperimentalpipelinepipelinege-permanent-link", "md_text": "```\nge(ge: _NewOutGe) -> _Pipeline[_InT, _NewOutGe]\n```\n\nConstrain a value to be greater than or equal to a certain value.\n\nSource code in `pydantic/experimental/pipeline.py`\n\n|  |  |\n| --- | --- |\n| ``` 247 248 249 ``` | ``` def ge(self: _Pipeline[_InT, _NewOutGe], ge: _NewOutGe) -> _Pipeline[_InT, _NewOutGe]:     \"\"\"Constrain a value to be greater than or equal to a certain value.\"\"\"     return self.constrain(annotated_types.Ge(ge)) ``` |", "url": "https://docs.pydantic.dev/latest/api/experimental/index.html#ge-indexhtmlpydanticexperimentalpipelinepipelinege-permanent-link", "page": "api/experimental/index.html", "source_site": "pydantic"}
{"title": "le [Â¶](index.html#pydantic.experimental.pipeline._Pipeline.le \"Permanent link\")", "anchor": "le-indexhtmlpydanticexperimentalpipelinepipelinele-permanent-link", "md_text": "```\nle(le: _NewOutLe) -> _Pipeline[_InT, _NewOutLe]\n```\n\nConstrain a value to be less than or equal to a certain value.\n\nSource code in `pydantic/experimental/pipeline.py`\n\n|  |  |\n| --- | --- |\n| ``` 251 252 253 ``` | ``` def le(self: _Pipeline[_InT, _NewOutLe], le: _NewOutLe) -> _Pipeline[_InT, _NewOutLe]:     \"\"\"Constrain a value to be less than or equal to a certain value.\"\"\"     return self.constrain(annotated_types.Le(le)) ``` |", "url": "https://docs.pydantic.dev/latest/api/experimental/index.html#le-indexhtmlpydanticexperimentalpipelinepipelinele-permanent-link", "page": "api/experimental/index.html", "source_site": "pydantic"}
{"title": "len [Â¶](index.html#pydantic.experimental.pipeline._Pipeline.len \"Permanent link\")", "anchor": "len-indexhtmlpydanticexperimentalpipelinepipelinelen-permanent-link", "md_text": "```\nlen(\n    min_len: int, max_len: int | None = None\n) -> _Pipeline[_InT, _NewOutLen]\n```\n\nConstrain a value to have a certain length.\n\nSource code in `pydantic/experimental/pipeline.py`\n\n|  |  |\n| --- | --- |\n| ``` 255 256 257 ``` | ``` def len(self: _Pipeline[_InT, _NewOutLen], min_len: int, max_len: int | None = None) -> _Pipeline[_InT, _NewOutLen]:     \"\"\"Constrain a value to have a certain length.\"\"\"     return self.constrain(annotated_types.Len(min_len, max_len)) ``` |", "url": "https://docs.pydantic.dev/latest/api/experimental/index.html#len-indexhtmlpydanticexperimentalpipelinepipelinelen-permanent-link", "page": "api/experimental/index.html", "source_site": "pydantic"}
{"title": "multiple\\_of [Â¶](index.html#pydantic.experimental.pipeline._Pipeline.multiple_of \"Permanent link\")", "anchor": "multipleof-indexhtmlpydanticexperimentalpipelinepipelinemultipleof-permanent-link", "md_text": "```\nmultiple_of(\n    multiple_of: _NewOutDiv,\n) -> _Pipeline[_InT, _NewOutDiv]\n\nmultiple_of(\n    multiple_of: _NewOutMod,\n) -> _Pipeline[_InT, _NewOutMod]\n\nmultiple_of(multiple_of: Any) -> _Pipeline[_InT, Any]\n```\n\nConstrain a value to be a multiple of a certain number.\n\nSource code in `pydantic/experimental/pipeline.py`\n\n|  |  |\n| --- | --- |\n| ``` 265 266 267 ``` | ``` def multiple_of(self: _Pipeline[_InT, Any], multiple_of: Any) -> _Pipeline[_InT, Any]:     \"\"\"Constrain a value to be a multiple of a certain number.\"\"\"     return self.constrain(annotated_types.MultipleOf(multiple_of)) ``` |", "url": "https://docs.pydantic.dev/latest/api/experimental/index.html#multipleof-indexhtmlpydanticexperimentalpipelinepipelinemultipleof-permanent-link", "page": "api/experimental/index.html", "source_site": "pydantic"}
{"title": "eq [Â¶](index.html#pydantic.experimental.pipeline._Pipeline.eq \"Permanent link\")", "anchor": "eq-indexhtmlpydanticexperimentalpipelinepipelineeq-permanent-link", "md_text": "```\neq(value: _OutT) -> _Pipeline[_InT, _OutT]\n```\n\nConstrain a value to be equal to a certain value.\n\nSource code in `pydantic/experimental/pipeline.py`\n\n|  |  |\n| --- | --- |\n| ``` 269 270 271 ``` | ``` def eq(self: _Pipeline[_InT, _OutT], value: _OutT) -> _Pipeline[_InT, _OutT]:     \"\"\"Constrain a value to be equal to a certain value.\"\"\"     return self.constrain(_Eq(value)) ``` |", "url": "https://docs.pydantic.dev/latest/api/experimental/index.html#eq-indexhtmlpydanticexperimentalpipelinepipelineeq-permanent-link", "page": "api/experimental/index.html", "source_site": "pydantic"}
{"title": "not\\_eq [Â¶](index.html#pydantic.experimental.pipeline._Pipeline.not_eq \"Permanent link\")", "anchor": "noteq-indexhtmlpydanticexperimentalpipelinepipelinenoteq-permanent-link", "md_text": "```\nnot_eq(value: _OutT) -> _Pipeline[_InT, _OutT]\n```\n\nConstrain a value to not be equal to a certain value.\n\nSource code in `pydantic/experimental/pipeline.py`\n\n|  |  |\n| --- | --- |\n| ``` 273 274 275 ``` | ``` def not_eq(self: _Pipeline[_InT, _OutT], value: _OutT) -> _Pipeline[_InT, _OutT]:     \"\"\"Constrain a value to not be equal to a certain value.\"\"\"     return self.constrain(_NotEq(value)) ``` |", "url": "https://docs.pydantic.dev/latest/api/experimental/index.html#noteq-indexhtmlpydanticexperimentalpipelinepipelinenoteq-permanent-link", "page": "api/experimental/index.html", "source_site": "pydantic"}
{"title": "in\\_ [Â¶](index.html#pydantic.experimental.pipeline._Pipeline.in_ \"Permanent link\")", "anchor": "in-indexhtmlpydanticexperimentalpipelinepipelinein-permanent-link", "md_text": "```\nin_(values: Container[_OutT]) -> _Pipeline[_InT, _OutT]\n```\n\nConstrain a value to be in a certain set.\n\nSource code in `pydantic/experimental/pipeline.py`\n\n|  |  |\n| --- | --- |\n| ``` 277 278 279 ``` | ``` def in_(self: _Pipeline[_InT, _OutT], values: Container[_OutT]) -> _Pipeline[_InT, _OutT]:     \"\"\"Constrain a value to be in a certain set.\"\"\"     return self.constrain(_In(values)) ``` |", "url": "https://docs.pydantic.dev/latest/api/experimental/index.html#in-indexhtmlpydanticexperimentalpipelinepipelinein-permanent-link", "page": "api/experimental/index.html", "source_site": "pydantic"}
{"title": "not\\_in [Â¶](index.html#pydantic.experimental.pipeline._Pipeline.not_in \"Permanent link\")", "anchor": "notin-indexhtmlpydanticexperimentalpipelinepipelinenotin-permanent-link", "md_text": "```\nnot_in(values: Container[_OutT]) -> _Pipeline[_InT, _OutT]\n```\n\nConstrain a value to not be in a certain set.\n\nSource code in `pydantic/experimental/pipeline.py`\n\n|  |  |\n| --- | --- |\n| ``` 281 282 283 ``` | ``` def not_in(self: _Pipeline[_InT, _OutT], values: Container[_OutT]) -> _Pipeline[_InT, _OutT]:     \"\"\"Constrain a value to not be in a certain set.\"\"\"     return self.constrain(_NotIn(values)) ``` |", "url": "https://docs.pydantic.dev/latest/api/experimental/index.html#notin-indexhtmlpydanticexperimentalpipelinepipelinenotin-permanent-link", "page": "api/experimental/index.html", "source_site": "pydantic"}
{"title": "otherwise [Â¶](index.html#pydantic.experimental.pipeline._Pipeline.otherwise \"Permanent link\")", "anchor": "otherwise-indexhtmlpydanticexperimentalpipelinepipelineotherwise-permanent-link", "md_text": "```\notherwise(\n    other: _Pipeline[_OtherIn, _OtherOut]\n) -> _Pipeline[_InT | _OtherIn, _OutT | _OtherOut]\n```\n\nCombine two validation chains, returning the result of the first chain if it succeeds, and the second chain if it fails.\n\nSource code in `pydantic/experimental/pipeline.py`\n\n|  |  |\n| --- | --- |\n| ``` 328 329 330 ``` | ``` def otherwise(self, other: _Pipeline[_OtherIn, _OtherOut]) -> _Pipeline[_InT | _OtherIn, _OutT | _OtherOut]:     \"\"\"Combine two validation chains, returning the result of the first chain if it succeeds, and the second chain if it fails.\"\"\"     return _Pipeline((_PipelineOr(self, other),)) ``` |", "url": "https://docs.pydantic.dev/latest/api/experimental/index.html#otherwise-indexhtmlpydanticexperimentalpipelinepipelineotherwise-permanent-link", "page": "api/experimental/index.html", "source_site": "pydantic"}
{"title": "then [Â¶](index.html#pydantic.experimental.pipeline._Pipeline.then \"Permanent link\")", "anchor": "then-indexhtmlpydanticexperimentalpipelinepipelinethen-permanent-link", "md_text": "```\nthen(\n    other: _Pipeline[_OutT, _OtherOut]\n) -> _Pipeline[_InT, _OtherOut]\n```\n\nPipe the result of one validation chain into another.\n\nSource code in `pydantic/experimental/pipeline.py`\n\n|  |  |\n| --- | --- |\n| ``` 334 335 336 ``` | ``` def then(self, other: _Pipeline[_OutT, _OtherOut]) -> _Pipeline[_InT, _OtherOut]:     \"\"\"Pipe the result of one validation chain into another.\"\"\"     return _Pipeline((_PipelineAnd(self, other),)) ``` |", "url": "https://docs.pydantic.dev/latest/api/experimental/index.html#then-indexhtmlpydanticexperimentalpipelinepipelinethen-permanent-link", "page": "api/experimental/index.html", "source_site": "pydantic"}
{"title": "Arguments schema API[Â¶](index.html#arguments-schema-api \"Permanent link\")", "anchor": "arguments-schema-apiindexhtmlarguments-schema-api-permanent-link", "md_text": "Experimental module exposing a function to generate a core schema that validates callable arguments.", "url": "https://docs.pydantic.dev/latest/api/experimental/index.html#arguments-schema-apiindexhtmlarguments-schema-api-permanent-link", "page": "api/experimental/index.html", "source_site": "pydantic"}
{"title": "generate\\_arguments\\_schema [Â¶](index.html#pydantic.experimental.arguments_schema.generate_arguments_schema \"Permanent link\")", "anchor": "generateargumentsschema-indexhtmlpydanticexperimentalargumentsschemagenerateargumentsschema-permanent-link", "md_text": "```\ngenerate_arguments_schema(\n    func: Callable[..., Any],\n    schema_type: Literal[\n        \"arguments\", \"arguments-v3\"\n    ] = \"arguments-v3\",\n    parameters_callback: (\n        Callable[[int, str, Any], Literal[\"skip\"] | None]\n        | None\n    ) = None,\n    config: ConfigDict | None = None,\n) -> CoreSchema\n```\n\nGenerate the schema for the arguments of a function.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `func` | `Callable[..., Any]` | The function to generate the schema for. | *required* |\n| `schema_type` | `Literal['arguments', 'arguments-v3']` | The type of schema to generate. | `'arguments-v3'` |\n| `parameters_callback` | `Callable[[int, str, Any], Literal['skip'] | None] | None` | A callable that will be invoked for each parameter. The callback should take three required arguments: the index, the name and the type annotation (or [`Parameter.empty`](https://docs.python.org/3/library/inspect.html#inspect.Parameter.empty) if not annotated) of the parameter. The callback can optionally return `'skip'`, so that the parameter gets excluded from the resulting schema. | `None` |\n| `config` | `ConfigDict | None` | The configuration to use. | `None` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `CoreSchema` | The generated schema. |\n\nSource code in `pydantic/experimental/arguments_schema.py`\n\n|  |  |\n| --- | --- |\n| ``` 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 ``` | ``` def generate_arguments_schema(     func: Callable[..., Any],     schema_type: Literal['arguments', 'arguments-v3'] = 'arguments-v3',     parameters_callback: Callable[[int, str, Any], Literal['skip'] | None] | None = None,     config: ConfigDict | None = None, ) -> CoreSchema:     \"\"\"Generate the schema for the arguments of a function.      Args:         func: The function to generate the schema for.         schema_type: The type of schema to generate.         parameters_callback: A callable that will be invoked for each parameter. The callback             should take three required arguments: the index, the name and the type annotation             (or [`Parameter.empty`][inspect.Parameter.empty] if not annotated) of the parameter.             The callback can optionally return `'skip'`, so that the parameter gets excluded             from the resulting schema.         config: The configuration to use.      Returns:         The generated schema.     \"\"\"     generate_schema = _generate_schema.GenerateSchema(         _config.ConfigWrapper(config),         ns_resolver=_namespace_utils.NsResolver(namespaces_tuple=_namespace_utils.ns_for_function(func)),     )      if schema_type == 'arguments':         schema = generate_schema._arguments_schema(func, parameters_callback)  # pyright: ignore[reportArgumentType]     else:         schema = generate_schema._arguments_v3_schema(func, parameters_callback)  # pyright: ignore[reportArgumentType]     return generate_schema.clean_schema(schema) ``` |\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/api/experimental/index.html#generateargumentsschema-indexhtmlpydanticexperimentalargumentsschemagenerateargumentsschema-permanent-link", "page": "api/experimental/index.html", "source_site": "pydantic"}
{"title": "rebuild [Â¶](index.html#pydantic.type_adapter.TypeAdapter.rebuild \"Permanent link\")", "anchor": "rebuild-indexhtmlpydantictypeadaptertypeadapterrebuild-permanent-link", "md_text": "```\nrebuild(\n    *,\n    force: bool = False,\n    raise_errors: bool = True,\n    _parent_namespace_depth: int = 2,\n    _types_namespace: MappingNamespace | None = None\n) -> bool | None\n```\n\nTry to rebuild the pydantic-core schema for the adapter's type.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `force` | `bool` | Whether to force the rebuilding of the type adapter's schema, defaults to `False`. | `False` |\n| `raise_errors` | `bool` | Whether to raise errors, defaults to `True`. | `True` |\n| `_parent_namespace_depth` | `int` | Depth at which to search for the [parent frame](https://docs.python.org/3/reference/datamodel.html#frame-objects). This frame is used when resolving forward annotations during schema rebuilding, by looking for the locals of this frame. Defaults to 2, which will result in the frame where the method was called. | `2` |\n| `_types_namespace` | `MappingNamespace | None` | An explicit types namespace to use, instead of using the local namespace from the parent frame. Defaults to `None`. | `None` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `bool | None` | Returns `None` if the schema is already \"complete\" and rebuilding was not required. |\n| `bool | None` | If rebuilding *was* required, returns `True` if rebuilding was successful, otherwise `False`. |\n\nSource code in `pydantic/type_adapter.py`\n\n|  |  |\n| --- | --- |\n| ``` 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 ``` | ``` def rebuild(     self,     *,     force: bool = False,     raise_errors: bool = True,     _parent_namespace_depth: int = 2,     _types_namespace: _namespace_utils.MappingNamespace | None = None, ) -> bool | None:     \"\"\"Try to rebuild the pydantic-core schema for the adapter's type.      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during     the initial attempt to build the schema, and automatic rebuilding fails.      Args:         force: Whether to force the rebuilding of the type adapter's schema, defaults to `False`.         raise_errors: Whether to raise errors, defaults to `True`.         _parent_namespace_depth: Depth at which to search for the [parent frame][frame-objects]. This             frame is used when resolving forward annotations during schema rebuilding, by looking for             the locals of this frame. Defaults to 2, which will result in the frame where the method             was called.         _types_namespace: An explicit types namespace to use, instead of using the local namespace             from the parent frame. Defaults to `None`.      Returns:         Returns `None` if the schema is already \"complete\" and rebuilding was not required.         If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.     \"\"\"     if not force and self.pydantic_complete:         return None      if _types_namespace is not None:         rebuild_ns = _types_namespace     elif _parent_namespace_depth > 0:         rebuild_ns = _typing_extra.parent_frame_namespace(parent_depth=_parent_namespace_depth, force=True) or {}     else:         rebuild_ns = {}      # we have to manually fetch globals here because there's no type on the stack of the NsResolver     # and so we skip the globalns = get_module_ns_of(typ) call that would normally happen     globalns = sys._getframe(max(_parent_namespace_depth - 1, 1)).f_globals     ns_resolver = _namespace_utils.NsResolver(         namespaces_tuple=_namespace_utils.NamespacesTuple(locals=rebuild_ns, globals=globalns),         parent_namespace=rebuild_ns,     )     return self._init_core_attrs(ns_resolver=ns_resolver, force=True, raise_errors=raise_errors) ``` |", "url": "https://docs.pydantic.dev/latest/api/type_adapter/index.html#rebuild-indexhtmlpydantictypeadaptertypeadapterrebuild-permanent-link", "page": "api/type_adapter/index.html", "source_site": "pydantic"}
{"title": "validate\\_python [Â¶](index.html#pydantic.type_adapter.TypeAdapter.validate_python \"Permanent link\")", "anchor": "validatepython-indexhtmlpydantictypeadaptertypeadaptervalidatepython-permanent-link", "md_text": "```\nvalidate_python(\n    object: Any,\n    /,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    from_attributes: bool | None = None,\n    context: Any | None = None,\n    experimental_allow_partial: (\n        bool | Literal[\"off\", \"on\", \"trailing-strings\"]\n    ) = False,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -> T\n```\n\nValidate a Python object against the model.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `object` | `Any` | The Python object to validate against the model. | *required* |\n| `strict` | `bool | None` | Whether to strictly check types. | `None` |\n| `extra` | `ExtraValues | None` | Whether to ignore, allow, or forbid extra data during model validation. See the [`extra` configuration value](../config/index.html#pydantic.config.ConfigDict.extra) for details. | `None` |\n| `from_attributes` | `bool | None` | Whether to extract data from object attributes. | `None` |\n| `context` | `Any | None` | Additional context to pass to the validator. | `None` |\n| `experimental_allow_partial` | `bool | Literal['off', 'on', 'trailing-strings']` | **Experimental** whether to enable [partial validation](../../concepts/experimental/index.html#partial-validation), e.g. to process streams. \\* False / 'off': Default behavior, no partial validation. \\* True / 'on': Enable partial validation. \\* 'trailing-strings': Enable partial validation and allow trailing strings in the input. | `False` |\n| `by_alias` | `bool | None` | Whether to use the field's alias when validating against the provided input data. | `None` |\n| `by_name` | `bool | None` | Whether to use the field's name when validating against the provided input data. | `None` |\n\nWhen using `TypeAdapter` with a Pydantic `dataclass`, the use of the `from_attributes`\nargument is not supported.\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `T` | The validated object. |\n\nSource code in `pydantic/type_adapter.py`\n\n|  |  |\n| --- | --- |\n| ``` 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 ``` | ``` def validate_python(     self,     object: Any,     /,     *,     strict: bool | None = None,     extra: ExtraValues | None = None,     from_attributes: bool | None = None,     context: Any | None = None,     experimental_allow_partial: bool | Literal['off', 'on', 'trailing-strings'] = False,     by_alias: bool | None = None,     by_name: bool | None = None, ) -> T:     \"\"\"Validate a Python object against the model.      Args:         object: The Python object to validate against the model.         strict: Whether to strictly check types.         extra: Whether to ignore, allow, or forbid extra data during model validation.             See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.         from_attributes: Whether to extract data from object attributes.         context: Additional context to pass to the validator.         experimental_allow_partial: **Experimental** whether to enable             [partial validation](../concepts/experimental.md#partial-validation), e.g. to process streams.             * False / 'off': Default behavior, no partial validation.             * True / 'on': Enable partial validation.             * 'trailing-strings': Enable partial validation and allow trailing strings in the input.         by_alias: Whether to use the field's alias when validating against the provided input data.         by_name: Whether to use the field's name when validating against the provided input data.      !!! note         When using `TypeAdapter` with a Pydantic `dataclass`, the use of the `from_attributes`         argument is not supported.      Returns:         The validated object.     \"\"\"     if by_alias is False and by_name is not True:         raise PydanticUserError(             'At least one of `by_alias` or `by_name` must be set to True.',             code='validate-by-alias-and-name-false',         )      return self.validator.validate_python(         object,         strict=strict,         extra=extra,         from_attributes=from_attributes,         context=context,         allow_partial=experimental_allow_partial,         by_alias=by_alias,         by_name=by_name,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/type_adapter/index.html#validatepython-indexhtmlpydantictypeadaptertypeadaptervalidatepython-permanent-link", "page": "api/type_adapter/index.html", "source_site": "pydantic"}
{"title": "validate\\_json [Â¶](index.html#pydantic.type_adapter.TypeAdapter.validate_json \"Permanent link\")", "anchor": "validatejson-indexhtmlpydantictypeadaptertypeadaptervalidatejson-permanent-link", "md_text": "```\nvalidate_json(\n    data: str | bytes | bytearray,\n    /,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    experimental_allow_partial: (\n        bool | Literal[\"off\", \"on\", \"trailing-strings\"]\n    ) = False,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -> T\n```\n\n[JSON Parsing](../../concepts/json/index.html#json-parsing)\n\nValidate a JSON string or bytes against the model.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `data` | `str | bytes | bytearray` | The JSON data to validate against the model. | *required* |\n| `strict` | `bool | None` | Whether to strictly check types. | `None` |\n| `extra` | `ExtraValues | None` | Whether to ignore, allow, or forbid extra data during model validation. See the [`extra` configuration value](../config/index.html#pydantic.config.ConfigDict.extra) for details. | `None` |\n| `context` | `Any | None` | Additional context to use during validation. | `None` |\n| `experimental_allow_partial` | `bool | Literal['off', 'on', 'trailing-strings']` | **Experimental** whether to enable [partial validation](../../concepts/experimental/index.html#partial-validation), e.g. to process streams. \\* False / 'off': Default behavior, no partial validation. \\* True / 'on': Enable partial validation. \\* 'trailing-strings': Enable partial validation and allow trailing strings in the input. | `False` |\n| `by_alias` | `bool | None` | Whether to use the field's alias when validating against the provided input data. | `None` |\n| `by_name` | `bool | None` | Whether to use the field's name when validating against the provided input data. | `None` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `T` | The validated object. |\n\nSource code in `pydantic/type_adapter.py`\n\n|  |  |\n| --- | --- |\n| ``` 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 ``` | ``` def validate_json(     self,     data: str | bytes | bytearray,     /,     *,     strict: bool | None = None,     extra: ExtraValues | None = None,     context: Any | None = None,     experimental_allow_partial: bool | Literal['off', 'on', 'trailing-strings'] = False,     by_alias: bool | None = None,     by_name: bool | None = None, ) -> T:     \"\"\"!!! abstract \"Usage Documentation\"         [JSON Parsing](../concepts/json.md#json-parsing)      Validate a JSON string or bytes against the model.      Args:         data: The JSON data to validate against the model.         strict: Whether to strictly check types.         extra: Whether to ignore, allow, or forbid extra data during model validation.             See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.         context: Additional context to use during validation.         experimental_allow_partial: **Experimental** whether to enable             [partial validation](../concepts/experimental.md#partial-validation), e.g. to process streams.             * False / 'off': Default behavior, no partial validation.             * True / 'on': Enable partial validation.             * 'trailing-strings': Enable partial validation and allow trailing strings in the input.         by_alias: Whether to use the field's alias when validating against the provided input data.         by_name: Whether to use the field's name when validating against the provided input data.      Returns:         The validated object.     \"\"\"     if by_alias is False and by_name is not True:         raise PydanticUserError(             'At least one of `by_alias` or `by_name` must be set to True.',             code='validate-by-alias-and-name-false',         )      return self.validator.validate_json(         data,         strict=strict,         extra=extra,         context=context,         allow_partial=experimental_allow_partial,         by_alias=by_alias,         by_name=by_name,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/type_adapter/index.html#validatejson-indexhtmlpydantictypeadaptertypeadaptervalidatejson-permanent-link", "page": "api/type_adapter/index.html", "source_site": "pydantic"}
{"title": "validate\\_strings [Â¶](index.html#pydantic.type_adapter.TypeAdapter.validate_strings \"Permanent link\")", "anchor": "validatestrings-indexhtmlpydantictypeadaptertypeadaptervalidatestrings-permanent-link", "md_text": "```\nvalidate_strings(\n    obj: Any,\n    /,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    experimental_allow_partial: (\n        bool | Literal[\"off\", \"on\", \"trailing-strings\"]\n    ) = False,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -> T\n```\n\nValidate object contains string data against the model.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `obj` | `Any` | The object contains string data to validate. | *required* |\n| `strict` | `bool | None` | Whether to strictly check types. | `None` |\n| `extra` | `ExtraValues | None` | Whether to ignore, allow, or forbid extra data during model validation. See the [`extra` configuration value](../config/index.html#pydantic.config.ConfigDict.extra) for details. | `None` |\n| `context` | `Any | None` | Additional context to use during validation. | `None` |\n| `experimental_allow_partial` | `bool | Literal['off', 'on', 'trailing-strings']` | **Experimental** whether to enable [partial validation](../../concepts/experimental/index.html#partial-validation), e.g. to process streams. \\* False / 'off': Default behavior, no partial validation. \\* True / 'on': Enable partial validation. \\* 'trailing-strings': Enable partial validation and allow trailing strings in the input. | `False` |\n| `by_alias` | `bool | None` | Whether to use the field's alias when validating against the provided input data. | `None` |\n| `by_name` | `bool | None` | Whether to use the field's name when validating against the provided input data. | `None` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `T` | The validated object. |\n\nSource code in `pydantic/type_adapter.py`\n\n|  |  |\n| --- | --- |\n| ``` 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 ``` | ``` def validate_strings(     self,     obj: Any,     /,     *,     strict: bool | None = None,     extra: ExtraValues | None = None,     context: Any | None = None,     experimental_allow_partial: bool | Literal['off', 'on', 'trailing-strings'] = False,     by_alias: bool | None = None,     by_name: bool | None = None, ) -> T:     \"\"\"Validate object contains string data against the model.      Args:         obj: The object contains string data to validate.         strict: Whether to strictly check types.         extra: Whether to ignore, allow, or forbid extra data during model validation.             See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.         context: Additional context to use during validation.         experimental_allow_partial: **Experimental** whether to enable             [partial validation](../concepts/experimental.md#partial-validation), e.g. to process streams.             * False / 'off': Default behavior, no partial validation.             * True / 'on': Enable partial validation.             * 'trailing-strings': Enable partial validation and allow trailing strings in the input.         by_alias: Whether to use the field's alias when validating against the provided input data.         by_name: Whether to use the field's name when validating against the provided input data.      Returns:         The validated object.     \"\"\"     if by_alias is False and by_name is not True:         raise PydanticUserError(             'At least one of `by_alias` or `by_name` must be set to True.',             code='validate-by-alias-and-name-false',         )      return self.validator.validate_strings(         obj,         strict=strict,         extra=extra,         context=context,         allow_partial=experimental_allow_partial,         by_alias=by_alias,         by_name=by_name,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/type_adapter/index.html#validatestrings-indexhtmlpydantictypeadaptertypeadaptervalidatestrings-permanent-link", "page": "api/type_adapter/index.html", "source_site": "pydantic"}
{"title": "get\\_default\\_value [Â¶](index.html#pydantic.type_adapter.TypeAdapter.get_default_value \"Permanent link\")", "anchor": "getdefaultvalue-indexhtmlpydantictypeadaptertypeadaptergetdefaultvalue-permanent-link", "md_text": "```\nget_default_value(\n    *,\n    strict: bool | None = None,\n    context: Any | None = None\n) -> Some[T] | None\n```\n\nGet the default value for the wrapped type.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `strict` | `bool | None` | Whether to strictly check types. | `None` |\n| `context` | `Any | None` | Additional context to pass to the validator. | `None` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `Some[T] | None` | The default value wrapped in a `Some` if there is one or None if not. |\n\nSource code in `pydantic/type_adapter.py`\n\n|  |  |\n| --- | --- |\n| ``` 549 550 551 552 553 554 555 556 557 558 559 ``` | ``` def get_default_value(self, *, strict: bool | None = None, context: Any | None = None) -> Some[T] | None:     \"\"\"Get the default value for the wrapped type.      Args:         strict: Whether to strictly check types.         context: Additional context to pass to the validator.      Returns:         The default value wrapped in a `Some` if there is one or None if not.     \"\"\"     return self.validator.get_default_value(strict=strict, context=context) ``` |", "url": "https://docs.pydantic.dev/latest/api/type_adapter/index.html#getdefaultvalue-indexhtmlpydantictypeadaptertypeadaptergetdefaultvalue-permanent-link", "page": "api/type_adapter/index.html", "source_site": "pydantic"}
{"title": "dump\\_python [Â¶](index.html#pydantic.type_adapter.TypeAdapter.dump_python \"Permanent link\")", "anchor": "dumppython-indexhtmlpydantictypeadaptertypeadapterdumppython-permanent-link", "md_text": "```\ndump_python(\n    instance: T,\n    /,\n    *,\n    mode: Literal[\"json\", \"python\"] = \"python\",\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: (\n        bool | Literal[\"none\", \"warn\", \"error\"]\n    ) = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n    context: Any | None = None,\n) -> Any\n```\n\nDump an instance of the adapted type to a Python object.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `instance` | `T` | The Python object to serialize. | *required* |\n| `mode` | `Literal['json', 'python']` | The output format. | `'python'` |\n| `include` | `IncEx | None` | Fields to include in the output. | `None` |\n| `exclude` | `IncEx | None` | Fields to exclude from the output. | `None` |\n| `by_alias` | `bool | None` | Whether to use alias names for field names. | `None` |\n| `exclude_unset` | `bool` | Whether to exclude unset fields. | `False` |\n| `exclude_defaults` | `bool` | Whether to exclude fields with default values. | `False` |\n| `exclude_none` | `bool` | Whether to exclude fields with None values. | `False` |\n| `exclude_computed_fields` | `bool` | Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated `round_trip` parameter instead. | `False` |\n| `round_trip` | `bool` | Whether to output the serialized data in a way that is compatible with deserialization. | `False` |\n| `warnings` | `bool | Literal['none', 'warn', 'error']` | How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a [`PydanticSerializationError`](../pydantic_core/index.html#pydantic_core.PydanticSerializationError). | `True` |\n| `fallback` | `Callable[[Any], Any] | None` | A function to call when an unknown value is encountered. If not provided, a [`PydanticSerializationError`](../pydantic_core/index.html#pydantic_core.PydanticSerializationError) error is raised. | `None` |\n| `serialize_as_any` | `bool` | Whether to serialize fields with duck-typing serialization behavior. | `False` |\n| `context` | `Any | None` | Additional context to pass to the serializer. | `None` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `Any` | The serialized object. |\n\nSource code in `pydantic/type_adapter.py`", "url": "https://docs.pydantic.dev/latest/api/type_adapter/index.html#dumppython-indexhtmlpydantictypeadaptertypeadapterdumppython-permanent-link", "page": "api/type_adapter/index.html", "source_site": "pydantic"}
{"title": "dump\\_python [Â¶](index.html#pydantic.type_adapter.TypeAdapter.dump_python \"Permanent link\")", "anchor": "dumppython-indexhtmlpydantictypeadaptertypeadapterdumppython-permanent-link", "md_text": "|  |  |\n| --- | --- |\n| ``` 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 ``` | ``` def dump_python(     self,     instance: T,     /,     *,     mode: Literal['json', 'python'] = 'python',     include: IncEx | None = None,     exclude: IncEx | None = None,     by_alias: bool | None = None,     exclude_unset: bool = False,     exclude_defaults: bool = False,     exclude_none: bool = False,     exclude_computed_fields: bool = False,     round_trip: bool = False,     warnings: bool | Literal['none', 'warn', 'error'] = True,     fallback: Callable[[Any], Any] | None = None,     serialize_as_any: bool = False,     context: Any | None = None, ) -> Any:     \"\"\"Dump an instance of the adapted type to a Python object.      Args:         instance: The Python object to serialize.         mode: The output format.         include: Fields to include in the output.         exclude: Fields to exclude from the output.         by_alias: Whether to use alias names for field names.         exclude_unset: Whether to exclude unset fields.         exclude_defaults: Whether to exclude fields with default values.         exclude_none: Whether to exclude fields with None values.         exclude_computed_fields: Whether to exclude computed fields.             While this can be useful for round-tripping, it is usually recommended to use the dedicated             `round_trip` parameter instead.         round_trip: Whether to output the serialized data in a way that is compatible with deserialization.         warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,             \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].         fallback: A function to call when an unknown value is encountered. If not provided,             a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.         serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.         context: Additional context to pass to the serializer.      Returns:         The serialized object.     \"\"\"     return self.serializer.to_python(         instance,         mode=mode,         by_alias=by_alias,         include=include,         exclude=exclude,         exclude_unset=exclude_unset,         exclude_defaults=exclude_defaults,         exclude_none=exclude_none,         exclude_computed_fields=exclude_computed_fields,         round_trip=round_trip,         warnings=warnings,         fallback=fallback,         serialize_as_any=serialize_as_any,         context=context,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/type_adapter/index.html#dumppython-indexhtmlpydantictypeadaptertypeadapterdumppython-permanent-link", "page": "api/type_adapter/index.html", "source_site": "pydantic"}
{"title": "dump\\_json [Â¶](index.html#pydantic.type_adapter.TypeAdapter.dump_json \"Permanent link\")", "anchor": "dumpjson-indexhtmlpydantictypeadaptertypeadapterdumpjson-permanent-link", "md_text": "```\ndump_json(\n    instance: T,\n    /,\n    *,\n    indent: int | None = None,\n    ensure_ascii: bool = False,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: (\n        bool | Literal[\"none\", \"warn\", \"error\"]\n    ) = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n    context: Any | None = None,\n) -> bytes\n```\n\n[JSON Serialization](../../concepts/json/index.html#json-serialization)\n\nSerialize an instance of the adapted type to JSON.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `instance` | `T` | The instance to be serialized. | *required* |\n| `indent` | `int | None` | Number of spaces for JSON indentation. | `None` |\n| `ensure_ascii` | `bool` | If `True`, the output is guaranteed to have all incoming non-ASCII characters escaped. If `False` (the default), these characters will be output as-is. | `False` |\n| `include` | `IncEx | None` | Fields to include. | `None` |\n| `exclude` | `IncEx | None` | Fields to exclude. | `None` |\n| `by_alias` | `bool | None` | Whether to use alias names for field names. | `None` |\n| `exclude_unset` | `bool` | Whether to exclude unset fields. | `False` |\n| `exclude_defaults` | `bool` | Whether to exclude fields with default values. | `False` |\n| `exclude_none` | `bool` | Whether to exclude fields with a value of `None`. | `False` |\n| `exclude_computed_fields` | `bool` | Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated `round_trip` parameter instead. | `False` |\n| `round_trip` | `bool` | Whether to serialize and deserialize the instance to ensure round-tripping. | `False` |\n| `warnings` | `bool | Literal['none', 'warn', 'error']` | How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a [`PydanticSerializationError`](../pydantic_core/index.html#pydantic_core.PydanticSerializationError). | `True` |\n| `fallback` | `Callable[[Any], Any] | None` | A function to call when an unknown value is encountered. If not provided, a [`PydanticSerializationError`](../pydantic_core/index.html#pydantic_core.PydanticSerializationError) error is raised. | `None` |\n| `serialize_as_any` | `bool` | Whether to serialize fields with duck-typing serialization behavior. | `False` |\n| `context` | `Any | None` | Additional context to pass to the serializer. | `None` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `bytes` | The JSON representation of the given instance as bytes. |\n\nSource code in `pydantic/type_adapter.py`", "url": "https://docs.pydantic.dev/latest/api/type_adapter/index.html#dumpjson-indexhtmlpydantictypeadaptertypeadapterdumpjson-permanent-link", "page": "api/type_adapter/index.html", "source_site": "pydantic"}
{"title": "dump\\_json [Â¶](index.html#pydantic.type_adapter.TypeAdapter.dump_json \"Permanent link\")", "anchor": "dumpjson-indexhtmlpydantictypeadaptertypeadapterdumpjson-permanent-link", "md_text": "|  |  |\n| --- | --- |\n| ``` 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 ``` | ``` def dump_json(     self,     instance: T,     /,     *,     indent: int | None = None,     ensure_ascii: bool = False,     include: IncEx | None = None,     exclude: IncEx | None = None,     by_alias: bool | None = None,     exclude_unset: bool = False,     exclude_defaults: bool = False,     exclude_none: bool = False,     exclude_computed_fields: bool = False,     round_trip: bool = False,     warnings: bool | Literal['none', 'warn', 'error'] = True,     fallback: Callable[[Any], Any] | None = None,     serialize_as_any: bool = False,     context: Any | None = None, ) -> bytes:     \"\"\"!!! abstract \"Usage Documentation\"         [JSON Serialization](../concepts/json.md#json-serialization)      Serialize an instance of the adapted type to JSON.      Args:         instance: The instance to be serialized.         indent: Number of spaces for JSON indentation.         ensure_ascii: If `True`, the output is guaranteed to have all incoming non-ASCII characters escaped.             If `False` (the default), these characters will be output as-is.         include: Fields to include.         exclude: Fields to exclude.         by_alias: Whether to use alias names for field names.         exclude_unset: Whether to exclude unset fields.         exclude_defaults: Whether to exclude fields with default values.         exclude_none: Whether to exclude fields with a value of `None`.         exclude_computed_fields: Whether to exclude computed fields.             While this can be useful for round-tripping, it is usually recommended to use the dedicated             `round_trip` parameter instead.         round_trip: Whether to serialize and deserialize the instance to ensure round-tripping.         warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,             \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].         fallback: A function to call when an unknown value is encountered. If not provided,             a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.         serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.         context: Additional context to pass to the serializer.      Returns:         The JSON representation of the given instance as bytes.     \"\"\"     return self.serializer.to_json(         instance,         indent=indent,         ensure_ascii=ensure_ascii,         include=include,         exclude=exclude,         by_alias=by_alias,         exclude_unset=exclude_unset,         exclude_defaults=exclude_defaults,         exclude_none=exclude_none,         exclude_computed_fields=exclude_computed_fields,         round_trip=round_trip,         warnings=warnings,         fallback=fallback,         serialize_as_any=serialize_as_any,         context=context,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/type_adapter/index.html#dumpjson-indexhtmlpydantictypeadaptertypeadapterdumpjson-permanent-link", "page": "api/type_adapter/index.html", "source_site": "pydantic"}
{"title": "json\\_schema [Â¶](index.html#pydantic.type_adapter.TypeAdapter.json_schema \"Permanent link\")", "anchor": "jsonschema-indexhtmlpydantictypeadaptertypeadapterjsonschema-permanent-link", "md_text": "```\njson_schema(\n    *,\n    by_alias: bool = True,\n    ref_template: str = DEFAULT_REF_TEMPLATE,\n    union_format: Literal[\n        \"any_of\", \"primitive_type_array\"\n    ] = \"any_of\",\n    schema_generator: type[\n        GenerateJsonSchema\n    ] = GenerateJsonSchema,\n    mode: JsonSchemaMode = \"validation\"\n) -> dict[str, Any]\n```\n\nGenerate a JSON schema for the adapted type.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `by_alias` | `bool` | Whether to use alias names for field names. | `True` |\n| `ref_template` | `str` | The format string used for generating $ref strings. | `DEFAULT_REF_TEMPLATE` |\n| `union_format` | `Literal['any_of', 'primitive_type_array']` | The format to use when combining schemas from unions together. Can be one of:   * `'any_of'`: Use the [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)   keyword to combine schemas (the default). * `'primitive_type_array'`: Use the [`type`](https://json-schema.org/understanding-json-schema/reference/type)   keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive   type (`string`, `boolean`, `null`, `integer` or `number`) or contains constraints/metadata, falls back to   `any_of`. | `'any_of'` |\n| `schema_generator` | `type[GenerateJsonSchema]` | To override the logic used to generate the JSON schema, as a subclass of `GenerateJsonSchema` with your desired modifications | `GenerateJsonSchema` |\n| `mode` | `JsonSchemaMode` | The mode in which to generate the schema. | `'validation'` |\n| `schema_generator` | `type[GenerateJsonSchema]` | The generator class used for creating the schema. | `GenerateJsonSchema` |\n| `mode` | `JsonSchemaMode` | The mode to use for schema generation. | `'validation'` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `dict[str, Any]` | The JSON schema for the model as a dictionary. |\n\nSource code in `pydantic/type_adapter.py`\n\n|  |  |\n| --- | --- |\n| ``` 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 ``` | ``` def json_schema(     self,     *,     by_alias: bool = True,     ref_template: str = DEFAULT_REF_TEMPLATE,     union_format: Literal['any_of', 'primitive_type_array'] = 'any_of',     schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,     mode: JsonSchemaMode = 'validation', ) -> dict[str, Any]:     \"\"\"Generate a JSON schema for the adapted type.      Args:         by_alias: Whether to use alias names for field names.         ref_template: The format string used for generating $ref strings.         union_format: The format to use when combining schemas from unions together. Can be one of:              - `'any_of'`: Use the [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)             keyword to combine schemas (the default).             - `'primitive_type_array'`: Use the [`type`](https://json-schema.org/understanding-json-schema/reference/type)             keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive             type (`string`, `boolean`, `null`, `integer` or `number`) or contains constraints/metadata, falls back to             `any_of`.         schema_generator: To override the logic used to generate the JSON schema, as a subclass of             `GenerateJsonSchema` with your desired modifications         mode: The mode in which to generate the schema.         schema_generator: The generator class used for creating the schema.         mode: The mode to use for schema generation.      Returns:         The JSON schema for the model as a dictionary.     \"\"\"     schema_generator_instance = schema_generator(         by_alias=by_alias, ref_template=ref_template, union_format=union_format     )     if isinstance(self.core_schema, _mock_val_ser.MockCoreSchema):         self.core_schema.rebuild()         assert not isinstance(self.core_schema, _mock_val_ser.MockCoreSchema), 'this is a bug! please report it'     return schema_generator_instance.generate(self.core_schema, mode=mode) ``` |", "url": "https://docs.pydantic.dev/latest/api/type_adapter/index.html#jsonschema-indexhtmlpydantictypeadaptertypeadapterjsonschema-permanent-link", "page": "api/type_adapter/index.html", "source_site": "pydantic"}
{"title": "json\\_schemas `staticmethod` [Â¶](index.html#pydantic.type_adapter.TypeAdapter.json_schemas \"Permanent link\")", "anchor": "jsonschemas-staticmethod-indexhtmlpydantictypeadaptertypeadapterjsonschemas-permanent-link", "md_text": "```\njson_schemas(\n    inputs: Iterable[\n        tuple[\n            JsonSchemaKeyT, JsonSchemaMode, TypeAdapter[Any]\n        ]\n    ],\n    /,\n    *,\n    by_alias: bool = True,\n    title: str | None = None,\n    description: str | None = None,\n    ref_template: str = DEFAULT_REF_TEMPLATE,\n    union_format: Literal[\n        \"any_of\", \"primitive_type_array\"\n    ] = \"any_of\",\n    schema_generator: type[\n        GenerateJsonSchema\n    ] = GenerateJsonSchema,\n) -> tuple[\n    dict[\n        tuple[JsonSchemaKeyT, JsonSchemaMode],\n        JsonSchemaValue,\n    ],\n    JsonSchemaValue,\n]\n```\n\nGenerate a JSON schema including definitions from multiple type adapters.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `inputs` | `Iterable[tuple[JsonSchemaKeyT, JsonSchemaMode, TypeAdapter[Any]]]` | Inputs to schema generation. The first two items will form the keys of the (first) output mapping; the type adapters will provide the core schemas that get converted into definitions in the output JSON schema. | *required* |\n| `by_alias` | `bool` | Whether to use alias names. | `True` |\n| `title` | `str | None` | The title for the schema. | `None` |\n| `description` | `str | None` | The description for the schema. | `None` |\n| `ref_template` | `str` | The format string used for generating $ref strings. | `DEFAULT_REF_TEMPLATE` |\n| `union_format` | `Literal['any_of', 'primitive_type_array']` | The format to use when combining schemas from unions together. Can be one of:   * `'any_of'`: Use the [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)   keyword to combine schemas (the default). * `'primitive_type_array'`: Use the [`type`](https://json-schema.org/understanding-json-schema/reference/type)   keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive   type (`string`, `boolean`, `null`, `integer` or `number`) or contains constraints/metadata, falls back to   `any_of`. | `'any_of'` |\n| `schema_generator` | `type[GenerateJsonSchema]` | The generator class used for creating the schema. | `GenerateJsonSchema` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `tuple[dict[tuple[JsonSchemaKeyT, JsonSchemaMode], JsonSchemaValue], JsonSchemaValue]` | A tuple where:   * The first element is a dictionary whose keys are tuples of JSON schema key type and JSON mode, and   whose values are the JSON schema corresponding to that pair of inputs. (These schemas may have   JsonRef references to definitions that are defined in the second returned element.) * The second element is a JSON schema containing all definitions referenced in the first returned   element, along with the optional title and description keys. |\n\nSource code in `pydantic/type_adapter.py`", "url": "https://docs.pydantic.dev/latest/api/type_adapter/index.html#jsonschemas-staticmethod-indexhtmlpydantictypeadaptertypeadapterjsonschemas-permanent-link", "page": "api/type_adapter/index.html", "source_site": "pydantic"}
{"title": "json\\_schemas `staticmethod` [Â¶](index.html#pydantic.type_adapter.TypeAdapter.json_schemas \"Permanent link\")", "anchor": "jsonschemas-staticmethod-indexhtmlpydantictypeadaptertypeadapterjsonschemas-permanent-link", "md_text": "|  |  |\n| --- | --- |\n| ``` 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 ``` | ``` @staticmethod def json_schemas(     inputs: Iterable[tuple[JsonSchemaKeyT, JsonSchemaMode, TypeAdapter[Any]]],     /,     *,     by_alias: bool = True,     title: str | None = None,     description: str | None = None,     ref_template: str = DEFAULT_REF_TEMPLATE,     union_format: Literal['any_of', 'primitive_type_array'] = 'any_of',     schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema, ) -> tuple[dict[tuple[JsonSchemaKeyT, JsonSchemaMode], JsonSchemaValue], JsonSchemaValue]:     \"\"\"Generate a JSON schema including definitions from multiple type adapters.      Args:         inputs: Inputs to schema generation. The first two items will form the keys of the (first)             output mapping; the type adapters will provide the core schemas that get converted into             definitions in the output JSON schema.         by_alias: Whether to use alias names.         title: The title for the schema.         description: The description for the schema.         ref_template: The format string used for generating $ref strings.         union_format: The format to use when combining schemas from unions together. Can be one of:              - `'any_of'`: Use the [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)             keyword to combine schemas (the default).             - `'primitive_type_array'`: Use the [`type`](https://json-schema.org/understanding-json-schema/reference/type)             keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive             type (`string`, `boolean`, `null`, `integer` or `number`) or contains constraints/metadata, falls back to             `any_of`.         schema_generator: The generator class used for creating the schema.      Returns:         A tuple where:              - The first element is a dictionary whose keys are tuples of JSON schema key type and JSON mode, and                 whose values are the JSON schema corresponding to that pair of inputs. (These schemas may have                 JsonRef references to definitions that are defined in the second returned element.)             - The second element is a JSON schema containing all definitions referenced in the first returned                 element, along with the optional title and description keys.      \"\"\"     schema_generator_instance = schema_generator(         by_alias=by_alias, ref_template=ref_template, union_format=union_format     )      inputs_ = []     for key, mode, adapter in inputs:         # This is the same pattern we follow for model json schemas - we attempt a core schema rebuild if we detect a mock         if isinstance(adapter.core_schema, _mock_val_ser.MockCoreSchema):             adapter.core_schema.rebuild()             assert not isinstance(adapter.core_schema, _mock_val_ser.MockCoreSchema), (                 'this is a bug! please report it'             )         inputs_.append((key, mode, adapter.core_schema))      json_schemas_map, definitions = schema_generator_instance.generate_definitions(inputs_)      json_schema: dict[str, Any] = {}     if definitions:         json_schema['$defs'] = definitions     if title:         json_schema['title'] = title     if description:         json_schema['description'] = description      return json_schemas_map, json_schema ``` |\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/api/type_adapter/index.html#jsonschemas-staticmethod-indexhtmlpydantictypeadaptertypeadapterjsonschemas-permanent-link", "page": "api/type_adapter/index.html", "source_site": "pydantic"}
{"title": "RootModel [Â¶](index.html#pydantic.root_model.RootModel \"Permanent link\")", "anchor": "rootmodel-indexhtmlpydanticrootmodelrootmodel-permanent-link", "md_text": "```\nRootModel(\n    root: RootModelRootType = PydanticUndefined, **data\n)\n```\n\nBases: `BaseModel`, `Generic[RootModelRootType]`\n\n[`RootModel` and Custom Root Types](../../concepts/models/index.html#rootmodel-and-custom-root-types)\n\nA Pydantic `BaseModel` for the root object of the model.\n\nAttributes:\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `root` | `RootModelRootType` | The root object of the model. |\n| `__pydantic_root_model__` |  | Whether the model is a RootModel. |\n| `__pydantic_private__` |  | Private fields in the model. |\n| `__pydantic_extra__` |  | Extra fields in the model. |\n\nSource code in `pydantic/root_model.py`\n\n|  |  |\n| --- | --- |\n| ``` 60 61 62 63 64 65 66 67 68 ``` | ``` def __init__(self, /, root: RootModelRootType = PydanticUndefined, **data) -> None:  # type: ignore     __tracebackhide__ = True     if data:         if root is not PydanticUndefined:             raise ValueError(                 '\"RootModel.__init__\" accepts either a single positional argument or arbitrary keyword arguments'             )         root = data  # type: ignore     self.__pydantic_validator__.validate_python(root, self_instance=self) ``` |", "url": "https://docs.pydantic.dev/latest/api/root_model/index.html#rootmodel-indexhtmlpydanticrootmodelrootmodel-permanent-link", "page": "api/root_model/index.html", "source_site": "pydantic"}
{"title": "model\\_construct `classmethod` [Â¶](index.html#pydantic.root_model.RootModel.model_construct \"Permanent link\")", "anchor": "modelconstruct-classmethod-indexhtmlpydanticrootmodelrootmodelmodelconstruct-permanent-link", "md_text": "```\nmodel_construct(\n    root: RootModelRootType,\n    _fields_set: set[str] | None = None,\n) -> Self\n```\n\nCreate a new model using the provided root object and update fields set.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `root` | `RootModelRootType` | The root object of the model. | *required* |\n| `_fields_set` | `set[str] | None` | The set of fields to be updated. | `None` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `Self` | The new model. |\n\nRaises:\n\n| Type | Description |\n| --- | --- |\n| `NotImplemented` | If the model is not a subclass of `RootModel`. |\n\nSource code in `pydantic/root_model.py`\n\n|  |  |\n| --- | --- |\n| ``` 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 ``` | ``` @classmethod def model_construct(cls, root: RootModelRootType, _fields_set: set[str] | None = None) -> Self:  # type: ignore     \"\"\"Create a new model using the provided root object and update fields set.      Args:         root: The root object of the model.         _fields_set: The set of fields to be updated.      Returns:         The new model.      Raises:         NotImplemented: If the model is not a subclass of `RootModel`.     \"\"\"     return super().model_construct(root=root, _fields_set=_fields_set) ``` |", "url": "https://docs.pydantic.dev/latest/api/root_model/index.html#modelconstruct-classmethod-indexhtmlpydanticrootmodelrootmodelmodelconstruct-permanent-link", "page": "api/root_model/index.html", "source_site": "pydantic"}
{"title": "model\\_dump [Â¶](index.html#pydantic.root_model.RootModel.model_dump \"Permanent link\")", "anchor": "modeldump-indexhtmlpydanticrootmodelrootmodelmodeldump-permanent-link", "md_text": "```\nmodel_dump(\n    *,\n    mode: Literal[\"json\", \"python\"] | str = \"python\",\n    include: Any = None,\n    exclude: Any = None,\n    context: dict[str, Any] | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: (\n        bool | Literal[\"none\", \"warn\", \"error\"]\n    ) = True,\n    serialize_as_any: bool = False\n) -> Any\n```\n\nThis method is included just to get a more accurate return type for type checkers.\nIt is included in this `if TYPE_CHECKING:` block since no override is actually necessary.\n\nSee the documentation of `BaseModel.model_dump` for more details about the arguments.\n\nGenerally, this method will have a return type of `RootModelRootType`, assuming that `RootModelRootType` is\nnot a `BaseModel` subclass. If `RootModelRootType` is a `BaseModel` subclass, then the return\ntype will likely be `dict[str, Any]`, as `model_dump` calls are recursive. The return type could\neven be something different, in the case of a custom serializer.\nThus, `Any` is used here to catch all of these cases.\n\nSource code in `pydantic/root_model.py`\n\n|  |  |\n| --- | --- |\n| ``` 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 ``` | ``` def model_dump(  # type: ignore     self,     *,     mode: Literal['json', 'python'] | str = 'python',     include: Any = None,     exclude: Any = None,     context: dict[str, Any] | None = None,     by_alias: bool | None = None,     exclude_unset: bool = False,     exclude_defaults: bool = False,     exclude_none: bool = False,     exclude_computed_fields: bool = False,     round_trip: bool = False,     warnings: bool | Literal['none', 'warn', 'error'] = True,     serialize_as_any: bool = False, ) -> Any:     \"\"\"This method is included just to get a more accurate return type for type checkers.     It is included in this `if TYPE_CHECKING:` block since no override is actually necessary.      See the documentation of `BaseModel.model_dump` for more details about the arguments.      Generally, this method will have a return type of `RootModelRootType`, assuming that `RootModelRootType` is     not a `BaseModel` subclass. If `RootModelRootType` is a `BaseModel` subclass, then the return     type will likely be `dict[str, Any]`, as `model_dump` calls are recursive. The return type could     even be something different, in the case of a custom serializer.     Thus, `Any` is used here to catch all of these cases.     \"\"\"     ... ``` |\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/api/root_model/index.html#modeldump-indexhtmlpydanticrootmodelrootmodelmodeldump-permanent-link", "page": "api/root_model/index.html", "source_site": "pydantic"}
{"title": "AliasPath `dataclass` [Â¶](index.html#pydantic.aliases.AliasPath \"Permanent link\")", "anchor": "aliaspath-dataclass-indexhtmlpydanticaliasesaliaspath-permanent-link", "md_text": "```\nAliasPath(first_arg: str, *args: str | int)\n```\n\n[`AliasPath` and `AliasChoices`](../../concepts/alias/index.html#aliaspath-and-aliaschoices)\n\nA data class used by `validation_alias` as a convenience to create aliases.\n\nAttributes:\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `path` | `list[int | str]` | A list of string or integer aliases. |\n\nSource code in `pydantic/aliases.py`\n\n|  |  |\n| --- | --- |\n| ``` 28 29 ``` | ``` def __init__(self, first_arg: str, *args: str | int) -> None:     self.path = [first_arg] + list(args) ``` |", "url": "https://docs.pydantic.dev/latest/api/aliases/index.html#aliaspath-dataclass-indexhtmlpydanticaliasesaliaspath-permanent-link", "page": "api/aliases/index.html", "source_site": "pydantic"}
{"title": "convert\\_to\\_aliases [Â¶](index.html#pydantic.aliases.AliasPath.convert_to_aliases \"Permanent link\")", "anchor": "converttoaliases-indexhtmlpydanticaliasesaliaspathconverttoaliases-permanent-link", "md_text": "```\nconvert_to_aliases() -> list[str | int]\n```\n\nConverts arguments to a list of string or integer aliases.\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `list[str | int]` | The list of aliases. |\n\nSource code in `pydantic/aliases.py`\n\n|  |  |\n| --- | --- |\n| ``` 31 32 33 34 35 36 37 ``` | ``` def convert_to_aliases(self) -> list[str | int]:     \"\"\"Converts arguments to a list of string or integer aliases.      Returns:         The list of aliases.     \"\"\"     return self.path ``` |", "url": "https://docs.pydantic.dev/latest/api/aliases/index.html#converttoaliases-indexhtmlpydanticaliasesaliaspathconverttoaliases-permanent-link", "page": "api/aliases/index.html", "source_site": "pydantic"}
{"title": "search\\_dict\\_for\\_path [Â¶](index.html#pydantic.aliases.AliasPath.search_dict_for_path \"Permanent link\")", "anchor": "searchdictforpath-indexhtmlpydanticaliasesaliaspathsearchdictforpath-permanent-link", "md_text": "```\nsearch_dict_for_path(d: dict) -> Any\n```\n\nSearches a dictionary for the path specified by the alias.\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `Any` | The value at the specified path, or `PydanticUndefined` if the path is not found. |\n\nSource code in `pydantic/aliases.py`\n\n|  |  |\n| --- | --- |\n| ``` 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 ``` | ``` def search_dict_for_path(self, d: dict) -> Any:     \"\"\"Searches a dictionary for the path specified by the alias.      Returns:         The value at the specified path, or `PydanticUndefined` if the path is not found.     \"\"\"     v = d     for k in self.path:         if isinstance(v, str):             # disallow indexing into a str, like for AliasPath('x', 0) and x='abc'             return PydanticUndefined         try:             v = v[k]         except (KeyError, IndexError, TypeError):             return PydanticUndefined     return v ``` |", "url": "https://docs.pydantic.dev/latest/api/aliases/index.html#searchdictforpath-indexhtmlpydanticaliasesaliaspathsearchdictforpath-permanent-link", "page": "api/aliases/index.html", "source_site": "pydantic"}
{"title": "AliasChoices `dataclass` [Â¶](index.html#pydantic.aliases.AliasChoices \"Permanent link\")", "anchor": "aliaschoices-dataclass-indexhtmlpydanticaliasesaliaschoices-permanent-link", "md_text": "```\nAliasChoices(\n    first_choice: str | AliasPath, *choices: str | AliasPath\n)\n```\n\n[`AliasPath` and `AliasChoices`](../../concepts/alias/index.html#aliaspath-and-aliaschoices)\n\nA data class used by `validation_alias` as a convenience to create aliases.\n\nAttributes:\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `choices` | `list[str | AliasPath]` | A list containing a string or `AliasPath`. |\n\nSource code in `pydantic/aliases.py`\n\n|  |  |\n| --- | --- |\n| ``` 70 71 ``` | ``` def __init__(self, first_choice: str | AliasPath, *choices: str | AliasPath) -> None:     self.choices = [first_choice] + list(choices) ``` |", "url": "https://docs.pydantic.dev/latest/api/aliases/index.html#aliaschoices-dataclass-indexhtmlpydanticaliasesaliaschoices-permanent-link", "page": "api/aliases/index.html", "source_site": "pydantic"}
{"title": "convert\\_to\\_aliases [Â¶](index.html#pydantic.aliases.AliasChoices.convert_to_aliases \"Permanent link\")", "anchor": "converttoaliases-indexhtmlpydanticaliasesaliaschoicesconverttoaliases-permanent-link", "md_text": "```\nconvert_to_aliases() -> list[list[str | int]]\n```\n\nConverts arguments to a list of lists containing string or integer aliases.\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `list[list[str | int]]` | The list of aliases. |\n\nSource code in `pydantic/aliases.py`\n\n|  |  |\n| --- | --- |\n| ``` 73 74 75 76 77 78 79 80 81 82 83 84 85 ``` | ``` def convert_to_aliases(self) -> list[list[str | int]]:     \"\"\"Converts arguments to a list of lists containing string or integer aliases.      Returns:         The list of aliases.     \"\"\"     aliases: list[list[str | int]] = []     for c in self.choices:         if isinstance(c, AliasPath):             aliases.append(c.convert_to_aliases())         else:             aliases.append([c])     return aliases ``` |", "url": "https://docs.pydantic.dev/latest/api/aliases/index.html#converttoaliases-indexhtmlpydanticaliasesaliaschoicesconverttoaliases-permanent-link", "page": "api/aliases/index.html", "source_site": "pydantic"}
{"title": "AliasGenerator `dataclass` [Â¶](index.html#pydantic.aliases.AliasGenerator \"Permanent link\")", "anchor": "aliasgenerator-dataclass-indexhtmlpydanticaliasesaliasgenerator-permanent-link", "md_text": "```\nAliasGenerator(\n    alias: Callable[[str], str] | None = None,\n    validation_alias: (\n        Callable[[str], str | AliasPath | AliasChoices]\n        | None\n    ) = None,\n    serialization_alias: Callable[[str], str] | None = None,\n)\n```\n\n[Using an `AliasGenerator`](../../concepts/alias/index.html#using-an-aliasgenerator)\n\nA data class used by `alias_generator` as a convenience to create various aliases.\n\nAttributes:\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `alias` | `Callable[[str], str] | None` | A callable that takes a field name and returns an alias for it. |\n| `validation_alias` | `Callable[[str], str | AliasPath | AliasChoices] | None` | A callable that takes a field name and returns a validation alias for it. |\n| `serialization_alias` | `Callable[[str], str] | None` | A callable that takes a field name and returns a serialization alias for it. |", "url": "https://docs.pydantic.dev/latest/api/aliases/index.html#aliasgenerator-dataclass-indexhtmlpydanticaliasesaliasgenerator-permanent-link", "page": "api/aliases/index.html", "source_site": "pydantic"}
{"title": "generate\\_aliases [Â¶](index.html#pydantic.aliases.AliasGenerator.generate_aliases \"Permanent link\")", "anchor": "generatealiases-indexhtmlpydanticaliasesaliasgeneratorgeneratealiases-permanent-link", "md_text": "```\ngenerate_aliases(\n    field_name: str,\n) -> tuple[\n    str | None,\n    str | AliasPath | AliasChoices | None,\n    str | None,\n]\n```\n\nGenerate `alias`, `validation_alias`, and `serialization_alias` for a field.\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `tuple[str | None, str | AliasPath | AliasChoices | None, str | None]` | A tuple of three aliases - validation, alias, and serialization. |\n\nSource code in `pydantic/aliases.py`\n\n|  |  |\n| --- | --- |\n| ``` 125 126 127 128 129 130 131 132 133 134 135 ``` | ``` def generate_aliases(self, field_name: str) -> tuple[str | None, str | AliasPath | AliasChoices | None, str | None]:     \"\"\"Generate `alias`, `validation_alias`, and `serialization_alias` for a field.      Returns:         A tuple of three aliases - validation, alias, and serialization.     \"\"\"     alias = self._generate_alias('alias', (str,), field_name)     validation_alias = self._generate_alias('validation_alias', (str, AliasChoices, AliasPath), field_name)     serialization_alias = self._generate_alias('serialization_alias', (str,), field_name)      return alias, validation_alias, serialization_alias  # type: ignore ``` |\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/api/aliases/index.html#generatealiases-indexhtmlpydanticaliasesaliasgeneratorgeneratealiases-permanent-link", "page": "api/aliases/index.html", "source_site": "pydantic"}
{"title": "Latitude [Â¶](index.html#pydantic_extra_types.coordinate.Latitude \"Permanent link\")", "anchor": "latitude-indexhtmlpydanticextratypescoordinatelatitude-permanent-link", "md_text": "Bases: `float`\n\nLatitude value should be between -90 and 90, inclusive.\n\nSupports both float and Decimal types.\n\n```\nfrom decimal import Decimal\nfrom pydantic import BaseModel\nfrom pydantic_extra_types.coordinate import Latitude\n\n\nclass Location(BaseModel):\n    latitude: Latitude\n\n\n# Using float\nlocation1 = Location(latitude=41.40338)\n# Using Decimal\nlocation2 = Location(latitude=Decimal('41.40338'))\n```", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_coordinate/index.html#latitude-indexhtmlpydanticextratypescoordinatelatitude-permanent-link", "page": "api/pydantic_extra_types_coordinate/index.html", "source_site": "pydantic"}
{"title": "Longitude [Â¶](index.html#pydantic_extra_types.coordinate.Longitude \"Permanent link\")", "anchor": "longitude-indexhtmlpydanticextratypescoordinatelongitude-permanent-link", "md_text": "Bases: `float`\n\nLongitude value should be between -180 and 180, inclusive.\n\nSupports both float and Decimal types.\n\n```\nfrom decimal import Decimal\nfrom pydantic import BaseModel\n\nfrom pydantic_extra_types.coordinate import Longitude\n\n\nclass Location(BaseModel):\n    longitude: Longitude\n\n\n# Using float\nlocation1 = Location(longitude=2.17403)\n# Using Decimal\nlocation2 = Location(longitude=Decimal('2.17403'))\n```", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_coordinate/index.html#longitude-indexhtmlpydanticextratypescoordinatelongitude-permanent-link", "page": "api/pydantic_extra_types_coordinate/index.html", "source_site": "pydantic"}
{"title": "Coordinate `dataclass` [Â¶](index.html#pydantic_extra_types.coordinate.Coordinate \"Permanent link\")", "anchor": "coordinate-dataclass-indexhtmlpydanticextratypescoordinatecoordinate-permanent-link", "md_text": "```\nCoordinate(latitude: Latitude, longitude: Longitude)\n```\n\nBases: `Representation`\n\nCoordinate parses Latitude and Longitude.\n\nYou can use the `Coordinate` data type for storing coordinates. Coordinates can be\ndefined using one of the following formats:\n\n1. Tuple: `(Latitude, Longitude)`. For example: `(41.40338, 2.17403)` or `(Decimal('41.40338'), Decimal('2.17403'))`.\n2. `Coordinate` instance: `Coordinate(latitude=Latitude, longitude=Longitude)`.\n\n```\nfrom decimal import Decimal\nfrom pydantic import BaseModel\n\nfrom pydantic_extra_types.coordinate import Coordinate\n\n\nclass Location(BaseModel):\n    coordinate: Coordinate\n\n\n# Using float values\nlocation1 = Location(coordinate=(41.40338, 2.17403))\n# > coordinate=Coordinate(latitude=41.40338, longitude=2.17403)\n\n# Using Decimal values\nlocation2 = Location(coordinate=(Decimal('41.40338'), Decimal('2.17403')))\n# > coordinate=Coordinate(latitude=41.40338, longitude=2.17403)\n```\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_coordinate/index.html#coordinate-dataclass-indexhtmlpydanticextratypescoordinatecoordinate-permanent-link", "page": "api/pydantic_extra_types_coordinate/index.html", "source_site": "pydantic"}
{"title": "MacAddress [Â¶](index.html#pydantic_extra_types.mac_address.MacAddress \"Permanent link\")", "anchor": "macaddress-indexhtmlpydanticextratypesmacaddressmacaddress-permanent-link", "md_text": "Bases: `str`\n\nRepresents a MAC address and provides methods for conversion, validation, and serialization.\n\n```\nfrom pydantic import BaseModel\n\nfrom pydantic_extra_types.mac_address import MacAddress\n\n\nclass Network(BaseModel):\n    mac_address: MacAddress\n\n\nnetwork = Network(mac_address='00:00:5e:00:53:01')\nprint(network)\n# > mac_address='00:00:5e:00:53:01'\n```", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_mac_address/index.html#macaddress-indexhtmlpydanticextratypesmacaddressmacaddress-permanent-link", "page": "api/pydantic_extra_types_mac_address/index.html", "source_site": "pydantic"}
{"title": "validate\\_mac\\_address `staticmethod` [Â¶](index.html#pydantic_extra_types.mac_address.MacAddress.validate_mac_address \"Permanent link\")", "anchor": "validatemacaddress-staticmethod-indexhtmlpydanticextratypesmacaddressmacaddressvalidatemacaddress-permanent-link", "md_text": "```\nvalidate_mac_address(value: bytes) -> str\n```\n\nValidate a MAC Address from the provided byte value.\n\nSource code in `pydantic_extra_types/mac_address.py`\n\n|  |  |\n| --- | --- |\n| ```  66  67  68  69  70  71  72  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90  91  92  93  94  95  96  97  98  99 100 101 102 103 104 105 106 ``` | ``` @staticmethod def validate_mac_address(value: bytes) -> str:     \"\"\"Validate a MAC Address from the provided byte value.\"\"\"     raw = value.decode()     if len(raw) < MINIMUM_LENGTH:         raise PydanticCustomError(             'mac_address_len',             'Length for a {mac_address} MAC address must be {required_length}',             {'mac_address': raw, 'required_length': MINIMUM_LENGTH},         )      for seperator, chunk_len in ((':', 2), ('-', 2), ('.', 4)):         if seperator not in raw:             continue          parts = raw.split(seperator)         if any(len(p) != chunk_len for p in parts):             raise PydanticCustomError(                 'mac_address_format',                 f'Must have the format xx{seperator}xx{seperator}xx{seperator}xx{seperator}xx{seperator}xx',             )          total_bytes = (len(parts) * chunk_len) // 2         if total_bytes not in ALLOWED_CHUNK_COUNTS:             raise PydanticCustomError(                 'mac_address_format',                 'Length for a {mac_address} MAC address must be {required_length}',                 {'mac_address': raw, 'required_length': ALLOWED_CHUNK_COUNTS},             )          try:             mac_bytes: list[int] = []             for part in parts:                 for i in range(0, chunk_len, 2):                     mac_bytes.append(int(part[i : i + 2], base=16))         except ValueError as exc:             raise PydanticCustomError('mac_address_format', 'Unrecognized format') from exc          return ':'.join(f'{b:02x}' for b in mac_bytes)      raise PydanticCustomError('mac_address_format', 'Unrecognized format') ``` |\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_mac_address/index.html#validatemacaddress-staticmethod-indexhtmlpydanticextratypesmacaddressmacaddressvalidatemacaddress-permanent-link", "page": "api/pydantic_extra_types_mac_address/index.html", "source_site": "pydantic"}
{"title": "LanguageInfo `dataclass` [Â¶](index.html#pydantic_extra_types.language_code.LanguageInfo \"Permanent link\")", "anchor": "languageinfo-dataclass-indexhtmlpydanticextratypeslanguagecodelanguageinfo-permanent-link", "md_text": "```\nLanguageInfo(\n    alpha2: Union[str, None], alpha3: str, name: str\n)\n```\n\nLanguageInfo is a dataclass that contains the language information.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `alpha2` | `Union[str, None]` | The language code in the [ISO 639-1 alpha-2](https://en.wikipedia.org/wiki/ISO_639-1) format. | *required* |\n| `alpha3` | `str` | The language code in the [ISO 639-3 alpha-3](https://en.wikipedia.org/wiki/ISO_639-3) format. | *required* |\n| `name` | `str` | The language name. | *required* |", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_language_code/index.html#languageinfo-dataclass-indexhtmlpydanticextratypeslanguagecodelanguageinfo-permanent-link", "page": "api/pydantic_extra_types_language_code/index.html", "source_site": "pydantic"}
{"title": "LanguageAlpha2 [Â¶](index.html#pydantic_extra_types.language_code.LanguageAlpha2 \"Permanent link\")", "anchor": "languagealpha2-indexhtmlpydanticextratypeslanguagecodelanguagealpha2-permanent-link", "md_text": "Bases: `str`\n\nLanguageAlpha2 parses languages codes in the [ISO 639-1 alpha-2](https://en.wikipedia.org/wiki/ISO_639-1)\nformat.\n\n```\nfrom pydantic import BaseModel\n\nfrom pydantic_extra_types.language_code import LanguageAlpha2\n\n\nclass Movie(BaseModel):\n    audio_lang: LanguageAlpha2\n    subtitles_lang: LanguageAlpha2\n\n\nmovie = Movie(audio_lang='de', subtitles_lang='fr')\nprint(movie)\n# > audio_lang='de' subtitles_lang='fr'\n```", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_language_code/index.html#languagealpha2-indexhtmlpydanticextratypeslanguagecodelanguagealpha2-permanent-link", "page": "api/pydantic_extra_types_language_code/index.html", "source_site": "pydantic"}
{"title": "alpha3 `property` [Â¶](index.html#pydantic_extra_types.language_code.LanguageAlpha2.alpha3 \"Permanent link\")", "anchor": "alpha3-property-indexhtmlpydanticextratypeslanguagecodelanguagealpha2alpha3-permanent-link", "md_text": "```\nalpha3: str\n```\n\nThe language code in the [ISO 639-3 alpha-3](https://en.wikipedia.org/wiki/ISO_639-3) format.", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_language_code/index.html#alpha3-property-indexhtmlpydanticextratypeslanguagecodelanguagealpha2alpha3-permanent-link", "page": "api/pydantic_extra_types_language_code/index.html", "source_site": "pydantic"}
{"title": "name `property` [Â¶](index.html#pydantic_extra_types.language_code.LanguageAlpha2.name \"Permanent link\")", "anchor": "name-property-indexhtmlpydanticextratypeslanguagecodelanguagealpha2name-permanent-link", "md_text": "```\nname: str\n```\n\nThe language name.", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_language_code/index.html#name-property-indexhtmlpydanticextratypeslanguagecodelanguagealpha2name-permanent-link", "page": "api/pydantic_extra_types_language_code/index.html", "source_site": "pydantic"}
{"title": "LanguageName [Â¶](index.html#pydantic_extra_types.language_code.LanguageName \"Permanent link\")", "anchor": "languagename-indexhtmlpydanticextratypeslanguagecodelanguagename-permanent-link", "md_text": "Bases: `str`\n\nLanguageName parses languages names listed in the [ISO 639-3 standard](https://en.wikipedia.org/wiki/ISO_639-3)\nformat.\n\n```\nfrom pydantic import BaseModel\n\nfrom pydantic_extra_types.language_code import LanguageName\n\n\nclass Movie(BaseModel):\n    audio_lang: LanguageName\n    subtitles_lang: LanguageName\n\n\nmovie = Movie(audio_lang='Dutch', subtitles_lang='Mandarin Chinese')\nprint(movie)\n# > audio_lang='Dutch' subtitles_lang='Mandarin Chinese'\n```", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_language_code/index.html#languagename-indexhtmlpydanticextratypeslanguagecodelanguagename-permanent-link", "page": "api/pydantic_extra_types_language_code/index.html", "source_site": "pydantic"}
{"title": "alpha2 `property` [Â¶](index.html#pydantic_extra_types.language_code.LanguageName.alpha2 \"Permanent link\")", "anchor": "alpha2-property-indexhtmlpydanticextratypeslanguagecodelanguagenamealpha2-permanent-link", "md_text": "```\nalpha2: Union[str, None]\n```\n\nThe language code in the [ISO 639-1 alpha-2](https://en.wikipedia.org/wiki/ISO_639-1) format. Does not exist for all languages.", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_language_code/index.html#alpha2-property-indexhtmlpydanticextratypeslanguagecodelanguagenamealpha2-permanent-link", "page": "api/pydantic_extra_types_language_code/index.html", "source_site": "pydantic"}
{"title": "alpha3 `property` [Â¶](index.html#pydantic_extra_types.language_code.LanguageName.alpha3 \"Permanent link\")", "anchor": "alpha3-property-indexhtmlpydanticextratypeslanguagecodelanguagenamealpha3-permanent-link", "md_text": "```\nalpha3: str\n```\n\nThe language code in the [ISO 639-3 alpha-3](https://en.wikipedia.org/wiki/ISO_639-3) format.", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_language_code/index.html#alpha3-property-indexhtmlpydanticextratypeslanguagecodelanguagenamealpha3-permanent-link", "page": "api/pydantic_extra_types_language_code/index.html", "source_site": "pydantic"}
{"title": "ISO639\\_3 [Â¶](index.html#pydantic_extra_types.language_code.ISO639_3 \"Permanent link\")", "anchor": "iso6393-indexhtmlpydanticextratypeslanguagecodeiso6393-permanent-link", "md_text": "Bases: `str`\n\nISO639\\_3 parses Language in the [ISO 639-3 alpha-3](https://en.wikipedia.org/wiki/ISO_639-3_alpha-3)\nformat.\n\n```\nfrom pydantic import BaseModel\n\nfrom pydantic_extra_types.language_code import ISO639_3\n\n\nclass Language(BaseModel):\n    alpha_3: ISO639_3\n\n\nlang = Language(alpha_3='ssr')\nprint(lang)\n# > alpha_3='ssr'\n```", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_language_code/index.html#iso6393-indexhtmlpydanticextratypeslanguagecodeiso6393-permanent-link", "page": "api/pydantic_extra_types_language_code/index.html", "source_site": "pydantic"}
{"title": "ISO639\\_5 [Â¶](index.html#pydantic_extra_types.language_code.ISO639_5 \"Permanent link\")", "anchor": "iso6395-indexhtmlpydanticextratypeslanguagecodeiso6395-permanent-link", "md_text": "Bases: `str`\n\nISO639\\_5 parses Language in the [ISO 639-5 alpha-3](https://en.wikipedia.org/wiki/ISO_639-5_alpha-3)\nformat.\n\n```\nfrom pydantic import BaseModel\n\nfrom pydantic_extra_types.language_code import ISO639_5\n\n\nclass Language(BaseModel):\n    alpha_3: ISO639_5\n\n\nlang = Language(alpha_3='gem')\nprint(lang)\n# > alpha_3='gem'\n```\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_language_code/index.html#iso6395-indexhtmlpydanticextratypeslanguagecodeiso6395-permanent-link", "page": "api/pydantic_extra_types_language_code/index.html", "source_site": "pydantic"}
{"title": "PaymentCardBrand [Â¶](index.html#pydantic_extra_types.payment.PaymentCardBrand \"Permanent link\")", "anchor": "paymentcardbrand-indexhtmlpydanticextratypespaymentpaymentcardbrand-permanent-link", "md_text": "Bases: `str`, `Enum`\n\nPayment card brands supported by the [`PaymentCardNumber`](index.html#pydantic_extra_types.payment.PaymentCardNumber).", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_payment/index.html#paymentcardbrand-indexhtmlpydanticextratypespaymentpaymentcardbrand-permanent-link", "page": "api/pydantic_extra_types_payment/index.html", "source_site": "pydantic"}
{"title": "PaymentCardNumber [Â¶](index.html#pydantic_extra_types.payment.PaymentCardNumber \"Permanent link\")", "anchor": "paymentcardnumber-indexhtmlpydanticextratypespaymentpaymentcardnumber-permanent-link", "md_text": "```\nPaymentCardNumber(card_number: str)\n```\n\nBases: `str`\n\nA [payment card number](https://en.wikipedia.org/wiki/Payment_card_number).\n\nSource code in `pydantic_extra_types/payment.py`\n\n|  |  |\n| --- | --- |\n| ``` 51 52 53 54 55 56 57 58 ``` | ``` def __init__(self, card_number: str):     self.validate_digits(card_number)      card_number = self.validate_luhn_check_digit(card_number)      self.bin = card_number[:6]     self.last4 = card_number[-4:]     self.brand = self.validate_brand(card_number) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_payment/index.html#paymentcardnumber-indexhtmlpydanticextratypespaymentpaymentcardnumber-permanent-link", "page": "api/pydantic_extra_types_payment/index.html", "source_site": "pydantic"}
{"title": "strip\\_whitespace `class-attribute` [Â¶](index.html#pydantic_extra_types.payment.PaymentCardNumber.strip_whitespace \"Permanent link\")", "anchor": "stripwhitespace-class-attribute-indexhtmlpydanticextratypespaymentpaymentcardnumberstripwhitespace-permanent-link", "md_text": "```\nstrip_whitespace: bool = True\n```\n\nWhether to strip whitespace from the input value.", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_payment/index.html#stripwhitespace-class-attribute-indexhtmlpydanticextratypespaymentpaymentcardnumberstripwhitespace-permanent-link", "page": "api/pydantic_extra_types_payment/index.html", "source_site": "pydantic"}
{"title": "min\\_length `class-attribute` [Â¶](index.html#pydantic_extra_types.payment.PaymentCardNumber.min_length \"Permanent link\")", "anchor": "minlength-class-attribute-indexhtmlpydanticextratypespaymentpaymentcardnumberminlength-permanent-link", "md_text": "```\nmin_length: int = 12\n```\n\nThe minimum length of the card number.", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_payment/index.html#minlength-class-attribute-indexhtmlpydanticextratypespaymentpaymentcardnumberminlength-permanent-link", "page": "api/pydantic_extra_types_payment/index.html", "source_site": "pydantic"}
{"title": "max\\_length `class-attribute` [Â¶](index.html#pydantic_extra_types.payment.PaymentCardNumber.max_length \"Permanent link\")", "anchor": "maxlength-class-attribute-indexhtmlpydanticextratypespaymentpaymentcardnumbermaxlength-permanent-link", "md_text": "```\nmax_length: int = 19\n```\n\nThe maximum length of the card number.", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_payment/index.html#maxlength-class-attribute-indexhtmlpydanticextratypespaymentpaymentcardnumbermaxlength-permanent-link", "page": "api/pydantic_extra_types_payment/index.html", "source_site": "pydantic"}
{"title": "bin `instance-attribute` [Â¶](index.html#pydantic_extra_types.payment.PaymentCardNumber.bin \"Permanent link\")", "anchor": "bin-instance-attribute-indexhtmlpydanticextratypespaymentpaymentcardnumberbin-permanent-link", "md_text": "```\nbin: str = card_number[:6]\n```\n\nThe first 6 digits of the card number.", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_payment/index.html#bin-instance-attribute-indexhtmlpydanticextratypespaymentpaymentcardnumberbin-permanent-link", "page": "api/pydantic_extra_types_payment/index.html", "source_site": "pydantic"}
{"title": "last4 `instance-attribute` [Â¶](index.html#pydantic_extra_types.payment.PaymentCardNumber.last4 \"Permanent link\")", "anchor": "last4-instance-attribute-indexhtmlpydanticextratypespaymentpaymentcardnumberlast4-permanent-link", "md_text": "```\nlast4: str = card_number[-4:]\n```\n\nThe last 4 digits of the card number.", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_payment/index.html#last4-instance-attribute-indexhtmlpydanticextratypespaymentpaymentcardnumberlast4-permanent-link", "page": "api/pydantic_extra_types_payment/index.html", "source_site": "pydantic"}
{"title": "brand `instance-attribute` [Â¶](index.html#pydantic_extra_types.payment.PaymentCardNumber.brand \"Permanent link\")", "anchor": "brand-instance-attribute-indexhtmlpydanticextratypespaymentpaymentcardnumberbrand-permanent-link", "md_text": "```\nbrand: PaymentCardBrand = validate_brand(card_number)\n```\n\nThe brand of the card.", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_payment/index.html#brand-instance-attribute-indexhtmlpydanticextratypespaymentpaymentcardnumberbrand-permanent-link", "page": "api/pydantic_extra_types_payment/index.html", "source_site": "pydantic"}
{"title": "masked `property` [Â¶](index.html#pydantic_extra_types.payment.PaymentCardNumber.masked \"Permanent link\")", "anchor": "masked-property-indexhtmlpydanticextratypespaymentpaymentcardnumbermasked-permanent-link", "md_text": "```\nmasked: str\n```\n\nThe masked card number.", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_payment/index.html#masked-property-indexhtmlpydanticextratypespaymentpaymentcardnumbermasked-permanent-link", "page": "api/pydantic_extra_types_payment/index.html", "source_site": "pydantic"}
{"title": "validate `classmethod` [Â¶](index.html#pydantic_extra_types.payment.PaymentCardNumber.validate \"Permanent link\")", "anchor": "validate-classmethod-indexhtmlpydanticextratypespaymentpaymentcardnumbervalidate-permanent-link", "md_text": "```\nvalidate(\n    __input_value: str, _: ValidationInfo\n) -> PaymentCardNumber\n```\n\nValidate the `PaymentCardNumber` instance.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `__input_value` | `str` | The input value to validate. | *required* |\n| `_` | `ValidationInfo` | The validation info. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `PaymentCardNumber` | The validated `PaymentCardNumber` instance. |\n\nSource code in `pydantic_extra_types/payment.py`\n\n|  |  |\n| --- | --- |\n| ``` 69 70 71 72 73 74 75 76 77 78 79 80 ``` | ``` @classmethod def validate(cls, __input_value: str, _: core_schema.ValidationInfo) -> PaymentCardNumber:     \"\"\"Validate the `PaymentCardNumber` instance.      Args:         __input_value: The input value to validate.         _: The validation info.      Returns:         The validated `PaymentCardNumber` instance.     \"\"\"     return cls(__input_value) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_payment/index.html#validate-classmethod-indexhtmlpydanticextratypespaymentpaymentcardnumbervalidate-permanent-link", "page": "api/pydantic_extra_types_payment/index.html", "source_site": "pydantic"}
{"title": "validate\\_digits `classmethod` [Â¶](index.html#pydantic_extra_types.payment.PaymentCardNumber.validate_digits \"Permanent link\")", "anchor": "validatedigits-classmethod-indexhtmlpydanticextratypespaymentpaymentcardnumbervalidatedigits-permanent-link", "md_text": "```\nvalidate_digits(card_number: str) -> None\n```\n\nValidate that the card number is all digits.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `card_number` | `str` | The card number to validate. | *required* |\n\nRaises:\n\n| Type | Description |\n| --- | --- |\n| `PydanticCustomError` | If the card number is not all digits. |\n\nSource code in `pydantic_extra_types/payment.py`\n\n|  |  |\n| --- | --- |\n| ``` 88 89 90 91 92 93 94 95 96 97 98 99 ``` | ``` @classmethod def validate_digits(cls, card_number: str) -> None:     \"\"\"Validate that the card number is all digits.      Args:         card_number: The card number to validate.      Raises:         PydanticCustomError: If the card number is not all digits.     \"\"\"     if not card_number or not all('0' <= c <= '9' for c in card_number):         raise PydanticCustomError('payment_card_number_digits', 'Card number is not all digits') ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_payment/index.html#validatedigits-classmethod-indexhtmlpydanticextratypespaymentpaymentcardnumbervalidatedigits-permanent-link", "page": "api/pydantic_extra_types_payment/index.html", "source_site": "pydantic"}
{"title": "validate\\_luhn\\_check\\_digit `classmethod` [Â¶](index.html#pydantic_extra_types.payment.PaymentCardNumber.validate_luhn_check_digit \"Permanent link\")", "anchor": "validateluhncheckdigit-classmethod-indexhtmlpydanticextratypespaymentpaymentcardnumbervalidateluhncheckdigit-permanent-link", "md_text": "```\nvalidate_luhn_check_digit(card_number: str) -> str\n```\n\nValidate the payment card number.\nBased on the [Luhn algorithm](https://en.wikipedia.org/wiki/Luhn_algorithm).\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `card_number` | `str` | The card number to validate. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `str` | The validated card number. |\n\nRaises:\n\n| Type | Description |\n| --- | --- |\n| `PydanticCustomError` | If the card number is not valid. |\n\nSource code in `pydantic_extra_types/payment.py`\n\n|  |  |\n| --- | --- |\n| ``` 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 ``` | ``` @classmethod def validate_luhn_check_digit(cls, card_number: str) -> str:     \"\"\"Validate the payment card number.     Based on the [Luhn algorithm](https://en.wikipedia.org/wiki/Luhn_algorithm).      Args:         card_number: The card number to validate.      Returns:         The validated card number.      Raises:         PydanticCustomError: If the card number is not valid.     \"\"\"     sum_ = int(card_number[-1])     length = len(card_number)     parity = length % 2     for i in range(length - 1):         digit = int(card_number[i])         if i % 2 == parity:             digit *= 2         if digit > 9:             digit -= 9         sum_ += digit     valid = sum_ % 10 == 0     if not valid:         raise PydanticCustomError('payment_card_number_luhn', 'Card number is not luhn valid')     return card_number ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_payment/index.html#validateluhncheckdigit-classmethod-indexhtmlpydanticextratypespaymentpaymentcardnumbervalidateluhncheckdigit-permanent-link", "page": "api/pydantic_extra_types_payment/index.html", "source_site": "pydantic"}
{"title": "validate\\_brand `staticmethod` [Â¶](index.html#pydantic_extra_types.payment.PaymentCardNumber.validate_brand \"Permanent link\")", "anchor": "validatebrand-staticmethod-indexhtmlpydanticextratypespaymentpaymentcardnumbervalidatebrand-permanent-link", "md_text": "```\nvalidate_brand(card_number: str) -> PaymentCardBrand\n```\n\nValidate length based on\n[BIN](https://en.wikipedia.org/wiki/Payment_card_number#Issuer_identification_number_(IIN))\nfor major brands.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `card_number` | `str` | The card number to validate. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `PaymentCardBrand` | The validated card brand. |\n\nRaises:\n\n| Type | Description |\n| --- | --- |\n| `PydanticCustomError` | If the card number is not valid. |\n\nSource code in `pydantic_extra_types/payment.py`\n\n|  |  |\n| --- | --- |\n| ``` 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 ``` | ``` @staticmethod def validate_brand(card_number: str) -> PaymentCardBrand:     \"\"\"Validate length based on     [BIN](https://en.wikipedia.org/wiki/Payment_card_number#Issuer_identification_number_(IIN))     for major brands.      Args:         card_number: The card number to validate.      Returns:         The validated card brand.      Raises:         PydanticCustomError: If the card number is not valid.     \"\"\"     brand, required_length = PaymentCardNumber._identify_brand(card_number)      valid = len(card_number) in required_length if brand != PaymentCardBrand.other else True      if not valid:         raise PydanticCustomError(             'payment_card_number_brand',             f'Length for a {brand} card must be {\" or \".join(map(str, required_length))}',             {'brand': brand, 'required_length': required_length},         )      return brand ``` |\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_payment/index.html#validatebrand-staticmethod-indexhtmlpydanticextratypespaymentpaymentcardnumbervalidatebrand-permanent-link", "page": "api/pydantic_extra_types_payment/index.html", "source_site": "pydantic"}
{"title": "BaseSettings [Â¶](index.html#pydantic_settings.BaseSettings \"Permanent link\")", "anchor": "basesettings-indexhtmlpydanticsettingsbasesettings-permanent-link", "md_text": "```\nBaseSettings(\n    __pydantic_self__,\n    _case_sensitive: bool | None = None,\n    _nested_model_default_partial_update: (\n        bool | None\n    ) = None,\n    _env_prefix: str | None = None,\n    _env_file: DotenvType | None = ENV_FILE_SENTINEL,\n    _env_file_encoding: str | None = None,\n    _env_ignore_empty: bool | None = None,\n    _env_nested_delimiter: str | None = None,\n    _env_parse_none_str: str | None = None,\n    _env_parse_enums: bool | None = None,\n    _cli_prog_name: str | None = None,\n    _cli_parse_args: (\n        bool | list[str] | tuple[str, ...] | None\n    ) = None,\n    _cli_settings_source: (\n        CliSettingsSource[Any] | None\n    ) = None,\n    _cli_parse_none_str: str | None = None,\n    _cli_hide_none_type: bool | None = None,\n    _cli_avoid_json: bool | None = None,\n    _cli_enforce_required: bool | None = None,\n    _cli_use_class_docs_for_groups: bool | None = None,\n    _cli_exit_on_error: bool | None = None,\n    _cli_prefix: str | None = None,\n    _cli_flag_prefix_char: str | None = None,\n    _cli_implicit_flags: bool | None = None,\n    _cli_ignore_unknown_args: bool | None = None,\n    _cli_kebab_case: bool | None = None,\n    _secrets_dir: PathType | None = None,\n    **values: Any\n)\n```\n\nBases: `BaseModel`\n\nBase class for settings, allowing values to be overridden by environment variables.\n\nThis is useful in production for secrets you do not wish to save in code, it plays nicely with docker(-compose),\nHeroku and any 12 factor app design.\n\nAll the below attributes can be set via `model_config`.\n\nParameters:", "url": "https://docs.pydantic.dev/latest/api/pydantic_settings/index.html#basesettings-indexhtmlpydanticsettingsbasesettings-permanent-link", "page": "api/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "BaseSettings [Â¶](index.html#pydantic_settings.BaseSettings \"Permanent link\")", "anchor": "basesettings-indexhtmlpydanticsettingsbasesettings-permanent-link", "md_text": "| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `_case_sensitive` | `bool | None` | Whether environment and CLI variable names should be read with case-sensitivity. Defaults to `None`. | `None` |\n| `_nested_model_default_partial_update` | `bool | None` | Whether to allow partial updates on nested model default object fields. Defaults to `False`. | `None` |\n| `_env_prefix` | `str | None` | Prefix for all environment variables. Defaults to `None`. | `None` |\n| `_env_file` | `DotenvType | None` | The env file(s) to load settings values from. Defaults to `Path('')`, which means that the value from `model_config['env_file']` should be used. You can also pass `None` to indicate that environment variables should not be loaded from an env file. | `ENV_FILE_SENTINEL` |\n| `_env_file_encoding` | `str | None` | The env file encoding, e.g. `'latin-1'`. Defaults to `None`. | `None` |\n| `_env_ignore_empty` | `bool | None` | Ignore environment variables where the value is an empty string. Default to `False`. | `None` |\n| `_env_nested_delimiter` | `str | None` | The nested env values delimiter. Defaults to `None`. | `None` |\n| `_env_parse_none_str` | `str | None` | The env string value that should be parsed (e.g. \"null\", \"void\", \"None\", etc.) into `None` type(None). Defaults to `None` type(None), which means no parsing should occur. | `None` |\n| `_env_parse_enums` | `bool | None` | Parse enum field names to values. Defaults to `None.`, which means no parsing should occur. | `None` |\n| `_cli_prog_name` | `str | None` | The CLI program name to display in help text. Defaults to `None` if \\_cli\\_parse\\_args is `None`. Otherwse, defaults to sys.argv[0]. | `None` |\n| `_cli_parse_args` | `bool | list[str] | tuple[str, ...] | None` | The list of CLI arguments to parse. Defaults to None. If set to `True`, defaults to sys.argv[1:]. | `None` |\n| `_cli_settings_source` | `CliSettingsSource[Any] | None` | Override the default CLI settings source with a user defined instance. Defaults to None. | `None` |\n| `_cli_parse_none_str` | `str | None` | The CLI string value that should be parsed (e.g. \"null\", \"void\", \"None\", etc.) into `None` type(None). Defaults to \\_env\\_parse\\_none\\_str value if set. Otherwise, defaults to \"null\" if \\_cli\\_avoid\\_json is `False`, and \"None\" if \\_cli\\_avoid\\_json is `True`. | `None` |\n| `_cli_hide_none_type` | `bool | None` | Hide `None` values in CLI help text. Defaults to `False`. | `None` |\n| `_cli_avoid_json` | `bool | None` | Avoid complex JSON objects in CLI help text. Defaults to `False`. | `None` |\n| `_cli_enforce_required` | `bool | None` | Enforce required fields at the CLI. Defaults to `False`. | `None` |\n| `_cli_use_class_docs_for_groups` | `bool | None` | Use class docstrings in CLI group help text instead of field descriptions. Defaults to `False`. | `None` |\n| `_cli_exit_on_error` | `bool | None` | Determines whether or not the internal parser exits with error info when an error occurs. Defaults to `True`. | `None` |\n| `_cli_prefix` | `str | None` | The root parser command line arguments prefix. Defaults to \"\". | `None` |\n| `_cli_flag_prefix_char` | `str | None` | The flag prefix character to use for CLI optional arguments. Defaults to '-'. | `None` |\n| `_cli_implicit_flags` | `bool | None` | Whether `bool` fields should be implicitly converted into CLI boolean flags. (e.g. --flag, --no-flag). Defaults to `False`. | `None` |\n| `_cli_ignore_unknown_args` | `bool | None` | Whether to ignore unknown CLI args and parse only known ones. Defaults to `False`. | `None` |\n| `_cli_kebab_case` | `bool | None` | CLI args use kebab case. Defaults to `False`. | `None` |\n| `_secrets_dir` | `PathType | None` | The secret files directory or a sequence of directories. Defaults to `None`. | `None` |\n\nSource code in `pydantic_settings/main.py`", "url": "https://docs.pydantic.dev/latest/api/pydantic_settings/index.html#basesettings-indexhtmlpydanticsettingsbasesettings-permanent-link", "page": "api/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "BaseSettings [Â¶](index.html#pydantic_settings.BaseSettings \"Permanent link\")", "anchor": "basesettings-indexhtmlpydanticsettingsbasesettings-permanent-link", "md_text": "|  |  |\n| --- | --- |\n| ``` 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 ``` | ``` def __init__(     __pydantic_self__,     _case_sensitive: bool | None = None,     _nested_model_default_partial_update: bool | None = None,     _env_prefix: str | None = None,     _env_file: DotenvType | None = ENV_FILE_SENTINEL,     _env_file_encoding: str | None = None,     _env_ignore_empty: bool | None = None,     _env_nested_delimiter: str | None = None,     _env_parse_none_str: str | None = None,     _env_parse_enums: bool | None = None,     _cli_prog_name: str | None = None,     _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,     _cli_settings_source: CliSettingsSource[Any] | None = None,     _cli_parse_none_str: str | None = None,     _cli_hide_none_type: bool | None = None,     _cli_avoid_json: bool | None = None,     _cli_enforce_required: bool | None = None,     _cli_use_class_docs_for_groups: bool | None = None,     _cli_exit_on_error: bool | None = None,     _cli_prefix: str | None = None,     _cli_flag_prefix_char: str | None = None,     _cli_implicit_flags: bool | None = None,     _cli_ignore_unknown_args: bool | None = None,     _cli_kebab_case: bool | None = None,     _secrets_dir: PathType | None = None,     **values: Any, ) -> None:     # Uses something other than `self` the first arg to allow \"self\" as a settable attribute     super().__init__(         **__pydantic_self__._settings_build_values(             values,             _case_sensitive=_case_sensitive,             _nested_model_default_partial_update=_nested_model_default_partial_update,             _env_prefix=_env_prefix,             _env_file=_env_file,             _env_file_encoding=_env_file_encoding,             _env_ignore_empty=_env_ignore_empty,             _env_nested_delimiter=_env_nested_delimiter,             _env_parse_none_str=_env_parse_none_str,             _env_parse_enums=_env_parse_enums,             _cli_prog_name=_cli_prog_name,             _cli_parse_args=_cli_parse_args,             _cli_settings_source=_cli_settings_source,             _cli_parse_none_str=_cli_parse_none_str,             _cli_hide_none_type=_cli_hide_none_type,             _cli_avoid_json=_cli_avoid_json,             _cli_enforce_required=_cli_enforce_required,             _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,             _cli_exit_on_error=_cli_exit_on_error,             _cli_prefix=_cli_prefix,             _cli_flag_prefix_char=_cli_flag_prefix_char,             _cli_implicit_flags=_cli_implicit_flags,             _cli_ignore_unknown_args=_cli_ignore_unknown_args,             _cli_kebab_case=_cli_kebab_case,             _secrets_dir=_secrets_dir,         )     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_settings/index.html#basesettings-indexhtmlpydanticsettingsbasesettings-permanent-link", "page": "api/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "settings\\_customise\\_sources `classmethod` [Â¶](index.html#pydantic_settings.BaseSettings.settings_customise_sources \"Permanent link\")", "anchor": "settingscustomisesources-classmethod-indexhtmlpydanticsettingsbasesettingssettingscustomisesources-permanent-link", "md_text": "```\nsettings_customise_sources(\n    settings_cls: type[BaseSettings],\n    init_settings: PydanticBaseSettingsSource,\n    env_settings: PydanticBaseSettingsSource,\n    dotenv_settings: PydanticBaseSettingsSource,\n    file_secret_settings: PydanticBaseSettingsSource,\n) -> tuple[PydanticBaseSettingsSource, ...]\n```\n\nDefine the sources and their order for loading the settings values.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `settings_cls` | `type[BaseSettings]` | The Settings class. | *required* |\n| `init_settings` | `PydanticBaseSettingsSource` | The `InitSettingsSource` instance. | *required* |\n| `env_settings` | `PydanticBaseSettingsSource` | The `EnvSettingsSource` instance. | *required* |\n| `dotenv_settings` | `PydanticBaseSettingsSource` | The `DotEnvSettingsSource` instance. | *required* |\n| `file_secret_settings` | `PydanticBaseSettingsSource` | The `SecretsSettingsSource` instance. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `tuple[PydanticBaseSettingsSource, ...]` | A tuple containing the sources and their order for loading the settings values. |\n\nSource code in `pydantic_settings/main.py`\n\n|  |  |\n| --- | --- |\n| ``` 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 ``` | ``` @classmethod def settings_customise_sources(     cls,     settings_cls: type[BaseSettings],     init_settings: PydanticBaseSettingsSource,     env_settings: PydanticBaseSettingsSource,     dotenv_settings: PydanticBaseSettingsSource,     file_secret_settings: PydanticBaseSettingsSource, ) -> tuple[PydanticBaseSettingsSource, ...]:     \"\"\"     Define the sources and their order for loading the settings values.      Args:         settings_cls: The Settings class.         init_settings: The `InitSettingsSource` instance.         env_settings: The `EnvSettingsSource` instance.         dotenv_settings: The `DotEnvSettingsSource` instance.         file_secret_settings: The `SecretsSettingsSource` instance.      Returns:         A tuple containing the sources and their order for loading the settings values.     \"\"\"     return init_settings, env_settings, dotenv_settings, file_secret_settings ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_settings/index.html#settingscustomisesources-classmethod-indexhtmlpydanticsettingsbasesettingssettingscustomisesources-permanent-link", "page": "api/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "CliApp [Â¶](index.html#pydantic_settings.CliApp \"Permanent link\")", "anchor": "cliapp-indexhtmlpydanticsettingscliapp-permanent-link", "md_text": "A utility class for running Pydantic `BaseSettings`, `BaseModel`, or `pydantic.dataclasses.dataclass` as\nCLI applications.", "url": "https://docs.pydantic.dev/latest/api/pydantic_settings/index.html#cliapp-indexhtmlpydanticsettingscliapp-permanent-link", "page": "api/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "run `staticmethod` [Â¶](index.html#pydantic_settings.CliApp.run \"Permanent link\")", "anchor": "run-staticmethod-indexhtmlpydanticsettingscliapprun-permanent-link", "md_text": "```\nrun(\n    model_cls: type[T],\n    cli_args: (\n        list[str]\n        | Namespace\n        | SimpleNamespace\n        | dict[str, Any]\n        | None\n    ) = None,\n    cli_settings_source: (\n        CliSettingsSource[Any] | None\n    ) = None,\n    cli_exit_on_error: bool | None = None,\n    cli_cmd_method_name: str = \"cli_cmd\",\n    **model_init_data: Any\n) -> T\n```\n\nRuns a Pydantic `BaseSettings`, `BaseModel`, or `pydantic.dataclasses.dataclass` as a CLI application.\nRunning a model as a CLI application requires the `cli_cmd` method to be defined in the model class.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `model_cls` | `type[T]` | The model class to run as a CLI application. | *required* |\n| `cli_args` | `list[str] | Namespace | SimpleNamespace | dict[str, Any] | None` | The list of CLI arguments to parse. If `cli_settings_source` is specified, this may also be a namespace or dictionary of pre-parsed CLI arguments. Defaults to `sys.argv[1:]`. | `None` |\n| `cli_settings_source` | `CliSettingsSource[Any] | None` | Override the default CLI settings source with a user defined instance. Defaults to `None`. | `None` |\n| `cli_exit_on_error` | `bool | None` | Determines whether this function exits on error. If model is subclass of `BaseSettings`, defaults to BaseSettings `cli_exit_on_error` value. Otherwise, defaults to `True`. | `None` |\n| `cli_cmd_method_name` | `str` | The CLI command method name to run. Defaults to \"cli\\_cmd\". | `'cli_cmd'` |\n| `model_init_data` | `Any` | The model init data. | `{}` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `T` | The ran instance of model. |\n\nRaises:\n\n| Type | Description |\n| --- | --- |\n| `SettingsError` | If model\\_cls is not subclass of `BaseModel` or `pydantic.dataclasses.dataclass`. |\n| `SettingsError` | If model\\_cls does not have a `cli_cmd` entrypoint defined. |\n\nSource code in `pydantic_settings/main.py`", "url": "https://docs.pydantic.dev/latest/api/pydantic_settings/index.html#run-staticmethod-indexhtmlpydanticsettingscliapprun-permanent-link", "page": "api/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "run `staticmethod` [Â¶](index.html#pydantic_settings.CliApp.run \"Permanent link\")", "anchor": "run-staticmethod-indexhtmlpydanticsettingscliapprun-permanent-link", "md_text": "|  |  |\n| --- | --- |\n| ``` 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 ``` | ``` @staticmethod def run(     model_cls: type[T],     cli_args: list[str] | Namespace | SimpleNamespace | dict[str, Any] | None = None,     cli_settings_source: CliSettingsSource[Any] | None = None,     cli_exit_on_error: bool | None = None,     cli_cmd_method_name: str = 'cli_cmd',     **model_init_data: Any, ) -> T:     \"\"\"     Runs a Pydantic `BaseSettings`, `BaseModel`, or `pydantic.dataclasses.dataclass` as a CLI application.     Running a model as a CLI application requires the `cli_cmd` method to be defined in the model class.      Args:         model_cls: The model class to run as a CLI application.         cli_args: The list of CLI arguments to parse. If `cli_settings_source` is specified, this may             also be a namespace or dictionary of pre-parsed CLI arguments. Defaults to `sys.argv[1:]`.         cli_settings_source: Override the default CLI settings source with a user defined instance.             Defaults to `None`.         cli_exit_on_error: Determines whether this function exits on error. If model is subclass of             `BaseSettings`, defaults to BaseSettings `cli_exit_on_error` value. Otherwise, defaults to             `True`.         cli_cmd_method_name: The CLI command method name to run. Defaults to \"cli_cmd\".         model_init_data: The model init data.      Returns:         The ran instance of model.      Raises:         SettingsError: If model_cls is not subclass of `BaseModel` or `pydantic.dataclasses.dataclass`.         SettingsError: If model_cls does not have a `cli_cmd` entrypoint defined.     \"\"\"      if not (is_pydantic_dataclass(model_cls) or is_model_class(model_cls)):         raise SettingsError(             f'Error: {model_cls.__name__} is not subclass of BaseModel or pydantic.dataclasses.dataclass'         )      cli_settings = None     cli_parse_args = True if cli_args is None else cli_args     if cli_settings_source is not None:         if isinstance(cli_parse_args, (Namespace, SimpleNamespace, dict)):             cli_settings = cli_settings_source(parsed_args=cli_parse_args)         else:             cli_settings = cli_settings_source(args=cli_parse_args)     elif isinstance(cli_parse_args, (Namespace, SimpleNamespace, dict)):         raise SettingsError('Error: `cli_args` must be list[str] or None when `cli_settings_source` is not used')      model_init_data['_cli_parse_args'] = cli_parse_args     model_init_data['_cli_exit_on_error'] = cli_exit_on_error     model_init_data['_cli_settings_source'] = cli_settings     if not issubclass(model_cls, BaseSettings):          class CliAppBaseSettings(BaseSettings, model_cls):  # type: ignore             model_config = SettingsConfigDict(                 nested_model_default_partial_update=True,                 case_sensitive=True,                 cli_hide_none_type=True,                 cli_avoid_json=True,                 cli_enforce_required=True,                 cli_implicit_flags=True,                 cli_kebab_case=True,             )          model = CliAppBaseSettings(**model_init_data)         model_init_data = {}         for field_name, field_info in model.model_fields.items():             model_init_data[_field_name_for_signature(field_name, field_info)] = getattr(model, field_name)      return CliApp._run_cli_cmd(model_cls(**model_init_data), cli_cmd_method_name, is_required=False) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_settings/index.html#run-staticmethod-indexhtmlpydanticsettingscliapprun-permanent-link", "page": "api/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "run\\_subcommand `staticmethod` [Â¶](index.html#pydantic_settings.CliApp.run_subcommand \"Permanent link\")", "anchor": "runsubcommand-staticmethod-indexhtmlpydanticsettingscliapprunsubcommand-permanent-link", "md_text": "```\nrun_subcommand(\n    model: PydanticModel,\n    cli_exit_on_error: bool | None = None,\n    cli_cmd_method_name: str = \"cli_cmd\",\n) -> PydanticModel\n```\n\nRuns the model subcommand. Running a model subcommand requires the `cli_cmd` method to be defined in\nthe nested model subcommand class.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `model` | `PydanticModel` | The model to run the subcommand from. | *required* |\n| `cli_exit_on_error` | `bool | None` | Determines whether this function exits with error if no subcommand is found. Defaults to model\\_config `cli_exit_on_error` value if set. Otherwise, defaults to `True`. | `None` |\n| `cli_cmd_method_name` | `str` | The CLI command method name to run. Defaults to \"cli\\_cmd\". | `'cli_cmd'` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `PydanticModel` | The ran subcommand model. |\n\nRaises:\n\n| Type | Description |\n| --- | --- |\n| `SystemExit` | When no subcommand is found and cli\\_exit\\_on\\_error=`True` (the default). |\n| `SettingsError` | When no subcommand is found and cli\\_exit\\_on\\_error=`False`. |\n\nSource code in `pydantic_settings/main.py`\n\n|  |  |\n| --- | --- |\n| ``` 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 ``` | ``` @staticmethod def run_subcommand(     model: PydanticModel, cli_exit_on_error: bool | None = None, cli_cmd_method_name: str = 'cli_cmd' ) -> PydanticModel:     \"\"\"     Runs the model subcommand. Running a model subcommand requires the `cli_cmd` method to be defined in     the nested model subcommand class.      Args:         model: The model to run the subcommand from.         cli_exit_on_error: Determines whether this function exits with error if no subcommand is found.             Defaults to model_config `cli_exit_on_error` value if set. Otherwise, defaults to `True`.         cli_cmd_method_name: The CLI command method name to run. Defaults to \"cli_cmd\".      Returns:         The ran subcommand model.      Raises:         SystemExit: When no subcommand is found and cli_exit_on_error=`True` (the default).         SettingsError: When no subcommand is found and cli_exit_on_error=`False`.     \"\"\"      subcommand = get_subcommand(model, is_required=True, cli_exit_on_error=cli_exit_on_error)     return CliApp._run_cli_cmd(subcommand, cli_cmd_method_name, is_required=True) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_settings/index.html#runsubcommand-staticmethod-indexhtmlpydanticsettingscliapprunsubcommand-permanent-link", "page": "api/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "SettingsConfigDict [Â¶](index.html#pydantic_settings.SettingsConfigDict \"Permanent link\")", "anchor": "settingsconfigdict-indexhtmlpydanticsettingssettingsconfigdict-permanent-link", "md_text": "Bases: `ConfigDict`", "url": "https://docs.pydantic.dev/latest/api/pydantic_settings/index.html#settingsconfigdict-indexhtmlpydanticsettingssettingsconfigdict-permanent-link", "page": "api/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "pyproject\\_toml\\_depth `instance-attribute` [Â¶](index.html#pydantic_settings.SettingsConfigDict.pyproject_toml_depth \"Permanent link\")", "anchor": "pyprojecttomldepth-instance-attribute-indexhtmlpydanticsettingssettingsconfigdictpyprojecttomldepth-permanent-link", "md_text": "```\npyproject_toml_depth: int\n```\n\nNumber of levels **up** from the current working directory to attempt to find a pyproject.toml\nfile.\n\nThis is only used when a pyproject.toml file is not found in the current working directory.", "url": "https://docs.pydantic.dev/latest/api/pydantic_settings/index.html#pyprojecttomldepth-instance-attribute-indexhtmlpydanticsettingssettingsconfigdictpyprojecttomldepth-permanent-link", "page": "api/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "pyproject\\_toml\\_table\\_header `instance-attribute` [Â¶](index.html#pydantic_settings.SettingsConfigDict.pyproject_toml_table_header \"Permanent link\")", "anchor": "pyprojecttomltableheader-instance-attribute-indexhtmlpydanticsettingssettingsconfigdictpyprojecttomltableheader-permanent-link", "md_text": "```\npyproject_toml_table_header: tuple[str, ...]\n```\n\nHeader of the TOML table within a pyproject.toml file to use when filling variables.\nThis is supplied as a `tuple[str, ...]` instead of a `str` to accommodate for headers\ncontaining a `.`.\n\nFor example, `toml_table_header = (\"tool\", \"my.tool\", \"foo\")` can be used to fill variable\nvalues from a table with header `[tool.\"my.tool\".foo]`.\n\nTo use the root table, exclude this config setting or provide an empty tuple.", "url": "https://docs.pydantic.dev/latest/api/pydantic_settings/index.html#pyprojecttomltableheader-instance-attribute-indexhtmlpydanticsettingssettingsconfigdictpyprojecttomltableheader-permanent-link", "page": "api/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "CliSettingsSource [Â¶](index.html#pydantic_settings.CliSettingsSource \"Permanent link\")", "anchor": "clisettingssource-indexhtmlpydanticsettingsclisettingssource-permanent-link", "md_text": "```\nCliSettingsSource(\n    settings_cls: type[BaseSettings],\n    cli_prog_name: str | None = None,\n    cli_parse_args: (\n        bool | list[str] | tuple[str, ...] | None\n    ) = None,\n    cli_parse_none_str: str | None = None,\n    cli_hide_none_type: bool | None = None,\n    cli_avoid_json: bool | None = None,\n    cli_enforce_required: bool | None = None,\n    cli_use_class_docs_for_groups: bool | None = None,\n    cli_exit_on_error: bool | None = None,\n    cli_prefix: str | None = None,\n    cli_flag_prefix_char: str | None = None,\n    cli_implicit_flags: bool | None = None,\n    cli_ignore_unknown_args: bool | None = None,\n    cli_kebab_case: bool | None = None,\n    case_sensitive: bool | None = True,\n    root_parser: Any = None,\n    parse_args_method: Callable[..., Any] | None = None,\n    add_argument_method: (\n        Callable[..., Any] | None\n    ) = add_argument,\n    add_argument_group_method: (\n        Callable[..., Any] | None\n    ) = add_argument_group,\n    add_parser_method: (\n        Callable[..., Any] | None\n    ) = add_parser,\n    add_subparsers_method: (\n        Callable[..., Any] | None\n    ) = add_subparsers,\n    formatter_class: Any = RawDescriptionHelpFormatter,\n)\n```\n\nBases: `EnvSettingsSource`, `Generic[T]`\n\nSource class for loading settings values from CLI.\n\nNote\n\nA `CliSettingsSource` connects with a `root_parser` object by using the parser methods to add\n`settings_cls` fields as command line arguments. The `CliSettingsSource` internal parser representation\nis based upon the `argparse` parsing library, and therefore, requires the parser methods to support\nthe same attributes as their `argparse` library counterparts.\n\nParameters:", "url": "https://docs.pydantic.dev/latest/api/pydantic_settings/index.html#clisettingssource-indexhtmlpydanticsettingsclisettingssource-permanent-link", "page": "api/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "CliSettingsSource [Â¶](index.html#pydantic_settings.CliSettingsSource \"Permanent link\")", "anchor": "clisettingssource-indexhtmlpydanticsettingsclisettingssource-permanent-link", "md_text": "| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `cli_prog_name` | `str | None` | The CLI program name to display in help text. Defaults to `None` if cli\\_parse\\_args is `None`. Otherwse, defaults to sys.argv[0]. | `None` |\n| `cli_parse_args` | `bool | list[str] | tuple[str, ...] | None` | The list of CLI arguments to parse. Defaults to None. If set to `True`, defaults to sys.argv[1:]. | `None` |\n| `cli_parse_none_str` | `str | None` | The CLI string value that should be parsed (e.g. \"null\", \"void\", \"None\", etc.) into `None` type(None). Defaults to \"null\" if cli\\_avoid\\_json is `False`, and \"None\" if cli\\_avoid\\_json is `True`. | `None` |\n| `cli_hide_none_type` | `bool | None` | Hide `None` values in CLI help text. Defaults to `False`. | `None` |\n| `cli_avoid_json` | `bool | None` | Avoid complex JSON objects in CLI help text. Defaults to `False`. | `None` |\n| `cli_enforce_required` | `bool | None` | Enforce required fields at the CLI. Defaults to `False`. | `None` |\n| `cli_use_class_docs_for_groups` | `bool | None` | Use class docstrings in CLI group help text instead of field descriptions. Defaults to `False`. | `None` |\n| `cli_exit_on_error` | `bool | None` | Determines whether or not the internal parser exits with error info when an error occurs. Defaults to `True`. | `None` |\n| `cli_prefix` | `str | None` | Prefix for command line arguments added under the root parser. Defaults to \"\". | `None` |\n| `cli_flag_prefix_char` | `str | None` | The flag prefix character to use for CLI optional arguments. Defaults to '-'. | `None` |\n| `cli_implicit_flags` | `bool | None` | Whether `bool` fields should be implicitly converted into CLI boolean flags. (e.g. --flag, --no-flag). Defaults to `False`. | `None` |\n| `cli_ignore_unknown_args` | `bool | None` | Whether to ignore unknown CLI args and parse only known ones. Defaults to `False`. | `None` |\n| `cli_kebab_case` | `bool | None` | CLI args use kebab case. Defaults to `False`. | `None` |\n| `case_sensitive` | `bool | None` | Whether CLI \"--arg\" names should be read with case-sensitivity. Defaults to `True`. Note: Case-insensitive matching is only supported on the internal root parser and does not apply to CLI subcommands. | `True` |\n| `root_parser` | `Any` | The root parser object. | `None` |\n| `parse_args_method` | `Callable[..., Any] | None` | The root parser parse args method. Defaults to `argparse.ArgumentParser.parse_args`. | `None` |\n| `add_argument_method` | `Callable[..., Any] | None` | The root parser add argument method. Defaults to `argparse.ArgumentParser.add_argument`. | `add_argument` |\n| `add_argument_group_method` | `Callable[..., Any] | None` | The root parser add argument group method. Defaults to `argparse.ArgumentParser.add_argument_group`. | `add_argument_group` |\n| `add_parser_method` | `Callable[..., Any] | None` | The root parser add new parser (sub-command) method. Defaults to `argparse._SubParsersAction.add_parser`. | `add_parser` |\n| `add_subparsers_method` | `Callable[..., Any] | None` | The root parser add subparsers (sub-commands) method. Defaults to `argparse.ArgumentParser.add_subparsers`. | `add_subparsers` |\n| `formatter_class` | `Any` | A class for customizing the root parser help text. Defaults to `argparse.RawDescriptionHelpFormatter`. | `RawDescriptionHelpFormatter` |\n\nSource code in `pydantic_settings/sources.py`", "url": "https://docs.pydantic.dev/latest/api/pydantic_settings/index.html#clisettingssource-indexhtmlpydanticsettingsclisettingssource-permanent-link", "page": "api/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "CliSettingsSource [Â¶](index.html#pydantic_settings.CliSettingsSource \"Permanent link\")", "anchor": "clisettingssource-indexhtmlpydanticsettingsclisettingssource-permanent-link", "md_text": "|  |  |\n| --- | --- |\n| ``` 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 ``` | ``` def __init__(     self,     settings_cls: type[BaseSettings],     cli_prog_name: str | None = None,     cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,     cli_parse_none_str: str | None = None,     cli_hide_none_type: bool | None = None,     cli_avoid_json: bool | None = None,     cli_enforce_required: bool | None = None,     cli_use_class_docs_for_groups: bool | None = None,     cli_exit_on_error: bool | None = None,     cli_prefix: str | None = None,     cli_flag_prefix_char: str | None = None,     cli_implicit_flags: bool | None = None,     cli_ignore_unknown_args: bool | None = None,     cli_kebab_case: bool | None = None,     case_sensitive: bool | None = True,     root_parser: Any = None,     parse_args_method: Callable[..., Any] | None = None,     add_argument_method: Callable[..., Any] | None = ArgumentParser.add_argument,     add_argument_group_method: Callable[..., Any] | None = ArgumentParser.add_argument_group,     add_parser_method: Callable[..., Any] | None = _SubParsersAction.add_parser,     add_subparsers_method: Callable[..., Any] | None = ArgumentParser.add_subparsers,     formatter_class: Any = RawDescriptionHelpFormatter, ) -> None:     self.cli_prog_name = (         cli_prog_name if cli_prog_name is not None else settings_cls.model_config.get('cli_prog_name', sys.argv[0])     )     self.cli_hide_none_type = (         cli_hide_none_type         if cli_hide_none_type is not None         else settings_cls.model_config.get('cli_hide_none_type', False)     )     self.cli_avoid_json = (         cli_avoid_json if cli_avoid_json is not None else settings_cls.model_config.get('cli_avoid_json', False)     )     if not cli_parse_none_str:         cli_parse_none_str = 'None' if self.cli_avoid_json is True else 'null'     self.cli_parse_none_str = cli_parse_none_str     self.cli_enforce_required = (         cli_enforce_required         if cli_enforce_required is not None         else settings_cls.model_config.get('cli_enforce_required', False)     )     self.cli_use_class_docs_for_groups = (         cli_use_class_docs_for_groups         if cli_use_class_docs_for_groups is not None         else settings_cls.model_config.get('cli_use_class_docs_for_groups', False)     )     self.cli_exit_on_error = (         cli_exit_on_error         if cli_exit_on_error is not None         else settings_cls.model_config.get('cli_exit_on_error', True)     )     self.cli_prefix = cli_prefix if cli_prefix is not None else settings_cls.model_config.get('cli_prefix', '')     self.cli_flag_prefix_char = (         cli_flag_prefix_char         if cli_flag_prefix_char is not None         else settings_cls.model_config.get('cli_flag_prefix_char', '-')     )     self._cli_flag_prefix = self.cli_flag_prefix_char * 2     if self.cli_prefix:         if cli_prefix.startswith('.') or cli_prefix.endswith('.') or not cli_prefix.replace('.', '').isidentifier():  # type: ignore             raise SettingsError(f'CLI settings source prefix is invalid: {cli_prefix}')         self.cli_prefix += '.'     self.cli_implicit_flags = (         cli_implicit_flags         if cli_implicit_flags is not None         else settings_cls.model_config.get('cli_implicit_flags', False)     )     self.cli_ignore_unknown_args = (         cli_ignore_unknown_args         if cli_ignore_unknown_args is not None         else settings_cls.model_config.get('cli_ignore_unknown_args', False)     )     self.cli_kebab_case = (         cli_kebab_case if cli_kebab_case is not None else settings_cls.model_config.get('cli_kebab_case', False)     )      case_sensitive = case_sensitive if case_sensitive is not None else True     if not case_sensitive and root_parser is not None:         raise SettingsError('Case-insensitive matching is only supported on the internal root parser')      super().__init__(         settings_cls,         env_nested_delimiter='.',         env_parse_none_str=self.cli_parse_none_str,         env_parse_enums=True,         env_prefix=self.cli_prefix,         case_sensitive=case_sensitive,     )      root_parser = (         _CliInternalArgParser(             cli_exit_on_error=self.cli_exit_on_error,             prog=self.cli_prog_name,             description=None if settings_cls.__doc__ is None else dedent(settings_cls.__doc__),             formatter_class=formatter_class,             prefix_chars=self.cli_flag_prefix_char,             allow_abbrev=False,         )         if root_parser is None         else root_parser     )     self._connect_root_parser(         root_parser=root_parser,         parse_args_method=parse_args_method,         add_argument_method=add_argument_method,         add_argument_group_method=add_argument_group_method,         add_parser_method=add_parser_method,         add_subparsers_method=add_subparsers_method,         formatter_class=formatter_class,     )      if cli_parse_args not in (None, False):         if cli_parse_args is True:             cli_parse_args = sys.argv[1:]         elif not isinstance(cli_parse_args, (list, tuple)):             raise SettingsError(                 f'cli_parse_args must be List[str] or Tuple[str, ...], recieved {type(cli_parse_args)}'             )         self._load_env_vars(parsed_args=self._parse_args(self.root_parser, cli_parse_args)) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_settings/index.html#clisettingssource-indexhtmlpydanticsettingsclisettingssource-permanent-link", "page": "api/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "root\\_parser `property` [Â¶](index.html#pydantic_settings.CliSettingsSource.root_parser \"Permanent link\")", "anchor": "rootparser-property-indexhtmlpydanticsettingsclisettingssourcerootparser-permanent-link", "md_text": "```\nroot_parser: T\n```\n\nThe connected root parser instance.", "url": "https://docs.pydantic.dev/latest/api/pydantic_settings/index.html#rootparser-property-indexhtmlpydanticsettingsclisettingssourcerootparser-permanent-link", "page": "api/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "DotEnvSettingsSource [Â¶](index.html#pydantic_settings.DotEnvSettingsSource \"Permanent link\")", "anchor": "dotenvsettingssource-indexhtmlpydanticsettingsdotenvsettingssource-permanent-link", "md_text": "```\nDotEnvSettingsSource(\n    settings_cls: type[BaseSettings],\n    env_file: DotenvType | None = ENV_FILE_SENTINEL,\n    env_file_encoding: str | None = None,\n    case_sensitive: bool | None = None,\n    env_prefix: str | None = None,\n    env_nested_delimiter: str | None = None,\n    env_ignore_empty: bool | None = None,\n    env_parse_none_str: str | None = None,\n    env_parse_enums: bool | None = None,\n)\n```\n\nBases: `EnvSettingsSource`\n\nSource class for loading settings values from env files.\n\nSource code in `pydantic_settings/sources.py`\n\n|  |  |\n| --- | --- |\n| ``` 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 ``` | ``` def __init__(     self,     settings_cls: type[BaseSettings],     env_file: DotenvType | None = ENV_FILE_SENTINEL,     env_file_encoding: str | None = None,     case_sensitive: bool | None = None,     env_prefix: str | None = None,     env_nested_delimiter: str | None = None,     env_ignore_empty: bool | None = None,     env_parse_none_str: str | None = None,     env_parse_enums: bool | None = None, ) -> None:     self.env_file = env_file if env_file != ENV_FILE_SENTINEL else settings_cls.model_config.get('env_file')     self.env_file_encoding = (         env_file_encoding if env_file_encoding is not None else settings_cls.model_config.get('env_file_encoding')     )     super().__init__(         settings_cls,         case_sensitive,         env_prefix,         env_nested_delimiter,         env_ignore_empty,         env_parse_none_str,         env_parse_enums,     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_settings/index.html#dotenvsettingssource-indexhtmlpydanticsettingsdotenvsettingssource-permanent-link", "page": "api/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "EnvSettingsSource [Â¶](index.html#pydantic_settings.EnvSettingsSource \"Permanent link\")", "anchor": "envsettingssource-indexhtmlpydanticsettingsenvsettingssource-permanent-link", "md_text": "```\nEnvSettingsSource(\n    settings_cls: type[BaseSettings],\n    case_sensitive: bool | None = None,\n    env_prefix: str | None = None,\n    env_nested_delimiter: str | None = None,\n    env_ignore_empty: bool | None = None,\n    env_parse_none_str: str | None = None,\n    env_parse_enums: bool | None = None,\n)\n```\n\nBases: `PydanticBaseEnvSettingsSource`\n\nSource class for loading settings values from environment variables.\n\nSource code in `pydantic_settings/sources.py`\n\n|  |  |\n| --- | --- |\n| ``` 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 ``` | ``` def __init__(     self,     settings_cls: type[BaseSettings],     case_sensitive: bool | None = None,     env_prefix: str | None = None,     env_nested_delimiter: str | None = None,     env_ignore_empty: bool | None = None,     env_parse_none_str: str | None = None,     env_parse_enums: bool | None = None, ) -> None:     super().__init__(         settings_cls, case_sensitive, env_prefix, env_ignore_empty, env_parse_none_str, env_parse_enums     )     self.env_nested_delimiter = (         env_nested_delimiter if env_nested_delimiter is not None else self.config.get('env_nested_delimiter')     )     self.env_prefix_len = len(self.env_prefix)      self.env_vars = self._load_env_vars() ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_settings/index.html#envsettingssource-indexhtmlpydanticsettingsenvsettingssource-permanent-link", "page": "api/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "get\\_field\\_value [Â¶](index.html#pydantic_settings.EnvSettingsSource.get_field_value \"Permanent link\")", "anchor": "getfieldvalue-indexhtmlpydanticsettingsenvsettingssourcegetfieldvalue-permanent-link", "md_text": "```\nget_field_value(\n    field: FieldInfo, field_name: str\n) -> tuple[Any, str, bool]\n```\n\nGets the value for field from environment variables and a flag to determine whether value is complex.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `field` | `FieldInfo` | The field. | *required* |\n| `field_name` | `str` | The field name. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `tuple[Any, str, bool]` | A tuple that contains the value (`None` if not found), key, and a flag to determine whether value is complex. |\n\nSource code in `pydantic_settings/sources.py`\n\n|  |  |\n| --- | --- |\n| ``` 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 ``` | ``` def get_field_value(self, field: FieldInfo, field_name: str) -> tuple[Any, str, bool]:     \"\"\"     Gets the value for field from environment variables and a flag to determine whether value is complex.      Args:         field: The field.         field_name: The field name.      Returns:         A tuple that contains the value (`None` if not found), key, and             a flag to determine whether value is complex.     \"\"\"      env_val: str | None = None     for field_key, env_name, value_is_complex in self._extract_field_info(field, field_name):         env_val = self.env_vars.get(env_name)         if env_val is not None:             break      return env_val, field_key, value_is_complex ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_settings/index.html#getfieldvalue-indexhtmlpydanticsettingsenvsettingssourcegetfieldvalue-permanent-link", "page": "api/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "prepare\\_field\\_value [Â¶](index.html#pydantic_settings.EnvSettingsSource.prepare_field_value \"Permanent link\")", "anchor": "preparefieldvalue-indexhtmlpydanticsettingsenvsettingssourcepreparefieldvalue-permanent-link", "md_text": "```\nprepare_field_value(\n    field_name: str,\n    field: FieldInfo,\n    value: Any,\n    value_is_complex: bool,\n) -> Any\n```\n\nPrepare value for the field.\n\n* Extract value for nested field.\n* Deserialize value to python object for complex field.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `field` | `FieldInfo` | The field. | *required* |\n| `field_name` | `str` | The field name. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `Any` | A tuple contains prepared value for the field. |\n\nRaises:\n\n| Type | Description |\n| --- | --- |\n| `ValuesError` | When There is an error in deserializing value for complex field. |\n\nSource code in `pydantic_settings/sources.py`\n\n|  |  |\n| --- | --- |\n| ``` 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 ``` | ``` def prepare_field_value(self, field_name: str, field: FieldInfo, value: Any, value_is_complex: bool) -> Any:     \"\"\"     Prepare value for the field.      * Extract value for nested field.     * Deserialize value to python object for complex field.      Args:         field: The field.         field_name: The field name.      Returns:         A tuple contains prepared value for the field.      Raises:         ValuesError: When There is an error in deserializing value for complex field.     \"\"\"     is_complex, allow_parse_failure = self._field_is_complex(field)     if self.env_parse_enums:         enum_val = _annotation_enum_name_to_val(field.annotation, value)         value = value if enum_val is None else enum_val      if is_complex or value_is_complex:         if isinstance(value, EnvNoneType):             return value         elif value is None:             # field is complex but no value found so far, try explode_env_vars             env_val_built = self.explode_env_vars(field_name, field, self.env_vars)             if env_val_built:                 return env_val_built         else:             # field is complex and there's a value, decode that as JSON, then add explode_env_vars             try:                 value = self.decode_complex_value(field_name, field, value)             except ValueError as e:                 if not allow_parse_failure:                     raise e              if isinstance(value, dict):                 return deep_update(value, self.explode_env_vars(field_name, field, self.env_vars))             else:                 return value     elif value is not None:         # simplest case, field is not complex, we only need to add the value if it was found         return value ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_settings/index.html#preparefieldvalue-indexhtmlpydanticsettingsenvsettingssourcepreparefieldvalue-permanent-link", "page": "api/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "next\\_field [Â¶](index.html#pydantic_settings.EnvSettingsSource.next_field \"Permanent link\")", "anchor": "nextfield-indexhtmlpydanticsettingsenvsettingssourcenextfield-permanent-link", "md_text": "```\nnext_field(\n    field: FieldInfo | Any | None,\n    key: str,\n    case_sensitive: bool | None = None,\n) -> FieldInfo | None\n```\n\nFind the field in a sub model by key(env name)\n\nBy having the following models:\n\npy\nclass SubSubModel(BaseSettings):\n    dvals: Dict\n\nclass SubModel(BaseSettings):\n    vals: list[str]\n    sub_sub_model: SubSubModel\n\nclass Cfg(BaseSettings):\n    sub_model: SubModel\n\n\nThen\n\nnext\\_field(sub\\_model, 'vals') Returns the `vals` field of `SubModel` class\nnext\\_field(sub\\_model, 'sub\\_sub\\_model') Returns `sub_sub_model` field of `SubModel` class\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `field` | `FieldInfo | Any | None` | The field. | *required* |\n| `key` | `str` | The key (env name). | *required* |\n| `case_sensitive` | `bool | None` | Whether to search for key case sensitively. | `None` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `FieldInfo | None` | Field if it finds the next field otherwise `None`. |\n\nSource code in `pydantic_settings/sources.py`\n\n|  |  |\n| --- | --- |\n| ``` 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 ``` | ``` def next_field(     self, field: FieldInfo | Any | None, key: str, case_sensitive: bool | None = None ) -> FieldInfo | None:     \"\"\"     Find the field in a sub model by key(env name)      By having the following models:          ```py         class SubSubModel(BaseSettings):             dvals: Dict          class SubModel(BaseSettings):             vals: list[str]             sub_sub_model: SubSubModel          class Cfg(BaseSettings):             sub_model: SubModel         ```      Then:         next_field(sub_model, 'vals') Returns the `vals` field of `SubModel` class         next_field(sub_model, 'sub_sub_model') Returns `sub_sub_model` field of `SubModel` class      Args:         field: The field.         key: The key (env name).         case_sensitive: Whether to search for key case sensitively.      Returns:         Field if it finds the next field otherwise `None`.     \"\"\"     if not field:         return None      annotation = field.annotation if isinstance(field, FieldInfo) else field     if origin_is_union(get_origin(annotation)) or isinstance(annotation, WithArgsTypes):         for type_ in get_args(annotation):             type_has_key = self.next_field(type_, key, case_sensitive)             if type_has_key:                 return type_has_key     elif is_model_class(annotation) or is_pydantic_dataclass(annotation):         fields = _get_model_fields(annotation)         # `case_sensitive is None` is here to be compatible with the old behavior.         # Has to be removed in V3.         for field_name, f in fields.items():             for _, env_name, _ in self._extract_field_info(f, field_name):                 if case_sensitive is None or case_sensitive:                     if field_name == key or env_name == key:                         return f                 elif field_name.lower() == key.lower() or env_name.lower() == key.lower():                     return f     return None ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_settings/index.html#nextfield-indexhtmlpydanticsettingsenvsettingssourcenextfield-permanent-link", "page": "api/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "explode\\_env\\_vars [Â¶](index.html#pydantic_settings.EnvSettingsSource.explode_env_vars \"Permanent link\")", "anchor": "explodeenvvars-indexhtmlpydanticsettingsenvsettingssourceexplodeenvvars-permanent-link", "md_text": "```\nexplode_env_vars(\n    field_name: str,\n    field: FieldInfo,\n    env_vars: Mapping[str, str | None],\n) -> dict[str, Any]\n```\n\nProcess env\\_vars and extract the values of keys containing env\\_nested\\_delimiter into nested dictionaries.\n\nThis is applied to a single field, hence filtering by env\\_var prefix.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `field_name` | `str` | The field name. | *required* |\n| `field` | `FieldInfo` | The field. | *required* |\n| `env_vars` | `Mapping[str, str | None]` | Environment variables. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `dict[str, Any]` | A dictionary contains extracted values from nested env values. |\n\nSource code in `pydantic_settings/sources.py`\n\n|  |  |\n| --- | --- |\n| ``` 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 ``` | ``` def explode_env_vars(self, field_name: str, field: FieldInfo, env_vars: Mapping[str, str | None]) -> dict[str, Any]:     \"\"\"     Process env_vars and extract the values of keys containing env_nested_delimiter into nested dictionaries.      This is applied to a single field, hence filtering by env_var prefix.      Args:         field_name: The field name.         field: The field.         env_vars: Environment variables.      Returns:         A dictionary contains extracted values from nested env values.     \"\"\"     is_dict = lenient_issubclass(get_origin(field.annotation), dict)      prefixes = [         f'{env_name}{self.env_nested_delimiter}' for _, env_name, _ in self._extract_field_info(field, field_name)     ]     result: dict[str, Any] = {}     for env_name, env_val in env_vars.items():         if not any(env_name.startswith(prefix) for prefix in prefixes):             continue         # we remove the prefix before splitting in case the prefix has characters in common with the delimiter         env_name_without_prefix = env_name[self.env_prefix_len :]         _, *keys, last_key = env_name_without_prefix.split(self.env_nested_delimiter)         env_var = result         target_field: FieldInfo | None = field         for key in keys:             target_field = self.next_field(target_field, key, self.case_sensitive)             if isinstance(env_var, dict):                 env_var = env_var.setdefault(key, {})          # get proper field with last_key         target_field = self.next_field(target_field, last_key, self.case_sensitive)          # check if env_val maps to a complex field and if so, parse the env_val         if (target_field or is_dict) and env_val:             if target_field:                 is_complex, allow_json_failure = self._field_is_complex(target_field)             else:                 # nested field type is dict                 is_complex, allow_json_failure = True, True             if is_complex:                 try:                     env_val = self.decode_complex_value(last_key, target_field, env_val)  # type: ignore                 except ValueError as e:                     if not allow_json_failure:                         raise e         if isinstance(env_var, dict):             if last_key not in env_var or not isinstance(env_val, EnvNoneType) or env_var[last_key] == {}:                 env_var[last_key] = env_val      return result ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_settings/index.html#explodeenvvars-indexhtmlpydanticsettingsenvsettingssourceexplodeenvvars-permanent-link", "page": "api/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "ForceDecode [Â¶](index.html#pydantic_settings.ForceDecode \"Permanent link\")", "anchor": "forcedecode-indexhtmlpydanticsettingsforcedecode-permanent-link", "md_text": "Annotation to force decoding of a field value.", "url": "https://docs.pydantic.dev/latest/api/pydantic_settings/index.html#forcedecode-indexhtmlpydanticsettingsforcedecode-permanent-link", "page": "api/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "InitSettingsSource [Â¶](index.html#pydantic_settings.InitSettingsSource \"Permanent link\")", "anchor": "initsettingssource-indexhtmlpydanticsettingsinitsettingssource-permanent-link", "md_text": "```\nInitSettingsSource(\n    settings_cls: type[BaseSettings],\n    init_kwargs: dict[str, Any],\n    nested_model_default_partial_update: bool | None = None,\n)\n```\n\nBases: `PydanticBaseSettingsSource`\n\nSource class for loading values provided during settings class initialization.\n\nSource code in `pydantic_settings/sources.py`\n\n|  |  |\n| --- | --- |\n| ``` 385 386 387 388 389 390 391 392 393 394 395 396 397 ``` | ``` def __init__(     self,     settings_cls: type[BaseSettings],     init_kwargs: dict[str, Any],     nested_model_default_partial_update: bool | None = None, ):     self.init_kwargs = init_kwargs     super().__init__(settings_cls)     self.nested_model_default_partial_update = (         nested_model_default_partial_update         if nested_model_default_partial_update is not None         else self.config.get('nested_model_default_partial_update', False)     ) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_settings/index.html#initsettingssource-indexhtmlpydanticsettingsinitsettingssource-permanent-link", "page": "api/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "JsonConfigSettingsSource [Â¶](index.html#pydantic_settings.JsonConfigSettingsSource \"Permanent link\")", "anchor": "jsonconfigsettingssource-indexhtmlpydanticsettingsjsonconfigsettingssource-permanent-link", "md_text": "```\nJsonConfigSettingsSource(\n    settings_cls: type[BaseSettings],\n    json_file: PathType | None = DEFAULT_PATH,\n    json_file_encoding: str | None = None,\n)\n```\n\nBases: `InitSettingsSource`, `ConfigFileSourceMixin`\n\nA source class that loads variables from a JSON file\n\nSource code in `pydantic_settings/sources.py`\n\n|  |  |\n| --- | --- |\n| ``` 2015 2016 2017 2018 2019 2020 2021 2022 2023 2024 2025 2026 2027 2028 ``` | ``` def __init__(     self,     settings_cls: type[BaseSettings],     json_file: PathType | None = DEFAULT_PATH,     json_file_encoding: str | None = None, ):     self.json_file_path = json_file if json_file != DEFAULT_PATH else settings_cls.model_config.get('json_file')     self.json_file_encoding = (         json_file_encoding         if json_file_encoding is not None         else settings_cls.model_config.get('json_file_encoding')     )     self.json_data = self._read_files(self.json_file_path)     super().__init__(settings_cls, self.json_data) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_settings/index.html#jsonconfigsettingssource-indexhtmlpydanticsettingsjsonconfigsettingssource-permanent-link", "page": "api/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "NoDecode [Â¶](index.html#pydantic_settings.NoDecode \"Permanent link\")", "anchor": "nodecode-indexhtmlpydanticsettingsnodecode-permanent-link", "md_text": "Annotation to prevent decoding of a field value.", "url": "https://docs.pydantic.dev/latest/api/pydantic_settings/index.html#nodecode-indexhtmlpydanticsettingsnodecode-permanent-link", "page": "api/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "PydanticBaseSettingsSource [Â¶](index.html#pydantic_settings.PydanticBaseSettingsSource \"Permanent link\")", "anchor": "pydanticbasesettingssource-indexhtmlpydanticsettingspydanticbasesettingssource-permanent-link", "md_text": "```\nPydanticBaseSettingsSource(\n    settings_cls: type[BaseSettings],\n)\n```\n\nBases: `ABC`\n\nAbstract base class for settings sources, every settings source classes should inherit from it.\n\nSource code in `pydantic_settings/sources.py`\n\n|  |  |\n| --- | --- |\n| ``` 236 237 238 239 240 ``` | ``` def __init__(self, settings_cls: type[BaseSettings]):     self.settings_cls = settings_cls     self.config = settings_cls.model_config     self._current_state: dict[str, Any] = {}     self._settings_sources_data: dict[str, dict[str, Any]] = {} ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_settings/index.html#pydanticbasesettingssource-indexhtmlpydanticsettingspydanticbasesettingssource-permanent-link", "page": "api/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "current\\_state `property` [Â¶](index.html#pydantic_settings.PydanticBaseSettingsSource.current_state \"Permanent link\")", "anchor": "currentstate-property-indexhtmlpydanticsettingspydanticbasesettingssourcecurrentstate-permanent-link", "md_text": "```\ncurrent_state: dict[str, Any]\n```\n\nThe current state of the settings, populated by the previous settings sources.", "url": "https://docs.pydantic.dev/latest/api/pydantic_settings/index.html#currentstate-property-indexhtmlpydanticsettingspydanticbasesettingssourcecurrentstate-permanent-link", "page": "api/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "settings\\_sources\\_data `property` [Â¶](index.html#pydantic_settings.PydanticBaseSettingsSource.settings_sources_data \"Permanent link\")", "anchor": "settingssourcesdata-property-indexhtmlpydanticsettingspydanticbasesettingssourcesettingssourcesdata-permanent-link", "md_text": "```\nsettings_sources_data: dict[str, dict[str, Any]]\n```\n\nThe state of all previous settings sources.", "url": "https://docs.pydantic.dev/latest/api/pydantic_settings/index.html#settingssourcesdata-property-indexhtmlpydanticsettingspydanticbasesettingssourcesettingssourcesdata-permanent-link", "page": "api/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "get\\_field\\_value `abstractmethod` [Â¶](index.html#pydantic_settings.PydanticBaseSettingsSource.get_field_value \"Permanent link\")", "anchor": "getfieldvalue-abstractmethod-indexhtmlpydanticsettingspydanticbasesettingssourcegetfieldvalue-permanent-link", "md_text": "```\nget_field_value(\n    field: FieldInfo, field_name: str\n) -> tuple[Any, str, bool]\n```\n\nGets the value, the key for model creation, and a flag to determine whether value is complex.\n\nThis is an abstract method that should be overridden in every settings source classes.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `field` | `FieldInfo` | The field. | *required* |\n| `field_name` | `str` | The field name. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `tuple[Any, str, bool]` | A tuple that contains the value, key and a flag to determine whether value is complex. |\n\nSource code in `pydantic_settings/sources.py`\n\n|  |  |\n| --- | --- |\n| ``` 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 ``` | ``` @abstractmethod def get_field_value(self, field: FieldInfo, field_name: str) -> tuple[Any, str, bool]:     \"\"\"     Gets the value, the key for model creation, and a flag to determine whether value is complex.      This is an abstract method that should be overridden in every settings source classes.      Args:         field: The field.         field_name: The field name.      Returns:         A tuple that contains the value, key and a flag to determine whether value is complex.     \"\"\"     pass ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_settings/index.html#getfieldvalue-abstractmethod-indexhtmlpydanticsettingspydanticbasesettingssourcegetfieldvalue-permanent-link", "page": "api/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "field\\_is\\_complex [Â¶](index.html#pydantic_settings.PydanticBaseSettingsSource.field_is_complex \"Permanent link\")", "anchor": "fieldiscomplex-indexhtmlpydanticsettingspydanticbasesettingssourcefieldiscomplex-permanent-link", "md_text": "```\nfield_is_complex(field: FieldInfo) -> bool\n```\n\nChecks whether a field is complex, in which case it will attempt to be parsed as JSON.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `field` | `FieldInfo` | The field. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `bool` | Whether the field is complex. |\n\nSource code in `pydantic_settings/sources.py`\n\n|  |  |\n| --- | --- |\n| ``` 286 287 288 289 290 291 292 293 294 295 296 ``` | ``` def field_is_complex(self, field: FieldInfo) -> bool:     \"\"\"     Checks whether a field is complex, in which case it will attempt to be parsed as JSON.      Args:         field: The field.      Returns:         Whether the field is complex.     \"\"\"     return _annotation_is_complex(field.annotation, field.metadata) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_settings/index.html#fieldiscomplex-indexhtmlpydanticsettingspydanticbasesettingssourcefieldiscomplex-permanent-link", "page": "api/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "prepare\\_field\\_value [Â¶](index.html#pydantic_settings.PydanticBaseSettingsSource.prepare_field_value \"Permanent link\")", "anchor": "preparefieldvalue-indexhtmlpydanticsettingspydanticbasesettingssourcepreparefieldvalue-permanent-link", "md_text": "```\nprepare_field_value(\n    field_name: str,\n    field: FieldInfo,\n    value: Any,\n    value_is_complex: bool,\n) -> Any\n```\n\nPrepares the value of a field.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `field_name` | `str` | The field name. | *required* |\n| `field` | `FieldInfo` | The field. | *required* |\n| `value` | `Any` | The value of the field that has to be prepared. | *required* |\n| `value_is_complex` | `bool` | A flag to determine whether value is complex. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `Any` | The prepared value. |\n\nSource code in `pydantic_settings/sources.py`\n\n|  |  |\n| --- | --- |\n| ``` 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 ``` | ``` def prepare_field_value(self, field_name: str, field: FieldInfo, value: Any, value_is_complex: bool) -> Any:     \"\"\"     Prepares the value of a field.      Args:         field_name: The field name.         field: The field.         value: The value of the field that has to be prepared.         value_is_complex: A flag to determine whether value is complex.      Returns:         The prepared value.     \"\"\"     if value is not None and (self.field_is_complex(field) or value_is_complex):         return self.decode_complex_value(field_name, field, value)     return value ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_settings/index.html#preparefieldvalue-indexhtmlpydanticsettingspydanticbasesettingssourcepreparefieldvalue-permanent-link", "page": "api/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "decode\\_complex\\_value [Â¶](index.html#pydantic_settings.PydanticBaseSettingsSource.decode_complex_value \"Permanent link\")", "anchor": "decodecomplexvalue-indexhtmlpydanticsettingspydanticbasesettingssourcedecodecomplexvalue-permanent-link", "md_text": "```\ndecode_complex_value(\n    field_name: str, field: FieldInfo, value: Any\n) -> Any\n```\n\nDecode the value for a complex field\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `field_name` | `str` | The field name. | *required* |\n| `field` | `FieldInfo` | The field. | *required* |\n| `value` | `Any` | The value of the field that has to be prepared. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `Any` | The decoded value for further preparation |\n\nSource code in `pydantic_settings/sources.py`\n\n|  |  |\n| --- | --- |\n| ``` 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 ``` | ``` def decode_complex_value(self, field_name: str, field: FieldInfo, value: Any) -> Any:     \"\"\"     Decode the value for a complex field      Args:         field_name: The field name.         field: The field.         value: The value of the field that has to be prepared.      Returns:         The decoded value for further preparation     \"\"\"     if field and (         NoDecode in field.metadata         or (self.config.get('enable_decoding') is False and ForceDecode not in field.metadata)     ):         return value      return json.loads(value) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_settings/index.html#decodecomplexvalue-indexhtmlpydanticsettingspydanticbasesettingssourcedecodecomplexvalue-permanent-link", "page": "api/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "PyprojectTomlConfigSettingsSource [Â¶](index.html#pydantic_settings.PyprojectTomlConfigSettingsSource \"Permanent link\")", "anchor": "pyprojecttomlconfigsettingssource-indexhtmlpydanticsettingspyprojecttomlconfigsettingssource-permanent-link", "md_text": "```\nPyprojectTomlConfigSettingsSource(\n    settings_cls: type[BaseSettings],\n    toml_file: Path | None = None,\n)\n```\n\nBases: `TomlConfigSettingsSource`\n\nA source class that loads variables from a `pyproject.toml` file.\n\nSource code in `pydantic_settings/sources.py`\n\n|  |  |\n| --- | --- |\n| ``` 2068 2069 2070 2071 2072 2073 2074 2075 2076 2077 2078 2079 2080 2081 2082 ``` | ``` def __init__(     self,     settings_cls: type[BaseSettings],     toml_file: Path | None = None, ) -> None:     self.toml_file_path = self._pick_pyproject_toml_file(         toml_file, settings_cls.model_config.get('pyproject_toml_depth', 0)     )     self.toml_table_header: tuple[str, ...] = settings_cls.model_config.get(         'pyproject_toml_table_header', ('tool', 'pydantic-settings')     )     self.toml_data = self._read_files(self.toml_file_path)     for key in self.toml_table_header:         self.toml_data = self.toml_data.get(key, {})     super(TomlConfigSettingsSource, self).__init__(settings_cls, self.toml_data) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_settings/index.html#pyprojecttomlconfigsettingssource-indexhtmlpydanticsettingspyprojecttomlconfigsettingssource-permanent-link", "page": "api/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "SecretsSettingsSource [Â¶](index.html#pydantic_settings.SecretsSettingsSource \"Permanent link\")", "anchor": "secretssettingssource-indexhtmlpydanticsettingssecretssettingssource-permanent-link", "md_text": "```\nSecretsSettingsSource(\n    settings_cls: type[BaseSettings],\n    secrets_dir: PathType | None = None,\n    case_sensitive: bool | None = None,\n    env_prefix: str | None = None,\n    env_ignore_empty: bool | None = None,\n    env_parse_none_str: str | None = None,\n    env_parse_enums: bool | None = None,\n)\n```\n\nBases: `PydanticBaseEnvSettingsSource`\n\nSource class for loading settings values from secret files.\n\nSource code in `pydantic_settings/sources.py`\n\n|  |  |\n| --- | --- |\n| ``` 629 630 631 632 633 634 635 636 637 638 639 640 641 642 ``` | ``` def __init__(     self,     settings_cls: type[BaseSettings],     secrets_dir: PathType | None = None,     case_sensitive: bool | None = None,     env_prefix: str | None = None,     env_ignore_empty: bool | None = None,     env_parse_none_str: str | None = None,     env_parse_enums: bool | None = None, ) -> None:     super().__init__(         settings_cls, case_sensitive, env_prefix, env_ignore_empty, env_parse_none_str, env_parse_enums     )     self.secrets_dir = secrets_dir if secrets_dir is not None else self.config.get('secrets_dir') ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_settings/index.html#secretssettingssource-indexhtmlpydanticsettingssecretssettingssource-permanent-link", "page": "api/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "find\\_case\\_path `classmethod` [Â¶](index.html#pydantic_settings.SecretsSettingsSource.find_case_path \"Permanent link\")", "anchor": "findcasepath-classmethod-indexhtmlpydanticsettingssecretssettingssourcefindcasepath-permanent-link", "md_text": "```\nfind_case_path(\n    dir_path: Path, file_name: str, case_sensitive: bool\n) -> Path | None\n```\n\nFind a file within path's directory matching filename, optionally ignoring case.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `dir_path` | `Path` | Directory path. | *required* |\n| `file_name` | `str` | File name. | *required* |\n| `case_sensitive` | `bool` | Whether to search for file name case sensitively. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `Path | None` | Whether file path or `None` if file does not exist in directory. |\n\nSource code in `pydantic_settings/sources.py`\n\n|  |  |\n| --- | --- |\n| ``` 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 ``` | ``` @classmethod def find_case_path(cls, dir_path: Path, file_name: str, case_sensitive: bool) -> Path | None:     \"\"\"     Find a file within path's directory matching filename, optionally ignoring case.      Args:         dir_path: Directory path.         file_name: File name.         case_sensitive: Whether to search for file name case sensitively.      Returns:         Whether file path or `None` if file does not exist in directory.     \"\"\"     for f in dir_path.iterdir():         if f.name == file_name:             return f         elif not case_sensitive and f.name.lower() == file_name.lower():             return f     return None ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_settings/index.html#findcasepath-classmethod-indexhtmlpydanticsettingssecretssettingssourcefindcasepath-permanent-link", "page": "api/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "get\\_field\\_value [Â¶](index.html#pydantic_settings.SecretsSettingsSource.get_field_value \"Permanent link\")", "anchor": "getfieldvalue-indexhtmlpydanticsettingssecretssettingssourcegetfieldvalue-permanent-link", "md_text": "```\nget_field_value(\n    field: FieldInfo, field_name: str\n) -> tuple[Any, str, bool]\n```\n\nGets the value for field from secret file and a flag to determine whether value is complex.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `field` | `FieldInfo` | The field. | *required* |\n| `field_name` | `str` | The field name. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `tuple[Any, str, bool]` | A tuple that contains the value (`None` if the file does not exist), key, and a flag to determine whether value is complex. |\n\nSource code in `pydantic_settings/sources.py`\n\n|  |  |\n| --- | --- |\n| ``` 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 ``` | ``` def get_field_value(self, field: FieldInfo, field_name: str) -> tuple[Any, str, bool]:     \"\"\"     Gets the value for field from secret file and a flag to determine whether value is complex.      Args:         field: The field.         field_name: The field name.      Returns:         A tuple that contains the value (`None` if the file does not exist), key, and             a flag to determine whether value is complex.     \"\"\"      for field_key, env_name, value_is_complex in self._extract_field_info(field, field_name):         # paths reversed to match the last-wins behaviour of `env_file`         for secrets_path in reversed(self.secrets_paths):             path = self.find_case_path(secrets_path, env_name, self.case_sensitive)             if not path:                 # path does not exist, we currently don't return a warning for this                 continue              if path.is_file():                 return path.read_text().strip(), field_key, value_is_complex             else:                 warnings.warn(                     f'attempted to load secret file \"{path}\" but found a {path_type_label(path)} instead.',                     stacklevel=4,                 )      return None, field_key, value_is_complex ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_settings/index.html#getfieldvalue-indexhtmlpydanticsettingssecretssettingssourcegetfieldvalue-permanent-link", "page": "api/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "TomlConfigSettingsSource [Â¶](index.html#pydantic_settings.TomlConfigSettingsSource \"Permanent link\")", "anchor": "tomlconfigsettingssource-indexhtmlpydanticsettingstomlconfigsettingssource-permanent-link", "md_text": "```\nTomlConfigSettingsSource(\n    settings_cls: type[BaseSettings],\n    toml_file: PathType | None = DEFAULT_PATH,\n)\n```\n\nBases: `InitSettingsSource`, `ConfigFileSourceMixin`\n\nA source class that loads variables from a TOML file\n\nSource code in `pydantic_settings/sources.py`\n\n|  |  |\n| --- | --- |\n| ``` 2043 2044 2045 2046 2047 2048 2049 2050 ``` | ``` def __init__(     self,     settings_cls: type[BaseSettings],     toml_file: PathType | None = DEFAULT_PATH, ):     self.toml_file_path = toml_file if toml_file != DEFAULT_PATH else settings_cls.model_config.get('toml_file')     self.toml_data = self._read_files(self.toml_file_path)     super().__init__(settings_cls, self.toml_data) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_settings/index.html#tomlconfigsettingssource-indexhtmlpydanticsettingstomlconfigsettingssource-permanent-link", "page": "api/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "YamlConfigSettingsSource [Â¶](index.html#pydantic_settings.YamlConfigSettingsSource \"Permanent link\")", "anchor": "yamlconfigsettingssource-indexhtmlpydanticsettingsyamlconfigsettingssource-permanent-link", "md_text": "```\nYamlConfigSettingsSource(\n    settings_cls: type[BaseSettings],\n    yaml_file: PathType | None = DEFAULT_PATH,\n    yaml_file_encoding: str | None = None,\n)\n```\n\nBases: `InitSettingsSource`, `ConfigFileSourceMixin`\n\nA source class that loads variables from a yaml file\n\nSource code in `pydantic_settings/sources.py`\n\n|  |  |\n| --- | --- |\n| ``` 2114 2115 2116 2117 2118 2119 2120 2121 2122 2123 2124 2125 2126 2127 ``` | ``` def __init__(     self,     settings_cls: type[BaseSettings],     yaml_file: PathType | None = DEFAULT_PATH,     yaml_file_encoding: str | None = None, ):     self.yaml_file_path = yaml_file if yaml_file != DEFAULT_PATH else settings_cls.model_config.get('yaml_file')     self.yaml_file_encoding = (         yaml_file_encoding         if yaml_file_encoding is not None         else settings_cls.model_config.get('yaml_file_encoding')     )     self.yaml_data = self._read_files(self.yaml_file_path)     super().__init__(settings_cls, self.yaml_data) ``` |", "url": "https://docs.pydantic.dev/latest/api/pydantic_settings/index.html#yamlconfigsettingssource-indexhtmlpydanticsettingsyamlconfigsettingssource-permanent-link", "page": "api/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "get\\_subcommand [Â¶](index.html#pydantic_settings.get_subcommand \"Permanent link\")", "anchor": "getsubcommand-indexhtmlpydanticsettingsgetsubcommand-permanent-link", "md_text": "```\nget_subcommand(\n    model: PydanticModel,\n    is_required: bool = True,\n    cli_exit_on_error: bool | None = None,\n) -> Optional[PydanticModel]\n```\n\nGet the subcommand from a model.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `model` | `PydanticModel` | The model to get the subcommand from. | *required* |\n| `is_required` | `bool` | Determines whether a model must have subcommand set and raises error if not found. Defaults to `True`. | `True` |\n| `cli_exit_on_error` | `bool | None` | Determines whether this function exits with error if no subcommand is found. Defaults to model\\_config `cli_exit_on_error` value if set. Otherwise, defaults to `True`. | `None` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `Optional[PydanticModel]` | The subcommand model if found, otherwise `None`. |\n\nRaises:\n\n| Type | Description |\n| --- | --- |\n| `SystemExit` | When no subcommand is found and is\\_required=`True` and cli\\_exit\\_on\\_error=`True` (the default). |\n| `SettingsError` | When no subcommand is found and is\\_required=`True` and cli\\_exit\\_on\\_error=`False`. |\n\nSource code in `pydantic_settings/sources.py`\n\n|  |  |\n| --- | --- |\n| ``` 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 ``` | ``` def get_subcommand(     model: PydanticModel, is_required: bool = True, cli_exit_on_error: bool | None = None ) -> Optional[PydanticModel]:     \"\"\"     Get the subcommand from a model.      Args:         model: The model to get the subcommand from.         is_required: Determines whether a model must have subcommand set and raises error if not             found. Defaults to `True`.         cli_exit_on_error: Determines whether this function exits with error if no subcommand is found.             Defaults to model_config `cli_exit_on_error` value if set. Otherwise, defaults to `True`.      Returns:         The subcommand model if found, otherwise `None`.      Raises:         SystemExit: When no subcommand is found and is_required=`True` and cli_exit_on_error=`True`             (the default).         SettingsError: When no subcommand is found and is_required=`True` and             cli_exit_on_error=`False`.     \"\"\"      model_cls = type(model)     if cli_exit_on_error is None and is_model_class(model_cls):         model_default = model_cls.model_config.get('cli_exit_on_error')         if isinstance(model_default, bool):             cli_exit_on_error = model_default     if cli_exit_on_error is None:         cli_exit_on_error = True      subcommands: list[str] = []     for field_name, field_info in _get_model_fields(model_cls).items():         if _CliSubCommand in field_info.metadata:             if getattr(model, field_name) is not None:                 return getattr(model, field_name)             subcommands.append(field_name)      if is_required:         error_message = (             f'Error: CLI subcommand is required {{{\", \".join(subcommands)}}}'             if subcommands             else 'Error: CLI subcommand is required but no subcommands were found.'         )         raise SystemExit(error_message) if cli_exit_on_error else SettingsError(error_message)      return None ``` |\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/api/pydantic_settings/index.html#getsubcommand-indexhtmlpydanticsettingsgetsubcommand-permanent-link", "page": "api/pydantic_settings/index.html", "source_site": "pydantic"}
{"title": "ConfigDict [Â¶](index.html#pydantic.config.ConfigDict \"Permanent link\")", "anchor": "configdict-indexhtmlpydanticconfigconfigdict-permanent-link", "md_text": "Bases: `TypedDict`\n\nA TypedDict for configuring Pydantic behaviour.", "url": "https://docs.pydantic.dev/latest/api/config/index.html#configdict-indexhtmlpydanticconfigconfigdict-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "title `instance-attribute` [Â¶](index.html#pydantic.config.ConfigDict.title \"Permanent link\")", "anchor": "title-instance-attribute-indexhtmlpydanticconfigconfigdicttitle-permanent-link", "md_text": "```\ntitle: str | None\n```\n\nThe title for the generated JSON schema, defaults to the model's name", "url": "https://docs.pydantic.dev/latest/api/config/index.html#title-instance-attribute-indexhtmlpydanticconfigconfigdicttitle-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "model\\_title\\_generator `instance-attribute` [Â¶](index.html#pydantic.config.ConfigDict.model_title_generator \"Permanent link\")", "anchor": "modeltitlegenerator-instance-attribute-indexhtmlpydanticconfigconfigdictmodeltitlegenerator-permanent-link", "md_text": "```\nmodel_title_generator: Callable[[type], str] | None\n```\n\nA callable that takes a model class and returns the title for it. Defaults to `None`.", "url": "https://docs.pydantic.dev/latest/api/config/index.html#modeltitlegenerator-instance-attribute-indexhtmlpydanticconfigconfigdictmodeltitlegenerator-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "field\\_title\\_generator `instance-attribute` [Â¶](index.html#pydantic.config.ConfigDict.field_title_generator \"Permanent link\")", "anchor": "fieldtitlegenerator-instance-attribute-indexhtmlpydanticconfigconfigdictfieldtitlegenerator-permanent-link", "md_text": "```\nfield_title_generator: (\n    Callable[[str, FieldInfo | ComputedFieldInfo], str]\n    | None\n)\n```\n\nA callable that takes a field's name and info and returns title for it. Defaults to `None`.", "url": "https://docs.pydantic.dev/latest/api/config/index.html#fieldtitlegenerator-instance-attribute-indexhtmlpydanticconfigconfigdictfieldtitlegenerator-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "str\\_to\\_lower `instance-attribute` [Â¶](index.html#pydantic.config.ConfigDict.str_to_lower \"Permanent link\")", "anchor": "strtolower-instance-attribute-indexhtmlpydanticconfigconfigdictstrtolower-permanent-link", "md_text": "```\nstr_to_lower: bool\n```\n\nWhether to convert all characters to lowercase for str types. Defaults to `False`.", "url": "https://docs.pydantic.dev/latest/api/config/index.html#strtolower-instance-attribute-indexhtmlpydanticconfigconfigdictstrtolower-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "str\\_to\\_upper `instance-attribute` [Â¶](index.html#pydantic.config.ConfigDict.str_to_upper \"Permanent link\")", "anchor": "strtoupper-instance-attribute-indexhtmlpydanticconfigconfigdictstrtoupper-permanent-link", "md_text": "```\nstr_to_upper: bool\n```\n\nWhether to convert all characters to uppercase for str types. Defaults to `False`.", "url": "https://docs.pydantic.dev/latest/api/config/index.html#strtoupper-instance-attribute-indexhtmlpydanticconfigconfigdictstrtoupper-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "str\\_strip\\_whitespace `instance-attribute` [Â¶](index.html#pydantic.config.ConfigDict.str_strip_whitespace \"Permanent link\")", "anchor": "strstripwhitespace-instance-attribute-indexhtmlpydanticconfigconfigdictstrstripwhitespace-permanent-link", "md_text": "```\nstr_strip_whitespace: bool\n```\n\nWhether to strip leading and trailing whitespace for str types.", "url": "https://docs.pydantic.dev/latest/api/config/index.html#strstripwhitespace-instance-attribute-indexhtmlpydanticconfigconfigdictstrstripwhitespace-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "str\\_min\\_length `instance-attribute` [Â¶](index.html#pydantic.config.ConfigDict.str_min_length \"Permanent link\")", "anchor": "strminlength-instance-attribute-indexhtmlpydanticconfigconfigdictstrminlength-permanent-link", "md_text": "```\nstr_min_length: int\n```\n\nThe minimum length for str types. Defaults to `None`.", "url": "https://docs.pydantic.dev/latest/api/config/index.html#strminlength-instance-attribute-indexhtmlpydanticconfigconfigdictstrminlength-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "str\\_max\\_length `instance-attribute` [Â¶](index.html#pydantic.config.ConfigDict.str_max_length \"Permanent link\")", "anchor": "strmaxlength-instance-attribute-indexhtmlpydanticconfigconfigdictstrmaxlength-permanent-link", "md_text": "```\nstr_max_length: int | None\n```\n\nThe maximum length for str types. Defaults to `None`.", "url": "https://docs.pydantic.dev/latest/api/config/index.html#strmaxlength-instance-attribute-indexhtmlpydanticconfigconfigdictstrmaxlength-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "extra `instance-attribute` [Â¶](index.html#pydantic.config.ConfigDict.extra \"Permanent link\")", "anchor": "extra-instance-attribute-indexhtmlpydanticconfigconfigdictextra-permanent-link", "md_text": "```\nextra: ExtraValues | None\n```\n\nWhether to ignore, allow, or forbid extra data during model initialization. Defaults to `'ignore'`.\n\nThree configuration values are available:\n\n* `'ignore'`: Providing extra data is ignored (the default):\n\n  ```\n  from pydantic import BaseModel, ConfigDict\n\n  class User(BaseModel):\n      model_config = ConfigDict(extra='ignore')  # (1)!\n\n      name: str\n\n  user = User(name='John Doe', age=20)  # (2)!\n  print(user)\n  #> name='John Doe'\n  ```\n\n  1. This is the default behaviour.\n  2. The `age` argument is ignored.\n* `'forbid'`: Providing extra data is not permitted, and a [`ValidationError`](../pydantic_core/index.html#pydantic_core.ValidationError)\n  will be raised if this is the case:\n\n  ```\n  from pydantic import BaseModel, ConfigDict, ValidationError\n\n\n  class Model(BaseModel):\n      x: int\n\n      model_config = ConfigDict(extra='forbid')\n\n\n  try:\n      Model(x=1, y='a')\n  except ValidationError as exc:\n      print(exc)\n      \"\"\"\n      1 validation error for Model\n      y\n        Extra inputs are not permitted [type=extra_forbidden, input_value='a', input_type=str]\n      \"\"\"\n  ```\n* `'allow'`: Providing extra data is allowed and stored in the `__pydantic_extra__` dictionary attribute:\n\n  ```\n  from pydantic import BaseModel, ConfigDict\n\n\n  class Model(BaseModel):\n      x: int\n\n      model_config = ConfigDict(extra='allow')\n\n\n  m = Model(x=1, y='a')\n  assert m.__pydantic_extra__ == {'y': 'a'}\n  ```\n\n  By default, no validation will be applied to these extra items, but you can set a type for the values by overriding\n  the type annotation for `__pydantic_extra__`:\n\n  ```\n  from pydantic import BaseModel, ConfigDict, Field, ValidationError\n\n\n  class Model(BaseModel):\n      __pydantic_extra__: dict[str, int] = Field(init=False)  # (1)!\n\n      x: int\n\n      model_config = ConfigDict(extra='allow')\n\n\n  try:\n      Model(x=1, y='a')\n  except ValidationError as exc:\n      print(exc)\n      \"\"\"\n      1 validation error for Model\n      y\n        Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='a', input_type=str]\n      \"\"\"\n\n  m = Model(x=1, y='2')\n  assert m.x == 1\n  assert m.y == 2\n  assert m.model_dump() == {'x': 1, 'y': 2}\n  assert m.__pydantic_extra__ == {'y': 2}\n  ```\n\n  1. The `= Field(init=False)` does not have any effect at runtime, but prevents the `__pydantic_extra__` field from\n     being included as a parameter to the model's `__init__` method by type checkers.\n\nAs well as specifying an `extra` configuration value on the model, you can also provide it as an argument to the validation methods.\nThis will override any `extra` configuration value set on the model:\n\n```\nfrom pydantic import BaseModel, ConfigDict, ValidationError\n\nclass Model(BaseModel):\n    x: int\n    model_config = ConfigDict(extra=\"allow\")\n\ntry:\n    # Override model config and forbid extra fields just this time\n    Model.model_validate({\"x\": 1, \"y\": 2}, extra=\"forbid\")\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for Model\n    y\n      Extra inputs are not permitted [type=extra_forbidden, input_value=2, input_type=int]\n    \"\"\"\n```", "url": "https://docs.pydantic.dev/latest/api/config/index.html#extra-instance-attribute-indexhtmlpydanticconfigconfigdictextra-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "frozen `instance-attribute` [Â¶](index.html#pydantic.config.ConfigDict.frozen \"Permanent link\")", "anchor": "frozen-instance-attribute-indexhtmlpydanticconfigconfigdictfrozen-permanent-link", "md_text": "```\nfrozen: bool\n```\n\nWhether models are faux-immutable, i.e. whether `__setattr__` is allowed, and also generates\na `__hash__()` method for the model. This makes instances of the model potentially hashable if all the\nattributes are hashable. Defaults to `False`.\n\nNote\n\nOn V1, the inverse of this setting was called `allow_mutation`, and was `True` by default.", "url": "https://docs.pydantic.dev/latest/api/config/index.html#frozen-instance-attribute-indexhtmlpydanticconfigconfigdictfrozen-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "populate\\_by\\_name `instance-attribute` [Â¶](index.html#pydantic.config.ConfigDict.populate_by_name \"Permanent link\")", "anchor": "populatebyname-instance-attribute-indexhtmlpydanticconfigconfigdictpopulatebyname-permanent-link", "md_text": "```\npopulate_by_name: bool\n```\n\nWhether an aliased field may be populated by its name as given by the model\nattribute, as well as the alias. Defaults to `False`.\n\n`populate_by_name` usage is not recommended in v2.11+ and will be deprecated in v3.\nInstead, you should use the [`validate_by_name`](index.html#pydantic.config.ConfigDict.validate_by_name) configuration setting.\n\nWhen `validate_by_name=True` and `validate_by_alias=True`, this is strictly equivalent to the\nprevious behavior of `populate_by_name=True`.\n\nIn v2.11, we also introduced a [`validate_by_alias`](index.html#pydantic.config.ConfigDict.validate_by_alias) setting that introduces more fine grained\ncontrol for validation behavior.\n\nHere's how you might go about using the new settings to achieve the same behavior:\n\n```\nfrom pydantic import BaseModel, ConfigDict, Field\n\nclass Model(BaseModel):\n    model_config = ConfigDict(validate_by_name=True, validate_by_alias=True)\n\n    my_field: str = Field(alias='my_alias')  # (1)!\n\nm = Model(my_alias='foo')  # (2)!\nprint(m)\n#> my_field='foo'\n\nm = Model(my_field='foo')  # (3)!\nprint(m)\n#> my_field='foo'\n```\n\n1. The field `'my_field'` has an alias `'my_alias'`.\n2. The model is populated by the alias `'my_alias'`.\n3. The model is populated by the attribute name `'my_field'`.", "url": "https://docs.pydantic.dev/latest/api/config/index.html#populatebyname-instance-attribute-indexhtmlpydanticconfigconfigdictpopulatebyname-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "use\\_enum\\_values `instance-attribute` [Â¶](index.html#pydantic.config.ConfigDict.use_enum_values \"Permanent link\")", "anchor": "useenumvalues-instance-attribute-indexhtmlpydanticconfigconfigdictuseenumvalues-permanent-link", "md_text": "```\nuse_enum_values: bool\n```\n\nWhether to populate models with the `value` property of enums, rather than the raw enum.\nThis may be useful if you want to serialize `model.model_dump()` later. Defaults to `False`.\n\nIf you have an `Optional[Enum]` value that you set a default for, you need to use `validate_default=True`\nfor said Field to ensure that the `use_enum_values` flag takes effect on the default, as extracting an\nenum's value occurs during validation, not serialization.\n\n```\nfrom enum import Enum\nfrom typing import Optional\n\nfrom pydantic import BaseModel, ConfigDict, Field\n\nclass SomeEnum(Enum):\n    FOO = 'foo'\n    BAR = 'bar'\n    BAZ = 'baz'\n\nclass SomeModel(BaseModel):\n    model_config = ConfigDict(use_enum_values=True)\n\n    some_enum: SomeEnum\n    another_enum: Optional[SomeEnum] = Field(\n        default=SomeEnum.FOO, validate_default=True\n    )\n\nmodel1 = SomeModel(some_enum=SomeEnum.BAR)\nprint(model1.model_dump())\n#> {'some_enum': 'bar', 'another_enum': 'foo'}\n\nmodel2 = SomeModel(some_enum=SomeEnum.BAR, another_enum=SomeEnum.BAZ)\nprint(model2.model_dump())\n#> {'some_enum': 'bar', 'another_enum': 'baz'}\n```", "url": "https://docs.pydantic.dev/latest/api/config/index.html#useenumvalues-instance-attribute-indexhtmlpydanticconfigconfigdictuseenumvalues-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "validate\\_assignment `instance-attribute` [Â¶](index.html#pydantic.config.ConfigDict.validate_assignment \"Permanent link\")", "anchor": "validateassignment-instance-attribute-indexhtmlpydanticconfigconfigdictvalidateassignment-permanent-link", "md_text": "```\nvalidate_assignment: bool\n```\n\nWhether to validate the data when the model is changed. Defaults to `False`.\n\nThe default behavior of Pydantic is to validate the data when the model is created.\n\nIn case the user changes the data after the model is created, the model is *not* revalidated.\n\n```\nfrom pydantic import BaseModel\n\nclass User(BaseModel):\n    name: str\n\nuser = User(name='John Doe')  # (1)!\nprint(user)\n#> name='John Doe'\nuser.name = 123  # (1)!\nprint(user)\n#> name=123\n```\n\n1. The validation happens only when the model is created.\n2. The validation does not happen when the data is changed.\n\nIn case you want to revalidate the model when the data is changed, you can use `validate_assignment=True`:\n\n```\nfrom pydantic import BaseModel, ValidationError\n\nclass User(BaseModel, validate_assignment=True):  # (1)!\n    name: str\n\nuser = User(name='John Doe')  # (2)!\nprint(user)\n#> name='John Doe'\ntry:\n    user.name = 123  # (3)!\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for User\n    name\n      Input should be a valid string [type=string_type, input_value=123, input_type=int]\n    '''\n```\n\n1. You can either use class keyword arguments, or `model_config` to set `validate_assignment=True`.\n2. The validation happens when the model is created.\n3. The validation *also* happens when the data is changed.", "url": "https://docs.pydantic.dev/latest/api/config/index.html#validateassignment-instance-attribute-indexhtmlpydanticconfigconfigdictvalidateassignment-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "arbitrary\\_types\\_allowed `instance-attribute` [Â¶](index.html#pydantic.config.ConfigDict.arbitrary_types_allowed \"Permanent link\")", "anchor": "arbitrarytypesallowed-instance-attribute-indexhtmlpydanticconfigconfigdictarbitrarytypesallowed-permanent-link", "md_text": "```\narbitrary_types_allowed: bool\n```\n\nWhether arbitrary types are allowed for field types. Defaults to `False`.\n\n```\nfrom pydantic import BaseModel, ConfigDict, ValidationError\n\n# This is not a pydantic model, it's an arbitrary class\nclass Pet:\n    def __init__(self, name: str):\n        self.name = name\n\nclass Model(BaseModel):\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n    pet: Pet\n    owner: str\n\npet = Pet(name='Hedwig')\n# A simple check of instance type is used to validate the data\nmodel = Model(owner='Harry', pet=pet)\nprint(model)\n#> pet=<__main__.Pet object at 0x0123456789ab> owner='Harry'\nprint(model.pet)\n#> <__main__.Pet object at 0x0123456789ab>\nprint(model.pet.name)\n#> Hedwig\nprint(type(model.pet))\n#> <class '__main__.Pet'>\ntry:\n    # If the value is not an instance of the type, it's invalid\n    Model(owner='Harry', pet='Hedwig')\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for Model\n    pet\n      Input should be an instance of Pet [type=is_instance_of, input_value='Hedwig', input_type=str]\n    '''\n\n# Nothing in the instance of the arbitrary type is checked\n# Here name probably should have been a str, but it's not validated\npet2 = Pet(name=42)\nmodel2 = Model(owner='Harry', pet=pet2)\nprint(model2)\n#> pet=<__main__.Pet object at 0x0123456789ab> owner='Harry'\nprint(model2.pet)\n#> <__main__.Pet object at 0x0123456789ab>\nprint(model2.pet.name)\n#> 42\nprint(type(model2.pet))\n#> <class '__main__.Pet'>\n```", "url": "https://docs.pydantic.dev/latest/api/config/index.html#arbitrarytypesallowed-instance-attribute-indexhtmlpydanticconfigconfigdictarbitrarytypesallowed-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "from\\_attributes `instance-attribute` [Â¶](index.html#pydantic.config.ConfigDict.from_attributes \"Permanent link\")", "anchor": "fromattributes-instance-attribute-indexhtmlpydanticconfigconfigdictfromattributes-permanent-link", "md_text": "```\nfrom_attributes: bool\n```\n\nWhether to build models and look up discriminators of tagged unions using python object attributes.", "url": "https://docs.pydantic.dev/latest/api/config/index.html#fromattributes-instance-attribute-indexhtmlpydanticconfigconfigdictfromattributes-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "loc\\_by\\_alias `instance-attribute` [Â¶](index.html#pydantic.config.ConfigDict.loc_by_alias \"Permanent link\")", "anchor": "locbyalias-instance-attribute-indexhtmlpydanticconfigconfigdictlocbyalias-permanent-link", "md_text": "```\nloc_by_alias: bool\n```\n\nWhether to use the actual key provided in the data (e.g. alias) for error `loc`s rather than the field's name. Defaults to `True`.", "url": "https://docs.pydantic.dev/latest/api/config/index.html#locbyalias-instance-attribute-indexhtmlpydanticconfigconfigdictlocbyalias-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "alias\\_generator `instance-attribute` [Â¶](index.html#pydantic.config.ConfigDict.alias_generator \"Permanent link\")", "anchor": "aliasgenerator-instance-attribute-indexhtmlpydanticconfigconfigdictaliasgenerator-permanent-link", "md_text": "```\nalias_generator: (\n    Callable[[str], str] | AliasGenerator | None\n)\n```\n\nA callable that takes a field name and returns an alias for it\nor an instance of [`AliasGenerator`](../aliases/index.html#pydantic.aliases.AliasGenerator). Defaults to `None`.\n\nWhen using a callable, the alias generator is used for both validation and serialization.\nIf you want to use different alias generators for validation and serialization, you can use\n[`AliasGenerator`](../aliases/index.html#pydantic.aliases.AliasGenerator) instead.\n\nIf data source field names do not match your code style (e.g. CamelCase fields),\nyou can automatically generate aliases using `alias_generator`. Here's an example with\na basic callable:\n\n```\nfrom pydantic import BaseModel, ConfigDict\nfrom pydantic.alias_generators import to_pascal\n\nclass Voice(BaseModel):\n    model_config = ConfigDict(alias_generator=to_pascal)\n\n    name: str\n    language_code: str\n\nvoice = Voice(Name='Filiz', LanguageCode='tr-TR')\nprint(voice.language_code)\n#> tr-TR\nprint(voice.model_dump(by_alias=True))\n#> {'Name': 'Filiz', 'LanguageCode': 'tr-TR'}\n```\n\nIf you want to use different alias generators for validation and serialization, you can use\n[`AliasGenerator`](../aliases/index.html#pydantic.aliases.AliasGenerator).\n\n```\nfrom pydantic import AliasGenerator, BaseModel, ConfigDict\nfrom pydantic.alias_generators import to_camel, to_pascal\n\nclass Athlete(BaseModel):\n    first_name: str\n    last_name: str\n    sport: str\n\n    model_config = ConfigDict(\n        alias_generator=AliasGenerator(\n            validation_alias=to_camel,\n            serialization_alias=to_pascal,\n        )\n    )\n\nathlete = Athlete(firstName='John', lastName='Doe', sport='track')\nprint(athlete.model_dump(by_alias=True))\n#> {'FirstName': 'John', 'LastName': 'Doe', 'Sport': 'track'}\n```\n\nNote\n\nPydantic offers three built-in alias generators: [`to_pascal`](index.html#pydantic.alias_generators.to_pascal),\n[`to_camel`](index.html#pydantic.alias_generators.to_camel), and [`to_snake`](index.html#pydantic.alias_generators.to_snake).", "url": "https://docs.pydantic.dev/latest/api/config/index.html#aliasgenerator-instance-attribute-indexhtmlpydanticconfigconfigdictaliasgenerator-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "ignored\\_types `instance-attribute` [Â¶](index.html#pydantic.config.ConfigDict.ignored_types \"Permanent link\")", "anchor": "ignoredtypes-instance-attribute-indexhtmlpydanticconfigconfigdictignoredtypes-permanent-link", "md_text": "```\nignored_types: tuple[type, ...]\n```\n\nA tuple of types that may occur as values of class attributes without annotations. This is\ntypically used for custom descriptors (classes that behave like `property`). If an attribute is set on a\nclass without an annotation and has a type that is not in this tuple (or otherwise recognized by\n*pydantic*), an error will be raised. Defaults to `()`.", "url": "https://docs.pydantic.dev/latest/api/config/index.html#ignoredtypes-instance-attribute-indexhtmlpydanticconfigconfigdictignoredtypes-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "allow\\_inf\\_nan `instance-attribute` [Â¶](index.html#pydantic.config.ConfigDict.allow_inf_nan \"Permanent link\")", "anchor": "allowinfnan-instance-attribute-indexhtmlpydanticconfigconfigdictallowinfnan-permanent-link", "md_text": "```\nallow_inf_nan: bool\n```\n\nWhether to allow infinity (`+inf` an `-inf`) and NaN values to float and decimal fields. Defaults to `True`.", "url": "https://docs.pydantic.dev/latest/api/config/index.html#allowinfnan-instance-attribute-indexhtmlpydanticconfigconfigdictallowinfnan-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "json\\_schema\\_extra `instance-attribute` [Â¶](index.html#pydantic.config.ConfigDict.json_schema_extra \"Permanent link\")", "anchor": "jsonschemaextra-instance-attribute-indexhtmlpydanticconfigconfigdictjsonschemaextra-permanent-link", "md_text": "```\njson_schema_extra: JsonDict | JsonSchemaExtraCallable | None\n```\n\nA dict or callable to provide extra JSON schema properties. Defaults to `None`.", "url": "https://docs.pydantic.dev/latest/api/config/index.html#jsonschemaextra-instance-attribute-indexhtmlpydanticconfigconfigdictjsonschemaextra-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "json\\_encoders `instance-attribute` [Â¶](index.html#pydantic.config.ConfigDict.json_encoders \"Permanent link\")", "anchor": "jsonencoders-instance-attribute-indexhtmlpydanticconfigconfigdictjsonencoders-permanent-link", "md_text": "```\njson_encoders: dict[type[object], JsonEncoder] | None\n```\n\nA `dict` of custom JSON encoders for specific types. Defaults to `None`.\n\nThis config option is a carryover from v1.\nWe originally planned to remove it in v2 but didn't have a 1:1 replacement so we are keeping it for now.\nIt is still deprecated and will likely be removed in the future.", "url": "https://docs.pydantic.dev/latest/api/config/index.html#jsonencoders-instance-attribute-indexhtmlpydanticconfigconfigdictjsonencoders-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "strict `instance-attribute` [Â¶](index.html#pydantic.config.ConfigDict.strict \"Permanent link\")", "anchor": "strict-instance-attribute-indexhtmlpydanticconfigconfigdictstrict-permanent-link", "md_text": "```\nstrict: bool\n```\n\n*(new in V2)* If `True`, strict validation is applied to all fields on the model.\n\nBy default, Pydantic attempts to coerce values to the correct type, when possible.\n\nThere are situations in which you may want to disable this behavior, and instead raise an error if a value's type\ndoes not match the field's type annotation.\n\nTo configure strict mode for all fields on a model, you can set `strict=True` on the model.\n\n```\nfrom pydantic import BaseModel, ConfigDict\n\nclass Model(BaseModel):\n    model_config = ConfigDict(strict=True)\n\n    name: str\n    age: int\n```\n\nSee [Strict Mode](../../concepts/strict_mode/index.html) for more details.\n\nSee the [Conversion Table](../../concepts/conversion_table/index.html) for more details on how Pydantic converts data in both\nstrict and lax modes.", "url": "https://docs.pydantic.dev/latest/api/config/index.html#strict-instance-attribute-indexhtmlpydanticconfigconfigdictstrict-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "revalidate\\_instances `instance-attribute` [Â¶](index.html#pydantic.config.ConfigDict.revalidate_instances \"Permanent link\")", "anchor": "revalidateinstances-instance-attribute-indexhtmlpydanticconfigconfigdictrevalidateinstances-permanent-link", "md_text": "```\nrevalidate_instances: Literal[\n    \"always\", \"never\", \"subclass-instances\"\n]\n```\n\nWhen and how to revalidate models and dataclasses during validation. Accepts the string\nvalues of `'never'`, `'always'` and `'subclass-instances'`. Defaults to `'never'`.\n\n* `'never'` will not revalidate models and dataclasses during validation\n* `'always'` will revalidate models and dataclasses during validation\n* `'subclass-instances'` will revalidate models and dataclasses during validation if the instance is a\n  subclass of the model or dataclass\n\nBy default, model and dataclass instances are not revalidated during validation.\n\n```\nfrom pydantic import BaseModel\n\nclass User(BaseModel, revalidate_instances='never'):  # (1)!\n    hobbies: list[str]\n\nclass SubUser(User):\n    sins: list[str]\n\nclass Transaction(BaseModel):\n    user: User\n\nmy_user = User(hobbies=['reading'])\nt = Transaction(user=my_user)\nprint(t)\n#> user=User(hobbies=['reading'])\n\nmy_user.hobbies = [1]  # (2)!\nt = Transaction(user=my_user)  # (3)!\nprint(t)\n#> user=User(hobbies=[1])\n\nmy_sub_user = SubUser(hobbies=['scuba diving'], sins=['lying'])\nt = Transaction(user=my_sub_user)\nprint(t)\n#> user=SubUser(hobbies=['scuba diving'], sins=['lying'])\n```\n\n1. `revalidate_instances` is set to `'never'` by \\*\\*default.\n2. The assignment is not validated, unless you set `validate_assignment` to `True` in the model's config.\n3. Since `revalidate_instances` is set to `never`, this is not revalidated.\n\nIf you want to revalidate instances during validation, you can set `revalidate_instances` to `'always'`\nin the model's config.\n\n```\nfrom pydantic import BaseModel, ValidationError\n\nclass User(BaseModel, revalidate_instances='always'):  # (1)!\n    hobbies: list[str]\n\nclass SubUser(User):\n    sins: list[str]\n\nclass Transaction(BaseModel):\n    user: User\n\nmy_user = User(hobbies=['reading'])\nt = Transaction(user=my_user)\nprint(t)\n#> user=User(hobbies=['reading'])\n\nmy_user.hobbies = [1]\ntry:\n    t = Transaction(user=my_user)  # (2)!\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for Transaction\n    user.hobbies.0\n      Input should be a valid string [type=string_type, input_value=1, input_type=int]\n    '''\n\nmy_sub_user = SubUser(hobbies=['scuba diving'], sins=['lying'])\nt = Transaction(user=my_sub_user)\nprint(t)  # (3)!\n#> user=User(hobbies=['scuba diving'])\n```\n\n1. `revalidate_instances` is set to `'always'`.\n2. The model is revalidated, since `revalidate_instances` is set to `'always'`.\n3. Using `'never'` we would have gotten `user=SubUser(hobbies=['scuba diving'], sins=['lying'])`.\n\nIt's also possible to set `revalidate_instances` to `'subclass-instances'` to only revalidate instances\nof subclasses of the model.\n\n```\nfrom pydantic import BaseModel\n\nclass User(BaseModel, revalidate_instances='subclass-instances'):  # (1)!\n    hobbies: list[str]\n\nclass SubUser(User):\n    sins: list[str]\n\nclass Transaction(BaseModel):\n    user: User\n\nmy_user = User(hobbies=['reading'])\nt = Transaction(user=my_user)\nprint(t)\n#> user=User(hobbies=['reading'])\n\nmy_user.hobbies = [1]\nt = Transaction(user=my_user)  # (2)!\nprint(t)\n#> user=User(hobbies=[1])\n\nmy_sub_user = SubUser(hobbies=['scuba diving'], sins=['lying'])\nt = Transaction(user=my_sub_user)\nprint(t)  # (3)!\n#> user=User(hobbies=['scuba diving'])\n```\n\n1. `revalidate_instances` is set to `'subclass-instances'`.\n2. This is not revalidated, since `my_user` is not a subclass of `User`.\n3. Using `'never'` we would have gotten `user=SubUser(hobbies=['scuba diving'], sins=['lying'])`.", "url": "https://docs.pydantic.dev/latest/api/config/index.html#revalidateinstances-instance-attribute-indexhtmlpydanticconfigconfigdictrevalidateinstances-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "ser\\_json\\_timedelta `instance-attribute` [Â¶](index.html#pydantic.config.ConfigDict.ser_json_timedelta \"Permanent link\")", "anchor": "serjsontimedelta-instance-attribute-indexhtmlpydanticconfigconfigdictserjsontimedelta-permanent-link", "md_text": "```\nser_json_timedelta: Literal['iso8601', 'float']\n```\n\nThe format of JSON serialized timedeltas. Accepts the string values of `'iso8601'` and\n`'float'`. Defaults to `'iso8601'`.\n\n* `'iso8601'` will serialize timedeltas to [ISO 8601 text format](https://en.wikipedia.org/wiki/ISO_8601#Durations).\n* `'float'` will serialize timedeltas to the total number of seconds.\n\nStarting in v2.12, it is recommended to use the [`ser_json_temporal`](index.html#pydantic.config.ConfigDict.ser_json_temporal)\nsetting instead of `ser_json_timedelta`. This setting will be deprecated in v3.", "url": "https://docs.pydantic.dev/latest/api/config/index.html#serjsontimedelta-instance-attribute-indexhtmlpydanticconfigconfigdictserjsontimedelta-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "ser\\_json\\_temporal `instance-attribute` [Â¶](index.html#pydantic.config.ConfigDict.ser_json_temporal \"Permanent link\")", "anchor": "serjsontemporal-instance-attribute-indexhtmlpydanticconfigconfigdictserjsontemporal-permanent-link", "md_text": "```\nser_json_temporal: Literal[\n    \"iso8601\", \"seconds\", \"milliseconds\"\n]\n```\n\nThe format of JSON serialized temporal types from the [`datetime`](https://docs.python.org/3/library/datetime.html#module-datetime) module. This includes:\n\n* [`datetime.datetime`](https://docs.python.org/3/library/datetime.html#datetime.datetime)\n* [`datetime.date`](https://docs.python.org/3/library/datetime.html#datetime.date)\n* [`datetime.time`](https://docs.python.org/3/library/datetime.html#datetime.time)\n* [`datetime.timedelta`](https://docs.python.org/3/library/datetime.html#datetime.timedelta)\n\nCan be one of:\n\n* `'iso8601'` will serialize date-like types to [ISO 8601 text format](https://en.wikipedia.org/wiki/ISO_8601#Durations).\n* `'milliseconds'` will serialize date-like types to a floating point number of milliseconds since the epoch.\n* `'seconds'` will serialize date-like types to a floating point number of seconds since the epoch.\n\nDefaults to `'iso8601'`.\n\nThis setting was introduced in v2.12. It overlaps with the [`ser_json_timedelta`](index.html#pydantic.config.ConfigDict.ser_json_timedelta)\nsetting which will be deprecated in v3. It also adds more configurability for\nthe other temporal types.", "url": "https://docs.pydantic.dev/latest/api/config/index.html#serjsontemporal-instance-attribute-indexhtmlpydanticconfigconfigdictserjsontemporal-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "val\\_temporal\\_unit `instance-attribute` [Â¶](index.html#pydantic.config.ConfigDict.val_temporal_unit \"Permanent link\")", "anchor": "valtemporalunit-instance-attribute-indexhtmlpydanticconfigconfigdictvaltemporalunit-permanent-link", "md_text": "```\nval_temporal_unit: Literal[\n    \"seconds\", \"milliseconds\", \"infer\"\n]\n```\n\nThe unit to assume for validating numeric input for datetime-like types ([`datetime.datetime`](https://docs.python.org/3/library/datetime.html#datetime.datetime) and [`datetime.date`](https://docs.python.org/3/library/datetime.html#datetime.date)). Can be one of:\n\n* `'seconds'` will validate date or time numeric inputs as seconds since the [epoch](https://en.wikipedia.org/wiki/Unix_time).\n* `'milliseconds'` will validate date or time numeric inputs as milliseconds since the [epoch](https://en.wikipedia.org/wiki/Unix_time).\n* `'infer'` will infer the unit from the string numeric input on unix time as:\n\n  + seconds since the [epoch](https://en.wikipedia.org/wiki/Unix_time) if \\(-2^{10} <= v <= 2^{10}\\)\n  + milliseconds since the [epoch](https://en.wikipedia.org/wiki/Unix_time) (if \\(v < -2^{10}\\) or \\(v > 2^{10}\\)).\n\nDefaults to `'infer'`.", "url": "https://docs.pydantic.dev/latest/api/config/index.html#valtemporalunit-instance-attribute-indexhtmlpydanticconfigconfigdictvaltemporalunit-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "ser\\_json\\_bytes `instance-attribute` [Â¶](index.html#pydantic.config.ConfigDict.ser_json_bytes \"Permanent link\")", "anchor": "serjsonbytes-instance-attribute-indexhtmlpydanticconfigconfigdictserjsonbytes-permanent-link", "md_text": "```\nser_json_bytes: Literal['utf8', 'base64', 'hex']\n```\n\nThe encoding of JSON serialized bytes. Defaults to `'utf8'`.\nSet equal to `val_json_bytes` to get back an equal value after serialization round trip.\n\n* `'utf8'` will serialize bytes to UTF-8 strings.\n* `'base64'` will serialize bytes to URL safe base64 strings.\n* `'hex'` will serialize bytes to hexadecimal strings.", "url": "https://docs.pydantic.dev/latest/api/config/index.html#serjsonbytes-instance-attribute-indexhtmlpydanticconfigconfigdictserjsonbytes-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "val\\_json\\_bytes `instance-attribute` [Â¶](index.html#pydantic.config.ConfigDict.val_json_bytes \"Permanent link\")", "anchor": "valjsonbytes-instance-attribute-indexhtmlpydanticconfigconfigdictvaljsonbytes-permanent-link", "md_text": "```\nval_json_bytes: Literal['utf8', 'base64', 'hex']\n```\n\nThe encoding of JSON serialized bytes to decode. Defaults to `'utf8'`.\nSet equal to `ser_json_bytes` to get back an equal value after serialization round trip.\n\n* `'utf8'` will deserialize UTF-8 strings to bytes.\n* `'base64'` will deserialize URL safe base64 strings to bytes.\n* `'hex'` will deserialize hexadecimal strings to bytes.", "url": "https://docs.pydantic.dev/latest/api/config/index.html#valjsonbytes-instance-attribute-indexhtmlpydanticconfigconfigdictvaljsonbytes-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "ser\\_json\\_inf\\_nan `instance-attribute` [Â¶](index.html#pydantic.config.ConfigDict.ser_json_inf_nan \"Permanent link\")", "anchor": "serjsoninfnan-instance-attribute-indexhtmlpydanticconfigconfigdictserjsoninfnan-permanent-link", "md_text": "```\nser_json_inf_nan: Literal['null', 'constants', 'strings']\n```\n\nThe encoding of JSON serialized infinity and NaN float values. Defaults to `'null'`.\n\n* `'null'` will serialize infinity and NaN values as `null`.\n* `'constants'` will serialize infinity and NaN values as `Infinity` and `NaN`.\n* `'strings'` will serialize infinity as string `\"Infinity\"` and NaN as string `\"NaN\"`.", "url": "https://docs.pydantic.dev/latest/api/config/index.html#serjsoninfnan-instance-attribute-indexhtmlpydanticconfigconfigdictserjsoninfnan-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "validate\\_default `instance-attribute` [Â¶](index.html#pydantic.config.ConfigDict.validate_default \"Permanent link\")", "anchor": "validatedefault-instance-attribute-indexhtmlpydanticconfigconfigdictvalidatedefault-permanent-link", "md_text": "```\nvalidate_default: bool\n```\n\nWhether to validate default values during validation. Defaults to `False`.", "url": "https://docs.pydantic.dev/latest/api/config/index.html#validatedefault-instance-attribute-indexhtmlpydanticconfigconfigdictvalidatedefault-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "validate\\_return `instance-attribute` [Â¶](index.html#pydantic.config.ConfigDict.validate_return \"Permanent link\")", "anchor": "validatereturn-instance-attribute-indexhtmlpydanticconfigconfigdictvalidatereturn-permanent-link", "md_text": "```\nvalidate_return: bool\n```\n\nWhether to validate the return value from call validators. Defaults to `False`.", "url": "https://docs.pydantic.dev/latest/api/config/index.html#validatereturn-instance-attribute-indexhtmlpydanticconfigconfigdictvalidatereturn-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "protected\\_namespaces `instance-attribute` [Â¶](index.html#pydantic.config.ConfigDict.protected_namespaces \"Permanent link\")", "anchor": "protectednamespaces-instance-attribute-indexhtmlpydanticconfigconfigdictprotectednamespaces-permanent-link", "md_text": "```\nprotected_namespaces: tuple[str | Pattern[str], ...]\n```\n\nA `tuple` of strings and/or patterns that prevent models from having fields with names that conflict with them.\nFor strings, we match on a prefix basis. Ex, if 'dog' is in the protected namespace, 'dog\\_name' will be protected.\nFor patterns, we match on the entire field name. Ex, if `re.compile(r'^dog$')` is in the protected namespace, 'dog' will be protected, but 'dog\\_name' will not be.\nDefaults to `('model_validate', 'model_dump',)`.\n\nThe reason we've selected these is to prevent collisions with other validation / dumping formats\nin the future - ex, `model_validate_{some_newly_supported_format}`.\n\nBefore v2.10, Pydantic used `('model_',)` as the default value for this setting to\nprevent collisions between model attributes and `BaseModel`'s own methods. This was changed\nin v2.10 given feedback that this restriction was limiting in AI and data science contexts,\nwhere it is common to have fields with names like `model_id`, `model_input`, `model_output`, etc.\n\nFor more details, see https://github.com/pydantic/pydantic/issues/10315.\n\n```\nimport warnings\n\nfrom pydantic import BaseModel\n\nwarnings.filterwarnings('error')  # Raise warnings as errors\n\ntry:\n\n    class Model(BaseModel):\n        model_dump_something: str\n\nexcept UserWarning as e:\n    print(e)\n    '''\n    Field 'model_dump_something' in 'Model' conflicts with protected namespace 'model_dump'.\n\n    You may be able to solve this by setting the 'protected_namespaces' configuration to ('model_validate',).\n    '''\n```\n\nYou can customize this behavior using the `protected_namespaces` setting:\n\n```\nimport re\nimport warnings\n\nfrom pydantic import BaseModel, ConfigDict\n\nwith warnings.catch_warnings(record=True) as caught_warnings:\n    warnings.simplefilter('always')  # Catch all warnings\n\n    class Model(BaseModel):\n        safe_field: str\n        also_protect_field: str\n        protect_this: str\n\n        model_config = ConfigDict(\n            protected_namespaces=(\n                'protect_me_',\n                'also_protect_',\n                re.compile('^protect_this$'),\n            )\n        )\n\nfor warning in caught_warnings:\n    print(f'{warning.message}')\n    '''\n    Field 'also_protect_field' in 'Model' conflicts with protected namespace 'also_protect_'.\n    You may be able to solve this by setting the 'protected_namespaces' configuration to ('protect_me_', re.compile('^protect_this$'))`.\n\n    Field 'protect_this' in 'Model' conflicts with protected namespace 're.compile('^protect_this$')'.\n    You may be able to solve this by setting the 'protected_namespaces' configuration to ('protect_me_', 'also_protect_')`.\n    '''\n```\n\nWhile Pydantic will only emit a warning when an item is in a protected namespace but does not actually have a collision,\nan error *is* raised if there is an actual collision with an existing attribute:\n\n```\nfrom pydantic import BaseModel, ConfigDict\n\ntry:\n\n    class Model(BaseModel):\n        model_validate: str\n\n        model_config = ConfigDict(protected_namespaces=('model_',))\n\nexcept ValueError as e:\n    print(e)\n    '''\n    Field 'model_validate' conflicts with member <bound method BaseModel.model_validate of <class 'pydantic.main.BaseModel'>> of protected namespace 'model_'.\n    '''\n```", "url": "https://docs.pydantic.dev/latest/api/config/index.html#protectednamespaces-instance-attribute-indexhtmlpydanticconfigconfigdictprotectednamespaces-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "hide\\_input\\_in\\_errors `instance-attribute` [Â¶](index.html#pydantic.config.ConfigDict.hide_input_in_errors \"Permanent link\")", "anchor": "hideinputinerrors-instance-attribute-indexhtmlpydanticconfigconfigdicthideinputinerrors-permanent-link", "md_text": "```\nhide_input_in_errors: bool\n```\n\nWhether to hide inputs when printing errors. Defaults to `False`.\n\nPydantic shows the input value and type when it raises `ValidationError` during the validation.\n\n```\nfrom pydantic import BaseModel, ValidationError\n\nclass Model(BaseModel):\n    a: str\n\ntry:\n    Model(a=123)\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for Model\n    a\n      Input should be a valid string [type=string_type, input_value=123, input_type=int]\n    '''\n```\n\nYou can hide the input value and type by setting the `hide_input_in_errors` config to `True`.\n\n```\nfrom pydantic import BaseModel, ConfigDict, ValidationError\n\nclass Model(BaseModel):\n    a: str\n    model_config = ConfigDict(hide_input_in_errors=True)\n\ntry:\n    Model(a=123)\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for Model\n    a\n      Input should be a valid string [type=string_type]\n    '''\n```", "url": "https://docs.pydantic.dev/latest/api/config/index.html#hideinputinerrors-instance-attribute-indexhtmlpydanticconfigconfigdicthideinputinerrors-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "defer\\_build `instance-attribute` [Â¶](index.html#pydantic.config.ConfigDict.defer_build \"Permanent link\")", "anchor": "deferbuild-instance-attribute-indexhtmlpydanticconfigconfigdictdeferbuild-permanent-link", "md_text": "```\ndefer_build: bool\n```\n\nWhether to defer model validator and serializer construction until the first model validation. Defaults to False.\n\nThis can be useful to avoid the overhead of building models which are only\nused nested within other models, or when you want to manually define type namespace via\n[`Model.model_rebuild(_types_namespace=...)`](../base_model/index.html#pydantic.BaseModel.model_rebuild).\n\nSince v2.10, this setting also applies to pydantic dataclasses and TypeAdapter instances.", "url": "https://docs.pydantic.dev/latest/api/config/index.html#deferbuild-instance-attribute-indexhtmlpydanticconfigconfigdictdeferbuild-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "plugin\\_settings `instance-attribute` [Â¶](index.html#pydantic.config.ConfigDict.plugin_settings \"Permanent link\")", "anchor": "pluginsettings-instance-attribute-indexhtmlpydanticconfigconfigdictpluginsettings-permanent-link", "md_text": "```\nplugin_settings: dict[str, object] | None\n```\n\nA `dict` of settings for plugins. Defaults to `None`.", "url": "https://docs.pydantic.dev/latest/api/config/index.html#pluginsettings-instance-attribute-indexhtmlpydanticconfigconfigdictpluginsettings-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "schema\\_generator `instance-attribute` [Â¶](index.html#pydantic.config.ConfigDict.schema_generator \"Permanent link\")", "anchor": "schemagenerator-instance-attribute-indexhtmlpydanticconfigconfigdictschemagenerator-permanent-link", "md_text": "```\nschema_generator: type[GenerateSchema] | None\n```\n\n`schema_generator` is deprecated in v2.10.\n\nPrior to v2.10, this setting was advertised as highly subject to change.\nIt's possible that this interface may once again become public once the internal core schema generation\nAPI is more stable, but that will likely come after significant performance improvements have been made.", "url": "https://docs.pydantic.dev/latest/api/config/index.html#schemagenerator-instance-attribute-indexhtmlpydanticconfigconfigdictschemagenerator-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "json\\_schema\\_serialization\\_defaults\\_required `instance-attribute` [Â¶](index.html#pydantic.config.ConfigDict.json_schema_serialization_defaults_required \"Permanent link\")", "anchor": "jsonschemaserializationdefaultsrequired-instance-attribute-indexhtmlpydanticconfigconfigdictjsonschemaserializationdefaultsrequired-permanent-link", "md_text": "```\njson_schema_serialization_defaults_required: bool\n```\n\nWhether fields with default values should be marked as required in the serialization schema. Defaults to `False`.\n\nThis ensures that the serialization schema will reflect the fact a field with a default will always be present\nwhen serializing the model, even though it is not required for validation.\n\nHowever, there are scenarios where this may be undesirable â€” in particular, if you want to share the schema\nbetween validation and serialization, and don't mind fields with defaults being marked as not required during\nserialization. See [#7209](https://github.com/pydantic/pydantic/issues/7209) for more details.\n\n```\nfrom pydantic import BaseModel, ConfigDict\n\nclass Model(BaseModel):\n    a: str = 'a'\n\n    model_config = ConfigDict(json_schema_serialization_defaults_required=True)\n\nprint(Model.model_json_schema(mode='validation'))\n'''\n{\n    'properties': {'a': {'default': 'a', 'title': 'A', 'type': 'string'}},\n    'title': 'Model',\n    'type': 'object',\n}\n'''\nprint(Model.model_json_schema(mode='serialization'))\n'''\n{\n    'properties': {'a': {'default': 'a', 'title': 'A', 'type': 'string'}},\n    'required': ['a'],\n    'title': 'Model',\n    'type': 'object',\n}\n'''\n```", "url": "https://docs.pydantic.dev/latest/api/config/index.html#jsonschemaserializationdefaultsrequired-instance-attribute-indexhtmlpydanticconfigconfigdictjsonschemaserializationdefaultsrequired-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "json\\_schema\\_mode\\_override `instance-attribute` [Â¶](index.html#pydantic.config.ConfigDict.json_schema_mode_override \"Permanent link\")", "anchor": "jsonschemamodeoverride-instance-attribute-indexhtmlpydanticconfigconfigdictjsonschemamodeoverride-permanent-link", "md_text": "```\njson_schema_mode_override: Literal[\n    \"validation\", \"serialization\", None\n]\n```\n\nIf not `None`, the specified mode will be used to generate the JSON schema regardless of what `mode` was passed to\nthe function call. Defaults to `None`.\n\nThis provides a way to force the JSON schema generation to reflect a specific mode, e.g., to always use the\nvalidation schema.\n\nIt can be useful when using frameworks (such as FastAPI) that may generate different schemas for validation\nand serialization that must both be referenced from the same schema; when this happens, we automatically append\n`-Input` to the definition reference for the validation schema and `-Output` to the definition reference for the\nserialization schema. By specifying a `json_schema_mode_override` though, this prevents the conflict between\nthe validation and serialization schemas (since both will use the specified schema), and so prevents the suffixes\nfrom being added to the definition references.\n\n```\nfrom pydantic import BaseModel, ConfigDict, Json\n\nclass Model(BaseModel):\n    a: Json[int]  # requires a string to validate, but will dump an int\n\nprint(Model.model_json_schema(mode='serialization'))\n'''\n{\n    'properties': {'a': {'title': 'A', 'type': 'integer'}},\n    'required': ['a'],\n    'title': 'Model',\n    'type': 'object',\n}\n'''\n\nclass ForceInputModel(Model):\n    # the following ensures that even with mode='serialization', we\n    # will get the schema that would be generated for validation.\n    model_config = ConfigDict(json_schema_mode_override='validation')\n\nprint(ForceInputModel.model_json_schema(mode='serialization'))\n'''\n{\n    'properties': {\n        'a': {\n            'contentMediaType': 'application/json',\n            'contentSchema': {'type': 'integer'},\n            'title': 'A',\n            'type': 'string',\n        }\n    },\n    'required': ['a'],\n    'title': 'ForceInputModel',\n    'type': 'object',\n}\n'''\n```", "url": "https://docs.pydantic.dev/latest/api/config/index.html#jsonschemamodeoverride-instance-attribute-indexhtmlpydanticconfigconfigdictjsonschemamodeoverride-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "coerce\\_numbers\\_to\\_str `instance-attribute` [Â¶](index.html#pydantic.config.ConfigDict.coerce_numbers_to_str \"Permanent link\")", "anchor": "coercenumberstostr-instance-attribute-indexhtmlpydanticconfigconfigdictcoercenumberstostr-permanent-link", "md_text": "```\ncoerce_numbers_to_str: bool\n```\n\nIf `True`, enables automatic coercion of any `Number` type to `str` in \"lax\" (non-strict) mode. Defaults to `False`.\n\nPydantic doesn't allow number types (`int`, `float`, `Decimal`) to be coerced as type `str` by default.\n\n```\nfrom decimal import Decimal\n\nfrom pydantic import BaseModel, ConfigDict, ValidationError\n\nclass Model(BaseModel):\n    value: str\n\ntry:\n    print(Model(value=42))\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for Model\n    value\n      Input should be a valid string [type=string_type, input_value=42, input_type=int]\n    '''\n\nclass Model(BaseModel):\n    model_config = ConfigDict(coerce_numbers_to_str=True)\n\n    value: str\n\nrepr(Model(value=42).value)\n#> \"42\"\nrepr(Model(value=42.13).value)\n#> \"42.13\"\nrepr(Model(value=Decimal('42.13')).value)\n#> \"42.13\"\n```", "url": "https://docs.pydantic.dev/latest/api/config/index.html#coercenumberstostr-instance-attribute-indexhtmlpydanticconfigconfigdictcoercenumberstostr-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "regex\\_engine `instance-attribute` [Â¶](index.html#pydantic.config.ConfigDict.regex_engine \"Permanent link\")", "anchor": "regexengine-instance-attribute-indexhtmlpydanticconfigconfigdictregexengine-permanent-link", "md_text": "```\nregex_engine: Literal['rust-regex', 'python-re']\n```\n\nThe regex engine to be used for pattern validation.\nDefaults to `'rust-regex'`.\n\n* `'rust-regex'` uses the [`regex`](https://docs.rs/regex) Rust crate,\n  which is non-backtracking and therefore more DDoS resistant, but does not support all regex features.\n* `'python-re'` use the [`re`](https://docs.python.org/3/library/re.html#module-re) module, which supports all regex features, but may be slower.\n\nIf you use a compiled regex pattern, the `'python-re'` engine will be used regardless of this setting.\nThis is so that flags such as [`re.IGNORECASE`](https://docs.python.org/3/library/re.html#re.IGNORECASE) are respected.\n\n```\nfrom pydantic import BaseModel, ConfigDict, Field, ValidationError\n\nclass Model(BaseModel):\n    model_config = ConfigDict(regex_engine='python-re')\n\n    value: str = Field(pattern=r'^abc(?=def)')\n\nprint(Model(value='abcdef').value)\n#> abcdef\n\ntry:\n    print(Model(value='abxyzcdef'))\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for Model\n    value\n      String should match pattern '^abc(?=def)' [type=string_pattern_mismatch, input_value='abxyzcdef', input_type=str]\n    '''\n```", "url": "https://docs.pydantic.dev/latest/api/config/index.html#regexengine-instance-attribute-indexhtmlpydanticconfigconfigdictregexengine-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "validation\\_error\\_cause `instance-attribute` [Â¶](index.html#pydantic.config.ConfigDict.validation_error_cause \"Permanent link\")", "anchor": "validationerrorcause-instance-attribute-indexhtmlpydanticconfigconfigdictvalidationerrorcause-permanent-link", "md_text": "```\nvalidation_error_cause: bool\n```\n\nIf `True`, Python exceptions that were part of a validation failure will be shown as an exception group as a cause. Can be useful for debugging. Defaults to `False`.\n\nNote\n\nPython 3.10 and older don't support exception groups natively. <=3.10, backport must be installed: `pip install exceptiongroup`.\n\n\nNote\n\nThe structure of validation errors are likely to change in future Pydantic versions. Pydantic offers no guarantees about their structure. Should be used for visual traceback debugging only.", "url": "https://docs.pydantic.dev/latest/api/config/index.html#validationerrorcause-instance-attribute-indexhtmlpydanticconfigconfigdictvalidationerrorcause-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "use\\_attribute\\_docstrings `instance-attribute` [Â¶](index.html#pydantic.config.ConfigDict.use_attribute_docstrings \"Permanent link\")", "anchor": "useattributedocstrings-instance-attribute-indexhtmlpydanticconfigconfigdictuseattributedocstrings-permanent-link", "md_text": "```\nuse_attribute_docstrings: bool\n```\n\nWhether docstrings of attributes (bare string literals immediately following the attribute declaration)\nshould be used for field descriptions. Defaults to `False`.\n\nAvailable in Pydantic v2.7+.\n\n```\nfrom pydantic import BaseModel, ConfigDict, Field\n\n\nclass Model(BaseModel):\n    model_config = ConfigDict(use_attribute_docstrings=True)\n\n    x: str\n    \"\"\"\n    Example of an attribute docstring\n    \"\"\"\n\n    y: int = Field(description=\"Description in Field\")\n    \"\"\"\n    Description in Field overrides attribute docstring\n    \"\"\"\n\n\nprint(Model.model_fields[\"x\"].description)\n# > Example of an attribute docstring\nprint(Model.model_fields[\"y\"].description)\n# > Description in Field\n```\n\nThis requires the source code of the class to be available at runtime.\n\nDue to current limitations, attribute docstrings detection may not work as expected when using\n[`TypedDict`](https://docs.python.org/3/library/typing.html#typing.TypedDict) and stdlib dataclasses, in particular when:\n\n* inheritance is being used.\n* multiple classes have the same name in the same source file (unless Python 3.13 or greater is used).", "url": "https://docs.pydantic.dev/latest/api/config/index.html#useattributedocstrings-instance-attribute-indexhtmlpydanticconfigconfigdictuseattributedocstrings-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "cache\\_strings `instance-attribute` [Â¶](index.html#pydantic.config.ConfigDict.cache_strings \"Permanent link\")", "anchor": "cachestrings-instance-attribute-indexhtmlpydanticconfigconfigdictcachestrings-permanent-link", "md_text": "```\ncache_strings: bool | Literal['all', 'keys', 'none']\n```\n\nWhether to cache strings to avoid constructing new Python objects. Defaults to True.\n\nEnabling this setting should significantly improve validation performance while increasing memory usage slightly.\n\n* `True` or `'all'` (the default): cache all strings\n* `'keys'`: cache only dictionary keys\n* `False` or `'none'`: no caching\n\n`True` or `'all'` is required to cache strings during general validation because\nvalidators don't know if they're in a key or a value.\n\nIf repeated strings are rare, it's recommended to use `'keys'` or `'none'` to reduce memory usage,\nas the performance difference is minimal if repeated strings are rare.", "url": "https://docs.pydantic.dev/latest/api/config/index.html#cachestrings-instance-attribute-indexhtmlpydanticconfigconfigdictcachestrings-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "validate\\_by\\_alias `instance-attribute` [Â¶](index.html#pydantic.config.ConfigDict.validate_by_alias \"Permanent link\")", "anchor": "validatebyalias-instance-attribute-indexhtmlpydanticconfigconfigdictvalidatebyalias-permanent-link", "md_text": "```\nvalidate_by_alias: bool\n```\n\nWhether an aliased field may be populated by its alias. Defaults to `True`.\n\nIn v2.11, `validate_by_alias` was introduced in conjunction with [`validate_by_name`](index.html#pydantic.config.ConfigDict.validate_by_name)\nto empower users with more fine grained validation control. In", "url": "https://docs.pydantic.dev/latest/api/config/index.html#validatebyalias-instance-attribute-indexhtmlpydanticconfigconfigdictvalidatebyalias-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "validate\\_by\\_name `instance-attribute` [Â¶](index.html#pydantic.config.ConfigDict.validate_by_name \"Permanent link\")", "anchor": "validatebyname-instance-attribute-indexhtmlpydanticconfigconfigdictvalidatebyname-permanent-link", "md_text": "```\nvalidate_by_name: bool\n```\n\nWhether an aliased field may be populated by its name as given by the model\nattribute. Defaults to `False`.\n\nIn v2.0-v2.10, the `populate_by_name` configuration setting was used to specify\nwhether or not a field could be populated by its name **and** alias.\n\nIn v2.11, `validate_by_name` was introduced in conjunction with [`validate_by_alias`](index.html#pydantic.config.ConfigDict.validate_by_alias)\nto empower users with more fine grained validation behavior control.\n\n```\nfrom pydantic import BaseModel, ConfigDict, Field\n\nclass Model(BaseModel):\n    model_config = ConfigDict(validate_by_name=True, validate_by_alias=True)\n\n    my_field: str = Field(validation_alias='my_alias')  # (1)!\n\nm = Model(my_alias='foo')  # (2)!\nprint(m)\n#> my_field='foo'\n\nm = Model(my_field='foo')  # (3)!\nprint(m)\n#> my_field='foo'\n```\n\n1. The field `'my_field'` has an alias `'my_alias'`.\n2. The model is populated by the alias `'my_alias'`.\n3. The model is populated by the attribute name `'my_field'`.\n\nYou cannot set both `validate_by_alias` and `validate_by_name` to `False`.\nThis would make it impossible to populate an attribute.\n\nSee [usage errors](../../errors/usage_errors/index.html#validate-by-alias-and-name-false) for an example.", "url": "https://docs.pydantic.dev/latest/api/config/index.html#validatebyname-instance-attribute-indexhtmlpydanticconfigconfigdictvalidatebyname-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "serialize\\_by\\_alias `instance-attribute` [Â¶](index.html#pydantic.config.ConfigDict.serialize_by_alias \"Permanent link\")", "anchor": "serializebyalias-instance-attribute-indexhtmlpydanticconfigconfigdictserializebyalias-permanent-link", "md_text": "```\nserialize_by_alias: bool\n```\n\nWhether an aliased field should be serialized by its alias. Defaults to `False`.\n\nNote: In v2.11, `serialize_by_alias` was introduced to address the\n[popular request](https://github.com/pydantic/pydantic/issues/8379)\nfor consistency with alias behavior for validation and serialization settings.\nIn v3, the default value is expected to change to `True` for consistency with the validation default.\n\n```\nfrom pydantic import BaseModel, ConfigDict, Field\n\nclass Model(BaseModel):\n    model_config = ConfigDict(serialize_by_alias=True)\n\n    my_field: str = Field(serialization_alias='my_alias')  # (1)!\n\nm = Model(my_field='foo')\nprint(m.model_dump())  # (2)!\n#> {'my_alias': 'foo'}\n```\n\n1. The field `'my_field'` has an alias `'my_alias'`.\n2. The model is serialized using the alias `'my_alias'` for the `'my_field'` attribute.", "url": "https://docs.pydantic.dev/latest/api/config/index.html#serializebyalias-instance-attribute-indexhtmlpydanticconfigconfigdictserializebyalias-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "url\\_preserve\\_empty\\_path `instance-attribute` [Â¶](index.html#pydantic.config.ConfigDict.url_preserve_empty_path \"Permanent link\")", "anchor": "urlpreserveemptypath-instance-attribute-indexhtmlpydanticconfigconfigdicturlpreserveemptypath-permanent-link", "md_text": "```\nurl_preserve_empty_path: bool\n```\n\nWhether to preserve empty URL paths when validating values for a URL type. Defaults to `False`.\n\n```\nfrom pydantic import AnyUrl, BaseModel, ConfigDict\n\nclass Model(BaseModel):\n    model_config = ConfigDict(url_preserve_empty_path=True)\n\n    url: AnyUrl\n\nm = Model(url='http://example.com')\nprint(m.url)\n#> http://example.com\n```", "url": "https://docs.pydantic.dev/latest/api/config/index.html#urlpreserveemptypath-instance-attribute-indexhtmlpydanticconfigconfigdicturlpreserveemptypath-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "with\\_config [Â¶](index.html#pydantic.config.with_config \"Permanent link\")", "anchor": "withconfig-indexhtmlpydanticconfigwithconfig-permanent-link", "md_text": "```\nwith_config(\n    *, config: ConfigDict\n) -> Callable[[_TypeT], _TypeT]\n\nwith_config(\n    config: ConfigDict,\n) -> Callable[[_TypeT], _TypeT]\n\nwith_config(\n    **config: Unpack[ConfigDict],\n) -> Callable[[_TypeT], _TypeT]\n\nwith_config(\n    config: ConfigDict | None = None, /, **kwargs: Any\n) -> Callable[[_TypeT], _TypeT]\n```\n\n[Configuration with other types](../../concepts/config/index.html#configuration-on-other-supported-types)\n\nA convenience decorator to set a [Pydantic configuration](index.html) on a `TypedDict` or a `dataclass` from the standard library.\n\nAlthough the configuration can be set using the `__pydantic_config__` attribute, it does not play well with type checkers,\nespecially with `TypedDict`.\n\n```\nfrom typing_extensions import TypedDict\n\nfrom pydantic import ConfigDict, TypeAdapter, with_config\n\n@with_config(ConfigDict(str_to_lower=True))\nclass TD(TypedDict):\n    x: str\n\nta = TypeAdapter(TD)\n\nprint(ta.validate_python({'x': 'ABC'}))\n#> {'x': 'abc'}\n```\n\nSource code in `pydantic/config.py`\n\n|  |  |\n| --- | --- |\n| ``` 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 ``` | ``` def with_config(config: ConfigDict | None = None, /, **kwargs: Any) -> Callable[[_TypeT], _TypeT]:     \"\"\"!!! abstract \"Usage Documentation\"         [Configuration with other types](../concepts/config.md#configuration-on-other-supported-types)      A convenience decorator to set a [Pydantic configuration](config.md) on a `TypedDict` or a `dataclass` from the standard library.      Although the configuration can be set using the `__pydantic_config__` attribute, it does not play well with type checkers,     especially with `TypedDict`.      !!! example \"Usage\"          ```python         from typing_extensions import TypedDict          from pydantic import ConfigDict, TypeAdapter, with_config          @with_config(ConfigDict(str_to_lower=True))         class TD(TypedDict):             x: str          ta = TypeAdapter(TD)          print(ta.validate_python({'x': 'ABC'}))         #> {'x': 'abc'}         ```     \"\"\"     if config is not None and kwargs:         raise ValueError('Cannot specify both `config` and keyword arguments')      if len(kwargs) == 1 and (kwargs_conf := kwargs.get('config')) is not None:         warnings.warn(             'Passing `config` as a keyword argument is deprecated. Pass `config` as a positional argument instead',             category=PydanticDeprecatedSince211,             stacklevel=2,         )         final_config = cast(ConfigDict, kwargs_conf)     else:         final_config = config if config is not None else cast(ConfigDict, kwargs)      def inner(class_: _TypeT, /) -> _TypeT:         # Ideally, we would check for `class_` to either be a `TypedDict` or a stdlib dataclass.         # However, the `@with_config` decorator can be applied *after* `@dataclass`. To avoid         # common mistakes, we at least check for `class_` to not be a Pydantic model.         from ._internal._utils import is_model_class          if is_model_class(class_):             raise PydanticUserError(                 f'Cannot use `with_config` on {class_.__name__} as it is a Pydantic model',                 code='with-config-on-model',             )         class_.__pydantic_config__ = final_config         return class_      return inner ``` |", "url": "https://docs.pydantic.dev/latest/api/config/index.html#withconfig-indexhtmlpydanticconfigwithconfig-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "ExtraValues `module-attribute` [Â¶](index.html#pydantic.config.ExtraValues \"Permanent link\")", "anchor": "extravalues-module-attribute-indexhtmlpydanticconfigextravalues-permanent-link", "md_text": "```\nExtraValues = Literal['allow', 'ignore', 'forbid']\n```", "url": "https://docs.pydantic.dev/latest/api/config/index.html#extravalues-module-attribute-indexhtmlpydanticconfigextravalues-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "pydantic.alias\\_generators [Â¶](index.html#pydantic.alias_generators \"Permanent link\")", "anchor": "pydanticaliasgenerators-indexhtmlpydanticaliasgenerators-permanent-link", "md_text": "Alias generators for converting between different capitalization conventions.", "url": "https://docs.pydantic.dev/latest/api/config/index.html#pydanticaliasgenerators-indexhtmlpydanticaliasgenerators-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "to\\_pascal [Â¶](index.html#pydantic.alias_generators.to_pascal \"Permanent link\")", "anchor": "topascal-indexhtmlpydanticaliasgeneratorstopascal-permanent-link", "md_text": "```\nto_pascal(snake: str) -> str\n```\n\nConvert a snake\\_case string to PascalCase.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `snake` | `str` | The string to convert. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `str` | The PascalCase string. |\n\nSource code in `pydantic/alias_generators.py`\n\n|  |  |\n| --- | --- |\n| ``` 12 13 14 15 16 17 18 19 20 21 22 ``` | ``` def to_pascal(snake: str) -> str:     \"\"\"Convert a snake_case string to PascalCase.      Args:         snake: The string to convert.      Returns:         The PascalCase string.     \"\"\"     camel = snake.title()     return re.sub('([0-9A-Za-z])_(?=[0-9A-Z])', lambda m: m.group(1), camel) ``` |", "url": "https://docs.pydantic.dev/latest/api/config/index.html#topascal-indexhtmlpydanticaliasgeneratorstopascal-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "to\\_camel [Â¶](index.html#pydantic.alias_generators.to_camel \"Permanent link\")", "anchor": "tocamel-indexhtmlpydanticaliasgeneratorstocamel-permanent-link", "md_text": "```\nto_camel(snake: str) -> str\n```\n\nConvert a snake\\_case string to camelCase.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `snake` | `str` | The string to convert. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `str` | The converted camelCase string. |\n\nSource code in `pydantic/alias_generators.py`\n\n|  |  |\n| --- | --- |\n| ``` 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 ``` | ``` def to_camel(snake: str) -> str:     \"\"\"Convert a snake_case string to camelCase.      Args:         snake: The string to convert.      Returns:         The converted camelCase string.     \"\"\"     # If the string is already in camelCase and does not contain a digit followed     # by a lowercase letter, return it as it is     if re.match('^[a-z]+[A-Za-z0-9]*$', snake) and not re.search(r'\\d[a-z]', snake):         return snake      camel = to_pascal(snake)     return re.sub('(^_*[A-Z])', lambda m: m.group(1).lower(), camel) ``` |", "url": "https://docs.pydantic.dev/latest/api/config/index.html#tocamel-indexhtmlpydanticaliasgeneratorstocamel-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "to\\_snake [Â¶](index.html#pydantic.alias_generators.to_snake \"Permanent link\")", "anchor": "tosnake-indexhtmlpydanticaliasgeneratorstosnake-permanent-link", "md_text": "```\nto_snake(camel: str) -> str\n```\n\nConvert a PascalCase, camelCase, or kebab-case string to snake\\_case.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `camel` | `str` | The string to convert. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `str` | The converted string in snake\\_case. |\n\nSource code in `pydantic/alias_generators.py`\n\n|  |  |\n| --- | --- |\n| ``` 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 ``` | ``` def to_snake(camel: str) -> str:     \"\"\"Convert a PascalCase, camelCase, or kebab-case string to snake_case.      Args:         camel: The string to convert.      Returns:         The converted string in snake_case.     \"\"\"     # Handle the sequence of uppercase letters followed by a lowercase letter     snake = re.sub(r'([A-Z]+)([A-Z][a-z])', lambda m: f'{m.group(1)}_{m.group(2)}', camel)     # Insert an underscore between a lowercase letter and an uppercase letter     snake = re.sub(r'([a-z])([A-Z])', lambda m: f'{m.group(1)}_{m.group(2)}', snake)     # Insert an underscore between a digit and an uppercase letter     snake = re.sub(r'([0-9])([A-Z])', lambda m: f'{m.group(1)}_{m.group(2)}', snake)     # Insert an underscore between a lowercase letter and a digit     snake = re.sub(r'([a-z])([0-9])', lambda m: f'{m.group(1)}_{m.group(2)}', snake)     # Replace hyphens with underscores to handle kebab-case     snake = snake.replace('-', '_')     return snake.lower() ``` |\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/api/config/index.html#tosnake-indexhtmlpydanticaliasgeneratorstosnake-permanent-link", "page": "api/config/index.html", "source_site": "pydantic"}
{"title": "ISO\\_15924 [Â¶](index.html#pydantic_extra_types.script_code.ISO_15924 \"Permanent link\")", "anchor": "iso15924-indexhtmlpydanticextratypesscriptcodeiso15924-permanent-link", "md_text": "Bases: `str`\n\nISO\\_15924 parses script in the [ISO 15924](https://en.wikipedia.org/wiki/ISO_15924)\nformat.\n\n```\nfrom pydantic import BaseModel\n\nfrom pydantic_extra_types.language_code import ISO_15924\n\n\nclass Script(BaseModel):\n    alpha_4: ISO_15924\n\n\nscript = Script(alpha_4='Java')\nprint(lang)\n# > script='Java'\n```\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_script_code/index.html#iso15924-indexhtmlpydanticextratypesscriptcodeiso15924-permanent-link", "page": "api/pydantic_extra_types_script_code/index.html", "source_site": "pydantic"}
{"title": "PydanticErrorMixin [Â¶](index.html#pydantic.errors.PydanticErrorMixin \"Permanent link\")", "anchor": "pydanticerrormixin-indexhtmlpydanticerrorspydanticerrormixin-permanent-link", "md_text": "```\nPydanticErrorMixin(\n    message: str, *, code: PydanticErrorCodes | None\n)\n```\n\nA mixin class for common functionality shared by all Pydantic-specific errors.\n\nAttributes:\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `message` |  | A message describing the error. |\n| `code` |  | An optional error code from PydanticErrorCodes enum. |\n\nSource code in `pydantic/errors.py`\n\n|  |  |\n| --- | --- |\n| ``` 90 91 92 ``` | ``` def __init__(self, message: str, *, code: PydanticErrorCodes | None) -> None:     self.message = message     self.code = code ``` |", "url": "https://docs.pydantic.dev/latest/api/errors/index.html#pydanticerrormixin-indexhtmlpydanticerrorspydanticerrormixin-permanent-link", "page": "api/errors/index.html", "source_site": "pydantic"}
{"title": "PydanticUserError [Â¶](index.html#pydantic.errors.PydanticUserError \"Permanent link\")", "anchor": "pydanticusererror-indexhtmlpydanticerrorspydanticusererror-permanent-link", "md_text": "```\nPydanticUserError(\n    message: str, *, code: PydanticErrorCodes | None\n)\n```\n\nBases: `PydanticErrorMixin`, `TypeError`\n\nAn error raised due to incorrect use of Pydantic.\n\nSource code in `pydantic/errors.py`\n\n|  |  |\n| --- | --- |\n| ``` 90 91 92 ``` | ``` def __init__(self, message: str, *, code: PydanticErrorCodes | None) -> None:     self.message = message     self.code = code ``` |", "url": "https://docs.pydantic.dev/latest/api/errors/index.html#pydanticusererror-indexhtmlpydanticerrorspydanticusererror-permanent-link", "page": "api/errors/index.html", "source_site": "pydantic"}
{"title": "PydanticUndefinedAnnotation [Â¶](index.html#pydantic.errors.PydanticUndefinedAnnotation \"Permanent link\")", "anchor": "pydanticundefinedannotation-indexhtmlpydanticerrorspydanticundefinedannotation-permanent-link", "md_text": "```\nPydanticUndefinedAnnotation(name: str, message: str)\n```\n\nBases: `PydanticErrorMixin`, `NameError`\n\nA subclass of `NameError` raised when handling undefined annotations during `CoreSchema` generation.\n\nAttributes:\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `name` |  | Name of the error. |\n| `message` |  | Description of the error. |\n\nSource code in `pydantic/errors.py`\n\n|  |  |\n| --- | --- |\n| ``` 113 114 115 ``` | ``` def __init__(self, name: str, message: str) -> None:     self.name = name     super().__init__(message=message, code='undefined-annotation') ``` |", "url": "https://docs.pydantic.dev/latest/api/errors/index.html#pydanticundefinedannotation-indexhtmlpydanticerrorspydanticundefinedannotation-permanent-link", "page": "api/errors/index.html", "source_site": "pydantic"}
{"title": "from\\_name\\_error `classmethod` [Â¶](index.html#pydantic.errors.PydanticUndefinedAnnotation.from_name_error \"Permanent link\")", "anchor": "fromnameerror-classmethod-indexhtmlpydanticerrorspydanticundefinedannotationfromnameerror-permanent-link", "md_text": "```\nfrom_name_error(name_error: NameError) -> Self\n```\n\nConvert a `NameError` to a `PydanticUndefinedAnnotation` error.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `name_error` | `NameError` | `NameError` to be converted. | *required* |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `Self` | Converted `PydanticUndefinedAnnotation` error. |\n\nSource code in `pydantic/errors.py`\n\n|  |  |\n| --- | --- |\n| ``` 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 ``` | ``` @classmethod def from_name_error(cls, name_error: NameError) -> Self:     \"\"\"Convert a `NameError` to a `PydanticUndefinedAnnotation` error.      Args:         name_error: `NameError` to be converted.      Returns:         Converted `PydanticUndefinedAnnotation` error.     \"\"\"     try:         name = name_error.name  # type: ignore  # python > 3.10     except AttributeError:         name = re.search(r\".*'(.+?)'\", str(name_error)).group(1)  # type: ignore[union-attr]     return cls(name=name, message=str(name_error)) ``` |", "url": "https://docs.pydantic.dev/latest/api/errors/index.html#fromnameerror-classmethod-indexhtmlpydanticerrorspydanticundefinedannotationfromnameerror-permanent-link", "page": "api/errors/index.html", "source_site": "pydantic"}
{"title": "PydanticImportError [Â¶](index.html#pydantic.errors.PydanticImportError \"Permanent link\")", "anchor": "pydanticimporterror-indexhtmlpydanticerrorspydanticimporterror-permanent-link", "md_text": "```\nPydanticImportError(message: str)\n```\n\nBases: `PydanticErrorMixin`, `ImportError`\n\nAn error raised when an import fails due to module changes between V1 and V2.\n\nAttributes:\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `message` |  | Description of the error. |\n\nSource code in `pydantic/errors.py`\n\n|  |  |\n| --- | --- |\n| ``` 141 142 ``` | ``` def __init__(self, message: str) -> None:     super().__init__(message, code='import-error') ``` |", "url": "https://docs.pydantic.dev/latest/api/errors/index.html#pydanticimporterror-indexhtmlpydanticerrorspydanticimporterror-permanent-link", "page": "api/errors/index.html", "source_site": "pydantic"}
{"title": "PydanticSchemaGenerationError [Â¶](index.html#pydantic.errors.PydanticSchemaGenerationError \"Permanent link\")", "anchor": "pydanticschemagenerationerror-indexhtmlpydanticerrorspydanticschemagenerationerror-permanent-link", "md_text": "```\nPydanticSchemaGenerationError(message: str)\n```\n\nBases: `PydanticUserError`\n\nAn error raised during failures to generate a `CoreSchema` for some type.\n\nAttributes:\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `message` |  | Description of the error. |\n\nSource code in `pydantic/errors.py`\n\n|  |  |\n| --- | --- |\n| ``` 152 153 ``` | ``` def __init__(self, message: str) -> None:     super().__init__(message, code='schema-for-unknown-type') ``` |", "url": "https://docs.pydantic.dev/latest/api/errors/index.html#pydanticschemagenerationerror-indexhtmlpydanticerrorspydanticschemagenerationerror-permanent-link", "page": "api/errors/index.html", "source_site": "pydantic"}
{"title": "PydanticInvalidForJsonSchema [Â¶](index.html#pydantic.errors.PydanticInvalidForJsonSchema \"Permanent link\")", "anchor": "pydanticinvalidforjsonschema-indexhtmlpydanticerrorspydanticinvalidforjsonschema-permanent-link", "md_text": "```\nPydanticInvalidForJsonSchema(message: str)\n```\n\nBases: `PydanticUserError`\n\nAn error raised during failures to generate a JSON schema for some `CoreSchema`.\n\nAttributes:\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `message` |  | Description of the error. |\n\nSource code in `pydantic/errors.py`\n\n|  |  |\n| --- | --- |\n| ``` 163 164 ``` | ``` def __init__(self, message: str) -> None:     super().__init__(message, code='invalid-for-json-schema') ``` |", "url": "https://docs.pydantic.dev/latest/api/errors/index.html#pydanticinvalidforjsonschema-indexhtmlpydanticerrorspydanticinvalidforjsonschema-permanent-link", "page": "api/errors/index.html", "source_site": "pydantic"}
{"title": "PydanticForbiddenQualifier [Â¶](index.html#pydantic.errors.PydanticForbiddenQualifier \"Permanent link\")", "anchor": "pydanticforbiddenqualifier-indexhtmlpydanticerrorspydanticforbiddenqualifier-permanent-link", "md_text": "```\nPydanticForbiddenQualifier(\n    qualifier: Qualifier, annotation: Any\n)\n```\n\nBases: `PydanticUserError`\n\nAn error raised if a forbidden type qualifier is found in a type annotation.\n\nSource code in `pydantic/errors.py`\n\n|  |  |\n| --- | --- |\n| ``` 179 180 181 182 183 184 185 186 ``` | ``` def __init__(self, qualifier: Qualifier, annotation: Any) -> None:     super().__init__(         message=(             f'The annotation {_repr.display_as_type(annotation)!r} contains the {self._qualifier_repr_map[qualifier]!r} '             f'type qualifier, which is invalid in the context it is defined.'         ),         code=None,     ) ``` |\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/api/errors/index.html#pydanticforbiddenqualifier-indexhtmlpydanticerrorspydanticforbiddenqualifier-permanent-link", "page": "api/errors/index.html", "source_site": "pydantic"}
{"title": "ULID `dataclass` [Â¶](index.html#pydantic_extra_types.ulid.ULID \"Permanent link\")", "anchor": "ulid-dataclass-indexhtmlpydanticextratypesulidulid-permanent-link", "md_text": "```\nULID(ulid: ULID)\n```\n\nBases: `Representation`\n\nA wrapper around [python-ulid](https://pypi.org/project/python-ulid/) package, which\nis a validate by the [ULID-spec](https://github.com/ulid/spec#implementations-in-other-languages).\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/api/pydantic_extra_types_ulid/index.html#ulid-dataclass-indexhtmlpydanticextratypesulidulid-permanent-link", "page": "api/pydantic_extra_types_ulid/index.html", "source_site": "pydantic"}
{"title": "The challenges of runtime evaluation[Â¶](index.html#the-challenges-of-runtime-evaluation \"Permanent link\")", "anchor": "the-challenges-of-runtime-evaluationindexhtmlthe-challenges-of-runtime-evaluation-permanent-link", "md_text": "Static type checkers make use of the AST to analyze the defined annotations.\nRegarding the previous example, this has the benefit of being able to understand what `MyType` refers to when analyzing\nthe class definition of `Foo`, even if `MyType` isn't yet defined at runtime.\n\nHowever, for runtime tools such as Pydantic, it is more challenging to correctly resolve these forward annotations.\nThe Python standard library provides some tools to do so ([`typing.get_type_hints()`](https://docs.python.org/3/library/typing.html#typing.get_type_hints),\n[`inspect.get_annotations()`](https://docs.python.org/3/library/inspect.html#inspect.get_annotations)), but they come with some limitations. Thus, they are\nbeing re-implemented in Pydantic with improved support for edge cases.\n\nAs Pydantic as grown, it's adapted to support many edge cases requiring irregular patterns for annotation evaluation.\nSome of these use cases aren't necessarily sound from a static type checking perspective. In v2.10, the internal\nlogic was refactored in an attempt to simplify and standardize annotation evaluation. Admittedly, backwards compatibility\nposed some challenges, and there is still some noticeable scar tissue in the codebase because of this.There's a hope that\n[PEP 649](https://peps.python.org/pep-0649/) (introduced in Python 3.14) will greatly simplify the process, especially when it comes to dealing with locals\nof a function.\n\nTo evaluate forward references, Pydantic roughly follows the same logic as described in the documentation of the\n[`typing.get_type_hints()`](https://docs.python.org/3/library/typing.html#typing.get_type_hints) function. That is, the built-in [`eval()`](https://docs.python.org/3/library/functions.html#eval) function is used\nby passing the forward reference, a global, and a local namespace. The namespace fetching logic is defined in the\nsections below.", "url": "https://docs.pydantic.dev/latest/internals/resolving_annotations/index.html#the-challenges-of-runtime-evaluationindexhtmlthe-challenges-of-runtime-evaluation-permanent-link", "page": "internals/resolving_annotations/index.html", "source_site": "pydantic"}
{"title": "Resolving annotations at class definition[Â¶](index.html#resolving-annotations-at-class-definition \"Permanent link\")", "anchor": "resolving-annotations-at-class-definitionindexhtmlresolving-annotations-at-class-definition-permanent-link", "md_text": "The following example will be used as a reference throughout this section:\n\n```\n# module1.py:\ntype MyType = int\n\nclass Base:\n    f1: 'MyType'\n\n# module2.py:\nfrom pydantic import BaseModel\n\nfrom module1 import Base\n\ntype MyType = str\n\n\ndef inner() -> None:\n    type InnerType = bool\n\n    class Model(BaseModel, Base):\n        type LocalType = bytes\n\n        f2: 'MyType'\n        f3: 'InnerType'\n        f4: 'LocalType'\n        f5: 'UnknownType'\n\n    type InnerType2 = complex\n```\n\nWhen the `Model` class is being built, different [namespaces](https://docs.python.org/3/glossary.html#term-namespace) are at play. For each base class\nof the `Model`'s [MRO](https://docs.python.org/3/glossary.html#term-method-resolution-order) (in reverse order â€” that is, starting with `Base`), the\nfollowing logic is applied:\n\n1. Fetch the `__annotations__` key from the current base class' `__dict__`, if present. For `Base`, this will be\n   `{'f1': 'MyType'}`.\n2. Iterate over the `__annotations__` items and try to evaluate the annotation [1](index.html#fn:1) using a custom wrapper around\n   the built-in [`eval()`](https://docs.python.org/3/library/functions.html#eval) function. This function takes two `globals` and `locals` arguments:\n   * The current module's `__dict__` is naturally used as `globals`. For `Base`, this will be\n     `sys.modules['module1'].__dict__`.\n   * For the `locals` argument, Pydantic will try to resolve symbols in the following namespaces, sorted by highest priority:\n     + A namespace created on the fly, containing the current class name (`{cls.__name__: cls}`). This is done\n       in order to support recursive references.\n     + The locals of the current class (i.e. `cls.__dict__`). For `Model`, this will include `LocalType`.\n     + The parent namespace of the class, if different from the globals described above. This is the\n       [locals](https://docs.python.org/3/reference/datamodel.html#frame.f_locals) of the frame where the class is being defined. For `Base`, because the class is being\n       defined in the module directly, this namespace won't be used as it will result in the globals being used again.\n       For `Model`, the parent namespace is the locals of the frame of `inner()`.\n3. If the annotation failed to evaluate, it is kept as is, so that the model can be rebuilt at a later stage. This will\n   be the case for `f5`.\n\nThe following table lists the resolved type annotations for every field, once the `Model` class has been created:\n\n| Field name | Resolved annotation |\n| --- | --- |\n| `f1` | [`int`](https://docs.python.org/3/library/functions.html#int) |\n| `f2` | [`str`](https://docs.python.org/3/library/stdtypes.html#str) |\n| `f3` | [`bool`](https://docs.python.org/3/library/functions.html#bool) |\n| `f4` | [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes) |\n| `f5` | `'UnknownType'` |", "url": "https://docs.pydantic.dev/latest/internals/resolving_annotations/index.html#resolving-annotations-at-class-definitionindexhtmlresolving-annotations-at-class-definition-permanent-link", "page": "internals/resolving_annotations/index.html", "source_site": "pydantic"}
{"title": "Limitations and backwards compatibility concerns[Â¶](index.html#limitations-and-backwards-compatibility-concerns \"Permanent link\")", "anchor": "limitations-and-backwards-compatibility-concernsindexhtmllimitations-and-backwards-compatibility-concerns-permanent-link", "md_text": "While the namespace fetching logic is trying to be as accurate as possible, we still face some limitations:\n\n* The locals of the current class (`cls.__dict__`) may include irrelevant entries, most of them being dunder attributes.\n  This means that the following annotation: `f: '__doc__'` will successfully (and unexpectedly) be resolved.\n* When the `Model` class is being created inside a function, we keep a copy of the [locals](https://docs.python.org/3/reference/datamodel.html#frame.f_locals) of the frame.\n  This copy only includes the symbols defined in the locals when `Model` is being defined, meaning `InnerType2` won't be included\n  (and will **not be** if doing a model rebuild at a later point!).\n  + To avoid memory leaks, we use [weak references](https://docs.python.org/3/library/weakref.html#module-weakref) to the locals of the function, meaning some forward references might\n    not resolve outside the function (1).\n  + Locals of the function are only taken into account for Pydantic models, but this pattern does not apply to dataclasses, typed\n    dictionaries or named tuples.\n\n1. Here is an example:\n\n   ```\n   def func():\n       A = int\n\n       class Model(BaseModel):\n           f: 'A | Forward'\n\n       return Model\n\n\n   Model = func()\n\n   Model.model_rebuild(_types_namespace={'Forward': str})\n   # pydantic.errors.PydanticUndefinedAnnotation: name 'A' is not defined\n   ```\n\nFor backwards compatibility reasons, and to be able to support valid use cases without having to rebuild models,\nthe namespace logic described above is a bit different when it comes to core schema generation.\nTaking the following example:\n\n```\nfrom dataclasses import dataclass\n\nfrom pydantic import BaseModel\n\n\n@dataclass\nclass Foo:\n    a: 'Bar | None' = None\n\n\nclass Bar(BaseModel):\n    b: Foo\n```\n\nOnce the fields for `Bar` have been collected (meaning annotations resolved), the `GenerateSchema` class converts\nevery field into a core schema. When it encounters another class-like field type (such as a dataclass), it will\ntry to evaluate annotations, following roughly the same logic as [described above](index.html#resolving-annotations-at-class-definition).\nHowever, to evaluate the `'Bar | None'` annotation, `Bar` needs to be present in the globals or locals, which is normally\n*not* the case: `Bar` is being created, so it is not \"assigned\" to the current module's `__dict__` at that point.\n\nTo avoid having to call [`model_rebuild()`](../../api/base_model/index.html#pydantic.BaseModel.model_rebuild) on `Bar`, both the parent namespace\n(if `Bar` was to be defined inside a function, and [the namespace provided during a model rebuild](index.html#model-rebuild-semantics))\nand the `{Bar.__name__: Bar}` namespace are included in the locals during annotations evaluation of `Foo`\n(with the lowest priority) (1).\n\n1. This backwards compatibility logic can introduce some inconsistencies, such as the following:\n\n   ```\n   from dataclasses import dataclass\n\n   from pydantic import BaseModel\n\n\n   @dataclass\n   class Foo:\n       # `a` and `b` shouldn't resolve:\n       a: 'Model'\n       b: 'Inner'\n\n\n   def func():\n       Inner = int\n\n       class Model(BaseModel):\n           foo: Foo\n\n       Model.__pydantic_complete__\n       #> True, should be False.\n   ```", "url": "https://docs.pydantic.dev/latest/internals/resolving_annotations/index.html#limitations-and-backwards-compatibility-concernsindexhtmllimitations-and-backwards-compatibility-concerns-permanent-link", "page": "internals/resolving_annotations/index.html", "source_site": "pydantic"}
{"title": "Resolving annotations when rebuilding a model[Â¶](index.html#resolving-annotations-when-rebuilding-a-model \"Permanent link\")", "anchor": "resolving-annotations-when-rebuilding-a-modelindexhtmlresolving-annotations-when-rebuilding-a-model-permanent-link", "md_text": "When a forward reference fails to evaluate, Pydantic will silently fail and stop the core schema\ngeneration process. This can be seen by inspecting the `__pydantic_core_schema__` of a model class:\n\n```\nfrom pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    f: 'MyType'\n\n\nFoo.__pydantic_core_schema__\n#> <pydantic._internal._mock_val_ser.MockCoreSchema object at 0x73cd0d9e6d00>\n```\n\nIf you then properly define `MyType`, you can rebuild the model:\n\n```\ntype MyType = int\n\nFoo.model_rebuild()\nFoo.__pydantic_core_schema__\n#> {'type': 'model', 'schema': {...}, ...}\n```\n\nThe [`model_rebuild()`](../../api/base_model/index.html#pydantic.BaseModel.model_rebuild) method uses a *rebuild namespace*, with the following semantics:\n\n* If an explicit `_types_namespace` argument is provided, it is used as the rebuild namespace.\n* If no namespace is provided, the namespace where the method is called will be used as the rebuild namespace.\n\nThis *rebuild namespace* will be merged with the model's parent namespace (if it was defined in a function) and used as is\n(see the [backwards compatibility logic](index.html#backwards-compatibility-logic) described above).\n\n---\n\n1. This is done unconditionally, as forward annotations can be only present *as part* of a type hint (e.g. `Optional['int']`), as dictated by\n   the [typing specification](https://typing.readthedocs.io/en/latest/spec/annotations.html#string-annotations).Â [â†©](index.html#fnref:1 \"Jump back to footnote 1 in the text\")\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/internals/resolving_annotations/index.html#resolving-annotations-when-rebuilding-a-modelindexhtmlresolving-annotations-when-rebuilding-a-model-permanent-link", "page": "internals/resolving_annotations/index.html", "source_site": "pydantic"}
{"title": "Model definition[Â¶](index.html#model-definition \"Permanent link\")", "anchor": "model-definitionindexhtmlmodel-definition-permanent-link", "md_text": "Whenever a Pydantic [`BaseModel`](../../api/base_model/index.html#pydantic.BaseModel) is defined, the metaclass\nwill analyze the body of the model to collect a number of elements:\n\n* Defined annotations to build model fields (collected in the [`model_fields`](../../api/base_model/index.html#pydantic.BaseModel.model_fields) attribute).\n* Model configuration, set with [`model_config`](../../api/base_model/index.html#pydantic.BaseModel.model_config).\n* Additional validators/serializers.\n* Private attributes, class variables, identification of generic parametrization, etc.", "url": "https://docs.pydantic.dev/latest/internals/architecture/index.html#model-definitionindexhtmlmodel-definition-permanent-link", "page": "internals/architecture/index.html", "source_site": "pydantic"}
{"title": "Communicating between `pydantic` and `pydantic-core`: the core schema[Â¶](index.html#communicating-between-pydantic-and-pydantic-core-the-core-schema \"Permanent link\")", "anchor": "communicating-between-pydantic-and-pydantic-core-the-core-schemaindexhtmlcommunicating-between-pydantic-and-pydantic-core-the-core-schema-permanent-link", "md_text": "We then need a way to communicate the collected information from the model definition to `pydantic-core`,\nso that validation and serialization is performed accordingly. To do so, Pydantic uses the concept\nof a core schema: a structured (and serializable) Python dictionary (represented using\n[`TypedDict`](https://docs.python.org/3/library/typing.html#typing.TypedDict) definitions) describing a specific validation and serialization\nlogic. It is the core data structure used to communicate between the `pydantic` and `pydantic-core`\npackages. Every core schema has a required `type` key, and extra properties depending on this `type`.\n\nThe generation of a core schema is handled in a single place, by the `GenerateSchema` class\n(no matter if it is for a Pydantic model or anything else).\n\nIt is not possible to define a custom core schema. A core schema needs to be understood by the\n`pydantic-core` package, and as such we only support a fixed number of core schema types.\nThis is also part of the reason why the `GenerateSchema` isn't truly exposed and properly\ndocumented.\n\nThe core schema definitions can be found in the [`pydantic_core.core_schema`](../../api/pydantic_core_schema/index.html#pydantic_core.core_schema) module.\n\nIn the case of a Pydantic model, a core schema will be constructed and set as the\n[`__pydantic_core_schema__`](../../api/base_model/index.html#pydantic.BaseModel.__pydantic_core_schema__) attribute.\n\nTo illustrate what a core schema looks like, we will take the example of the\n[`bool`](../../api/pydantic_core_schema/index.html#pydantic_core.core_schema.bool_schema) core schema:\n\n```\nclass BoolSchema(TypedDict, total=False):\n    type: Required[Literal['bool']]\n    strict: bool\n    ref: str\n    metadata: Any\n    serialization: SerSchema\n```\n\nWhen defining a Pydantic model with a boolean field:\n\n```\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    foo: bool = Field(strict=True)\n```\n\nThe core schema for the `foo` field will look like:\n\n```\n{\n    'type': 'bool',\n    'strict': True,\n}\n```\n\nAs seen in the [`BoolSchema`](../../api/pydantic_core_schema/index.html#pydantic_core.core_schema.bool_schema) definition,\nthe serialization logic is also defined in the core schema.\nIf we were to define a custom serialization function for `foo` (1), the `serialization` key would look like:\n\n1. For example using the [`field_serializer`](../../api/functional_serializers/index.html#pydantic.functional_serializers.field_serializer) decorator:\n\n   ```\n   class Model(BaseModel):\n       foo: bool = Field(strict=True)\n\n       @field_serializer('foo', mode='plain')\n       def serialize_foo(self, value: bool) -> Any:\n           ...\n   \n{\n    'type': 'function-plain',\n    'function': <function Model.serialize_foo at 0x111>,\n    'is_field_serializer': True,\n    'info_arg': False,\n    'return_schema': {'type': 'int'},\n}\n```\n\nNote that this is also a core schema definition, just that it is only relevant for `pydantic-core` during serialization.\n\nCore schemas cover a broad scope, and are used whenever we want to communicate between the Python and Rust side.\nWhile the previous examples were related to validation and serialization, it could in theory be used for anything:\nerror management, extra metadata, etc.", "url": "https://docs.pydantic.dev/latest/internals/architecture/index.html#communicating-between-pydantic-and-pydantic-core-the-core-schemaindexhtmlcommunicating-between-pydantic-and-pydantic-core-the-core-schema-permanent-link", "page": "internals/architecture/index.html", "source_site": "pydantic"}
{"title": "JSON Schema generation[Â¶](index.html#json-schema-generation \"Permanent link\")", "anchor": "json-schema-generationindexhtmljson-schema-generation-permanent-link", "md_text": "You may have noticed that the previous serialization core schema has a `return_schema` key.\nThis is because the core schema is also used to generate the corresponding JSON Schema.\n\nSimilar to how the core schema is generated, the JSON Schema generation is handled by the\n[`GenerateJsonSchema`](../../api/json_schema/index.html#pydantic.json_schema.GenerateJsonSchema) class.\nThe [`generate`](../../api/json_schema/index.html#pydantic.json_schema.GenerateJsonSchema.generate) method\nis the main entry point and is given the core schema of that model.\n\nComing back to our `bool` field example, the [`bool_schema`](../../api/json_schema/index.html#pydantic.json_schema.GenerateJsonSchema.bool_schema)\nmethod will be given the previously generated [boolean core schema](../../api/pydantic_core_schema/index.html#pydantic_core.core_schema.bool_schema)\nand will return the following JSON Schema:\n\n```\n{\n    {\"type\": \"boolean\"}\n}\n```", "url": "https://docs.pydantic.dev/latest/internals/architecture/index.html#json-schema-generationindexhtmljson-schema-generation-permanent-link", "page": "internals/architecture/index.html", "source_site": "pydantic"}
{"title": "Customizing the core schema and JSON schema[Â¶](index.html#customizing-the-core-schema-and-json-schema \"Permanent link\")", "anchor": "customizing-the-core-schema-and-json-schemaindexhtmlcustomizing-the-core-schema-and-json-schema-permanent-link", "md_text": "[Custom types](../../concepts/types/index.html#custom-types)\n\n[Implementing `__get_pydantic_core_schema__`](../../concepts/json_schema/index.html#implementing-__get_pydantic_core_schema__)\n\n[Implementing `__get_pydantic_json_schema__`](../../concepts/json_schema/index.html#implementing-__get_pydantic_json_schema__)\n\nWhile the `GenerateSchema` and [`GenerateJsonSchema`](../../api/json_schema/index.html#pydantic.json_schema.GenerateJsonSchema) classes handle\nthe creation of the corresponding schemas, Pydantic offers a way to customize them in some cases, following a wrapper pattern.\nThis customization is done through the `__get_pydantic_core_schema__` and `__get_pydantic_json_schema__` methods.\n\nTo understand this wrapper pattern, we will take the example of metadata classes used with [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated),\nwhere the `__get_pydantic_core_schema__` method can be used:\n\n```\nfrom typing import Annotated, Any\n\nfrom pydantic_core import CoreSchema\n\nfrom pydantic import GetCoreSchemaHandler, TypeAdapter\n\n\nclass MyStrict:\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source: Any, handler: GetCoreSchemaHandler\n    ) -> CoreSchema:\n        schema = handler(source)  # (1)!\n        schema['strict'] = True\n        return schema\n\n\nclass MyGt:\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source: Any, handler: GetCoreSchemaHandler\n    ) -> CoreSchema:\n        schema = handler(source)  # (2)!\n        schema['gt'] = 1\n        return schema\n\n\nta = TypeAdapter(Annotated[int, MyStrict(), MyGt()])\n```\n\n1. `MyStrict` is the first annotation to be applied. At this point, `schema = {'type': 'int'}`.\n2. `MyGt` is the last annotation to be applied. At this point, `schema = {'type': 'int', 'strict': True}`.\n\nWhen the `GenerateSchema` class builds the core schema for `Annotated[int, MyStrict(), MyGt()]`, it will\ncreate an instance of a `GetCoreSchemaHandler` to be passed to the `MyGt.__get_pydantic_core_schema__` method. (1)\n\n1. In the case of our [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated) pattern, the `GetCoreSchemaHandler` is defined in a nested way.\n   Calling it will recursively call the other `__get_pydantic_core_schema__` methods until it reaches the `int` annotation,\n   where a simple `{'type': 'int'}` schema is returned.\n\nThe `source` argument depends on the core schema generation pattern. In the case of [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated),\nthe `source` will be the type being annotated. When [defining a custom type](../../concepts/types/index.html#as-a-method-on-a-custom-type),\nthe `source` will be the actual class where `__get_pydantic_core_schema__` is defined.", "url": "https://docs.pydantic.dev/latest/internals/architecture/index.html#customizing-the-core-schema-and-json-schemaindexhtmlcustomizing-the-core-schema-and-json-schema-permanent-link", "page": "internals/architecture/index.html", "source_site": "pydantic"}
{"title": "Model validation and serialization[Â¶](index.html#model-validation-and-serialization \"Permanent link\")", "anchor": "model-validation-and-serializationindexhtmlmodel-validation-and-serialization-permanent-link", "md_text": "While model definition was scoped to the *class* level (i.e. when defining your model), model validation\nand serialization happens at the *instance* level. Both these concepts are handled in `pydantic-core`\n(providing a 5 to 20 performance increase compared to Pydantic V1), by using the previously built core schema.\n\n`pydantic-core` exposes a [`SchemaValidator`](../../api/pydantic_core/index.html#pydantic_core.SchemaValidator) and\n[`SchemaSerializer`](../../api/pydantic_core/index.html#pydantic_core.SchemaSerializer) class to perform these tasks:\n\n```\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    foo: int\n\n\nmodel = Model.model_validate({'foo': 1})  # (1)!\ndumped = model.model_dump()  # (2)!\n```\n\n1. The provided data is sent to `pydantic-core` by using the\n   [`SchemaValidator.validate_python`](../../api/pydantic_core/index.html#pydantic_core.SchemaValidator.validate_python) method.\n   `pydantic-core` will validate (following the core schema of the model) the data and populate\n   the model's `__dict__` attribute.\n2. The `model` instance is sent to `pydantic-core` by using the\n   [`SchemaSerializer.to_python`](../../api/pydantic_core/index.html#pydantic_core.SchemaSerializer.to_python) method.\n   `pydantic-core` will read the instance's `__dict__` attribute and built the appropriate result\n   (again, following the core schema of the model).\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/internals/architecture/index.html#model-validation-and-serializationindexhtmlmodel-validation-and-serialization-permanent-link", "page": "internals/architecture/index.html", "source_site": "pydantic"}
{"title": "Class not fully defined[Â¶](index.html#class-not-fully-defined \"Permanent link\")", "anchor": "class-not-fully-definedindexhtmlclass-not-fully-defined-permanent-link", "md_text": "This error is raised when a type referenced in an annotation of a pydantic-validated type\n(such as a subclass of `BaseModel`, or a pydantic `dataclass`) is not defined:\n\n```\nfrom typing import ForwardRef\n\nfrom pydantic import BaseModel, PydanticUserError\n\nUndefinedType = ForwardRef('UndefinedType')\n\n\nclass Foobar(BaseModel):\n    a: UndefinedType\n\n\ntry:\n    Foobar(a=1)\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'class-not-fully-defined'\n```\n\nOr when the type has been defined after usage:\n\n```\nfrom typing import Optional\n\nfrom pydantic import BaseModel, PydanticUserError\n\n\nclass Foo(BaseModel):\n    a: Optional['Bar'] = None\n\n\ntry:\n    # this doesn't work, see raised error\n    foo = Foo(a={'b': {'a': None}})\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'class-not-fully-defined'\n\n\nclass Bar(BaseModel):\n    b: 'Foo'\n\n\n# this works, though\nfoo = Foo(a={'b': {'a': None}})\n```\n\nFor BaseModel subclasses, it can be fixed by defining the type and then calling `.model_rebuild()`:\n\n```\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    a: Optional['Bar'] = None\n\n\nclass Bar(BaseModel):\n    b: 'Foo'\n\n\nFoo.model_rebuild()\n\nfoo = Foo(a={'b': {'a': None}})\n```\n\nIn other cases, the error message should indicate how to rebuild the class with the appropriate type defined.", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#class-not-fully-definedindexhtmlclass-not-fully-defined-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "Custom JSON Schema[Â¶](index.html#custom-json-schema \"Permanent link\")", "anchor": "custom-json-schemaindexhtmlcustom-json-schema-permanent-link", "md_text": "The `__modify_schema__` method is no longer supported in V2. You should use the `__get_pydantic_json_schema__` method instead.\n\nThe `__modify_schema__` used to receive a single argument representing the JSON schema. See the example below:\n\nOld way\n\n```\nfrom pydantic import BaseModel, PydanticUserError\n\ntry:\n\n    class Model(BaseModel):\n        @classmethod\n        def __modify_schema__(cls, field_schema):\n            field_schema.update(examples=['example'])\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'custom-json-schema'\n```\n\nThe new method `__get_pydantic_json_schema__` receives two arguments: the first is a dictionary denoted as `CoreSchema`,\nand the second a callable `handler` that receives a `CoreSchema` as parameter, and returns a JSON schema. See the example\nbelow:\n\nNew way\n\n```\nfrom typing import Any\n\nfrom pydantic_core import CoreSchema\n\nfrom pydantic import BaseModel, GetJsonSchemaHandler\n\n\nclass Model(BaseModel):\n    @classmethod\n    def __get_pydantic_json_schema__(\n        cls, core_schema: CoreSchema, handler: GetJsonSchemaHandler\n    ) -> dict[str, Any]:\n        json_schema = super().__get_pydantic_json_schema__(core_schema, handler)\n        json_schema = handler.resolve_ref_schema(json_schema)\n        json_schema.update(examples=['example'])\n        return json_schema\n\n\nprint(Model.model_json_schema())\n\"\"\"\n{'examples': ['example'], 'properties': {}, 'title': 'Model', 'type': 'object'}\n\"\"\"\n```", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#custom-json-schemaindexhtmlcustom-json-schema-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "Decorator on missing field[Â¶](index.html#decorator-missing-field \"Permanent link\")", "anchor": "decorator-on-missing-fieldindexhtmldecorator-missing-field-permanent-link", "md_text": "This error is raised when you define a decorator with a field that is not valid.\n\n```\nfrom typing import Any\n\nfrom pydantic import BaseModel, PydanticUserError, field_validator\n\ntry:\n\n    class Model(BaseModel):\n        a: str\n\n        @field_validator('b')\n        def check_b(cls, v: Any):\n            return v\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'decorator-missing-field'\n```\n\nYou can use `check_fields=False` if you're inheriting from the model and intended this.\n\n```\nfrom typing import Any\n\nfrom pydantic import BaseModel, create_model, field_validator\n\n\nclass Model(BaseModel):\n    @field_validator('a', check_fields=False)\n    def check_a(cls, v: Any):\n        return v\n\n\nmodel = create_model('FooModel', a=(str, 'cake'), __base__=Model)\n```", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#decorator-on-missing-fieldindexhtmldecorator-missing-field-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "Discriminator no field[Â¶](index.html#discriminator-no-field \"Permanent link\")", "anchor": "discriminator-no-fieldindexhtmldiscriminator-no-field-permanent-link", "md_text": "This error is raised when a model in discriminated unions doesn't define a discriminator field.\n\nPython 3.9 and abovePython 3.10 and above\n\n```\nfrom typing import Literal, Union\n\nfrom pydantic import BaseModel, Field, PydanticUserError\n\n\nclass Cat(BaseModel):\n    c: str\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n    d: str\n\n\ntry:\n\n    class Model(BaseModel):\n        pet: Union[Cat, Dog] = Field(discriminator='pet_type')\n        number: int\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'discriminator-no-field'\n\nfrom typing import Literal\n\nfrom pydantic import BaseModel, Field, PydanticUserError\n\n\nclass Cat(BaseModel):\n    c: str\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n    d: str\n\n\ntry:\n\n    class Model(BaseModel):\n        pet: Cat | Dog = Field(discriminator='pet_type')\n        number: int\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'discriminator-no-field'\n```", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#discriminator-no-fieldindexhtmldiscriminator-no-field-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "Discriminator alias type[Â¶](index.html#discriminator-alias-type \"Permanent link\")", "anchor": "discriminator-alias-typeindexhtmldiscriminator-alias-type-permanent-link", "md_text": "This error is raised when you define a non-string alias on a discriminator field.\n\nPython 3.9 and abovePython 3.10 and above\n\n```\nfrom typing import Literal, Union\n\nfrom pydantic import AliasChoices, BaseModel, Field, PydanticUserError\n\n\nclass Cat(BaseModel):\n    pet_type: Literal['cat'] = Field(\n        validation_alias=AliasChoices('Pet', 'PET')\n    )\n    c: str\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n    d: str\n\n\ntry:\n\n    class Model(BaseModel):\n        pet: Union[Cat, Dog] = Field(discriminator='pet_type')\n        number: int\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'discriminator-alias-type'\n\nfrom typing import Literal\n\nfrom pydantic import AliasChoices, BaseModel, Field, PydanticUserError\n\n\nclass Cat(BaseModel):\n    pet_type: Literal['cat'] = Field(\n        validation_alias=AliasChoices('Pet', 'PET')\n    )\n    c: str\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n    d: str\n\n\ntry:\n\n    class Model(BaseModel):\n        pet: Cat | Dog = Field(discriminator='pet_type')\n        number: int\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'discriminator-alias-type'\n```", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#discriminator-alias-typeindexhtmldiscriminator-alias-type-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "Discriminator needs literal[Â¶](index.html#discriminator-needs-literal \"Permanent link\")", "anchor": "discriminator-needs-literalindexhtmldiscriminator-needs-literal-permanent-link", "md_text": "This error is raised when you define a non-`Literal` type on a discriminator field.\n\nPython 3.9 and abovePython 3.10 and above\n\n```\nfrom typing import Literal, Union\n\nfrom pydantic import BaseModel, Field, PydanticUserError\n\n\nclass Cat(BaseModel):\n    pet_type: int\n    c: str\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n    d: str\n\n\ntry:\n\n    class Model(BaseModel):\n        pet: Union[Cat, Dog] = Field(discriminator='pet_type')\n        number: int\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'discriminator-needs-literal'\n\nfrom typing import Literal\n\nfrom pydantic import BaseModel, Field, PydanticUserError\n\n\nclass Cat(BaseModel):\n    pet_type: int\n    c: str\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n    d: str\n\n\ntry:\n\n    class Model(BaseModel):\n        pet: Cat | Dog = Field(discriminator='pet_type')\n        number: int\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'discriminator-needs-literal'\n```", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#discriminator-needs-literalindexhtmldiscriminator-needs-literal-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "Discriminator alias[Â¶](index.html#discriminator-alias \"Permanent link\")", "anchor": "discriminator-aliasindexhtmldiscriminator-alias-permanent-link", "md_text": "This error is raised when you define different aliases on discriminator fields.\n\nPython 3.9 and abovePython 3.10 and above\n\n```\nfrom typing import Literal, Union\n\nfrom pydantic import BaseModel, Field, PydanticUserError\n\n\nclass Cat(BaseModel):\n    pet_type: Literal['cat'] = Field(validation_alias='PET')\n    c: str\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog'] = Field(validation_alias='Pet')\n    d: str\n\n\ntry:\n\n    class Model(BaseModel):\n        pet: Union[Cat, Dog] = Field(discriminator='pet_type')\n        number: int\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'discriminator-alias'\n\nfrom typing import Literal\n\nfrom pydantic import BaseModel, Field, PydanticUserError\n\n\nclass Cat(BaseModel):\n    pet_type: Literal['cat'] = Field(validation_alias='PET')\n    c: str\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog'] = Field(validation_alias='Pet')\n    d: str\n\n\ntry:\n\n    class Model(BaseModel):\n        pet: Cat | Dog = Field(discriminator='pet_type')\n        number: int\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'discriminator-alias'\n```", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#discriminator-aliasindexhtmldiscriminator-alias-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "Invalid discriminator validator[Â¶](index.html#discriminator-validator \"Permanent link\")", "anchor": "invalid-discriminator-validatorindexhtmldiscriminator-validator-permanent-link", "md_text": "This error is raised when you use a before, wrap, or plain validator on a discriminator field.\n\nThis is disallowed because the discriminator field is used to determine the type of the model to use for validation,\nso you can't use a validator that might change its value.\n\nPython 3.9 and abovePython 3.10 and above\n\n```\nfrom typing import Literal, Union\n\nfrom pydantic import BaseModel, Field, PydanticUserError, field_validator\n\n\nclass Cat(BaseModel):\n    pet_type: Literal['cat']\n\n    @field_validator('pet_type', mode='before')\n    @classmethod\n    def validate_pet_type(cls, v):\n        if v == 'kitten':\n            return 'cat'\n        return v\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n\n\ntry:\n\n    class Model(BaseModel):\n        pet: Union[Cat, Dog] = Field(discriminator='pet_type')\n        number: int\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'discriminator-validator'\n\nfrom typing import Literal\n\nfrom pydantic import BaseModel, Field, PydanticUserError, field_validator\n\n\nclass Cat(BaseModel):\n    pet_type: Literal['cat']\n\n    @field_validator('pet_type', mode='before')\n    @classmethod\n    def validate_pet_type(cls, v):\n        if v == 'kitten':\n            return 'cat'\n        return v\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n\n\ntry:\n\n    class Model(BaseModel):\n        pet: Cat | Dog = Field(discriminator='pet_type')\n        number: int\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'discriminator-validator'\n```\n\nThis can be worked around by using a standard `Union`, dropping the discriminator:\n\nPython 3.9 and abovePython 3.10 and above\n\n```\nfrom typing import Literal, Union\n\nfrom pydantic import BaseModel, field_validator\n\n\nclass Cat(BaseModel):\n    pet_type: Literal['cat']\n\n    @field_validator('pet_type', mode='before')\n    @classmethod\n    def validate_pet_type(cls, v):\n        if v == 'kitten':\n            return 'cat'\n        return v\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n\n\nclass Model(BaseModel):\n    pet: Union[Cat, Dog]\n\n\nassert Model(pet={'pet_type': 'kitten'}).pet.pet_type == 'cat'\n\nfrom typing import Literal\n\nfrom pydantic import BaseModel, field_validator\n\n\nclass Cat(BaseModel):\n    pet_type: Literal['cat']\n\n    @field_validator('pet_type', mode='before')\n    @classmethod\n    def validate_pet_type(cls, v):\n        if v == 'kitten':\n            return 'cat'\n        return v\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n\n\nclass Model(BaseModel):\n    pet: Cat | Dog\n\n\nassert Model(pet={'pet_type': 'kitten'}).pet.pet_type == 'cat'\n```", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#invalid-discriminator-validatorindexhtmldiscriminator-validator-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "Callable discriminator case with no tag[Â¶](index.html#callable-discriminator-no-tag \"Permanent link\")", "anchor": "callable-discriminator-case-with-no-tagindexhtmlcallable-discriminator-no-tag-permanent-link", "md_text": "This error is raised when a `Union` that uses a callable `Discriminator` doesn't have `Tag` annotations for all cases.\n\nPython 3.9 and abovePython 3.10 and above\n\n```\nfrom typing import Annotated, Union\n\nfrom pydantic import BaseModel, Discriminator, PydanticUserError, Tag\n\n\ndef model_x_discriminator(v):\n    if isinstance(v, str):\n        return 'str'\n    if isinstance(v, (dict, BaseModel)):\n        return 'model'\n\n\n# tag missing for both union choices\ntry:\n\n    class DiscriminatedModel(BaseModel):\n        x: Annotated[\n            Union[str, 'DiscriminatedModel'],\n            Discriminator(model_x_discriminator),\n        ]\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'callable-discriminator-no-tag'\n\n# tag missing for `'DiscriminatedModel'` union choice\ntry:\n\n    class DiscriminatedModel(BaseModel):\n        x: Annotated[\n            Union[Annotated[str, Tag('str')], 'DiscriminatedModel'],\n            Discriminator(model_x_discriminator),\n        ]\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'callable-discriminator-no-tag'\n\n# tag missing for `str` union choice\ntry:\n\n    class DiscriminatedModel(BaseModel):\n        x: Annotated[\n            Union[str, Annotated['DiscriminatedModel', Tag('model')]],\n            Discriminator(model_x_discriminator),\n        ]\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'callable-discriminator-no-tag'\n\nfrom typing import Annotated, Union\n\nfrom pydantic import BaseModel, Discriminator, PydanticUserError, Tag\n\n\ndef model_x_discriminator(v):\n    if isinstance(v, str):\n        return 'str'\n    if isinstance(v, (dict, BaseModel)):\n        return 'model'\n\n\n# tag missing for both union choices\ntry:\n\n    class DiscriminatedModel(BaseModel):\n        x: Annotated[\n            Union[str, 'DiscriminatedModel'],\n            Discriminator(model_x_discriminator),\n        ]\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'callable-discriminator-no-tag'\n\n# tag missing for `'DiscriminatedModel'` union choice\ntry:\n\n    class DiscriminatedModel(BaseModel):\n        x: Annotated[\n            Union[Annotated[str, Tag('str')], 'DiscriminatedModel'],\n            Discriminator(model_x_discriminator),\n        ]\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'callable-discriminator-no-tag'\n\n# tag missing for `str` union choice\ntry:\n\n    class DiscriminatedModel(BaseModel):\n        x: Annotated[\n            str | Annotated['DiscriminatedModel', Tag('model')],\n            Discriminator(model_x_discriminator),\n        ]\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'callable-discriminator-no-tag'\n```", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#callable-discriminator-case-with-no-tagindexhtmlcallable-discriminator-no-tag-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "`TypedDict` version[Â¶](index.html#typed-dict-version \"Permanent link\")", "anchor": "typeddict-versionindexhtmltyped-dict-version-permanent-link", "md_text": "This error is raised when you use [typing.TypedDict](https://docs.python.org/3/library/typing.html#typing.TypedDict)\ninstead of `typing_extensions.TypedDict` on Python < 3.12.", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#typeddict-versionindexhtmltyped-dict-version-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "Model parent field overridden[Â¶](index.html#model-field-overridden \"Permanent link\")", "anchor": "model-parent-field-overriddenindexhtmlmodel-field-overridden-permanent-link", "md_text": "This error is raised when a field defined on a base class was overridden by a non-annotated attribute.\n\n```\nfrom pydantic import BaseModel, PydanticUserError\n\n\nclass Foo(BaseModel):\n    a: float\n\n\ntry:\n\n    class Bar(Foo):\n        x: float = 12.3\n        a = 123.0\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'model-field-overridden'\n```", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#model-parent-field-overriddenindexhtmlmodel-field-overridden-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "Model field missing annotation[Â¶](index.html#model-field-missing-annotation \"Permanent link\")", "anchor": "model-field-missing-annotationindexhtmlmodel-field-missing-annotation-permanent-link", "md_text": "This error is raised when a field doesn't have an annotation.\n\n```\nfrom pydantic import BaseModel, Field, PydanticUserError\n\ntry:\n\n    class Model(BaseModel):\n        a = Field('foobar')\n        b = None\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'model-field-missing-annotation'\n```\n\nIf the field is not meant to be a field, you may be able to resolve the error\nby annotating it as a `ClassVar`:\n\n```\nfrom typing import ClassVar\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    a: ClassVar[str]\n```\n\nOr updating `model_config['ignored_types']`:\n\n```\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass IgnoredType:\n    pass\n\n\nclass MyModel(BaseModel):\n    model_config = ConfigDict(ignored_types=(IgnoredType,))\n\n    _a = IgnoredType()\n    _b: int = IgnoredType()\n    _c: IgnoredType\n    _d: IgnoredType = IgnoredType()\n```", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#model-field-missing-annotationindexhtmlmodel-field-missing-annotation-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "`Config` and `model_config` both defined[Â¶](index.html#config-both \"Permanent link\")", "anchor": "config-and-modelconfig-both-definedindexhtmlconfig-both-permanent-link", "md_text": "This error is raised when `class Config` and `model_config` are used together.\n\n```\nfrom pydantic import BaseModel, ConfigDict, PydanticUserError\n\ntry:\n\n    class Model(BaseModel):\n        model_config = ConfigDict(from_attributes=True)\n\n        a: str\n\n        class Config:\n            from_attributes = True\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'config-both'\n```", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#config-and-modelconfig-both-definedindexhtmlconfig-both-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "Keyword arguments removed[Â¶](index.html#removed-kwargs \"Permanent link\")", "anchor": "keyword-arguments-removedindexhtmlremoved-kwargs-permanent-link", "md_text": "This error is raised when the keyword arguments are not available in Pydantic V2.\n\nFor example, `regex` is removed from Pydantic V2:\n\n```\nfrom pydantic import BaseModel, Field, PydanticUserError\n\ntry:\n\n    class Model(BaseModel):\n        x: str = Field(regex='test')\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'removed-kwargs'\n```", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#keyword-arguments-removedindexhtmlremoved-kwargs-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "Circular reference schema[Â¶](index.html#circular-reference-schema \"Permanent link\")", "anchor": "circular-reference-schemaindexhtmlcircular-reference-schema-permanent-link", "md_text": "This error is raised when a circular reference is found that would otherwise result in an infinite recursion.\n\nFor example, this is a valid type alias:\n\n```\ntype A = list[A] | None\n```\n\nwhile these are not:\n\n```\ntype A = A\n\ntype B = C\ntype C = B\n```", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#circular-reference-schemaindexhtmlcircular-reference-schema-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "JSON schema invalid type[Â¶](index.html#invalid-for-json-schema \"Permanent link\")", "anchor": "json-schema-invalid-typeindexhtmlinvalid-for-json-schema-permanent-link", "md_text": "This error is raised when Pydantic fails to generate a JSON schema for some `CoreSchema`.\n\n```\nfrom pydantic import BaseModel, ImportString, PydanticUserError\n\n\nclass Model(BaseModel):\n    a: ImportString\n\n\ntry:\n    Model.model_json_schema()\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'invalid-for-json-schema'\n```", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#json-schema-invalid-typeindexhtmlinvalid-for-json-schema-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "JSON schema already used[Â¶](index.html#json-schema-already-used \"Permanent link\")", "anchor": "json-schema-already-usedindexhtmljson-schema-already-used-permanent-link", "md_text": "This error is raised when the JSON schema generator has already been used to generate a JSON schema.\nYou must create a new instance to generate a new JSON schema.", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#json-schema-already-usedindexhtmljson-schema-already-used-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "BaseModel instantiated[Â¶](index.html#base-model-instantiated \"Permanent link\")", "anchor": "basemodel-instantiatedindexhtmlbase-model-instantiated-permanent-link", "md_text": "This error is raised when you instantiate `BaseModel` directly. Pydantic models should inherit from `BaseModel`.\n\n```\nfrom pydantic import BaseModel, PydanticUserError\n\ntry:\n    BaseModel()\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'base-model-instantiated'\n```", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#basemodel-instantiatedindexhtmlbase-model-instantiated-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "Undefined annotation[Â¶](index.html#undefined-annotation \"Permanent link\")", "anchor": "undefined-annotationindexhtmlundefined-annotation-permanent-link", "md_text": "This error is raised when handling undefined annotations during `CoreSchema` generation.\n\n```\nfrom pydantic import BaseModel, PydanticUndefinedAnnotation\n\n\nclass Model(BaseModel):\n    a: 'B'  # noqa F821\n\n\ntry:\n    Model.model_rebuild()\nexcept PydanticUndefinedAnnotation as exc_info:\n    assert exc_info.code == 'undefined-annotation'\n```", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#undefined-annotationindexhtmlundefined-annotation-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "Schema for unknown type[Â¶](index.html#schema-for-unknown-type \"Permanent link\")", "anchor": "schema-for-unknown-typeindexhtmlschema-for-unknown-type-permanent-link", "md_text": "This error is raised when Pydantic fails to generate a `CoreSchema` for some type.\n\n```\nfrom pydantic import BaseModel, PydanticUserError\n\ntry:\n\n    class Model(BaseModel):\n        x: 43 = 123\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'schema-for-unknown-type'\n```", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#schema-for-unknown-typeindexhtmlschema-for-unknown-type-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "Import error[Â¶](index.html#import-error \"Permanent link\")", "anchor": "import-errorindexhtmlimport-error-permanent-link", "md_text": "This error is raised when you try to import an object that was available in Pydantic V1, but has been removed in\nPydantic V2.\n\nSee the [Migration Guide](../../migration/index.html) for more information.", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#import-errorindexhtmlimport-error-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "`create_model` field definitions[Â¶](index.html#create-model-field-definitions \"Permanent link\")", "anchor": "createmodel-field-definitionsindexhtmlcreate-model-field-definitions-permanent-link", "md_text": "This error is raised when you provide invalid field definitions in [`create_model()`](../../api/base_model/index.html#pydantic.create_model).\n\n```\nfrom pydantic import PydanticUserError, create_model\n\ntry:\n    create_model('FooModel', foo=(str, 'default value', 'more'))\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'create-model-field-definitions'\n```\n\nThe fields definition syntax can be found in the [dynamic model creation](../../concepts/models/index.html#dynamic-model-creation) documentation.", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#createmodel-field-definitionsindexhtmlcreate-model-field-definitions-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "Validator with no fields[Â¶](index.html#validator-no-fields \"Permanent link\")", "anchor": "validator-with-no-fieldsindexhtmlvalidator-no-fields-permanent-link", "md_text": "This error is raised when you use validator bare (with no fields).\n\n```\nfrom pydantic import BaseModel, PydanticUserError, field_validator\n\ntry:\n\n    class Model(BaseModel):\n        a: str\n\n        @field_validator\n        def checker(cls, v):\n            return v\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'validator-no-fields'\n```\n\nValidators should be used with fields and keyword arguments.\n\n```\nfrom pydantic import BaseModel, field_validator\n\n\nclass Model(BaseModel):\n    a: str\n\n    @field_validator('a')\n    def checker(cls, v):\n        return v\n```", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#validator-with-no-fieldsindexhtmlvalidator-no-fields-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "Invalid validator fields[Â¶](index.html#validator-invalid-fields \"Permanent link\")", "anchor": "invalid-validator-fieldsindexhtmlvalidator-invalid-fields-permanent-link", "md_text": "This error is raised when you use a validator with non-string fields.\n\n```\nfrom pydantic import BaseModel, PydanticUserError, field_validator\n\ntry:\n\n    class Model(BaseModel):\n        a: str\n        b: str\n\n        @field_validator(['a', 'b'])\n        def check_fields(cls, v):\n            return v\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'validator-invalid-fields'\n```\n\nFields should be passed as separate string arguments:\n\n```\nfrom pydantic import BaseModel, field_validator\n\n\nclass Model(BaseModel):\n    a: str\n    b: str\n\n    @field_validator('a', 'b')\n    def check_fields(cls, v):\n        return v\n```", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#invalid-validator-fieldsindexhtmlvalidator-invalid-fields-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "Validator on instance method[Â¶](index.html#validator-instance-method \"Permanent link\")", "anchor": "validator-on-instance-methodindexhtmlvalidator-instance-method-permanent-link", "md_text": "This error is raised when you apply a validator on an instance method.\n\n```\nfrom pydantic import BaseModel, PydanticUserError, field_validator\n\ntry:\n\n    class Model(BaseModel):\n        a: int = 1\n\n        @field_validator('a')\n        def check_a(self, value):\n            return value\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'validator-instance-method'\n```", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#validator-on-instance-methodindexhtmlvalidator-instance-method-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "`json_schema_input_type` used with the wrong mode[Â¶](index.html#validator-input-type \"Permanent link\")", "anchor": "jsonschemainputtype-used-with-the-wrong-modeindexhtmlvalidator-input-type-permanent-link", "md_text": "This error is raised when you explicitly specify a value for the `json_schema_input_type`\nargument and `mode` isn't set to either `'before'`, `'plain'` or `'wrap'`.\n\n```\nfrom pydantic import BaseModel, PydanticUserError, field_validator\n\ntry:\n\n    class Model(BaseModel):\n        a: int = 1\n\n        @field_validator('a', mode='after', json_schema_input_type=int)\n        @classmethod\n        def check_a(self, value):\n            return value\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'validator-input-type'\n```\n\nDocumenting the JSON Schema input type is only possible for validators where the given\nvalue can be anything. That is why it isn't available for `after` validators, where\nthe value is first validated against the type annotation.", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#jsonschemainputtype-used-with-the-wrong-modeindexhtmlvalidator-input-type-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "Root validator, `pre`, `skip_on_failure`[Â¶](index.html#root-validator-pre-skip \"Permanent link\")", "anchor": "root-validator-pre-skiponfailureindexhtmlroot-validator-pre-skip-permanent-link", "md_text": "If you use `@root_validator` with `pre=False` (the default) you MUST specify `skip_on_failure=True`.\nThe `skip_on_failure=False` option is no longer available.\n\nIf you were not trying to set `skip_on_failure=False`, you can safely set `skip_on_failure=True`.\nIf you do, this root validator will no longer be called if validation fails for any of the fields.\n\nPlease see the [Migration Guide](../../migration/index.html) for more details.", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#root-validator-pre-skiponfailureindexhtmlroot-validator-pre-skip-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "`model_serializer` instance methods[Â¶](index.html#model-serializer-instance-method \"Permanent link\")", "anchor": "modelserializer-instance-methodsindexhtmlmodel-serializer-instance-method-permanent-link", "md_text": "`@model_serializer` must be applied to instance methods.\n\nThis error is raised when you apply `model_serializer` on an instance method without `self`:\n\n```\nfrom pydantic import BaseModel, PydanticUserError, model_serializer\n\ntry:\n\n    class MyModel(BaseModel):\n        a: int\n\n        @model_serializer\n        def _serialize(slf, x, y, z):\n            return slf\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'model-serializer-instance-method'\n```\n\nOr on a class method:\n\n```\nfrom pydantic import BaseModel, PydanticUserError, model_serializer\n\ntry:\n\n    class MyModel(BaseModel):\n        a: int\n\n        @model_serializer\n        @classmethod\n        def _serialize(self, x, y, z):\n            return self\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'model-serializer-instance-method'\n```", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#modelserializer-instance-methodsindexhtmlmodel-serializer-instance-method-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "`validator`, `field`, `config`, and `info`[Â¶](index.html#validator-field-config-info \"Permanent link\")", "anchor": "validator-field-config-and-infoindexhtmlvalidator-field-config-info-permanent-link", "md_text": "The `field` and `config` parameters are not available in Pydantic V2.\nPlease use the `info` parameter instead.\n\nYou can access the configuration via `info.config`,\nbut it is a dictionary instead of an object like it was in Pydantic V1.\n\nThe `field` argument is no longer available.", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#validator-field-config-and-infoindexhtmlvalidator-field-config-info-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "Pydantic V1 validator signature[Â¶](index.html#validator-v1-signature \"Permanent link\")", "anchor": "pydantic-v1-validator-signatureindexhtmlvalidator-v1-signature-permanent-link", "md_text": "This error is raised when you use an unsupported signature for Pydantic V1-style validator.\n\n```\nimport warnings\n\nfrom pydantic import BaseModel, PydanticUserError, validator\n\nwarnings.filterwarnings('ignore', category=DeprecationWarning)\n\ntry:\n\n    class Model(BaseModel):\n        a: int\n\n        @validator('a')\n        def check_a(cls, value, foo):\n            return value\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'validator-v1-signature'\n```", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#pydantic-v1-validator-signatureindexhtmlvalidator-v1-signature-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "Unrecognized `field_validator` signature[Â¶](index.html#validator-signature \"Permanent link\")", "anchor": "unrecognized-fieldvalidator-signatureindexhtmlvalidator-signature-permanent-link", "md_text": "This error is raised when a `field_validator` or `model_validator` function has the wrong signature.\n\n```\nfrom pydantic import BaseModel, PydanticUserError, field_validator\n\ntry:\n\n    class Model(BaseModel):\n        a: str\n\n        @field_validator('a')\n        @classmethod\n        def check_a(cls):\n            return 'a'\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'validator-signature'\n```", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#unrecognized-fieldvalidator-signatureindexhtmlvalidator-signature-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "Unrecognized `field_serializer` signature[Â¶](index.html#field-serializer-signature \"Permanent link\")", "anchor": "unrecognized-fieldserializer-signatureindexhtmlfield-serializer-signature-permanent-link", "md_text": "This error is raised when the `field_serializer` function has the wrong signature.\n\n```\nfrom pydantic import BaseModel, PydanticUserError, field_serializer\n\ntry:\n\n    class Model(BaseModel):\n        x: int\n\n        @field_serializer('x')\n        def no_args():\n            return 'x'\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'field-serializer-signature'\n```\n\nValid field serializer signatures are:\n\n```\nfrom pydantic import FieldSerializationInfo, SerializerFunctionWrapHandler, field_serializer\n\n# an instance method with the default mode or `mode='plain'`\n@field_serializer('x')  # or @field_serializer('x', mode='plain')\ndef ser_x(self, value: Any, info: FieldSerializationInfo): ...\n\n# a static method or function with the default mode or `mode='plain'`\n@field_serializer('x')  # or @field_serializer('x', mode='plain')\n@staticmethod\ndef ser_x(value: Any, info: FieldSerializationInfo): ...\n\n# equivalent to\ndef ser_x(value: Any, info: FieldSerializationInfo): ...\nserializer('x')(ser_x)\n\n# an instance method with `mode='wrap'`\n@field_serializer('x', mode='wrap')\ndef ser_x(self, value: Any, nxt: SerializerFunctionWrapHandler, info: FieldSerializationInfo): ...\n\n# a static method or function with `mode='wrap'`\n@field_serializer('x', mode='wrap')\n@staticmethod\ndef ser_x(value: Any, nxt: SerializerFunctionWrapHandler, info: FieldSerializationInfo): ...\n\n# equivalent to\ndef ser_x(value: Any, nxt: SerializerFunctionWrapHandler, info: FieldSerializationInfo): ...\nserializer('x')(ser_x)\n\n# For all of these, you can also choose to omit the `info` argument, for example:\n@field_serializer('x')\ndef ser_x(self, value: Any): ...\n\n@field_serializer('x', mode='wrap')\ndef ser_x(self, value: Any, handler: SerializerFunctionWrapHandler): ...\n```", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#unrecognized-fieldserializer-signatureindexhtmlfield-serializer-signature-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "Unrecognized `model_serializer` signature[Â¶](index.html#model-serializer-signature \"Permanent link\")", "anchor": "unrecognized-modelserializer-signatureindexhtmlmodel-serializer-signature-permanent-link", "md_text": "This error is raised when the `model_serializer` function has the wrong signature.\n\n```\nfrom pydantic import BaseModel, PydanticUserError, model_serializer\n\ntry:\n\n    class MyModel(BaseModel):\n        a: int\n\n        @model_serializer\n        def _serialize(self, x, y, z):\n            return self\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'model-serializer-signature'\n```\n\nValid model serializer signatures are:\n\n```\nfrom pydantic import SerializerFunctionWrapHandler, SerializationInfo, model_serializer\n\n# an instance method with the default mode or `mode='plain'`\n@model_serializer  # or model_serializer(mode='plain')\ndef mod_ser(self, info: SerializationInfo): ...\n\n# an instance method with `mode='wrap'`\n@model_serializer(mode='wrap')\ndef mod_ser(self, handler: SerializerFunctionWrapHandler, info: SerializationInfo):\n\n# For all of these, you can also choose to omit the `info` argument, for example:\n@model_serializer(mode='plain')\ndef mod_ser(self): ...\n\n@model_serializer(mode='wrap')\ndef mod_ser(self, handler: SerializerFunctionWrapHandler): ...\n```", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#unrecognized-modelserializer-signatureindexhtmlmodel-serializer-signature-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "Multiple field serializers[Â¶](index.html#multiple-field-serializers \"Permanent link\")", "anchor": "multiple-field-serializersindexhtmlmultiple-field-serializers-permanent-link", "md_text": "This error is raised when multiple `model_serializer` functions are defined for a field.\n\n```\nfrom pydantic import BaseModel, PydanticUserError, field_serializer\n\ntry:\n\n    class MyModel(BaseModel):\n        x: int\n        y: int\n\n        @field_serializer('x', 'y')\n        def serializer1(v):\n            return f'{v:,}'\n\n        @field_serializer('x')\n        def serializer2(v):\n            return v\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'multiple-field-serializers'\n```", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#multiple-field-serializersindexhtmlmultiple-field-serializers-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "Invalid annotated type[Â¶](index.html#invalid-annotated-type \"Permanent link\")", "anchor": "invalid-annotated-typeindexhtmlinvalid-annotated-type-permanent-link", "md_text": "This error is raised when an annotation cannot annotate a type.\n\n```\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, FutureDate, PydanticUserError\n\ntry:\n\n    class Model(BaseModel):\n        foo: Annotated[str, FutureDate()]\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'invalid-annotated-type'\n```", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#invalid-annotated-typeindexhtmlinvalid-annotated-type-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "`config` is unused with `TypeAdapter`[Â¶](index.html#type-adapter-config-unused \"Permanent link\")", "anchor": "config-is-unused-with-typeadapterindexhtmltype-adapter-config-unused-permanent-link", "md_text": "You will get this error if you try to pass `config` to `TypeAdapter` when the type is a type that\nhas its own config that cannot be overridden (currently this is only `BaseModel`, `TypedDict` and `dataclass`):\n\nPython 3.9 and abovePython 3.13 and above\n\n```\nfrom typing_extensions import TypedDict\n\nfrom pydantic import ConfigDict, PydanticUserError, TypeAdapter\n\n\nclass MyTypedDict(TypedDict):\n    x: int\n\n\ntry:\n    TypeAdapter(MyTypedDict, config=ConfigDict(strict=True))\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'type-adapter-config-unused'\n\nfrom typing import TypedDict\n\nfrom pydantic import ConfigDict, PydanticUserError, TypeAdapter\n\n\nclass MyTypedDict(TypedDict):\n    x: int\n\n\ntry:\n    TypeAdapter(MyTypedDict, config=ConfigDict(strict=True))\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'type-adapter-config-unused'\n```\n\nInstead you'll need to subclass the type and override or set the config on it:\n\nPython 3.9 and abovePython 3.13 and above\n\n```\nfrom typing_extensions import TypedDict\n\nfrom pydantic import ConfigDict, TypeAdapter\n\n\nclass MyTypedDict(TypedDict):\n    x: int\n\n    # or `model_config = ...` for BaseModel\n    __pydantic_config__ = ConfigDict(strict=True)\n\n\nTypeAdapter(MyTypedDict)  # ok\n\nfrom typing import TypedDict\n\nfrom pydantic import ConfigDict, TypeAdapter\n\n\nclass MyTypedDict(TypedDict):\n    x: int\n\n    # or `model_config = ...` for BaseModel\n    __pydantic_config__ = ConfigDict(strict=True)\n\n\nTypeAdapter(MyTypedDict)  # ok\n```", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#config-is-unused-with-typeadapterindexhtmltype-adapter-config-unused-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "Cannot specify `model_config['extra']` with `RootModel`[Â¶](index.html#root-model-extra \"Permanent link\")", "anchor": "cannot-specify-modelconfigextra-with-rootmodelindexhtmlroot-model-extra-permanent-link", "md_text": "Because `RootModel` is not capable of storing or even accepting extra fields during initialization, we raise an error\nif you try to specify a value for the config setting `'extra'` when creating a subclass of `RootModel`:\n\n```\nfrom pydantic import PydanticUserError, RootModel\n\ntry:\n\n    class MyRootModel(RootModel):\n        model_config = {'extra': 'allow'}\n        root: int\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'root-model-extra'\n```", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#cannot-specify-modelconfigextra-with-rootmodelindexhtmlroot-model-extra-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "Cannot evaluate type annotation[Â¶](index.html#unevaluable-type-annotation \"Permanent link\")", "anchor": "cannot-evaluate-type-annotationindexhtmlunevaluable-type-annotation-permanent-link", "md_text": "Because type annotations are evaluated *after* assignments, you might get unexpected results when using a type annotation name\nthat clashes with one of your fields. We raise an error in the following case:\n\n```\nfrom datetime import date\n\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    date: date = Field(description='A date')\n```\n\nAs a workaround, you can either use an alias or change your import:\n\n```\nimport datetime\n# Or `from datetime import date as _date`\n\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    date: datetime.date = Field(description='A date')\n```", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#cannot-evaluate-type-annotationindexhtmlunevaluable-type-annotation-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "Incompatible `dataclass` `init` and `extra` settings[Â¶](index.html#dataclass-init-false-extra-allow \"Permanent link\")", "anchor": "incompatible-dataclass-init-and-extra-settingsindexhtmldataclass-init-false-extra-allow-permanent-link", "md_text": "Pydantic does not allow the specification of the `extra='allow'` setting on a dataclass\nwhile any of the fields have `init=False` set.\n\nThus, you may not do something like the following:\n\n```\nfrom pydantic import ConfigDict, Field\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass(config=ConfigDict(extra='allow'))\nclass A:\n    a: int = Field(init=False, default=1)\n```\n\nThe above snippet results in the following error during schema building for the `A` dataclass:\n\n```\npydantic.errors.PydanticUserError: Field a has `init=False` and dataclass has config setting `extra=\"allow\"`.\nThis combination is not allowed.\n```", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#incompatible-dataclass-init-and-extra-settingsindexhtmldataclass-init-false-extra-allow-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "Incompatible `init` and `init_var` settings on `dataclass` field[Â¶](index.html#clashing-init-and-init-var \"Permanent link\")", "anchor": "incompatible-init-and-initvar-settings-on-dataclass-fieldindexhtmlclashing-init-and-init-var-permanent-link", "md_text": "The `init=False` and `init_var=True` settings are mutually exclusive. Doing so results in the `PydanticUserError` shown in the example below.\n\n```\nfrom pydantic import Field\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass Foo:\n    bar: str = Field(init=False, init_var=True)\n\n\n\"\"\"\npydantic.errors.PydanticUserError: Dataclass field bar has init=False and init_var=True, but these are mutually exclusive.\n\"\"\"\n```", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#incompatible-init-and-initvar-settings-on-dataclass-fieldindexhtmlclashing-init-and-init-var-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "`model_config` is used as a model field[Â¶](index.html#model-config-invalid-field-name \"Permanent link\")", "anchor": "modelconfig-is-used-as-a-model-fieldindexhtmlmodel-config-invalid-field-name-permanent-link", "md_text": "This error is raised when `model_config` is used as the name of a field.\n\n```\nfrom pydantic import BaseModel, PydanticUserError\n\ntry:\n\n    class Model(BaseModel):\n        model_config: str\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'model-config-invalid-field-name'\n```", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#modelconfig-is-used-as-a-model-fieldindexhtmlmodel-config-invalid-field-name-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "[`with_config`](../../api/config/index.html#pydantic.config.with_config) is used on a `BaseModel` subclass[Â¶](index.html#with-config-on-model \"Permanent link\")", "anchor": "withconfigapiconfigindexhtmlpydanticconfigwithconfig-is-used-on-a-basemodel-subclassindexhtmlwith-config-on-model-permanent-link", "md_text": "This error is raised when the [`with_config`](../../api/config/index.html#pydantic.config.with_config) decorator is used on a class which is already a Pydantic model (use the `model_config` attribute instead).\n\n```\nfrom pydantic import BaseModel, PydanticUserError, with_config\n\ntry:\n\n    @with_config({'allow_inf_nan': True})\n    class Model(BaseModel):\n        bar: str\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'with-config-on-model'\n```", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#withconfigapiconfigindexhtmlpydanticconfigwithconfig-is-used-on-a-basemodel-subclassindexhtmlwith-config-on-model-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "`dataclass` is used on a `BaseModel` subclass[Â¶](index.html#dataclass-on-model \"Permanent link\")", "anchor": "dataclass-is-used-on-a-basemodel-subclassindexhtmldataclass-on-model-permanent-link", "md_text": "This error is raised when the Pydantic `dataclass` decorator is used on a class which is already\na Pydantic model.\n\n```\nfrom pydantic import BaseModel, PydanticUserError\nfrom pydantic.dataclasses import dataclass\n\ntry:\n\n    @dataclass\n    class Model(BaseModel):\n        bar: str\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'dataclass-on-model'\n```", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#dataclass-is-used-on-a-basemodel-subclassindexhtmldataclass-on-model-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "Unsupported type for `validate_call`[Â¶](index.html#validate-call-type \"Permanent link\")", "anchor": "unsupported-type-for-validatecallindexhtmlvalidate-call-type-permanent-link", "md_text": "`validate_call` has some limitations on the callables it can validate. This error is raised when you try to use it with an unsupported callable.\nCurrently the supported callables are functions (including lambdas, but not built-ins) and methods and instances of [`partial`](https://docs.python.org/3/library/functools.html#functools.partial).\nIn the case of [`partial`](https://docs.python.org/3/library/functools.html#functools.partial), the function being partially applied must be one of the supported callables.", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#unsupported-type-for-validatecallindexhtmlvalidate-call-type-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "`@classmethod`, `@staticmethod`, and `@property`[Â¶](index.html#classmethod-staticmethod-and-property \"Permanent link\")", "anchor": "classmethod-staticmethod-and-propertyindexhtmlclassmethod-staticmethod-and-property-permanent-link", "md_text": "These decorators must be put before `validate_call`.\n\n```\nfrom pydantic import PydanticUserError, validate_call\n\n# error\ntry:\n\n    class A:\n        @validate_call\n        @classmethod\n        def f1(cls): ...\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'validate-call-type'\n\n\n# correct\n@classmethod\n@validate_call\ndef f2(cls): ...\n```", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#classmethod-staticmethod-and-propertyindexhtmlclassmethod-staticmethod-and-property-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "Classes[Â¶](index.html#classes \"Permanent link\")", "anchor": "classesindexhtmlclasses-permanent-link", "md_text": "While classes are callables themselves, `validate_call` can't be applied on them, as it needs to know about which method to use (`__init__` or `__new__`) to fetch type annotations. If you want to validate the constructor of a class, you should put `validate_call` on top of the appropriate method instead.\n\n```\nfrom pydantic import PydanticUserError, validate_call\n\n# error\ntry:\n\n    @validate_call\n    class A1: ...\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'validate-call-type'\n\n\n# correct\nclass A2:\n    @validate_call\n    def __init__(self): ...\n\n    @validate_call\n    def __new__(cls): ...\n```", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#classesindexhtmlclasses-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "Callable instances[Â¶](index.html#callable-instances \"Permanent link\")", "anchor": "callable-instancesindexhtmlcallable-instances-permanent-link", "md_text": "Although instances can be callable by implementing a `__call__` method, currently the instances of these types cannot be validated with `validate_call`.\nThis may change in the future, but for now, you should use `validate_call` explicitly on `__call__` instead.\n\n```\nfrom pydantic import PydanticUserError, validate_call\n\n# error\ntry:\n\n    class A1:\n        def __call__(self): ...\n\n    validate_call(A1())\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'validate-call-type'\n\n\n# correct\nclass A2:\n    @validate_call\n    def __call__(self): ...\n```", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#callable-instancesindexhtmlcallable-instances-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "Invalid signature[Â¶](index.html#invalid-signature \"Permanent link\")", "anchor": "invalid-signatureindexhtmlinvalid-signature-permanent-link", "md_text": "This is generally less common, but a possible reason is that you are trying to validate a method that doesn't have at least one argument (usually `self`).\n\n```\nfrom pydantic import PydanticUserError, validate_call\n\ntry:\n\n    class A:\n        def f(): ...\n\n    validate_call(A().f)\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'validate-call-type'\n```", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#invalid-signatureindexhtmlinvalid-signature-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "[`Unpack`](https://docs.python.org/3/library/typing.html#typing.Unpack) used without a [`TypedDict`](https://docs.python.org/3/library/typing.html#typing.TypedDict)[Â¶](index.html#unpack-typed-dict \"Permanent link\")", "anchor": "unpackhttpsdocspythonorg3librarytypinghtmltypingunpack-used-without-a-typeddicthttpsdocspythonorg3librarytypinghtmltypingtypeddictindexhtmlunpack-typed-dict-permanent-link", "md_text": "This error is raised when [`Unpack`](https://docs.python.org/3/library/typing.html#typing.Unpack) is used with something other than\na [`TypedDict`](https://docs.python.org/3/library/typing.html#typing.TypedDict) class object to type hint variadic keyword parameters.\n\nFor reference, see the [related specification section](https://typing.readthedocs.io/en/latest/spec/callables.html#unpack-for-keyword-arguments) and [PEP 692](https://peps.python.org/pep-0692/).\n\nPython 3.9 and abovePython 3.12 and above\n\n```\nfrom typing_extensions import Unpack\n\nfrom pydantic import PydanticUserError, validate_call\n\ntry:\n\n    @validate_call\n    def func(**kwargs: Unpack[int]):\n        pass\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'unpack-typed-dict'\n\nfrom typing import Unpack\n\nfrom pydantic import PydanticUserError, validate_call\n\ntry:\n\n    @validate_call\n    def func(**kwargs: Unpack[int]):\n        pass\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'unpack-typed-dict'\n```", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#unpackhttpsdocspythonorg3librarytypinghtmltypingunpack-used-without-a-typeddicthttpsdocspythonorg3librarytypinghtmltypingtypeddictindexhtmlunpack-typed-dict-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "Overlapping unpacked [`TypedDict`](https://docs.python.org/3/library/typing.html#typing.TypedDict) fields and arguments[Â¶](index.html#overlapping-unpack-typed-dict \"Permanent link\")", "anchor": "overlapping-unpacked-typeddicthttpsdocspythonorg3librarytypinghtmltypingtypeddict-fields-and-argumentsindexhtmloverlapping-unpack-typed-dict-permanent-link", "md_text": "This error is raised when the typed dictionary used to type hint variadic keywords parameters has field names\noverlapping with other parameters (unless [positional only](https://docs.python.org/3/glossary.html#positional-only-parameter)).\n\nFor reference, see the [related specification section](https://typing.readthedocs.io/en/latest/spec/callables.html#unpack-for-keyword-arguments) and [PEP 692](https://peps.python.org/pep-0692/).\n\nPython 3.9 and abovePython 3.12 and abovePython 3.13 and above\n\n```\nfrom typing_extensions import TypedDict, Unpack\n\nfrom pydantic import PydanticUserError, validate_call\n\n\nclass TD(TypedDict):\n    a: int\n\n\ntry:\n\n    @validate_call\n    def func(a: int, **kwargs: Unpack[TD]):\n        pass\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'overlapping-unpack-typed-dict'\n\nfrom typing_extensions import TypedDict\nfrom typing import Unpack\n\nfrom pydantic import PydanticUserError, validate_call\n\n\nclass TD(TypedDict):\n    a: int\n\n\ntry:\n\n    @validate_call\n    def func(a: int, **kwargs: Unpack[TD]):\n        pass\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'overlapping-unpack-typed-dict'\n\nfrom typing import TypedDict, Unpack\n\nfrom pydantic import PydanticUserError, validate_call\n\n\nclass TD(TypedDict):\n    a: int\n\n\ntry:\n\n    @validate_call\n    def func(a: int, **kwargs: Unpack[TD]):\n        pass\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'overlapping-unpack-typed-dict'\n```", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#overlapping-unpacked-typeddicthttpsdocspythonorg3librarytypinghtmltypingtypeddict-fields-and-argumentsindexhtmloverlapping-unpack-typed-dict-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "Invalid `Self` type[Â¶](index.html#invalid-self-type \"Permanent link\")", "anchor": "invalid-self-typeindexhtmlinvalid-self-type-permanent-link", "md_text": "Currently, [`Self`](https://docs.python.org/3/library/typing.html#typing.Self) can only be used to annotate a field of a class (specifically, subclasses of [`BaseModel`](../../api/base_model/index.html#pydantic.BaseModel), [`NamedTuple`](https://docs.python.org/3/library/typing.html#typing.NamedTuple), [`TypedDict`](https://docs.python.org/3/library/typing.html#typing.TypedDict), or dataclasses). Attempting to use [`Self`](https://docs.python.org/3/library/typing.html#typing.Self) in any other ways will raise this error.\n\nPython 3.9 and abovePython 3.11 and above\n\n```\nfrom typing_extensions import Self\n\nfrom pydantic import PydanticUserError, validate_call\n\ntry:\n\n    @validate_call\n    def func(self: Self):\n        pass\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'invalid-self-type'\n\nfrom typing import Self\n\nfrom pydantic import PydanticUserError, validate_call\n\ntry:\n\n    @validate_call\n    def func(self: Self):\n        pass\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'invalid-self-type'\n```\n\nThe following example of [`validate_call()`](../../api/validate_call/index.html#pydantic.validate_call_decorator.validate_call) will also raise this error, even though it is correct from a type-checking perspective. This may be supported in the future.\n\nPython 3.9 and abovePython 3.11 and above\n\n```\nfrom typing_extensions import Self\n\nfrom pydantic import BaseModel, PydanticUserError, validate_call\n\ntry:\n\n    class A(BaseModel):\n        @validate_call\n        def func(self, arg: Self):\n            pass\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'invalid-self-type'\n\nfrom typing import Self\n\nfrom pydantic import BaseModel, PydanticUserError, validate_call\n\ntry:\n\n    class A(BaseModel):\n        @validate_call\n        def func(self, arg: Self):\n            pass\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'invalid-self-type'\n```", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#invalid-self-typeindexhtmlinvalid-self-type-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "`validate_by_alias` and `validate_by_name` both set to `False`[Â¶](index.html#validate-by-alias-and-name-false \"Permanent link\")", "anchor": "validatebyalias-and-validatebyname-both-set-to-falseindexhtmlvalidate-by-alias-and-name-false-permanent-link", "md_text": "This error is raised when you set `validate_by_alias` and `validate_by_name` to `False` in the configuration.\n\nThis is not allowed because it would make it impossible to populate attributes.\n\n```\nfrom pydantic import BaseModel, ConfigDict, Field, PydanticUserError\n\ntry:\n\n    class Model(BaseModel):\n        a: int = Field(alias='A')\n\n        model_config = ConfigDict(\n            validate_by_alias=False, validate_by_name=False\n        )\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'validate-by-alias-and-name-false'\n```\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/errors/usage_errors/index.html#validatebyalias-and-validatebyname-both-set-to-falseindexhtmlvalidate-by-alias-and-name-false-permanent-link", "page": "errors/usage_errors/index.html", "source_site": "pydantic"}
{"title": "`arguments_type`[Â¶](index.html#arguments_type \"Permanent link\")", "anchor": "argumentstypeindexhtmlargumentstype-permanent-link", "md_text": "This error is raised when an object that would be passed as arguments to a function during validation is not\na `tuple`, `list`, or `dict`. Because `NamedTuple` uses function calls in its implementation, that is one way to\nproduce this error:\n\n```\nfrom typing import NamedTuple\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass MyNamedTuple(NamedTuple):\n    x: int\n\n\nclass MyModel(BaseModel):\n    field: MyNamedTuple\n\n\ntry:\n    MyModel.model_validate({'field': 'invalid'})\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'arguments_type'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#argumentstypeindexhtmlargumentstype-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`assertion_error`[Â¶](index.html#assertion_error \"Permanent link\")", "anchor": "assertionerrorindexhtmlassertionerror-permanent-link", "md_text": "This error is raised when a failing `assert` statement is encountered during validation:\n\n```\nfrom pydantic import BaseModel, ValidationError, field_validator\n\n\nclass Model(BaseModel):\n    x: int\n\n    @field_validator('x')\n    @classmethod\n    def force_x_positive(cls, v):\n        assert v > 0\n        return v\n\n\ntry:\n    Model(x=-1)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'assertion_error'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#assertionerrorindexhtmlassertionerror-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`bool_parsing`[Â¶](index.html#bool_parsing \"Permanent link\")", "anchor": "boolparsingindexhtmlboolparsing-permanent-link", "md_text": "This error is raised when the input value is a string that is not valid for coercion to a boolean:\n\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: bool\n\n\nModel(x='true')  # OK\n\ntry:\n    Model(x='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'bool_parsing'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#boolparsingindexhtmlboolparsing-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`bool_type`[Â¶](index.html#bool_type \"Permanent link\")", "anchor": "booltypeindexhtmlbooltype-permanent-link", "md_text": "This error is raised when the input value's type is not valid for a `bool` field:\n\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: bool\n\n\ntry:\n    Model(x=None)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'bool_type'\n```\n\nThis error is also raised for strict fields when the input value is not an instance of `bool`.", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#booltypeindexhtmlbooltype-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`bytes_invalid_encoding`[Â¶](index.html#bytes_invalid_encoding \"Permanent link\")", "anchor": "bytesinvalidencodingindexhtmlbytesinvalidencoding-permanent-link", "md_text": "This error is raised when a `bytes` value is invalid under the configured encoding.\nIn the following example, `b'a'` is invalid hex (odd number of digits).\n\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: bytes\n    model_config = {'val_json_bytes': 'hex'}\n\n\ntry:\n    Model(x=b'a')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'bytes_invalid_encoding'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#bytesinvalidencodingindexhtmlbytesinvalidencoding-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`bytes_too_long`[Â¶](index.html#bytes_too_long \"Permanent link\")", "anchor": "bytestoolongindexhtmlbytestoolong-permanent-link", "md_text": "This error is raised when the length of a `bytes` value is greater than the field's `max_length` constraint:\n\n```\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: bytes = Field(max_length=3)\n\n\ntry:\n    Model(x=b'test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'bytes_too_long'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#bytestoolongindexhtmlbytestoolong-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`bytes_too_short`[Â¶](index.html#bytes_too_short \"Permanent link\")", "anchor": "bytestooshortindexhtmlbytestooshort-permanent-link", "md_text": "This error is raised when the length of a `bytes` value is less than the field's `min_length` constraint:\n\n```\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: bytes = Field(min_length=3)\n\n\ntry:\n    Model(x=b't')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'bytes_too_short'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#bytestooshortindexhtmlbytestooshort-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`bytes_type`[Â¶](index.html#bytes_type \"Permanent link\")", "anchor": "bytestypeindexhtmlbytestype-permanent-link", "md_text": "This error is raised when the input value's type is not valid for a `bytes` field:\n\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: bytes\n\n\ntry:\n    Model(x=123)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'bytes_type'\n```\n\nThis error is also raised for strict fields when the input value is not an instance of `bytes`.", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#bytestypeindexhtmlbytestype-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`callable_type`[Â¶](index.html#callable_type \"Permanent link\")", "anchor": "callabletypeindexhtmlcallabletype-permanent-link", "md_text": "This error is raised when the input value is not valid as a `Callable`:\n\nPython 3.9 and abovePython 3.10 and above\n\n```\nfrom typing import Any, Callable\n\nfrom pydantic import BaseModel, ImportString, ValidationError\n\n\nclass Model(BaseModel):\n    x: ImportString[Callable[[Any], Any]]\n\n\nModel(x='math:cos')  # OK\n\ntry:\n    Model(x='os.path')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'callable_type'\n\nfrom typing import Any\nfrom collections.abc import Callable\n\nfrom pydantic import BaseModel, ImportString, ValidationError\n\n\nclass Model(BaseModel):\n    x: ImportString[Callable[[Any], Any]]\n\n\nModel(x='math:cos')  # OK\n\ntry:\n    Model(x='os.path')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'callable_type'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#callabletypeindexhtmlcallabletype-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`complex_str_parsing`[Â¶](index.html#complex_str_parsing \"Permanent link\")", "anchor": "complexstrparsingindexhtmlcomplexstrparsing-permanent-link", "md_text": "This error is raised when the input value is a string but cannot be parsed as a complex number because\nit does not follow the [rule](https://docs.python.org/3/library/functions.html#complex) in Python:\n\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    num: complex\n\n\ntry:\n    # Complex numbers in json are expected to be valid complex strings.\n    # This value `abc` is not a valid complex string.\n    Model.model_validate_json('{\"num\": \"abc\"}')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'complex_str_parsing'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#complexstrparsingindexhtmlcomplexstrparsing-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`complex_type`[Â¶](index.html#complex_type \"Permanent link\")", "anchor": "complextypeindexhtmlcomplextype-permanent-link", "md_text": "This error is raised when the input value cannot be interpreted as a complex number:\n\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    num: complex\n\n\ntry:\n    Model(num=False)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'complex_type'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#complextypeindexhtmlcomplextype-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`dataclass_exact_type`[Â¶](index.html#dataclass_exact_type \"Permanent link\")", "anchor": "dataclassexacttypeindexhtmldataclassexacttype-permanent-link", "md_text": "This error is raised when validating a dataclass with `strict=True` and the input is not an instance of the dataclass:\n\n```\nimport pydantic.dataclasses\nfrom pydantic import TypeAdapter, ValidationError\n\n\n@pydantic.dataclasses.dataclass\nclass MyDataclass:\n    x: str\n\n\nadapter = TypeAdapter(MyDataclass)\n\nprint(adapter.validate_python(MyDataclass(x='test'), strict=True))\n#> MyDataclass(x='test')\nprint(adapter.validate_python({'x': 'test'}))\n#> MyDataclass(x='test')\n\ntry:\n    adapter.validate_python({'x': 'test'}, strict=True)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'dataclass_exact_type'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#dataclassexacttypeindexhtmldataclassexacttype-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`dataclass_type`[Â¶](index.html#dataclass_type \"Permanent link\")", "anchor": "dataclasstypeindexhtmldataclasstype-permanent-link", "md_text": "This error is raised when the input value is not valid for a `dataclass` field:\n\n```\nfrom pydantic import ValidationError, dataclasses\n\n\n@dataclasses.dataclass\nclass Inner:\n    x: int\n\n\n@dataclasses.dataclass\nclass Outer:\n    y: Inner\n\n\nOuter(y=Inner(x=1))  # OK\n\ntry:\n    Outer(y=1)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'dataclass_type'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#dataclasstypeindexhtmldataclasstype-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`date_from_datetime_inexact`[Â¶](index.html#date_from_datetime_inexact \"Permanent link\")", "anchor": "datefromdatetimeinexactindexhtmldatefromdatetimeinexact-permanent-link", "md_text": "This error is raised when the input `datetime` value provided for a `date` field has a nonzero time component.\nFor a timestamp to parse into a field of type `date`, the time components must all be zero:\n\n```\nfrom datetime import date, datetime\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: date\n\n\nModel(x='2023-01-01')  # OK\nModel(x=datetime(2023, 1, 1))  # OK\n\ntry:\n    Model(x=datetime(2023, 1, 1, 12))\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'date_from_datetime_inexact'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#datefromdatetimeinexactindexhtmldatefromdatetimeinexact-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`date_from_datetime_parsing`[Â¶](index.html#date_from_datetime_parsing \"Permanent link\")", "anchor": "datefromdatetimeparsingindexhtmldatefromdatetimeparsing-permanent-link", "md_text": "This error is raised when the input value is a string that cannot be parsed for a `date` field:\n\n```\nfrom datetime import date\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: date\n\n\ntry:\n    Model(x='XX1494012000')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'date_from_datetime_parsing'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#datefromdatetimeparsingindexhtmldatefromdatetimeparsing-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`date_future`[Â¶](index.html#date_future \"Permanent link\")", "anchor": "datefutureindexhtmldatefuture-permanent-link", "md_text": "This error is raised when the input value provided for a `FutureDate` field is not in the future:\n\n```\nfrom datetime import date\n\nfrom pydantic import BaseModel, FutureDate, ValidationError\n\n\nclass Model(BaseModel):\n    x: FutureDate\n\n\ntry:\n    Model(x=date(2000, 1, 1))\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'date_future'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#datefutureindexhtmldatefuture-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`date_parsing`[Â¶](index.html#date_parsing \"Permanent link\")", "anchor": "dateparsingindexhtmldateparsing-permanent-link", "md_text": "This error is raised when validating JSON where the input value is string that cannot be parsed for a `date` field:\n\n```\nimport json\nfrom datetime import date\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: date = Field(strict=True)\n\n\ntry:\n    Model.model_validate_json(json.dumps({'x': '1'}))\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'date_parsing'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#dateparsingindexhtmldateparsing-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`date_past`[Â¶](index.html#date_past \"Permanent link\")", "anchor": "datepastindexhtmldatepast-permanent-link", "md_text": "This error is raised when the value provided for a `PastDate` field is not in the past:\n\n```\nfrom datetime import date, timedelta\n\nfrom pydantic import BaseModel, PastDate, ValidationError\n\n\nclass Model(BaseModel):\n    x: PastDate\n\n\ntry:\n    Model(x=date.today() + timedelta(1))\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'date_past'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#datepastindexhtmldatepast-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`date_type`[Â¶](index.html#date_type \"Permanent link\")", "anchor": "datetypeindexhtmldatetype-permanent-link", "md_text": "This error is raised when the input value's type is not valid for a `date` field:\n\n```\nfrom datetime import date\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: date\n\n\ntry:\n    Model(x=None)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'date_type'\n```\n\nThis error is also raised for strict fields when the input value is not an instance of `date`.", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#datetypeindexhtmldatetype-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`datetime_from_date_parsing`[Â¶](index.html#datetime_from_date_parsing \"Permanent link\")", "anchor": "datetimefromdateparsingindexhtmldatetimefromdateparsing-permanent-link", "md_text": "This error is raised when the input value is a string that cannot be parsed for a `datetime` field:\n\n```\nfrom datetime import datetime\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: datetime\n\n\ntry:\n    # there is no 13th month\n    Model(x='2023-13-01')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'datetime_from_date_parsing'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#datetimefromdateparsingindexhtmldatetimefromdateparsing-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`datetime_future`[Â¶](index.html#datetime_future \"Permanent link\")", "anchor": "datetimefutureindexhtmldatetimefuture-permanent-link", "md_text": "This error is raised when the value provided for a `FutureDatetime` field is not in the future:\n\n```\nfrom datetime import datetime\n\nfrom pydantic import BaseModel, FutureDatetime, ValidationError\n\n\nclass Model(BaseModel):\n    x: FutureDatetime\n\n\ntry:\n    Model(x=datetime(2000, 1, 1))\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'datetime_future'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#datetimefutureindexhtmldatetimefuture-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`datetime_object_invalid`[Â¶](index.html#datetime_object_invalid \"Permanent link\")", "anchor": "datetimeobjectinvalidindexhtmldatetimeobjectinvalid-permanent-link", "md_text": "This error is raised when something about the `datetime` object is not valid:\n\n```\nfrom datetime import datetime, tzinfo\n\nfrom pydantic import AwareDatetime, BaseModel, ValidationError\n\n\nclass CustomTz(tzinfo):\n    # utcoffset is not implemented!\n\n    def tzname(self, _dt):\n        return 'CustomTZ'\n\n\nclass Model(BaseModel):\n    x: AwareDatetime\n\n\ntry:\n    Model(x=datetime(2023, 1, 1, tzinfo=CustomTz()))\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'datetime_object_invalid'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#datetimeobjectinvalidindexhtmldatetimeobjectinvalid-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`datetime_parsing`[Â¶](index.html#datetime_parsing \"Permanent link\")", "anchor": "datetimeparsingindexhtmldatetimeparsing-permanent-link", "md_text": "This error is raised when the value is a string that cannot be parsed for a `datetime` field:\n\n```\nimport json\nfrom datetime import datetime\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: datetime = Field(strict=True)\n\n\ntry:\n    Model.model_validate_json(json.dumps({'x': 'not a datetime'}))\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'datetime_parsing'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#datetimeparsingindexhtmldatetimeparsing-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`datetime_past`[Â¶](index.html#datetime_past \"Permanent link\")", "anchor": "datetimepastindexhtmldatetimepast-permanent-link", "md_text": "This error is raised when the value provided for a `PastDatetime` field is not in the past:\n\n```\nfrom datetime import datetime, timedelta\n\nfrom pydantic import BaseModel, PastDatetime, ValidationError\n\n\nclass Model(BaseModel):\n    x: PastDatetime\n\n\ntry:\n    Model(x=datetime.now() + timedelta(100))\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'datetime_past'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#datetimepastindexhtmldatetimepast-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`datetime_type`[Â¶](index.html#datetime_type \"Permanent link\")", "anchor": "datetimetypeindexhtmldatetimetype-permanent-link", "md_text": "This error is raised when the input value's type is not valid for a `datetime` field:\n\n```\nfrom datetime import datetime\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: datetime\n\n\ntry:\n    Model(x=None)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'datetime_type'\n```\n\nThis error is also raised for strict fields when the input value is not an instance of `datetime`.", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#datetimetypeindexhtmldatetimetype-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`decimal_max_digits`[Â¶](index.html#decimal_max_digits \"Permanent link\")", "anchor": "decimalmaxdigitsindexhtmldecimalmaxdigits-permanent-link", "md_text": "This error is raised when the value provided for a `Decimal` has too many digits:\n\n```\nfrom decimal import Decimal\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: Decimal = Field(max_digits=3)\n\n\ntry:\n    Model(x='42.1234')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'decimal_max_digits'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#decimalmaxdigitsindexhtmldecimalmaxdigits-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`decimal_max_places`[Â¶](index.html#decimal_max_places \"Permanent link\")", "anchor": "decimalmaxplacesindexhtmldecimalmaxplaces-permanent-link", "md_text": "This error is raised when the value provided for a `Decimal` has too many digits after the decimal point:\n\n```\nfrom decimal import Decimal\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: Decimal = Field(decimal_places=3)\n\n\ntry:\n    Model(x='42.1234')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'decimal_max_places'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#decimalmaxplacesindexhtmldecimalmaxplaces-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`decimal_parsing`[Â¶](index.html#decimal_parsing \"Permanent link\")", "anchor": "decimalparsingindexhtmldecimalparsing-permanent-link", "md_text": "This error is raised when the value provided for a `Decimal` could not be parsed as a decimal number:\n\n```\nfrom decimal import Decimal\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: Decimal = Field(decimal_places=3)\n\n\ntry:\n    Model(x='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'decimal_parsing'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#decimalparsingindexhtmldecimalparsing-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`decimal_type`[Â¶](index.html#decimal_type \"Permanent link\")", "anchor": "decimaltypeindexhtmldecimaltype-permanent-link", "md_text": "This error is raised when the value provided for a `Decimal` is of the wrong type:\n\n```\nfrom decimal import Decimal\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: Decimal = Field(decimal_places=3)\n\n\ntry:\n    Model(x=[1, 2, 3])\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'decimal_type'\n```\n\nThis error is also raised for strict fields when the input value is not an instance of `Decimal`.", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#decimaltypeindexhtmldecimaltype-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`decimal_whole_digits`[Â¶](index.html#decimal_whole_digits \"Permanent link\")", "anchor": "decimalwholedigitsindexhtmldecimalwholedigits-permanent-link", "md_text": "This error is raised when the value provided for a `Decimal` has more digits before the decimal point than `max_digits` - `decimal_places` (as long as both are specified):\n\n```\nfrom decimal import Decimal\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: Decimal = Field(max_digits=6, decimal_places=3)\n\n\ntry:\n    Model(x='12345.6')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'decimal_whole_digits'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#decimalwholedigitsindexhtmldecimalwholedigits-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`default_factory_not_called`[Â¶](index.html#default_factory_not_called \"Permanent link\")", "anchor": "defaultfactorynotcalledindexhtmldefaultfactorynotcalled-permanent-link", "md_text": "This error is raised when a [default factory taking validated data](../../concepts/fields/index.html#default-factory-validated-data)\ncan't be called, because validation failed on previous fields:\n\n```\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    a: int = Field(gt=10)\n    b: int = Field(default_factory=lambda data: data['a'])\n\n\ntry:\n    Model(a=1)\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    2 validation errors for Model\n    a\n      Input should be greater than 10 [type=greater_than, input_value=1, input_type=int]\n    b\n      The default factory uses validated data, but at least one validation error occurred [type=default_factory_not_called]\n    \"\"\"\n    print(repr(exc.errors()[1]['type']))\n    #> 'default_factory_not_called'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#defaultfactorynotcalledindexhtmldefaultfactorynotcalled-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`dict_type`[Â¶](index.html#dict_type \"Permanent link\")", "anchor": "dicttypeindexhtmldicttype-permanent-link", "md_text": "This error is raised when the input value's type is not `dict` for a `dict` field:\n\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: dict\n\n\ntry:\n    Model(x=['1', '2'])\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'dict_type'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#dicttypeindexhtmldicttype-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`enum`[Â¶](index.html#enum \"Permanent link\")", "anchor": "enumindexhtmlenum-permanent-link", "md_text": "This error is raised when the input value does not exist in an `enum` field members:\n\n```\nfrom enum import Enum\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass MyEnum(str, Enum):\n    option = 'option'\n\n\nclass Model(BaseModel):\n    x: MyEnum\n\n\ntry:\n    Model(x='other_option')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'enum'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#enumindexhtmlenum-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`extra_forbidden`[Â¶](index.html#extra_forbidden \"Permanent link\")", "anchor": "extraforbiddenindexhtmlextraforbidden-permanent-link", "md_text": "This error is raised when the input value contains extra fields, but `model_config['extra'] == 'forbid'`:\n\n```\nfrom pydantic import BaseModel, ConfigDict, ValidationError\n\n\nclass Model(BaseModel):\n    x: str\n\n    model_config = ConfigDict(extra='forbid')\n\n\ntry:\n    Model(x='test', y='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'extra_forbidden'\n```\n\nYou can read more about the `extra` configuration in the [Extra Attributes](../../api/config/index.html#pydantic.config.ConfigDict.extra) section.", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#extraforbiddenindexhtmlextraforbidden-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`finite_number`[Â¶](index.html#finite_number \"Permanent link\")", "anchor": "finitenumberindexhtmlfinitenumber-permanent-link", "md_text": "This error is raised when the value is infinite, or too large to be represented as a 64-bit floating point number\nduring validation:\n\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: int\n\n\ntry:\n    Model(x=2.2250738585072011e308)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'finite_number'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#finitenumberindexhtmlfinitenumber-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`float_parsing`[Â¶](index.html#float_parsing \"Permanent link\")", "anchor": "floatparsingindexhtmlfloatparsing-permanent-link", "md_text": "This error is raised when the value is a string that can't be parsed as a `float`:\n\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: float\n\n\ntry:\n    Model(x='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'float_parsing'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#floatparsingindexhtmlfloatparsing-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`float_type`[Â¶](index.html#float_type \"Permanent link\")", "anchor": "floattypeindexhtmlfloattype-permanent-link", "md_text": "This error is raised when the input value's type is not valid for a `float` field:\n\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: float\n\n\ntry:\n    Model(x=None)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'float_type'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#floattypeindexhtmlfloattype-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`frozen_field`[Â¶](index.html#frozen_field \"Permanent link\")", "anchor": "frozenfieldindexhtmlfrozenfield-permanent-link", "md_text": "This error is raised when you attempt to assign a value to a field with `frozen=True`, or to delete such a field:\n\n```\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: str = Field('test', frozen=True)\n\n\nmodel = Model()\n\ntry:\n    model.x = 'test1'\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'frozen_field'\n\ntry:\n    del model.x\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'frozen_field'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#frozenfieldindexhtmlfrozenfield-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`frozen_instance`[Â¶](index.html#frozen_instance \"Permanent link\")", "anchor": "frozeninstanceindexhtmlfrozeninstance-permanent-link", "md_text": "This error is raised when `frozen` is set in the [configuration](../../concepts/config/index.html) and you attempt to delete or assign a new value to\nany of the fields:\n\n```\nfrom pydantic import BaseModel, ConfigDict, ValidationError\n\n\nclass Model(BaseModel):\n    x: int\n\n    model_config = ConfigDict(frozen=True)\n\n\nm = Model(x=1)\n\ntry:\n    m.x = 2\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'frozen_instance'\n\ntry:\n    del m.x\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'frozen_instance'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#frozeninstanceindexhtmlfrozeninstance-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`frozen_set_type`[Â¶](index.html#frozen_set_type \"Permanent link\")", "anchor": "frozensettypeindexhtmlfrozensettype-permanent-link", "md_text": "This error is raised when the input value's type is not valid for a `frozenset` field:\n\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: frozenset\n\n\ntry:\n    model = Model(x='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'frozen_set_type'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#frozensettypeindexhtmlfrozensettype-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`get_attribute_error`[Â¶](index.html#get_attribute_error \"Permanent link\")", "anchor": "getattributeerrorindexhtmlgetattributeerror-permanent-link", "md_text": "This error is raised when `model_config['from_attributes'] == True` and an error is raised while reading the attributes:\n\n```\nfrom pydantic import BaseModel, ConfigDict, ValidationError\n\n\nclass Foobar:\n    def __init__(self):\n        self.x = 1\n\n    @property\n    def y(self):\n        raise RuntimeError('intentional error')\n\n\nclass Model(BaseModel):\n    x: int\n    y: str\n\n    model_config = ConfigDict(from_attributes=True)\n\n\ntry:\n    Model.model_validate(Foobar())\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'get_attribute_error'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#getattributeerrorindexhtmlgetattributeerror-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`greater_than`[Â¶](index.html#greater_than \"Permanent link\")", "anchor": "greaterthanindexhtmlgreaterthan-permanent-link", "md_text": "This error is raised when the value is not greater than the field's `gt` constraint:\n\n```\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: int = Field(gt=10)\n\n\ntry:\n    Model(x=10)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'greater_than'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#greaterthanindexhtmlgreaterthan-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`greater_than_equal`[Â¶](index.html#greater_than_equal \"Permanent link\")", "anchor": "greaterthanequalindexhtmlgreaterthanequal-permanent-link", "md_text": "This error is raised when the value is not greater than or equal to the field's `ge` constraint:\n\n```\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: int = Field(ge=10)\n\n\ntry:\n    Model(x=9)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'greater_than_equal'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#greaterthanequalindexhtmlgreaterthanequal-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`int_from_float`[Â¶](index.html#int_from_float \"Permanent link\")", "anchor": "intfromfloatindexhtmlintfromfloat-permanent-link", "md_text": "This error is raised when you provide a `float` value for an `int` field:\n\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: int\n\n\ntry:\n    Model(x=0.5)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'int_from_float'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#intfromfloatindexhtmlintfromfloat-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`int_parsing`[Â¶](index.html#int_parsing \"Permanent link\")", "anchor": "intparsingindexhtmlintparsing-permanent-link", "md_text": "This error is raised when the value can't be parsed as `int`:\n\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: int\n\n\ntry:\n    Model(x='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'int_parsing'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#intparsingindexhtmlintparsing-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`int_parsing_size`[Â¶](index.html#int_parsing_size \"Permanent link\")", "anchor": "intparsingsizeindexhtmlintparsingsize-permanent-link", "md_text": "This error is raised when attempting to parse a python or JSON value from a string outside the maximum range that Python\n`str` to `int` parsing permits:\n\n```\nimport json\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: int\n\n\n# from Python\nassert Model(x='1' * 4_300).x == int('1' * 4_300)  # OK\n\ntoo_long = '1' * 4_301\ntry:\n    Model(x=too_long)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'int_parsing_size'\n\n# from JSON\ntry:\n    Model.model_validate_json(json.dumps({'x': too_long}))\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'int_parsing_size'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#intparsingsizeindexhtmlintparsingsize-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`int_type`[Â¶](index.html#int_type \"Permanent link\")", "anchor": "inttypeindexhtmlinttype-permanent-link", "md_text": "This error is raised when the input value's type is not valid for an `int` field:\n\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: int\n\n\ntry:\n    Model(x=None)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'int_type'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#inttypeindexhtmlinttype-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`invalid_key`[Â¶](index.html#invalid_key \"Permanent link\")", "anchor": "invalidkeyindexhtmlinvalidkey-permanent-link", "md_text": "This error is raised when attempting to validate a `dict` that has a key that is not an instance of `str`:\n\n```\nfrom pydantic import BaseModel, ConfigDict, ValidationError\n\n\nclass Model(BaseModel):\n    x: int\n\n    model_config = ConfigDict(extra='allow')\n\n\ntry:\n    Model.model_validate({'x': 1, b'y': 2})\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'invalid_key'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#invalidkeyindexhtmlinvalidkey-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`is_instance_of`[Â¶](index.html#is_instance_of \"Permanent link\")", "anchor": "isinstanceofindexhtmlisinstanceof-permanent-link", "md_text": "This error is raised when the input value is not an instance of the expected type:\n\n```\nfrom pydantic import BaseModel, ConfigDict, ValidationError\n\n\nclass Nested:\n    x: str\n\n\nclass Model(BaseModel):\n    y: Nested\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n\ntry:\n    Model(y='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'is_instance_of'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#isinstanceofindexhtmlisinstanceof-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`is_subclass_of`[Â¶](index.html#is_subclass_of \"Permanent link\")", "anchor": "issubclassofindexhtmlissubclassof-permanent-link", "md_text": "This error is raised when the input value is not a subclass of the expected type:\n\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Nested:\n    x: str\n\n\nclass Model(BaseModel):\n    y: type[Nested]\n\n\ntry:\n    Model(y='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'is_subclass_of'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#issubclassofindexhtmlissubclassof-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`iterable_type`[Â¶](index.html#iterable_type \"Permanent link\")", "anchor": "iterabletypeindexhtmliterabletype-permanent-link", "md_text": "This error is raised when the input value is not valid as an `Iterable`:\n\n```\nfrom collections.abc import Iterable\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    y: Iterable[str]\n\n\ntry:\n    Model(y=123)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'iterable_type'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#iterabletypeindexhtmliterabletype-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`iteration_error`[Â¶](index.html#iteration_error \"Permanent link\")", "anchor": "iterationerrorindexhtmliterationerror-permanent-link", "md_text": "This error is raised when an error occurs during iteration:\n\n```\nfrom pydantic import BaseModel, ValidationError\n\n\ndef gen():\n    yield 1\n    raise RuntimeError('error')\n\n\nclass Model(BaseModel):\n    x: list[int]\n\n\ntry:\n    Model(x=gen())\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'iteration_error'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#iterationerrorindexhtmliterationerror-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`json_invalid`[Â¶](index.html#json_invalid \"Permanent link\")", "anchor": "jsoninvalidindexhtmljsoninvalid-permanent-link", "md_text": "This error is raised when the input value is not a valid JSON string:\n\n```\nfrom pydantic import BaseModel, Json, ValidationError\n\n\nclass Model(BaseModel):\n    x: Json\n\n\ntry:\n    Model(x='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'json_invalid'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#jsoninvalidindexhtmljsoninvalid-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`json_type`[Â¶](index.html#json_type \"Permanent link\")", "anchor": "jsontypeindexhtmljsontype-permanent-link", "md_text": "This error is raised when the input value is of a type that cannot be parsed as JSON:\n\n```\nfrom pydantic import BaseModel, Json, ValidationError\n\n\nclass Model(BaseModel):\n    x: Json\n\n\ntry:\n    Model(x=None)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'json_type'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#jsontypeindexhtmljsontype-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`less_than`[Â¶](index.html#less_than \"Permanent link\")", "anchor": "lessthanindexhtmllessthan-permanent-link", "md_text": "This error is raised when the input value is not less than the field's `lt` constraint:\n\n```\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: int = Field(lt=10)\n\n\ntry:\n    Model(x=10)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'less_than'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#lessthanindexhtmllessthan-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`less_than_equal`[Â¶](index.html#less_than_equal \"Permanent link\")", "anchor": "lessthanequalindexhtmllessthanequal-permanent-link", "md_text": "This error is raised when the input value is not less than or equal to the field's `le` constraint:\n\n```\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: int = Field(le=10)\n\n\ntry:\n    Model(x=11)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'less_than_equal'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#lessthanequalindexhtmllessthanequal-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`list_type`[Â¶](index.html#list_type \"Permanent link\")", "anchor": "listtypeindexhtmllisttype-permanent-link", "md_text": "This error is raised when the input value's type is not valid for a `list` field:\n\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: list[int]\n\n\ntry:\n    Model(x=1)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'list_type'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#listtypeindexhtmllisttype-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`literal_error`[Â¶](index.html#literal_error \"Permanent link\")", "anchor": "literalerrorindexhtmlliteralerror-permanent-link", "md_text": "This error is raised when the input value is not one of the expected literal values:\n\n```\nfrom typing import Literal\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: Literal['a', 'b']\n\n\nModel(x='a')  # OK\n\ntry:\n    Model(x='c')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'literal_error'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#literalerrorindexhtmlliteralerror-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`mapping_type`[Â¶](index.html#mapping_type \"Permanent link\")", "anchor": "mappingtypeindexhtmlmappingtype-permanent-link", "md_text": "This error is raised when a problem occurs during validation due to a failure in a call to the methods from the\n`Mapping` protocol, such as `.items()`:\n\n```\nfrom collections.abc import Mapping\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass BadMapping(Mapping):\n    def items(self):\n        raise ValueError()\n\n    def __iter__(self):\n        raise ValueError()\n\n    def __getitem__(self, key):\n        raise ValueError()\n\n    def __len__(self):\n        return 1\n\n\nclass Model(BaseModel):\n    x: dict[str, str]\n\n\ntry:\n    Model(x=BadMapping())\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'mapping_type'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#mappingtypeindexhtmlmappingtype-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`missing`[Â¶](index.html#missing \"Permanent link\")", "anchor": "missingindexhtmlmissing-permanent-link", "md_text": "This error is raised when there are required fields missing from the input value:\n\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: str\n\n\ntry:\n    Model()\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'missing'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#missingindexhtmlmissing-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`missing_argument`[Â¶](index.html#missing_argument \"Permanent link\")", "anchor": "missingargumentindexhtmlmissingargument-permanent-link", "md_text": "This error is raised when a required positional-or-keyword argument is not passed to a function decorated with\n`validate_call`:\n\n```\nfrom pydantic import ValidationError, validate_call\n\n\n@validate_call\ndef foo(a: int):\n    return a\n\n\ntry:\n    foo()\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'missing_argument'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#missingargumentindexhtmlmissingargument-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`missing_keyword_only_argument`[Â¶](index.html#missing_keyword_only_argument \"Permanent link\")", "anchor": "missingkeywordonlyargumentindexhtmlmissingkeywordonlyargument-permanent-link", "md_text": "This error is raised when a required keyword-only argument is not passed to a function decorated with `validate_call`:\n\n```\nfrom pydantic import ValidationError, validate_call\n\n\n@validate_call\ndef foo(*, a: int):\n    return a\n\n\ntry:\n    foo()\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'missing_keyword_only_argument'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#missingkeywordonlyargumentindexhtmlmissingkeywordonlyargument-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`missing_positional_only_argument`[Â¶](index.html#missing_positional_only_argument \"Permanent link\")", "anchor": "missingpositionalonlyargumentindexhtmlmissingpositionalonlyargument-permanent-link", "md_text": "This error is raised when a required positional-only argument is not passed to a function decorated with\n`validate_call`:\n\n```\nfrom pydantic import ValidationError, validate_call\n\n\n@validate_call\ndef foo(a: int, /):\n    return a\n\n\ntry:\n    foo()\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'missing_positional_only_argument'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#missingpositionalonlyargumentindexhtmlmissingpositionalonlyargument-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`missing_sentinel_error`[Â¶](index.html#missing_sentinel_error \"Permanent link\")", "anchor": "missingsentinelerrorindexhtmlmissingsentinelerror-permanent-link", "md_text": "This error is raised when the experimental `MISSING` sentinel is the only value allowed, and wasn't\nprovided during validation:\n\n```\nfrom pydantic import BaseModel, ValidationError\nfrom pydantic.experimental.missing_sentinel import MISSING\n\n\nclass Model(BaseModel):\n    f: MISSING\n\n\ntry:\n    Model(f=1)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'missing_sentinel_error'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#missingsentinelerrorindexhtmlmissingsentinelerror-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`model_attributes_type`[Â¶](index.html#model_attributes_type \"Permanent link\")", "anchor": "modelattributestypeindexhtmlmodelattributestype-permanent-link", "md_text": "This error is raised when the input value is not a valid dictionary, model instance, or instance that fields can be extracted from:\n\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    a: int\n    b: int\n\n\n# simply validating a dict\nprint(Model.model_validate({'a': 1, 'b': 2}))\n#> a=1 b=2\n\n\nclass CustomObj:\n    def __init__(self, a, b):\n        self.a = a\n        self.b = b\n\n\n# using from attributes to extract fields from an objects\nprint(Model.model_validate(CustomObj(3, 4), from_attributes=True))\n#> a=3 b=4\n\ntry:\n    Model.model_validate('not an object', from_attributes=True)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'model_attributes_type'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#modelattributestypeindexhtmlmodelattributestype-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`model_type`[Â¶](index.html#model_type \"Permanent link\")", "anchor": "modeltypeindexhtmlmodeltype-permanent-link", "md_text": "This error is raised when the input to a model is not an instance of the model or dict:\n\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    a: int\n    b: int\n\n\n# simply validating a dict\nm = Model.model_validate({'a': 1, 'b': 2})\nprint(m)\n#> a=1 b=2\n\n# validating an existing model instance\nprint(Model.model_validate(m))\n#> a=1 b=2\n\ntry:\n    Model.model_validate('not an object')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'model_type'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#modeltypeindexhtmlmodeltype-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`multiple_argument_values`[Â¶](index.html#multiple_argument_values \"Permanent link\")", "anchor": "multipleargumentvaluesindexhtmlmultipleargumentvalues-permanent-link", "md_text": "This error is raised when you provide multiple values for a single argument while calling a function decorated with\n`validate_call`:\n\n```\nfrom pydantic import ValidationError, validate_call\n\n\n@validate_call\ndef foo(a: int):\n    return a\n\n\ntry:\n    foo(1, a=2)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'multiple_argument_values'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#multipleargumentvaluesindexhtmlmultipleargumentvalues-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`multiple_of`[Â¶](index.html#multiple_of \"Permanent link\")", "anchor": "multipleofindexhtmlmultipleof-permanent-link", "md_text": "This error is raised when the input is not a multiple of a field's `multiple_of` constraint:\n\n```\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: int = Field(multiple_of=5)\n\n\ntry:\n    Model(x=1)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'multiple_of'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#multipleofindexhtmlmultipleof-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`needs_python_object`[Â¶](index.html#needs_python_object \"Permanent link\")", "anchor": "needspythonobjectindexhtmlneedspythonobject-permanent-link", "md_text": "This type of error is raised when validation is attempted from a format that cannot be converted to a Python object.\nFor example, we cannot check `isinstance` or `issubclass` from JSON:\n\n```\nimport json\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    bm: type[BaseModel]\n\n\ntry:\n    Model.model_validate_json(json.dumps({'bm': 'not a basemodel class'}))\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'needs_python_object'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#needspythonobjectindexhtmlneedspythonobject-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`no_such_attribute`[Â¶](index.html#no_such_attribute \"Permanent link\")", "anchor": "nosuchattributeindexhtmlnosuchattribute-permanent-link", "md_text": "This error is raised when `validate_assignment=True` in the config, and you attempt to assign a value to an attribute\nthat is not an existing field:\n\n```\nfrom pydantic import ConfigDict, ValidationError, dataclasses\n\n\n@dataclasses.dataclass(config=ConfigDict(validate_assignment=True))\nclass MyDataclass:\n    x: int\n\n\nm = MyDataclass(x=1)\ntry:\n    m.y = 10\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'no_such_attribute'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#nosuchattributeindexhtmlnosuchattribute-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`none_required`[Â¶](index.html#none_required \"Permanent link\")", "anchor": "nonerequiredindexhtmlnonerequired-permanent-link", "md_text": "This error is raised when the input value is not `None` for a field that requires `None`:\n\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: None\n\n\ntry:\n    Model(x=1)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'none_required'\n```\n\nYou may encounter this error when there is a naming collision in your model between a field name and its type. More specifically, this error is likely to be thrown when the default value of that field is `None`.\n\nFor example, the following would yield the `none_required` validation error since the field `int` is set to a default value of `None` and has the exact same name as its type, which causes problems with validation.\n\n```\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass M1(BaseModel):\n    int: Optional[int] = None\n\n\nm = M1(int=123)  # errors\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#nonerequiredindexhtmlnonerequired-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`recursion_loop`[Â¶](index.html#recursion_loop \"Permanent link\")", "anchor": "recursionloopindexhtmlrecursionloop-permanent-link", "md_text": "This error is raised when a cyclic reference is detected:\n\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: list['Model']\n\n\nd = {'x': []}\nd['x'].append(d)\ntry:\n    Model(**d)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'recursion_loop'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#recursionloopindexhtmlrecursionloop-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`set_item_not_hashable`[Â¶](index.html#set_item_not_hashable \"Permanent link\")", "anchor": "setitemnothashableindexhtmlsetitemnothashable-permanent-link", "md_text": "This error is raised when an unhashable value is validated against a [`set`](https://docs.python.org/3/reference/expressions.html#set) or a [`frozenset`](https://docs.python.org/3/library/stdtypes.html#frozenset):\n\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: set[object]\n\n\nclass Unhashable:\n    __hash__ = None\n\n\ntry:\n    Model(x=[{'a': 'b'}, Unhashable()])\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'set_item_not_hashable'\n    print(repr(exc.errors()[1]['type']))\n    #> 'set_item_not_hashable'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#setitemnothashableindexhtmlsetitemnothashable-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`set_type`[Â¶](index.html#set_type \"Permanent link\")", "anchor": "settypeindexhtmlsettype-permanent-link", "md_text": "This error is raised when the value type is not valid for a `set` field:\n\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: set[int]\n\n\ntry:\n    Model(x='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'set_type'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#settypeindexhtmlsettype-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`string_pattern_mismatch`[Â¶](index.html#string_pattern_mismatch \"Permanent link\")", "anchor": "stringpatternmismatchindexhtmlstringpatternmismatch-permanent-link", "md_text": "This error is raised when the input value doesn't match the field's `pattern` constraint:\n\n```\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: str = Field(pattern='test')\n\n\ntry:\n    Model(x='1')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'string_pattern_mismatch'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#stringpatternmismatchindexhtmlstringpatternmismatch-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`string_sub_type`[Â¶](index.html#string_sub_type \"Permanent link\")", "anchor": "stringsubtypeindexhtmlstringsubtype-permanent-link", "md_text": "This error is raised when the value is an instance of a strict subtype of `str` when the field is strict:\n\n```\nfrom enum import Enum\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass MyEnum(str, Enum):\n    foo = 'foo'\n\n\nclass Model(BaseModel):\n    x: str = Field(strict=True)\n\n\ntry:\n    Model(x=MyEnum.foo)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'string_sub_type'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#stringsubtypeindexhtmlstringsubtype-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`string_too_long`[Â¶](index.html#string_too_long \"Permanent link\")", "anchor": "stringtoolongindexhtmlstringtoolong-permanent-link", "md_text": "This error is raised when the input value is a string whose length is greater than the field's `max_length` constraint:\n\n```\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: str = Field(max_length=3)\n\n\ntry:\n    Model(x='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'string_too_long'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#stringtoolongindexhtmlstringtoolong-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`string_too_short`[Â¶](index.html#string_too_short \"Permanent link\")", "anchor": "stringtooshortindexhtmlstringtooshort-permanent-link", "md_text": "This error is raised when the input value is a string whose length is less than the field's `min_length` constraint:\n\n```\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: str = Field(min_length=3)\n\n\ntry:\n    Model(x='t')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'string_too_short'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#stringtooshortindexhtmlstringtooshort-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`string_type`[Â¶](index.html#string_type \"Permanent link\")", "anchor": "stringtypeindexhtmlstringtype-permanent-link", "md_text": "This error is raised when the input value's type is not valid for a `str` field:\n\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: str\n\n\ntry:\n    Model(x=1)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'string_type'\n```\n\nThis error is also raised for strict fields when the input value is not an instance of `str`.", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#stringtypeindexhtmlstringtype-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`string_unicode`[Â¶](index.html#string_unicode \"Permanent link\")", "anchor": "stringunicodeindexhtmlstringunicode-permanent-link", "md_text": "This error is raised when the value cannot be parsed as a Unicode string:\n\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: str\n\n\ntry:\n    Model(x=b'\\x81')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'string_unicode'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#stringunicodeindexhtmlstringunicode-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`time_delta_parsing`[Â¶](index.html#time_delta_parsing \"Permanent link\")", "anchor": "timedeltaparsingindexhtmltimedeltaparsing-permanent-link", "md_text": "This error is raised when the input value is a string that cannot be parsed for a `timedelta` field:\n\n```\nfrom datetime import timedelta\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: timedelta\n\n\ntry:\n    Model(x='t')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'time_delta_parsing'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#timedeltaparsingindexhtmltimedeltaparsing-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`time_delta_type`[Â¶](index.html#time_delta_type \"Permanent link\")", "anchor": "timedeltatypeindexhtmltimedeltatype-permanent-link", "md_text": "This error is raised when the input value's type is not valid for a `timedelta` field:\n\n```\nfrom datetime import timedelta\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: timedelta\n\n\ntry:\n    Model(x=None)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'time_delta_type'\n```\n\nThis error is also raised for strict fields when the input value is not an instance of `timedelta`.", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#timedeltatypeindexhtmltimedeltatype-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`time_parsing`[Â¶](index.html#time_parsing \"Permanent link\")", "anchor": "timeparsingindexhtmltimeparsing-permanent-link", "md_text": "This error is raised when the input value is a string that cannot be parsed for a `time` field:\n\n```\nfrom datetime import time\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: time\n\n\ntry:\n    Model(x='25:20:30.400')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'time_parsing'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#timeparsingindexhtmltimeparsing-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`time_type`[Â¶](index.html#time_type \"Permanent link\")", "anchor": "timetypeindexhtmltimetype-permanent-link", "md_text": "This error is raised when the value type is not valid for a `time` field:\n\n```\nfrom datetime import time\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: time\n\n\ntry:\n    Model(x=None)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'time_type'\n```\n\nThis error is also raised for strict fields when the input value is not an instance of `time`.", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#timetypeindexhtmltimetype-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`timezone_aware`[Â¶](index.html#timezone_aware \"Permanent link\")", "anchor": "timezoneawareindexhtmltimezoneaware-permanent-link", "md_text": "This error is raised when the `datetime` value provided for a timezone-aware `datetime` field\ndoesn't have timezone information:\n\n```\nfrom datetime import datetime\n\nfrom pydantic import AwareDatetime, BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: AwareDatetime\n\n\ntry:\n    Model(x=datetime.now())\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'timezone_aware'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#timezoneawareindexhtmltimezoneaware-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`timezone_naive`[Â¶](index.html#timezone_naive \"Permanent link\")", "anchor": "timezonenaiveindexhtmltimezonenaive-permanent-link", "md_text": "This error is raised when the `datetime` value provided for a timezone-naive `datetime` field\nhas timezone info:\n\n```\nfrom datetime import datetime, timezone\n\nfrom pydantic import BaseModel, NaiveDatetime, ValidationError\n\n\nclass Model(BaseModel):\n    x: NaiveDatetime\n\n\ntry:\n    Model(x=datetime.now(tz=timezone.utc))\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'timezone_naive'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#timezonenaiveindexhtmltimezonenaive-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`too_long`[Â¶](index.html#too_long \"Permanent link\")", "anchor": "toolongindexhtmltoolong-permanent-link", "md_text": "This error is raised when the input value's length is greater than the field's `max_length` constraint:\n\n```\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: list[int] = Field(max_length=3)\n\n\ntry:\n    Model(x=[1, 2, 3, 4])\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'too_long'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#toolongindexhtmltoolong-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`too_short`[Â¶](index.html#too_short \"Permanent link\")", "anchor": "tooshortindexhtmltooshort-permanent-link", "md_text": "This error is raised when the value length is less than the field's `min_length` constraint:\n\n```\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: list[int] = Field(min_length=3)\n\n\ntry:\n    Model(x=[1, 2])\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'too_short'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#tooshortindexhtmltooshort-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`tuple_type`[Â¶](index.html#tuple_type \"Permanent link\")", "anchor": "tupletypeindexhtmltupletype-permanent-link", "md_text": "This error is raised when the input value's type is not valid for a `tuple` field:\n\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: tuple[int]\n\n\ntry:\n    Model(x=None)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'tuple_type'\n```\n\nThis error is also raised for strict fields when the input value is not an instance of `tuple`.", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#tupletypeindexhtmltupletype-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`unexpected_keyword_argument`[Â¶](index.html#unexpected_keyword_argument \"Permanent link\")", "anchor": "unexpectedkeywordargumentindexhtmlunexpectedkeywordargument-permanent-link", "md_text": "This error is raised when you provide a value by keyword for a positional-only\nargument while calling a function decorated with `validate_call`:\n\n```\nfrom pydantic import ValidationError, validate_call\n\n\n@validate_call\ndef foo(a: int, /):\n    return a\n\n\ntry:\n    foo(a=2)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[1]['type']))\n    #> 'unexpected_keyword_argument'\n```\n\nIt is also raised when using pydantic.dataclasses and `extra=forbid`:\n\n```\nfrom pydantic import TypeAdapter, ValidationError\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass(config={'extra': 'forbid'})\nclass Foo:\n    bar: int\n\n\ntry:\n    TypeAdapter(Foo).validate_python({'bar': 1, 'foobar': 2})\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'unexpected_keyword_argument'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#unexpectedkeywordargumentindexhtmlunexpectedkeywordargument-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`unexpected_positional_argument`[Â¶](index.html#unexpected_positional_argument \"Permanent link\")", "anchor": "unexpectedpositionalargumentindexhtmlunexpectedpositionalargument-permanent-link", "md_text": "This error is raised when you provide a positional value for a keyword-only\nargument while calling a function decorated with `validate_call`:\n\n```\nfrom pydantic import ValidationError, validate_call\n\n\n@validate_call\ndef foo(*, a: int):\n    return a\n\n\ntry:\n    foo(2)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[1]['type']))\n    #> 'unexpected_positional_argument'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#unexpectedpositionalargumentindexhtmlunexpectedpositionalargument-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`union_tag_invalid`[Â¶](index.html#union_tag_invalid \"Permanent link\")", "anchor": "uniontaginvalidindexhtmluniontaginvalid-permanent-link", "md_text": "This error is raised when the input's discriminator is not one of the expected values:\n\nPython 3.9 and abovePython 3.10 and above\n\n```\nfrom typing import Literal, Union\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass BlackCat(BaseModel):\n    pet_type: Literal['blackcat']\n\n\nclass WhiteCat(BaseModel):\n    pet_type: Literal['whitecat']\n\n\nclass Model(BaseModel):\n    cat: Union[BlackCat, WhiteCat] = Field(discriminator='pet_type')\n\n\ntry:\n    Model(cat={'pet_type': 'dog'})\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'union_tag_invalid'\n\nfrom typing import Literal\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass BlackCat(BaseModel):\n    pet_type: Literal['blackcat']\n\n\nclass WhiteCat(BaseModel):\n    pet_type: Literal['whitecat']\n\n\nclass Model(BaseModel):\n    cat: BlackCat | WhiteCat = Field(discriminator='pet_type')\n\n\ntry:\n    Model(cat={'pet_type': 'dog'})\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'union_tag_invalid'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#uniontaginvalidindexhtmluniontaginvalid-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`union_tag_not_found`[Â¶](index.html#union_tag_not_found \"Permanent link\")", "anchor": "uniontagnotfoundindexhtmluniontagnotfound-permanent-link", "md_text": "This error is raised when it is not possible to extract a discriminator value from the input:\n\nPython 3.9 and abovePython 3.10 and above\n\n```\nfrom typing import Literal, Union\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass BlackCat(BaseModel):\n    pet_type: Literal['blackcat']\n\n\nclass WhiteCat(BaseModel):\n    pet_type: Literal['whitecat']\n\n\nclass Model(BaseModel):\n    cat: Union[BlackCat, WhiteCat] = Field(discriminator='pet_type')\n\n\ntry:\n    Model(cat={'name': 'blackcat'})\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'union_tag_not_found'\n\nfrom typing import Literal\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass BlackCat(BaseModel):\n    pet_type: Literal['blackcat']\n\n\nclass WhiteCat(BaseModel):\n    pet_type: Literal['whitecat']\n\n\nclass Model(BaseModel):\n    cat: BlackCat | WhiteCat = Field(discriminator='pet_type')\n\n\ntry:\n    Model(cat={'name': 'blackcat'})\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'union_tag_not_found'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#uniontagnotfoundindexhtmluniontagnotfound-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`url_parsing`[Â¶](index.html#url_parsing \"Permanent link\")", "anchor": "urlparsingindexhtmlurlparsing-permanent-link", "md_text": "This error is raised when the input value cannot be parsed as a URL:\n\n```\nfrom pydantic import AnyUrl, BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: AnyUrl\n\n\ntry:\n    Model(x='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'url_parsing'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#urlparsingindexhtmlurlparsing-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`url_scheme`[Â¶](index.html#url_scheme \"Permanent link\")", "anchor": "urlschemeindexhtmlurlscheme-permanent-link", "md_text": "This error is raised when the URL scheme is not valid for the URL type of the field:\n\n```\nfrom pydantic import BaseModel, HttpUrl, ValidationError\n\n\nclass Model(BaseModel):\n    x: HttpUrl\n\n\ntry:\n    Model(x='ftp://example.com')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'url_scheme'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#urlschemeindexhtmlurlscheme-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`url_syntax_violation`[Â¶](index.html#url_syntax_violation \"Permanent link\")", "anchor": "urlsyntaxviolationindexhtmlurlsyntaxviolation-permanent-link", "md_text": "This error is raised when the URL syntax is not valid:\n\n```\nfrom pydantic import BaseModel, Field, HttpUrl, ValidationError\n\n\nclass Model(BaseModel):\n    x: HttpUrl = Field(strict=True)\n\n\ntry:\n    Model(x='http:////example.com')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'url_syntax_violation'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#urlsyntaxviolationindexhtmlurlsyntaxviolation-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`url_too_long`[Â¶](index.html#url_too_long \"Permanent link\")", "anchor": "urltoolongindexhtmlurltoolong-permanent-link", "md_text": "This error is raised when the URL length is greater than 2083:\n\n```\nfrom pydantic import BaseModel, HttpUrl, ValidationError\n\n\nclass Model(BaseModel):\n    x: HttpUrl\n\n\ntry:\n    Model(x='x' * 2084)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'url_too_long'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#urltoolongindexhtmlurltoolong-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`url_type`[Â¶](index.html#url_type \"Permanent link\")", "anchor": "urltypeindexhtmlurltype-permanent-link", "md_text": "This error is raised when the input value's type is not valid for a URL field:\n\n```\nfrom pydantic import BaseModel, HttpUrl, ValidationError\n\n\nclass Model(BaseModel):\n    x: HttpUrl\n\n\ntry:\n    Model(x=None)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'url_type'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#urltypeindexhtmlurltype-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`uuid_parsing`[Â¶](index.html#uuid_parsing \"Permanent link\")", "anchor": "uuidparsingindexhtmluuidparsing-permanent-link", "md_text": "This error is raised when the input value's type is not valid for a UUID field:\n\n```\nfrom uuid import UUID\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    u: UUID\n\n\ntry:\n    Model(u='12345678-124-1234-1234-567812345678')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'uuid_parsing'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#uuidparsingindexhtmluuidparsing-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`uuid_type`[Â¶](index.html#uuid_type \"Permanent link\")", "anchor": "uuidtypeindexhtmluuidtype-permanent-link", "md_text": "This error is raised when the input value's type is not valid instance for a UUID field (str, bytes or UUID):\n\n```\nfrom uuid import UUID\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    u: UUID\n\n\ntry:\n    Model(u=1234567812412341234567812345678)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'uuid_type'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#uuidtypeindexhtmluuidtype-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`uuid_version`[Â¶](index.html#uuid_version \"Permanent link\")", "anchor": "uuidversionindexhtmluuidversion-permanent-link", "md_text": "This error is raised when the input value's type is not match UUID version:\n\n```\nfrom pydantic import UUID5, BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    u: UUID5\n\n\ntry:\n    Model(u='a6cc5730-2261-11ee-9c43-2eb5a363657c')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'uuid_version'\n```", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#uuidversionindexhtmluuidversion-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "`value_error`[Â¶](index.html#value_error \"Permanent link\")", "anchor": "valueerrorindexhtmlvalueerror-permanent-link", "md_text": "This error is raised when a `ValueError` is raised during validation:\n\n```\nfrom pydantic import BaseModel, ValidationError, field_validator\n\n\nclass Model(BaseModel):\n    x: str\n\n    @field_validator('x')\n    @classmethod\n    def repeat_b(cls, v):\n        raise ValueError()\n\n\ntry:\n    Model(x='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'value_error'\n```\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/errors/validation_errors/index.html#valueerrorindexhtmlvalueerror-permanent-link", "page": "errors/validation_errors/index.html", "source_site": "pydantic"}
{"title": "Error messages[Â¶](index.html#error-messages \"Permanent link\")", "anchor": "error-messagesindexhtmlerror-messages-permanent-link", "md_text": "Pydantic attempts to provide useful default error messages for validation and usage errors, which can be found here:\n\n* [Validation Errors](../validation_errors/index.html): Errors that happen during data validation.\n* [Usage Errors](../usage_errors/index.html): Errors that happen when using Pydantic.", "url": "https://docs.pydantic.dev/latest/errors/errors/index.html#error-messagesindexhtmlerror-messages-permanent-link", "page": "errors/errors/index.html", "source_site": "pydantic"}
{"title": "Customize error messages[Â¶](index.html#customize-error-messages \"Permanent link\")", "anchor": "customize-error-messagesindexhtmlcustomize-error-messages-permanent-link", "md_text": "You can customize error messages by creating a custom error handler.\n\n```\nfrom pydantic_core import ErrorDetails\n\nfrom pydantic import BaseModel, HttpUrl, ValidationError\n\nCUSTOM_MESSAGES = {\n    'int_parsing': 'This is not an integer! ðŸ¤¦',\n    'url_scheme': 'Hey, use the right URL scheme! I wanted {expected_schemes}.',\n}\n\n\ndef convert_errors(\n    e: ValidationError, custom_messages: dict[str, str]\n) -> list[ErrorDetails]:\n    new_errors: list[ErrorDetails] = []\n    for error in e.errors():\n        custom_message = custom_messages.get(error['type'])\n        if custom_message:\n            ctx = error.get('ctx')\n            error['msg'] = (\n                custom_message.format(**ctx) if ctx else custom_message\n            )\n        new_errors.append(error)\n    return new_errors\n\n\nclass Model(BaseModel):\n    a: int\n    b: HttpUrl\n\n\ntry:\n    Model(a='wrong', b='ftp://example.com')\nexcept ValidationError as e:\n    errors = convert_errors(e, CUSTOM_MESSAGES)\n    print(errors)\n    \"\"\"\n    [\n        {\n            'type': 'int_parsing',\n            'loc': ('a',),\n            'msg': 'This is not an integer! ðŸ¤¦',\n            'input': 'wrong',\n            'url': 'https://errors.pydantic.dev/2/v/int_parsing',\n        },\n        {\n            'type': 'url_scheme',\n            'loc': ('b',),\n            'msg': \"Hey, use the right URL scheme! I wanted 'http' or 'https'.\",\n            'input': 'ftp://example.com',\n            'ctx': {'expected_schemes': \"'http' or 'https'\"},\n            'url': 'https://errors.pydantic.dev/2/v/url_scheme',\n        },\n    ]\n    \"\"\"\n```\n\nA common use case would be to translate error messages. For example, in the above example,\nwe could translate the error messages replacing the `CUSTOM_MESSAGES` dictionary with a\ndictionary of translations.\n\nAnother example is customizing the way that the `'loc'` value of an error is represented.\n\nPython 3.9 and abovePython 3.10 and above\n\n```\nfrom typing import Any, Union\n\nfrom pydantic import BaseModel, ValidationError\n\n\ndef loc_to_dot_sep(loc: tuple[Union[str, int], ...]) -> str:\n    path = ''\n    for i, x in enumerate(loc):\n        if isinstance(x, str):\n            if i > 0:\n                path += '.'\n            path += x\n        elif isinstance(x, int):\n            path += f'[{x}]'\n        else:\n            raise TypeError('Unexpected type')\n    return path\n\n\ndef convert_errors(e: ValidationError) -> list[dict[str, Any]]:\n    new_errors: list[dict[str, Any]] = e.errors()\n    for error in new_errors:\n        error['loc'] = loc_to_dot_sep(error['loc'])\n    return new_errors\n\n\nclass TestNestedModel(BaseModel):\n    key: str\n    value: str\n\n\nclass TestModel(BaseModel):\n    items: list[TestNestedModel]\n\n\ndata = {'items': [{'key': 'foo', 'value': 'bar'}, {'key': 'baz'}]}\n\ntry:\n    TestModel.model_validate(data)\nexcept ValidationError as e:\n    print(e.errors())  # (1)!\n    \"\"\"\n    [\n        {\n            'type': 'missing',\n            'loc': ('items', 1, 'value'),\n            'msg': 'Field required',\n            'input': {'key': 'baz'},\n            'url': 'https://errors.pydantic.dev/2/v/missing',\n        }\n    ]\n    \"\"\"\n    pretty_errors = convert_errors(e)\n    print(pretty_errors)  # (2)!\n    \"\"\"\n    [\n        {\n            'type': 'missing',\n            'loc': 'items[1].value',\n            'msg': 'Field required',\n            'input': {'key': 'baz'},\n            'url': 'https://errors.pydantic.dev/2/v/missing',\n        }\n    ]\n    \"\"\"\n```\n\n1. By default, `e.errors()` produces a list of errors with `loc` values that take the form of tuples.\n2. With our custom `loc_to_dot_sep` function, we've modified the form of the `loc` representation.\n\n```\nfrom typing import Any\n\nfrom pydantic import BaseModel, ValidationError\n\n\ndef loc_to_dot_sep(loc: tuple[str | int, ...]) -> str:\n    path = ''\n    for i, x in enumerate(loc):\n        if isinstance(x, str):\n            if i > 0:\n                path += '.'\n            path += x\n        elif isinstance(x, int):\n            path += f'[{x}]'\n        else:\n            raise TypeError('Unexpected type')\n    return path\n\n\ndef convert_errors(e: ValidationError) -> list[dict[str, Any]]:\n    new_errors: list[dict[str, Any]] = e.errors()\n    for error in new_errors:\n        error['loc'] = loc_to_dot_sep(error['loc'])\n    return new_errors\n\n\nclass TestNestedModel(BaseModel):\n    key: str\n    value: str\n\n\nclass TestModel(BaseModel):\n    items: list[TestNestedModel]\n\n\ndata = {'items': [{'key': 'foo', 'value': 'bar'}, {'key': 'baz'}]}", "url": "https://docs.pydantic.dev/latest/errors/errors/index.html#customize-error-messagesindexhtmlcustomize-error-messages-permanent-link", "page": "errors/errors/index.html", "source_site": "pydantic"}
{"title": "Customize error messages[Â¶](index.html#customize-error-messages \"Permanent link\")", "anchor": "customize-error-messagesindexhtmlcustomize-error-messages-permanent-link", "md_text": "try:\n    TestModel.model_validate(data)\nexcept ValidationError as e:\n    print(e.errors())  # (1)!\n    \"\"\"\n    [\n        {\n            'type': 'missing',\n            'loc': ('items', 1, 'value'),\n            'msg': 'Field required',\n            'input': {'key': 'baz'},\n            'url': 'https://errors.pydantic.dev/2/v/missing',\n        }\n    ]\n    \"\"\"\n    pretty_errors = convert_errors(e)\n    print(pretty_errors)  # (2)!\n    \"\"\"\n    [\n        {\n            'type': 'missing',\n            'loc': 'items[1].value',\n            'msg': 'Field required',\n            'input': {'key': 'baz'},\n            'url': 'https://errors.pydantic.dev/2/v/missing',\n        }\n    ]\n    \"\"\"\n```\n\n1. By default, `e.errors()` produces a list of errors with `loc` values that take the form of tuples.\n2. With our custom `loc_to_dot_sep` function, we've modified the form of the `loc` representation.\n\nWas this page helpful?\n\nThanks for your feedback!\n\nThanks for your feedback!\n\nBack to top", "url": "https://docs.pydantic.dev/latest/errors/errors/index.html#customize-error-messagesindexhtmlcustomize-error-messages-permanent-link", "page": "errors/errors/index.html", "source_site": "pydantic"}
